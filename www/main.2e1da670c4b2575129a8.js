/*! For license information please see main.2e1da670c4b2575129a8.js.LICENSE.txt */
(() => {
    var e, t, n, r, i = {
        5887: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.createCurve = t.getHash = void 0;
            const r = n(1377), i = n(64), s = n(7851);

            function a(e) {
                return {
                    hash: e,
                    hmac: (t, ...n) => (0, r.hmac)(e, t, (0, i.concatBytes)(...n)),
                    randomBytes: i.randomBytes
                }
            }

            t.getHash = a, t.createCurve = function (e, t) {
                const n = t => (0, s.weierstrass)({...e, ...a(t)});
                return Object.freeze({...n(t), create: n})
            }
        }, 1465: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.validateBasic = t.wNAF = void 0;
            const r = n(9530), i = n(4323), s = BigInt(0), a = BigInt(1);
            t.wNAF = function (e, t) {
                const n = (e, t) => {
                    const n = t.negate();
                    return e ? n : t
                }, r = e => ({windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1)});
                return {
                    constTimeNegate: n, unsafeLadder(t, n) {
                        let r = e.ZERO, i = t;
                        for (; n > s;) n & a && (r = r.add(i)), i = i.double(), n >>= a;
                        return r
                    }, precomputeWindow(e, t) {
                        const {windows: n, windowSize: i} = r(t), s = [];
                        let a = e, o = a;
                        for (let e = 0; e < n; e++) {
                            o = a, s.push(o);
                            for (let e = 1; e < i; e++) o = o.add(a), s.push(o);
                            a = o.double()
                        }
                        return s
                    }, wNAF(t, i, s) {
                        const {windows: o, windowSize: l} = r(t);
                        let c = e.ZERO, u = e.BASE;
                        const d = BigInt(2 ** t - 1), h = 2 ** t, f = BigInt(t);
                        for (let e = 0; e < o; e++) {
                            const t = e * l;
                            let r = Number(s & d);
                            s >>= f, r > l && (r -= h, s += a);
                            const o = t, p = t + Math.abs(r) - 1, m = e % 2 != 0, g = r < 0;
                            0 === r ? u = u.add(n(m, i[o])) : c = c.add(n(g, i[p]))
                        }
                        return {p: c, f: u}
                    }, wNAFCached(e, t, n, r) {
                        const i = e._WINDOW_SIZE || 1;
                        let s = t.get(e);
                        return s || (s = this.precomputeWindow(e, i), 1 !== i && t.set(e, r(s))), this.wNAF(i, s, n)
                    }
                }
            }, t.validateBasic = function (e) {
                return (0, r.validateField)(e.Fp), (0, i.validateObject)(e, {
                    n: "bigint",
                    h: "bigint",
                    Gx: "field",
                    Gy: "field"
                }, {
                    nBitLength: "isSafeInteger",
                    nByteLength: "isSafeInteger"
                }), Object.freeze({...(0, r.nLength)(e.n, e.nBitLength), ...e, p: e.Fp.ORDER})
            }
        }, 1322: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.createHasher = t.isogenyMap = t.hash_to_field = t.expand_message_xof = t.expand_message_xmd = void 0;
            const r = n(9530), i = n(4323), s = i.bytesToNumberBE;

            function a(e, t) {
                if (e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`);
                const n = Array.from({length: t}).fill(0);
                for (let r = t - 1; r >= 0; r--) n[r] = 255 & e, e >>>= 8;
                return new Uint8Array(n)
            }

            function o(e, t) {
                const n = new Uint8Array(e.length);
                for (let r = 0; r < e.length; r++) n[r] = e[r] ^ t[r];
                return n
            }

            function l(e) {
                if (!(e instanceof Uint8Array)) throw new Error("Uint8Array expected")
            }

            function c(e) {
                if (!Number.isSafeInteger(e)) throw new Error("number expected")
            }

            function u(e, t, n, r) {
                l(e), l(t), c(n), t.length > 255 && (t = r((0, i.concatBytes)((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
                const {outputLen: s, blockLen: u} = r, d = Math.ceil(n / s);
                if (d > 255) throw new Error("Invalid xmd length");
                const h = (0, i.concatBytes)(t, a(t.length, 1)), f = a(0, u), p = a(n, 2), m = new Array(d),
                    g = r((0, i.concatBytes)(f, e, p, a(0, 1), h));
                m[0] = r((0, i.concatBytes)(g, a(1, 1), h));
                for (let e = 1; e <= d; e++) {
                    const t = [o(g, m[e - 1]), a(e + 1, 1), h];
                    m[e] = r((0, i.concatBytes)(...t))
                }
                return (0, i.concatBytes)(...m).slice(0, n)
            }

            function d(e, t, n, r, s) {
                if (l(e), l(t), c(n), t.length > 255) {
                    const e = Math.ceil(2 * r / 8);
                    t = s.create({dkLen: e}).update((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest()
                }
                if (n > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
                return s.create({dkLen: n}).update(e).update(a(n, 2)).update(t).update(a(t.length, 1)).digest()
            }

            function h(e, t, n) {
                (0, i.validateObject)(n, {
                    DST: "string",
                    p: "bigint",
                    m: "isSafeInteger",
                    k: "isSafeInteger",
                    hash: "hash"
                });
                const {p: a, k: o, m: h, hash: f, expand: p, DST: m} = n;
                l(e), c(t);
                const g = function (e) {
                    if (e instanceof Uint8Array) return e;
                    if ("string" == typeof e) return (0, i.utf8ToBytes)(e);
                    throw new Error("DST must be Uint8Array or string")
                }(m), y = a.toString(2).length, v = Math.ceil((y + o) / 8), b = t * h * v;
                let w;
                if ("xmd" === p) w = u(e, g, b, f); else if ("xof" === p) w = d(e, g, b, o, f); else {
                    if ("_internal_pass" !== p) throw new Error('expand must be "xmd" or "xof"');
                    w = e
                }
                const x = new Array(t);
                for (let e = 0; e < t; e++) {
                    const t = new Array(h);
                    for (let n = 0; n < h; n++) {
                        const i = v * (n + e * h), o = w.subarray(i, i + v);
                        t[n] = (0, r.mod)(s(o), a)
                    }
                    x[e] = t
                }
                return x
            }

            t.expand_message_xmd = u, t.expand_message_xof = d, t.hash_to_field = h, t.isogenyMap = function (e, t) {
                const n = t.map((e => Array.from(e).reverse()));
                return (t, r) => {
                    const [i, s, a, o] = n.map((n => n.reduce(((n, r) => e.add(e.mul(n, t), r)))));
                    return t = e.div(i, s), r = e.mul(r, e.div(a, o)), {x: t, y: r}
                }
            }, t.createHasher = function (e, t, n) {
                if ("function" != typeof t) throw new Error("mapToCurve() must be defined");
                return {
                    hashToCurve(r, i) {
                        const s = h(r, 2, {...n, DST: n.DST, ...i}), a = e.fromAffine(t(s[0])),
                            o = e.fromAffine(t(s[1])), l = a.add(o).clearCofactor();
                        return l.assertValidity(), l
                    }, encodeToCurve(r, i) {
                        const s = h(r, 1, {...n, DST: n.encodeDST, ...i}), a = e.fromAffine(t(s[0])).clearCofactor();
                        return a.assertValidity(), a
                    }
                }
            }
        }, 9530: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.hashToPrivateScalar = t.FpSqrtEven = t.FpSqrtOdd = t.Field = t.nLength = t.FpIsSquare = t.FpDiv = t.FpInvertBatch = t.FpPow = t.validateField = t.isNegativeLE = t.FpSqrt = t.tonelliShanks = t.invert = t.pow2 = t.pow = t.mod = void 0;
            const r = n(4323), i = BigInt(0), s = BigInt(1), a = BigInt(2), o = BigInt(3), l = BigInt(4), c = BigInt(5),
                u = BigInt(8);

            function d(e, t) {
                const n = e % t;
                return n >= i ? n : t + n
            }

            function h(e, t, n) {
                if (n <= i || t < i) throw new Error("Expected power/modulo > 0");
                if (n === s) return i;
                let r = s;
                for (; t > i;) t & s && (r = r * e % n), e = e * e % n, t >>= s;
                return r
            }

            function f(e, t) {
                if (e === i || t <= i) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
                let n = d(e, t), r = t, a = i, o = s, l = s, c = i;
                for (; n !== i;) {
                    const e = r / n, t = r % n, i = a - l * e, s = o - c * e;
                    r = n, n = t, a = l, o = c, l = i, c = s
                }
                if (r !== s) throw new Error("invert: does not exist");
                return d(a, t)
            }

            function p(e) {
                const t = (e - s) / a;
                let n, r, o;
                for (n = e - s, r = 0; n % a === i; n /= a, r++) ;
                for (o = a; o < e && h(o, t, e) !== e - s; o++) ;
                if (1 === r) {
                    const t = (e + s) / l;
                    return function (e, n) {
                        const r = e.pow(n, t);
                        if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
                        return r
                    }
                }
                const c = (n + s) / a;
                return function (e, i) {
                    if (e.pow(i, t) === e.neg(e.ONE)) throw new Error("Cannot find square root");
                    let a = r, l = e.pow(e.mul(e.ONE, o), n), u = e.pow(i, c), d = e.pow(i, n);
                    for (; !e.eql(d, e.ONE);) {
                        if (e.eql(d, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let n = e.sqr(d); t < a && !e.eql(n, e.ONE); t++) n = e.sqr(n);
                        const n = e.pow(l, s << BigInt(a - t - 1));
                        l = e.sqr(n), u = e.mul(u, n), d = e.mul(d, l), a = t
                    }
                    return u
                }
            }

            function m(e) {
                if (e % l === o) {
                    const t = (e + s) / l;
                    return function (e, n) {
                        const r = e.pow(n, t);
                        if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
                        return r
                    }
                }
                if (e % u === c) {
                    const t = (e - c) / u;
                    return function (e, n) {
                        const r = e.mul(n, a), i = e.pow(r, t), s = e.mul(n, i), o = e.mul(e.mul(s, a), i),
                            l = e.mul(s, e.sub(o, e.ONE));
                        if (!e.eql(e.sqr(l), n)) throw new Error("Cannot find square root");
                        return l
                    }
                }
                return p(e)
            }

            BigInt(9), BigInt(16), t.mod = d, t.pow = h, t.pow2 = function (e, t, n) {
                let r = e;
                for (; t-- > i;) r *= r, r %= n;
                return r
            }, t.invert = f, t.tonelliShanks = p, t.FpSqrt = m, t.isNegativeLE = (e, t) => (d(e, t) & s) === s;
            const g = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

            function y(e, t, n) {
                if (n < i) throw new Error("Expected power > 0");
                if (n === i) return e.ONE;
                if (n === s) return t;
                let r = e.ONE, a = t;
                for (; n > i;) n & s && (r = e.mul(r, a)), a = e.sqr(a), n >>= s;
                return r
            }

            function v(e, t) {
                const n = new Array(t.length),
                    r = t.reduce(((t, r, i) => e.is0(r) ? t : (n[i] = t, e.mul(t, r))), e.ONE), i = e.inv(r);
                return t.reduceRight(((t, r, i) => e.is0(r) ? t : (n[i] = e.mul(t, n[i]), e.mul(t, r))), i), n
            }

            function b(e, t) {
                const n = void 0 !== t ? t : e.toString(2).length;
                return {nBitLength: n, nByteLength: Math.ceil(n / 8)}
            }

            t.validateField = function (e) {
                const t = g.reduce(((e, t) => (e[t] = "function", e)), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger"
                });
                return (0, r.validateObject)(e, t)
            }, t.FpPow = y, t.FpInvertBatch = v, t.FpDiv = function (e, t, n) {
                return e.mul(t, "bigint" == typeof n ? f(n, e.ORDER) : e.inv(n))
            }, t.FpIsSquare = function (e) {
                const t = (e.ORDER - s) / a;
                return n => {
                    const r = e.pow(n, t);
                    return e.eql(r, e.ZERO) || e.eql(r, e.ONE)
                }
            }, t.nLength = b, t.Field = function (e, t, n = !1, a = {}) {
                if (e <= i) throw new Error(`Expected Fp ORDER > 0, got ${e}`);
                const {nBitLength: o, nByteLength: l} = b(e, t);
                if (l > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
                const c = m(e), u = Object.freeze({
                    ORDER: e,
                    BITS: o,
                    BYTES: l,
                    MASK: (0, r.bitMask)(o),
                    ZERO: i,
                    ONE: s,
                    create: t => d(t, e),
                    isValid: t => {
                        if ("bigint" != typeof t) throw new Error("Invalid field element: expected bigint, got " + typeof t);
                        return i <= t && t < e
                    },
                    is0: e => e === i,
                    isOdd: e => (e & s) === s,
                    neg: t => d(-t, e),
                    eql: (e, t) => e === t,
                    sqr: t => d(t * t, e),
                    add: (t, n) => d(t + n, e),
                    sub: (t, n) => d(t - n, e),
                    mul: (t, n) => d(t * n, e),
                    pow: (e, t) => y(u, e, t),
                    div: (t, n) => d(t * f(n, e), e),
                    sqrN: e => e * e,
                    addN: (e, t) => e + t,
                    subN: (e, t) => e - t,
                    mulN: (e, t) => e * t,
                    inv: t => f(t, e),
                    sqrt: a.sqrt || (e => c(u, e)),
                    invertBatch: e => v(u, e),
                    cmov: (e, t, n) => n ? t : e,
                    toBytes: e => n ? (0, r.numberToBytesLE)(e, l) : (0, r.numberToBytesBE)(e, l),
                    fromBytes: e => {
                        if (e.length !== l) throw new Error(`Fp.fromBytes: expected ${l}, got ${e.length}`);
                        return n ? (0, r.bytesToNumberLE)(e) : (0, r.bytesToNumberBE)(e)
                    }
                });
                return Object.freeze(u)
            }, t.FpSqrtOdd = function (e, t) {
                if (!e.isOdd) throw new Error("Field doesn't have isOdd");
                const n = e.sqrt(t);
                return e.isOdd(n) ? n : e.neg(n)
            }, t.FpSqrtEven = function (e, t) {
                if (!e.isOdd) throw new Error("Field doesn't have isOdd");
                const n = e.sqrt(t);
                return e.isOdd(n) ? e.neg(n) : n
            }, t.hashToPrivateScalar = function (e, t, n = !1) {
                const i = (e = (0, r.ensureBytes)("privateHash", e)).length, a = b(t).nByteLength + 8;
                if (a < 24 || i < a || i > 1024) throw new Error(`hashToPrivateScalar: expected ${a}-1024 bytes of input, got ${i}`);
                return d(n ? (0, r.bytesToNumberLE)(e) : (0, r.bytesToNumberBE)(e), t - s) + s
            }
        }, 4323: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.validateObject = t.createHmacDrbg = t.bitMask = t.bitSet = t.bitGet = t.bitLen = t.utf8ToBytes = t.equalBytes = t.concatBytes = t.ensureBytes = t.numberToVarBytesBE = t.numberToBytesLE = t.numberToBytesBE = t.bytesToNumberLE = t.bytesToNumberBE = t.hexToBytes = t.hexToNumber = t.numberToHexUnpadded = t.bytesToHex = void 0;
            const n = BigInt(0), r = BigInt(1), i = BigInt(2), s = e => e instanceof Uint8Array,
                a = Array.from({length: 256}, ((e, t) => t.toString(16).padStart(2, "0")));

            function o(e) {
                if (!s(e)) throw new Error("Uint8Array expected");
                let t = "";
                for (let n = 0; n < e.length; n++) t += a[e[n]];
                return t
            }

            function l(e) {
                const t = e.toString(16);
                return 1 & t.length ? `0${t}` : t
            }

            function c(e) {
                if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
                return BigInt("" === e ? "0" : `0x${e}`)
            }

            function u(e) {
                if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
                if (e.length % 2) throw new Error("hex string is invalid: unpadded " + e.length);
                const t = new Uint8Array(e.length / 2);
                for (let n = 0; n < t.length; n++) {
                    const r = 2 * n, i = e.slice(r, r + 2), s = Number.parseInt(i, 16);
                    if (Number.isNaN(s) || s < 0) throw new Error("invalid byte sequence");
                    t[n] = s
                }
                return t
            }

            function d(...e) {
                const t = new Uint8Array(e.reduce(((e, t) => e + t.length), 0));
                let n = 0;
                return e.forEach((e => {
                    if (!s(e)) throw new Error("Uint8Array expected");
                    t.set(e, n), n += e.length
                })), t
            }

            t.bytesToHex = o, t.numberToHexUnpadded = l, t.hexToNumber = c, t.hexToBytes = u, t.bytesToNumberBE = function (e) {
                return c(o(e))
            }, t.bytesToNumberLE = function (e) {
                if (!s(e)) throw new Error("Uint8Array expected");
                return c(o(Uint8Array.from(e).reverse()))
            }, t.numberToBytesBE = (e, t) => u(e.toString(16).padStart(2 * t, "0")), t.numberToBytesLE = (e, n) => (0, t.numberToBytesBE)(e, n).reverse(), t.numberToVarBytesBE = e => u(l(e)), t.ensureBytes = function (e, t, n) {
                let r;
                if ("string" == typeof t) try {
                    r = u(t)
                } catch (n) {
                    throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`)
                } else {
                    if (!s(t)) throw new Error(`${e} must be hex string or Uint8Array`);
                    r = Uint8Array.from(t)
                }
                const i = r.length;
                if ("number" == typeof n && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`);
                return r
            }, t.concatBytes = d, t.equalBytes = function (e, t) {
                if (e.length !== t.length) return !1;
                for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
                return !0
            }, t.utf8ToBytes = function (e) {
                if ("string" != typeof e) throw new Error("utf8ToBytes expected string, got " + typeof e);
                return (new TextEncoder).encode(e)
            }, t.bitLen = function (e) {
                let t;
                for (t = 0; e > n; e >>= r, t += 1) ;
                return t
            }, t.bitGet = (e, t) => e >> BigInt(t) & r, t.bitSet = (e, t, i) => e | (i ? r : n) << BigInt(t), t.bitMask = e => (i << BigInt(e - 1)) - r;
            const h = e => new Uint8Array(e), f = e => Uint8Array.from(e);
            t.createHmacDrbg = function (e, t, n) {
                if ("number" != typeof e || e < 2) throw new Error("hashLen must be a number");
                if ("number" != typeof t || t < 2) throw new Error("qByteLen must be a number");
                if ("function" != typeof n) throw new Error("hmacFn must be a function");
                let r = h(e), i = h(e), s = 0;
                const a = () => {
                    r.fill(1), i.fill(0), s = 0
                }, o = (...e) => n(i, r, ...e), l = (e = h()) => {
                    i = o(f([0]), e), r = o(), 0 !== e.length && (i = o(f([1]), e), r = o())
                }, c = () => {
                    if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
                    let e = 0;
                    const n = [];
                    for (; e < t;) {
                        r = o();
                        const t = r.slice();
                        n.push(t), e += r.length
                    }
                    return d(...n)
                };
                return (e, t) => {
                    let n;
                    for (a(), l(e); !(n = t(c()));) l();
                    return a(), n
                }
            };
            const p = {
                bigint: e => "bigint" == typeof e,
                function: e => "function" == typeof e,
                boolean: e => "boolean" == typeof e,
                string: e => "string" == typeof e,
                isSafeInteger: e => Number.isSafeInteger(e),
                array: e => Array.isArray(e),
                field: (e, t) => t.Fp.isValid(e),
                hash: e => "function" == typeof e && Number.isSafeInteger(e.outputLen)
            };
            t.validateObject = function (e, t, n = {}) {
                const r = (t, n, r) => {
                    const i = p[n];
                    if ("function" != typeof i) throw new Error(`Invalid validator "${n}", expected function`);
                    const s = e[t];
                    if (!(r && void 0 === s || i(s, e))) throw new Error(`Invalid param ${String(t)}=${s} (${typeof s}), expected ${n}`)
                };
                for (const [e, n] of Object.entries(t)) r(e, n, !1);
                for (const [e, t] of Object.entries(n)) r(e, t, !0);
                return e
            }
        }, 7851: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.mapToCurveSimpleSWU = t.SWUFpSqrtRatio = t.weierstrass = t.weierstrassPoints = t.DER = void 0;
            const r = n(9530), i = n(4323), s = n(4323), a = n(1465), {bytesToNumberBE: o, hexToBytes: l} = i;
            t.DER = {
                Err: class extends Error {
                    constructor(e = "") {
                        super(e)
                    }
                }, _parseInt(e) {
                    const {Err: n} = t.DER;
                    if (e.length < 2 || 2 !== e[0]) throw new n("Invalid signature integer tag");
                    const r = e[1], i = e.subarray(2, r + 2);
                    if (!r || i.length !== r) throw new n("Invalid signature integer: wrong length");
                    if (128 & i[0]) throw new n("Invalid signature integer: negative");
                    if (0 === i[0] && !(128 & i[1])) throw new n("Invalid signature integer: unnecessary leading zero");
                    return {d: o(i), l: e.subarray(r + 2)}
                }, toSig(e) {
                    const {Err: n} = t.DER, r = "string" == typeof e ? l(e) : e;
                    if (!(r instanceof Uint8Array)) throw new Error("ui8a expected");
                    let i = r.length;
                    if (i < 2 || 48 != r[0]) throw new n("Invalid signature tag");
                    if (r[1] !== i - 2) throw new n("Invalid signature: incorrect length");
                    const {d: s, l: a} = t.DER._parseInt(r.subarray(2)), {d: o, l: c} = t.DER._parseInt(a);
                    if (c.length) throw new n("Invalid signature: left bytes after parsing");
                    return {r: s, s: o}
                }, hexFromSig(e) {
                    const t = e => 8 & Number.parseInt(e[0], 16) ? "00" + e : e, n = e => {
                        const t = e.toString(16);
                        return 1 & t.length ? `0${t}` : t
                    }, r = t(n(e.s)), i = t(n(e.r)), s = r.length / 2, a = i.length / 2, o = n(s), l = n(a);
                    return `30${n(a + s + 4)}02${l}${i}02${o}${r}`
                }
            };
            const c = BigInt(0), u = BigInt(1), d = BigInt(2), h = BigInt(3), f = BigInt(4);

            function p(e) {
                const t = function (e) {
                    const t = (0, a.validateBasic)(e);
                    i.validateObject(t, {a: "field", b: "field"}, {
                        allowedPrivateKeyLengths: "array",
                        wrapPrivateKey: "boolean",
                        isTorsionFree: "function",
                        clearCofactor: "function",
                        allowInfinityPoint: "boolean",
                        fromBytes: "function",
                        toBytes: "function"
                    });
                    const {endo: n, Fp: r, a: s} = t;
                    if (n) {
                        if (!r.eql(s, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                        if ("object" != typeof n || "bigint" != typeof n.beta || "function" != typeof n.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
                    }
                    return Object.freeze({...t})
                }(e), {Fp: n} = t, o = t.toBytes || ((e, t, r) => {
                    const s = t.toAffine();
                    return i.concatBytes(Uint8Array.from([4]), n.toBytes(s.x), n.toBytes(s.y))
                }), l = t.fromBytes || (e => {
                    const t = e.subarray(1);
                    return {x: n.fromBytes(t.subarray(0, n.BYTES)), y: n.fromBytes(t.subarray(n.BYTES, 2 * n.BYTES))}
                });

                function d(e) {
                    const {a: r, b: i} = t, s = n.sqr(e), a = n.mul(s, e);
                    return n.add(n.add(a, n.mul(e, r)), i)
                }

                if (!n.eql(n.sqr(t.Gy), d(t.Gx))) throw new Error("bad generator point: equation left != right");

                function f(e) {
                    return "bigint" == typeof e && c < e && e < t.n
                }

                function p(e) {
                    if (!f(e)) throw new Error("Expected valid bigint: 0 < bigint < curve.n")
                }

                function m(e) {
                    const {allowedPrivateKeyLengths: n, nByteLength: a, wrapPrivateKey: o, n: l} = t;
                    if (n && "bigint" != typeof e) {
                        if (e instanceof Uint8Array && (e = i.bytesToHex(e)), "string" != typeof e || !n.includes(e.length)) throw new Error("Invalid key");
                        e = e.padStart(2 * a, "0")
                    }
                    let c;
                    try {
                        c = "bigint" == typeof e ? e : i.bytesToNumberBE((0, s.ensureBytes)("private key", e, a))
                    } catch (t) {
                        throw new Error(`private key must be ${a} bytes, hex or bigint, not ${typeof e}`)
                    }
                    return o && (c = r.mod(c, l)), p(c), c
                }

                const g = new Map;

                function y(e) {
                    if (!(e instanceof v)) throw new Error("ProjectivePoint expected")
                }

                class v {
                    constructor(e, t, r) {
                        if (this.px = e, this.py = t, this.pz = r, null == e || !n.isValid(e)) throw new Error("x required");
                        if (null == t || !n.isValid(t)) throw new Error("y required");
                        if (null == r || !n.isValid(r)) throw new Error("z required")
                    }

                    static fromAffine(e) {
                        const {x: t, y: r} = e || {};
                        if (!e || !n.isValid(t) || !n.isValid(r)) throw new Error("invalid affine point");
                        if (e instanceof v) throw new Error("projective point not allowed");
                        const i = e => n.eql(e, n.ZERO);
                        return i(t) && i(r) ? v.ZERO : new v(t, r, n.ONE)
                    }

                    get x() {
                        return this.toAffine().x
                    }

                    get y() {
                        return this.toAffine().y
                    }

                    static normalizeZ(e) {
                        const t = n.invertBatch(e.map((e => e.pz)));
                        return e.map(((e, n) => e.toAffine(t[n]))).map(v.fromAffine)
                    }

                    static fromHex(e) {
                        const t = v.fromAffine(l((0, s.ensureBytes)("pointHex", e)));
                        return t.assertValidity(), t
                    }

                    static fromPrivateKey(e) {
                        return v.BASE.multiply(m(e))
                    }

                    _setWindowSize(e) {
                        this._WINDOW_SIZE = e, g.delete(this)
                    }

                    assertValidity() {
                        if (this.is0()) {
                            if (t.allowInfinityPoint) return;
                            throw new Error("bad point: ZERO")
                        }
                        const {x: e, y: r} = this.toAffine();
                        if (!n.isValid(e) || !n.isValid(r)) throw new Error("bad point: x or y not FE");
                        const i = n.sqr(r), s = d(e);
                        if (!n.eql(i, s)) throw new Error("bad point: equation left != right");
                        if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup")
                    }

                    hasEvenY() {
                        const {y: e} = this.toAffine();
                        if (n.isOdd) return !n.isOdd(e);
                        throw new Error("Field doesn't support isOdd")
                    }

                    equals(e) {
                        y(e);
                        const {px: t, py: r, pz: i} = this, {px: s, py: a, pz: o} = e,
                            l = n.eql(n.mul(t, o), n.mul(s, i)), c = n.eql(n.mul(r, o), n.mul(a, i));
                        return l && c
                    }

                    negate() {
                        return new v(this.px, n.neg(this.py), this.pz)
                    }

                    double() {
                        const {a: e, b: r} = t, i = n.mul(r, h), {px: s, py: a, pz: o} = this;
                        let l = n.ZERO, c = n.ZERO, u = n.ZERO, d = n.mul(s, s), f = n.mul(a, a), p = n.mul(o, o),
                            m = n.mul(s, a);
                        return m = n.add(m, m), u = n.mul(s, o), u = n.add(u, u), l = n.mul(e, u), c = n.mul(i, p), c = n.add(l, c), l = n.sub(f, c), c = n.add(f, c), c = n.mul(l, c), l = n.mul(m, l), u = n.mul(i, u), p = n.mul(e, p), m = n.sub(d, p), m = n.mul(e, m), m = n.add(m, u), u = n.add(d, d), d = n.add(u, d), d = n.add(d, p), d = n.mul(d, m), c = n.add(c, d), p = n.mul(a, o), p = n.add(p, p), d = n.mul(p, m), l = n.sub(l, d), u = n.mul(p, f), u = n.add(u, u), u = n.add(u, u), new v(l, c, u)
                    }

                    add(e) {
                        y(e);
                        const {px: r, py: i, pz: s} = this, {px: a, py: o, pz: l} = e;
                        let c = n.ZERO, u = n.ZERO, d = n.ZERO;
                        const f = t.a, p = n.mul(t.b, h);
                        let m = n.mul(r, a), g = n.mul(i, o), b = n.mul(s, l), w = n.add(r, i), x = n.add(a, o);
                        w = n.mul(w, x), x = n.add(m, g), w = n.sub(w, x), x = n.add(r, s);
                        let E = n.add(a, l);
                        return x = n.mul(x, E), E = n.add(m, b), x = n.sub(x, E), E = n.add(i, s), c = n.add(o, l), E = n.mul(E, c), c = n.add(g, b), E = n.sub(E, c), d = n.mul(f, x), c = n.mul(p, b), d = n.add(c, d), c = n.sub(g, d), d = n.add(g, d), u = n.mul(c, d), g = n.add(m, m), g = n.add(g, m), b = n.mul(f, b), x = n.mul(p, x), g = n.add(g, b), b = n.sub(m, b), b = n.mul(f, b), x = n.add(x, b), m = n.mul(g, x), u = n.add(u, m), m = n.mul(E, x), c = n.mul(w, c), c = n.sub(c, m), m = n.mul(w, g), d = n.mul(E, d), d = n.add(d, m), new v(c, u, d)
                    }

                    subtract(e) {
                        return this.add(e.negate())
                    }

                    is0() {
                        return this.equals(v.ZERO)
                    }

                    wNAF(e) {
                        return w.wNAFCached(this, g, e, (e => {
                            const t = n.invertBatch(e.map((e => e.pz)));
                            return e.map(((e, n) => e.toAffine(t[n]))).map(v.fromAffine)
                        }))
                    }

                    multiplyUnsafe(e) {
                        const r = v.ZERO;
                        if (e === c) return r;
                        if (p(e), e === u) return this;
                        const {endo: i} = t;
                        if (!i) return w.unsafeLadder(this, e);
                        let {k1neg: s, k1: a, k2neg: o, k2: l} = i.splitScalar(e), d = r, h = r, f = this;
                        for (; a > c || l > c;) a & u && (d = d.add(f)), l & u && (h = h.add(f)), f = f.double(), a >>= u, l >>= u;
                        return s && (d = d.negate()), o && (h = h.negate()), h = new v(n.mul(h.px, i.beta), h.py, h.pz), d.add(h)
                    }

                    multiply(e) {
                        p(e);
                        let r, i, s = e;
                        const {endo: a} = t;
                        if (a) {
                            const {k1neg: e, k1: t, k2neg: o, k2: l} = a.splitScalar(s);
                            let {p: c, f: u} = this.wNAF(t), {p: d, f: h} = this.wNAF(l);
                            c = w.constTimeNegate(e, c), d = w.constTimeNegate(o, d), d = new v(n.mul(d.px, a.beta), d.py, d.pz), r = c.add(d), i = u.add(h)
                        } else {
                            const {p: e, f: t} = this.wNAF(s);
                            r = e, i = t
                        }
                        return v.normalizeZ([r, i])[0]
                    }

                    multiplyAndAddUnsafe(e, t, n) {
                        const r = v.BASE,
                            i = (e, t) => t !== c && t !== u && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t),
                            s = i(this, t).add(i(e, n));
                        return s.is0() ? void 0 : s
                    }

                    toAffine(e) {
                        const {px: t, py: r, pz: i} = this, s = this.is0();
                        null == e && (e = s ? n.ONE : n.inv(i));
                        const a = n.mul(t, e), o = n.mul(r, e), l = n.mul(i, e);
                        if (s) return {x: n.ZERO, y: n.ZERO};
                        if (!n.eql(l, n.ONE)) throw new Error("invZ was invalid");
                        return {x: a, y: o}
                    }

                    isTorsionFree() {
                        const {h: e, isTorsionFree: n} = t;
                        if (e === u) return !0;
                        if (n) return n(v, this);
                        throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                    }

                    clearCofactor() {
                        const {h: e, clearCofactor: n} = t;
                        return e === u ? this : n ? n(v, this) : this.multiplyUnsafe(t.h)
                    }

                    toRawBytes(e = !0) {
                        return this.assertValidity(), o(v, this, e)
                    }

                    toHex(e = !0) {
                        return i.bytesToHex(this.toRawBytes(e))
                    }
                }

                v.BASE = new v(t.Gx, t.Gy, n.ONE), v.ZERO = new v(n.ZERO, n.ONE, n.ZERO);
                const b = t.nBitLength, w = (0, a.wNAF)(v, t.endo ? Math.ceil(b / 2) : b);
                return {
                    CURVE: t,
                    ProjectivePoint: v,
                    normPrivateKeyToScalar: m,
                    weierstrassEquation: d,
                    isWithinCurveOrder: f
                }
            }

            function m(e, t) {
                const n = e.ORDER;
                let r = c;
                for (let e = n - u; e % d === c; e /= d) r += u;
                const i = r, s = (n - u) / d ** i, a = (s - u) / d, o = d ** i - u, l = d ** (i - u), p = e.pow(t, s),
                    m = e.pow(t, (s + u) / d);
                let g = (t, n) => {
                    let r = p, s = e.pow(n, o), c = e.sqr(s);
                    c = e.mul(c, n);
                    let h = e.mul(t, c);
                    h = e.pow(h, a), h = e.mul(h, s), s = e.mul(h, n), c = e.mul(h, t);
                    let f = e.mul(c, s);
                    h = e.pow(f, l);
                    let g = e.eql(h, e.ONE);
                    s = e.mul(c, m), h = e.mul(f, r), c = e.cmov(s, c, g), f = e.cmov(h, f, g);
                    for (let t = i; t > u; t--) {
                        let n = d ** (t - d), i = e.pow(f, n);
                        const a = e.eql(i, e.ONE);
                        s = e.mul(c, r), r = e.mul(r, r), i = e.mul(f, r), c = e.cmov(s, c, a), f = e.cmov(i, f, a)
                    }
                    return {isValid: g, value: c}
                };
                if (e.ORDER % f === h) {
                    const n = (e.ORDER - h) / f, r = e.sqrt(e.neg(t));
                    g = (t, i) => {
                        let s = e.sqr(i);
                        const a = e.mul(t, i);
                        s = e.mul(s, a);
                        let o = e.pow(s, n);
                        o = e.mul(o, a);
                        const l = e.mul(o, r), c = e.mul(e.sqr(o), i), u = e.eql(c, t);
                        return {isValid: u, value: e.cmov(l, o, u)}
                    }
                }
                return g
            }

            t.weierstrassPoints = p, t.weierstrass = function (e) {
                const n = function (e) {
                    const t = (0, a.validateBasic)(e);
                    return i.validateObject(t, {
                        hash: "hash",
                        hmac: "function",
                        randomBytes: "function"
                    }, {
                        bits2int: "function",
                        bits2int_modN: "function",
                        lowS: "boolean"
                    }), Object.freeze({lowS: !0, ...t})
                }(e), {Fp: o, n: l} = n, d = o.BYTES + 1, h = 2 * o.BYTES + 1;

                function f(e) {
                    return r.mod(e, l)
                }

                function m(e) {
                    return r.invert(e, l)
                }

                const {
                    ProjectivePoint: g,
                    normPrivateKeyToScalar: y,
                    weierstrassEquation: v,
                    isWithinCurveOrder: b
                } = p({
                    ...n, toBytes(e, t, n) {
                        const r = t.toAffine(), s = o.toBytes(r.x), a = i.concatBytes;
                        return n ? a(Uint8Array.from([t.hasEvenY() ? 2 : 3]), s) : a(Uint8Array.from([4]), s, o.toBytes(r.y))
                    }, fromBytes(e) {
                        const t = e.length, n = e[0], r = e.subarray(1);
                        if (t !== d || 2 !== n && 3 !== n) {
                            if (t === h && 4 === n) return {
                                x: o.fromBytes(r.subarray(0, o.BYTES)),
                                y: o.fromBytes(r.subarray(o.BYTES, 2 * o.BYTES))
                            };
                            throw new Error(`Point of length ${t} was invalid. Expected ${d} compressed bytes or ${h} uncompressed bytes`)
                        }
                        {
                            const e = i.bytesToNumberBE(r);
                            if (!(c < (s = e) && s < o.ORDER)) throw new Error("Point is not on curve");
                            const t = v(e);
                            let a = o.sqrt(t);
                            return 1 == (1 & n) != ((a & u) === u) && (a = o.neg(a)), {x: e, y: a}
                        }
                        var s
                    }
                }), w = e => i.bytesToHex(i.numberToBytesBE(e, n.nByteLength));

                function x(e) {
                    return e > l >> u
                }

                const E = (e, t, n) => i.bytesToNumberBE(e.slice(t, n));

                class S {
                    constructor(e, t, n) {
                        this.r = e, this.s = t, this.recovery = n, this.assertValidity()
                    }

                    static fromCompact(e) {
                        const t = n.nByteLength;
                        return e = (0, s.ensureBytes)("compactSignature", e, 2 * t), new S(E(e, 0, t), E(e, t, 2 * t))
                    }

                    static fromDER(e) {
                        const {r: n, s: r} = t.DER.toSig((0, s.ensureBytes)("DER", e));
                        return new S(n, r)
                    }

                    assertValidity() {
                        if (!b(this.r)) throw new Error("r must be 0 < r < CURVE.n");
                        if (!b(this.s)) throw new Error("s must be 0 < s < CURVE.n")
                    }

                    addRecoveryBit(e) {
                        return new S(this.r, this.s, e)
                    }

                    recoverPublicKey(e) {
                        const {r: t, s: r, recovery: i} = this, a = C((0, s.ensureBytes)("msgHash", e));
                        if (null == i || ![0, 1, 2, 3].includes(i)) throw new Error("recovery id invalid");
                        const l = 2 === i || 3 === i ? t + n.n : t;
                        if (l >= o.ORDER) throw new Error("recovery id 2 or 3 invalid");
                        const c = 0 == (1 & i) ? "02" : "03", u = g.fromHex(c + w(l)), d = m(l), h = f(-a * d),
                            p = f(r * d), y = g.BASE.multiplyAndAddUnsafe(u, h, p);
                        if (!y) throw new Error("point at infinify");
                        return y.assertValidity(), y
                    }

                    hasHighS() {
                        return x(this.s)
                    }

                    normalizeS() {
                        return this.hasHighS() ? new S(this.r, f(-this.s), this.recovery) : this
                    }

                    toDERRawBytes() {
                        return i.hexToBytes(this.toDERHex())
                    }

                    toDERHex() {
                        return t.DER.hexFromSig({r: this.r, s: this.s})
                    }

                    toCompactRawBytes() {
                        return i.hexToBytes(this.toCompactHex())
                    }

                    toCompactHex() {
                        return w(this.r) + w(this.s)
                    }
                }

                const k = {
                    isValidPrivateKey(e) {
                        try {
                            return y(e), !0
                        } catch (e) {
                            return !1
                        }
                    }, normPrivateKeyToScalar: y, randomPrivateKey: () => {
                        const e = n.randomBytes(o.BYTES + 8), t = r.hashToPrivateScalar(e, l);
                        return i.numberToBytesBE(t, n.nByteLength)
                    }, precompute: (e = 8, t = g.BASE) => (t._setWindowSize(e), t.multiply(BigInt(3)), t)
                };

                function A(e) {
                    const t = e instanceof Uint8Array, n = "string" == typeof e, r = (t || n) && e.length;
                    return t ? r === d || r === h : n ? r === 2 * d || r === 2 * h : e instanceof g
                }

                const T = n.bits2int || function (e) {
                    const t = i.bytesToNumberBE(e), r = 8 * e.length - n.nBitLength;
                    return r > 0 ? t >> BigInt(r) : t
                }, C = n.bits2int_modN || function (e) {
                    return f(T(e))
                }, R = i.bitMask(n.nBitLength);

                function L(e) {
                    if ("bigint" != typeof e) throw new Error("bigint expected");
                    if (!(c <= e && e < R)) throw new Error(`bigint expected < 2^${n.nBitLength}`);
                    return i.numberToBytesBE(e, n.nByteLength)
                }

                const _ = {lowS: n.lowS, prehash: !1}, P = {lowS: n.lowS, prehash: !1};
                return g.BASE._setWindowSize(8), {
                    CURVE: n, getPublicKey: function (e, t = !0) {
                        return g.fromPrivateKey(e).toRawBytes(t)
                    }, getSharedSecret: function (e, t, n = !0) {
                        if (A(e)) throw new Error("first arg must be private key");
                        if (!A(t)) throw new Error("second arg must be public key");
                        return g.fromHex(t).multiply(y(e)).toRawBytes(n)
                    }, sign: function (e, t, r = _) {
                        const {seed: a, k2sig: l} = function (e, t, r = _) {
                            if (["recovered", "canonical"].some((e => e in r))) throw new Error("sign() legacy options not supported");
                            const {hash: a, randomBytes: l} = n;
                            let {lowS: d, prehash: h, extraEntropy: p} = r;
                            null == d && (d = !0), e = (0, s.ensureBytes)("msgHash", e), h && (e = (0, s.ensureBytes)("prehashed msgHash", a(e)));
                            const v = C(e), w = y(t), E = [L(w), L(v)];
                            if (null != p) {
                                const e = !0 === p ? l(o.BYTES) : p;
                                E.push((0, s.ensureBytes)("extraEntropy", e, o.BYTES))
                            }
                            const k = i.concatBytes(...E), A = v;
                            return {
                                seed: k, k2sig: function (e) {
                                    const t = T(e);
                                    if (!b(t)) return;
                                    const n = m(t), r = g.BASE.multiply(t).toAffine(), i = f(r.x);
                                    if (i === c) return;
                                    const s = f(n * f(A + i * w));
                                    if (s === c) return;
                                    let a = (r.x === i ? 0 : 2) | Number(r.y & u), o = s;
                                    return d && x(s) && (o = function (e) {
                                        return x(e) ? f(-e) : e
                                    }(s), a ^= 1), new S(i, o, a)
                                }
                            }
                        }(e, t, r);
                        return i.createHmacDrbg(n.hash.outputLen, n.nByteLength, n.hmac)(a, l)
                    }, verify: function (e, r, i, a = P) {
                        const o = e;
                        if (r = (0, s.ensureBytes)("msgHash", r), i = (0, s.ensureBytes)("publicKey", i), "strict" in a) throw new Error("options.strict was renamed to lowS");
                        const {lowS: l, prehash: c} = a;
                        let u, d;
                        try {
                            if ("string" == typeof o || o instanceof Uint8Array) try {
                                u = S.fromDER(o)
                            } catch (e) {
                                if (!(e instanceof t.DER.Err)) throw e;
                                u = S.fromCompact(o)
                            } else {
                                if ("object" != typeof o || "bigint" != typeof o.r || "bigint" != typeof o.s) throw new Error("PARSE");
                                {
                                    const {r: e, s: t} = o;
                                    u = new S(e, t)
                                }
                            }
                            d = g.fromHex(i)
                        } catch (e) {
                            if ("PARSE" === e.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
                            return !1
                        }
                        if (l && u.hasHighS()) return !1;
                        c && (r = n.hash(r));
                        const {r: h, s: p} = u, y = C(r), v = m(p), b = f(y * v), w = f(h * v),
                            x = g.BASE.multiplyAndAddUnsafe(d, b, w)?.toAffine();
                        return !!x && f(x.x) === h
                    }, ProjectivePoint: g, Signature: S, utils: k
                }
            }, t.SWUFpSqrtRatio = m, t.mapToCurveSimpleSWU = function (e, t) {
                if (r.validateField(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
                const n = m(e, t.Z);
                if (!e.isOdd) throw new Error("Fp.isOdd is not implemented!");
                return r => {
                    let i, s, a, o, l, c, u, d;
                    i = e.sqr(r), i = e.mul(i, t.Z), s = e.sqr(i), s = e.add(s, i), a = e.add(s, e.ONE), a = e.mul(a, t.B), o = e.cmov(t.Z, e.neg(s), !e.eql(s, e.ZERO)), o = e.mul(o, t.A), s = e.sqr(a), c = e.sqr(o), l = e.mul(c, t.A), s = e.add(s, l), s = e.mul(s, a), c = e.mul(c, o), l = e.mul(c, t.B), s = e.add(s, l), u = e.mul(i, a);
                    const {isValid: h, value: f} = n(s, c);
                    d = e.mul(i, r), d = e.mul(d, f), u = e.cmov(u, a, h), d = e.cmov(d, f, h);
                    const p = e.isOdd(r) === e.isOdd(d);
                    return d = e.cmov(e.neg(d), d, p), u = e.div(u, o), {x: u, y: d}
                }
            }
        }, 8358: (e, t, n) => {
            "use strict";
            var r;
            Object.defineProperty(t, "__esModule", {value: !0}), t.encodeToCurve = t.hashToCurve = t.schnorr = t.secp256k1 = void 0;
            const i = n(6053), s = n(64), a = n(9530), o = n(7851), l = n(4323), c = n(1322), u = n(5887),
                d = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
                h = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), f = BigInt(1),
                p = BigInt(2), m = (e, t) => (e + t / p) / t;

            function g(e) {
                const t = d, n = BigInt(3), r = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23),
                    l = BigInt(44), c = BigInt(88), u = e * e * e % t, h = u * u * e % t,
                    f = (0, a.pow2)(h, n, t) * h % t, m = (0, a.pow2)(f, n, t) * h % t,
                    g = (0, a.pow2)(m, p, t) * u % t, v = (0, a.pow2)(g, i, t) * g % t,
                    b = (0, a.pow2)(v, s, t) * v % t, w = (0, a.pow2)(b, l, t) * b % t,
                    x = (0, a.pow2)(w, c, t) * w % t, E = (0, a.pow2)(x, l, t) * b % t,
                    S = (0, a.pow2)(E, n, t) * h % t, k = (0, a.pow2)(S, o, t) * v % t,
                    A = (0, a.pow2)(k, r, t) * u % t, T = (0, a.pow2)(A, p, t);
                if (!y.eql(y.sqr(T), e)) throw new Error("Cannot find square root");
                return T
            }

            const y = (0, a.Field)(d, void 0, void 0, {sqrt: g});
            t.secp256k1 = (0, u.createCurve)({
                a: BigInt(0),
                b: BigInt(7),
                Fp: y,
                n: h,
                Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                h: BigInt(1),
                lowS: !0,
                endo: {
                    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                    splitScalar: e => {
                        const t = h, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                            r = -f * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                            i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s = n,
                            o = BigInt("0x100000000000000000000000000000000"), l = m(s * e, t), c = m(-r * e, t);
                        let u = (0, a.mod)(e - l * n - c * i, t), d = (0, a.mod)(-l * r - c * s, t);
                        const p = u > o, g = d > o;
                        if (p && (u = t - u), g && (d = t - d), u > o || d > o) throw new Error("splitScalar: Endomorphism failed, k=" + e);
                        return {k1neg: p, k1: u, k2neg: g, k2: d}
                    }
                }
            }, i.sha256);
            const v = BigInt(0), b = e => "bigint" == typeof e && v < e && e < d, w = {};

            function x(e, ...t) {
                let n = w[e];
                if (void 0 === n) {
                    const t = (0, i.sha256)(Uint8Array.from(e, (e => e.charCodeAt(0))));
                    n = (0, l.concatBytes)(t, t), w[e] = n
                }
                return (0, i.sha256)((0, l.concatBytes)(n, ...t))
            }

            const E = e => e.toRawBytes(!0).slice(1), S = e => (0, l.numberToBytesBE)(e, 32), k = e => (0, a.mod)(e, d),
                A = e => (0, a.mod)(e, h), T = t.secp256k1.ProjectivePoint;

            function C(e) {
                let n = t.secp256k1.utils.normPrivateKeyToScalar(e), r = T.fromPrivateKey(n);
                return {scalar: r.hasEvenY() ? n : A(-n), bytes: E(r)}
            }

            function R(e) {
                if (!b(e)) throw new Error("bad x: need 0 < x < p");
                const t = k(e * e);
                let n = g(k(t * e + BigInt(7)));
                n % p !== v && (n = k(-n));
                const r = new T(e, n, f);
                return r.assertValidity(), r
            }

            function L(...e) {
                return A((0, l.bytesToNumberBE)(x("BIP0340/challenge", ...e)))
            }

            function _(e, t, n) {
                const r = (0, l.ensureBytes)("signature", e, 64), i = (0, l.ensureBytes)("message", t),
                    s = (0, l.ensureBytes)("publicKey", n, 32);
                try {
                    const e = R((0, l.bytesToNumberBE)(s)), t = (0, l.bytesToNumberBE)(r.subarray(0, 32));
                    if (!b(t)) return !1;
                    const n = (0, l.bytesToNumberBE)(r.subarray(32, 64));
                    if (!("bigint" == typeof (u = n) && v < u && u < h)) return !1;
                    const d = L(S(t), E(e), i), f = (a = e, o = n, c = A(-d), T.BASE.multiplyAndAddUnsafe(a, o, c));
                    return !(!f || !f.hasEvenY() || f.toAffine().x !== t)
                } catch (e) {
                    return !1
                }
                var a, o, c, u
            }

            t.schnorr = {
                getPublicKey: function (e) {
                    return C(e).bytes
                },
                sign: function (e, t, n = (0, s.randomBytes)(32)) {
                    const r = (0, l.ensureBytes)("message", e), {bytes: i, scalar: a} = C(t),
                        o = (0, l.ensureBytes)("auxRand", n, 32),
                        c = S(a ^ (0, l.bytesToNumberBE)(x("BIP0340/aux", o))), u = x("BIP0340/nonce", c, i, r),
                        d = A((0, l.bytesToNumberBE)(u));
                    if (d === v) throw new Error("sign failed: k is zero");
                    const {bytes: h, scalar: f} = C(d), p = L(h, i, r), m = new Uint8Array(64);
                    if (m.set(h, 0), m.set(S(A(f + p * a)), 32), !_(m, r, i)) throw new Error("sign: Invalid signature produced");
                    return m
                },
                verify: _,
                utils: {
                    randomPrivateKey: t.secp256k1.utils.randomPrivateKey,
                    lift_x: R,
                    pointToBytes: E,
                    numberToBytesBE: l.numberToBytesBE,
                    bytesToNumberBE: l.bytesToNumberBE,
                    taggedHash: x,
                    mod: a.mod
                }
            };
            const P = c.isogenyMap(y, [["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"], ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"], ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"], ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]].map((e => e.map((e => BigInt(e)))))),
                N = (0, o.mapToCurveSimpleSWU)(y, {
                    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
                    B: BigInt("1771"),
                    Z: y.create(BigInt("-11"))
                });
            r = c.createHasher(t.secp256k1.ProjectivePoint, (e => {
                const {x: t, y: n} = N(y.create(e[0]));
                return P(t, n)
            }), {
                DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
                encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
                p: y.ORDER,
                m: 1,
                k: 128,
                expand: "xmd",
                hash: i.sha256
            }), t.hashToCurve = r.hashToCurve, t.encodeToCurve = r.encodeToCurve
        }, 3525: (e, t) => {
            "use strict";

            function n(e) {
                if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`)
            }

            function r(e) {
                if ("boolean" != typeof e) throw new Error(`Expected boolean, not ${e}`)
            }

            function i(e, ...t) {
                if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
                if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`)
            }

            function s(e) {
                if ("function" != typeof e || "function" != typeof e.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
                n(e.outputLen), n(e.blockLen)
            }

            function a(e, t = !0) {
                if (e.destroyed) throw new Error("Hash instance has been destroyed");
                if (t && e.finished) throw new Error("Hash#digest() has already been called")
            }

            function o(e, t) {
                i(e);
                const n = t.outputLen;
                if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`)
            }

            Object.defineProperty(t, "__esModule", {value: !0}), t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0, t.number = n, t.bool = r, t.bytes = i, t.hash = s, t.exists = a, t.output = o;
            const l = {number: n, bool: r, bytes: i, hash: s, exists: a, output: o};
            t.default = l
        }, 9350: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.SHA2 = void 0;
            const r = n(3525), i = n(64);

            class s extends i.Hash {
                constructor(e, t, n, r) {
                    super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, i.createView)(this.buffer)
                }

                update(e) {
                    r.default.exists(this);
                    const {view: t, buffer: n, blockLen: s} = this, a = (e = (0, i.toBytes)(e)).length;
                    for (let r = 0; r < a;) {
                        const o = Math.min(s - this.pos, a - r);
                        if (o !== s) n.set(e.subarray(r, r + o), this.pos), this.pos += o, r += o, this.pos === s && (this.process(t, 0), this.pos = 0); else {
                            const t = (0, i.createView)(e);
                            for (; s <= a - r; r += s) this.process(t, r)
                        }
                    }
                    return this.length += e.length, this.roundClean(), this
                }

                digestInto(e) {
                    r.default.exists(this), r.default.output(e, this), this.finished = !0;
                    const {buffer: t, view: n, blockLen: s, isLE: a} = this;
                    let {pos: o} = this;
                    t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(n, 0), o = 0);
                    for (let e = o; e < s; e++) t[e] = 0;
                    !function (e, t, n, r) {
                        if ("function" == typeof e.setBigUint64) return e.setBigUint64(t, n, r);
                        const i = BigInt(32), s = BigInt(4294967295), a = Number(n >> i & s), o = Number(n & s),
                            l = r ? 4 : 0, c = r ? 0 : 4;
                        e.setUint32(t + l, a, r), e.setUint32(t + c, o, r)
                    }(n, s - 8, BigInt(8 * this.length), a), this.process(n, 0);
                    const l = (0, i.createView)(e), c = this.outputLen;
                    if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
                    const u = c / 4, d = this.get();
                    if (u > d.length) throw new Error("_sha2: outputLen bigger than state");
                    for (let e = 0; e < u; e++) l.setUint32(4 * e, d[e], a)
                }

                digest() {
                    const {buffer: e, outputLen: t} = this;
                    this.digestInto(e);
                    const n = e.slice(0, t);
                    return this.destroy(), n
                }

                _cloneInto(e) {
                    e || (e = new this.constructor), e.set(...this.get());
                    const {blockLen: t, buffer: n, length: r, finished: i, destroyed: s, pos: a} = this;
                    return e.length = r, e.pos = a, e.finished = i, e.destroyed = s, r % t && e.buffer.set(n), e
                }
            }

            t.SHA2 = s
        }, 1655: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.add = t.toBig = t.split = t.fromBig = void 0;
            const n = BigInt(2 ** 32 - 1), r = BigInt(32);

            function i(e, t = !1) {
                return t ? {h: Number(e & n), l: Number(e >> r & n)} : {h: 0 | Number(e >> r & n), l: 0 | Number(e & n)}
            }

            function s(e, t = !1) {
                let n = new Uint32Array(e.length), r = new Uint32Array(e.length);
                for (let s = 0; s < e.length; s++) {
                    const {h: a, l: o} = i(e[s], t);
                    [n[s], r[s]] = [a, o]
                }
                return [n, r]
            }

            function a(e, t, n, r) {
                const i = (t >>> 0) + (r >>> 0);
                return {h: e + n + (i / 2 ** 32 | 0) | 0, l: 0 | i}
            }

            t.fromBig = i, t.split = s, t.toBig = (e, t) => BigInt(e >>> 0) << r | BigInt(t >>> 0), t.add = a;
            const o = {
                fromBig: i,
                split: s,
                toBig: t.toBig,
                shrSH: (e, t, n) => e >>> n,
                shrSL: (e, t, n) => e << 32 - n | t >>> n,
                rotrSH: (e, t, n) => e >>> n | t << 32 - n,
                rotrSL: (e, t, n) => e << 32 - n | t >>> n,
                rotrBH: (e, t, n) => e << 64 - n | t >>> n - 32,
                rotrBL: (e, t, n) => e >>> n - 32 | t << 64 - n,
                rotr32H: (e, t) => t,
                rotr32L: (e, t) => e,
                rotlSH: (e, t, n) => e << n | t >>> 32 - n,
                rotlSL: (e, t, n) => t << n | e >>> 32 - n,
                rotlBH: (e, t, n) => t << n - 32 | e >>> 64 - n,
                rotlBL: (e, t, n) => e << n - 32 | t >>> 64 - n,
                add: a,
                add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
                add3H: (e, t, n, r) => t + n + r + (e / 2 ** 32 | 0) | 0,
                add4L: (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
                add4H: (e, t, n, r, i) => t + n + r + i + (e / 2 ** 32 | 0) | 0,
                add5H: (e, t, n, r, i, s) => t + n + r + i + s + (e / 2 ** 32 | 0) | 0,
                add5L: (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0)
            };
            t.default = o
        }, 825: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.crypto = void 0, t.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0
        }, 1377: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.hmac = void 0;
            const r = n(3525), i = n(64);

            class s extends i.Hash {
                constructor(e, t) {
                    super(), this.finished = !1, this.destroyed = !1, r.default.hash(e);
                    const n = (0, i.toBytes)(t);
                    if (this.iHash = e.create(), "function" != typeof this.iHash.update) throw new TypeError("Expected instance of class which extends utils.Hash");
                    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
                    const s = this.blockLen, a = new Uint8Array(s);
                    a.set(n.length > s ? e.create().update(n).digest() : n);
                    for (let e = 0; e < a.length; e++) a[e] ^= 54;
                    this.iHash.update(a), this.oHash = e.create();
                    for (let e = 0; e < a.length; e++) a[e] ^= 106;
                    this.oHash.update(a), a.fill(0)
                }

                update(e) {
                    return r.default.exists(this), this.iHash.update(e), this
                }

                digestInto(e) {
                    r.default.exists(this), r.default.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy()
                }

                digest() {
                    const e = new Uint8Array(this.oHash.outputLen);
                    return this.digestInto(e), e
                }

                _cloneInto(e) {
                    e || (e = Object.create(Object.getPrototypeOf(this), {}));
                    const {oHash: t, iHash: n, finished: r, destroyed: i, blockLen: s, outputLen: a} = this;
                    return e.finished = r, e.destroyed = i, e.blockLen = s, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e
                }

                destroy() {
                    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
                }
            }

            t.hmac = (e, t, n) => new s(e, t).update(n).digest(), t.hmac.create = (e, t) => new s(e, t)
        }, 9179: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.pbkdf2Async = t.pbkdf2 = void 0;
            const r = n(3525), i = n(1377), s = n(64);

            function a(e, t, n, a) {
                r.default.hash(e);
                const o = (0, s.checkOpts)({dkLen: 32, asyncTick: 10}, a), {c: l, dkLen: c, asyncTick: u} = o;
                if (r.default.number(l), r.default.number(c), r.default.number(u), l < 1) throw new Error("PBKDF2: iterations (c) should be >= 1");
                const d = (0, s.toBytes)(t), h = (0, s.toBytes)(n), f = new Uint8Array(c), p = i.hmac.create(e, d),
                    m = p._cloneInto().update(h);
                return {c: l, dkLen: c, asyncTick: u, DK: f, PRF: p, PRFSalt: m}
            }

            function o(e, t, n, r, i) {
                return e.destroy(), t.destroy(), r && r.destroy(), i.fill(0), n
            }

            t.pbkdf2 = function (e, t, n, r) {
                const {c: i, dkLen: l, DK: c, PRF: u, PRFSalt: d} = a(e, t, n, r);
                let h;
                const f = new Uint8Array(4), p = (0, s.createView)(f), m = new Uint8Array(u.outputLen);
                for (let e = 1, t = 0; t < l; e++, t += u.outputLen) {
                    const n = c.subarray(t, t + u.outputLen);
                    p.setInt32(0, e, !1), (h = d._cloneInto(h)).update(f).digestInto(m), n.set(m.subarray(0, n.length));
                    for (let e = 1; e < i; e++) {
                        u._cloneInto(h).update(m).digestInto(m);
                        for (let e = 0; e < n.length; e++) n[e] ^= m[e]
                    }
                }
                return o(u, d, c, h, m)
            }, t.pbkdf2Async = async function (e, t, n, r) {
                const {c: i, dkLen: l, asyncTick: c, DK: u, PRF: d, PRFSalt: h} = a(e, t, n, r);
                let f;
                const p = new Uint8Array(4), m = (0, s.createView)(p), g = new Uint8Array(d.outputLen);
                for (let e = 1, t = 0; t < l; e++, t += d.outputLen) {
                    const n = u.subarray(t, t + d.outputLen);
                    m.setInt32(0, e, !1), (f = h._cloneInto(f)).update(p).digestInto(g), n.set(g.subarray(0, n.length)), await (0, s.asyncLoop)(i - 1, c, (e => {
                        d._cloneInto(f).update(g).digestInto(g);
                        for (let e = 0; e < n.length; e++) n[e] ^= g[e]
                    }))
                }
                return o(d, h, u, f, g)
            }
        }, 6053: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.sha224 = t.sha256 = void 0;
            const r = n(9350), i = n(64), s = (e, t, n) => e & t ^ e & n ^ t & n,
                a = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
                o = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
                l = new Uint32Array(64);

            class c extends r.SHA2 {
                constructor() {
                    super(64, 32, 8, !1), this.A = 0 | o[0], this.B = 0 | o[1], this.C = 0 | o[2], this.D = 0 | o[3], this.E = 0 | o[4], this.F = 0 | o[5], this.G = 0 | o[6], this.H = 0 | o[7]
                }

                get() {
                    const {A: e, B: t, C: n, D: r, E: i, F: s, G: a, H: o} = this;
                    return [e, t, n, r, i, s, a, o]
                }

                set(e, t, n, r, i, s, a, o) {
                    this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | s, this.G = 0 | a, this.H = 0 | o
                }

                process(e, t) {
                    for (let n = 0; n < 16; n++, t += 4) l[n] = e.getUint32(t, !1);
                    for (let e = 16; e < 64; e++) {
                        const t = l[e - 15], n = l[e - 2], r = (0, i.rotr)(t, 7) ^ (0, i.rotr)(t, 18) ^ t >>> 3,
                            s = (0, i.rotr)(n, 17) ^ (0, i.rotr)(n, 19) ^ n >>> 10;
                        l[e] = s + l[e - 7] + r + l[e - 16] | 0
                    }
                    let {A: n, B: r, C: o, D: c, E: u, F: d, G: h, H: f} = this;
                    for (let e = 0; e < 64; e++) {
                        const t = f + ((0, i.rotr)(u, 6) ^ (0, i.rotr)(u, 11) ^ (0, i.rotr)(u, 25)) + ((p = u) & d ^ ~p & h) + a[e] + l[e] | 0,
                            m = ((0, i.rotr)(n, 2) ^ (0, i.rotr)(n, 13) ^ (0, i.rotr)(n, 22)) + s(n, r, o) | 0;
                        f = h, h = d, d = u, u = c + t | 0, c = o, o = r, r = n, n = t + m | 0
                    }
                    var p;
                    n = n + this.A | 0, r = r + this.B | 0, o = o + this.C | 0, c = c + this.D | 0, u = u + this.E | 0, d = d + this.F | 0, h = h + this.G | 0, f = f + this.H | 0, this.set(n, r, o, c, u, d, h, f)
                }

                roundClean() {
                    l.fill(0)
                }

                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
                }
            }

            class u extends c {
                constructor() {
                    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28
                }
            }

            t.sha256 = (0, i.wrapConstructor)((() => new c)), t.sha224 = (0, i.wrapConstructor)((() => new u))
        }, 2540: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.sha384 = t.sha512_256 = t.sha512_224 = t.sha512 = t.SHA512 = void 0;
            const r = n(9350), i = n(1655),
                s = n(64), [a, o] = i.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e => BigInt(e)))),
                l = new Uint32Array(80), c = new Uint32Array(80);

            class u extends r.SHA2 {
                constructor() {
                    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
                }

                get() {
                    const {
                        Ah: e,
                        Al: t,
                        Bh: n,
                        Bl: r,
                        Ch: i,
                        Cl: s,
                        Dh: a,
                        Dl: o,
                        Eh: l,
                        El: c,
                        Fh: u,
                        Fl: d,
                        Gh: h,
                        Gl: f,
                        Hh: p,
                        Hl: m
                    } = this;
                    return [e, t, n, r, i, s, a, o, l, c, u, d, h, f, p, m]
                }

                set(e, t, n, r, i, s, a, o, l, c, u, d, h, f, p, m) {
                    this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | n, this.Bl = 0 | r, this.Ch = 0 | i, this.Cl = 0 | s, this.Dh = 0 | a, this.Dl = 0 | o, this.Eh = 0 | l, this.El = 0 | c, this.Fh = 0 | u, this.Fl = 0 | d, this.Gh = 0 | h, this.Gl = 0 | f, this.Hh = 0 | p, this.Hl = 0 | m
                }

                process(e, t) {
                    for (let n = 0; n < 16; n++, t += 4) l[n] = e.getUint32(t), c[n] = e.getUint32(t += 4);
                    for (let e = 16; e < 80; e++) {
                        const t = 0 | l[e - 15], n = 0 | c[e - 15],
                            r = i.default.rotrSH(t, n, 1) ^ i.default.rotrSH(t, n, 8) ^ i.default.shrSH(t, n, 7),
                            s = i.default.rotrSL(t, n, 1) ^ i.default.rotrSL(t, n, 8) ^ i.default.shrSL(t, n, 7),
                            a = 0 | l[e - 2], o = 0 | c[e - 2],
                            u = i.default.rotrSH(a, o, 19) ^ i.default.rotrBH(a, o, 61) ^ i.default.shrSH(a, o, 6),
                            d = i.default.rotrSL(a, o, 19) ^ i.default.rotrBL(a, o, 61) ^ i.default.shrSL(a, o, 6),
                            h = i.default.add4L(s, d, c[e - 7], c[e - 16]),
                            f = i.default.add4H(h, r, u, l[e - 7], l[e - 16]);
                        l[e] = 0 | f, c[e] = 0 | h
                    }
                    let {
                        Ah: n,
                        Al: r,
                        Bh: s,
                        Bl: u,
                        Ch: d,
                        Cl: h,
                        Dh: f,
                        Dl: p,
                        Eh: m,
                        El: g,
                        Fh: y,
                        Fl: v,
                        Gh: b,
                        Gl: w,
                        Hh: x,
                        Hl: E
                    } = this;
                    for (let e = 0; e < 80; e++) {
                        const t = i.default.rotrSH(m, g, 14) ^ i.default.rotrSH(m, g, 18) ^ i.default.rotrBH(m, g, 41),
                            S = i.default.rotrSL(m, g, 14) ^ i.default.rotrSL(m, g, 18) ^ i.default.rotrBL(m, g, 41),
                            k = m & y ^ ~m & b, A = g & v ^ ~g & w, T = i.default.add5L(E, S, A, o[e], c[e]),
                            C = i.default.add5H(T, x, t, k, a[e], l[e]), R = 0 | T,
                            L = i.default.rotrSH(n, r, 28) ^ i.default.rotrBH(n, r, 34) ^ i.default.rotrBH(n, r, 39),
                            _ = i.default.rotrSL(n, r, 28) ^ i.default.rotrBL(n, r, 34) ^ i.default.rotrBL(n, r, 39),
                            P = n & s ^ n & d ^ s & d, N = r & u ^ r & h ^ u & h;
                        x = 0 | b, E = 0 | w, b = 0 | y, w = 0 | v, y = 0 | m, v = 0 | g, ({
                            h: m,
                            l: g
                        } = i.default.add(0 | f, 0 | p, 0 | C, 0 | R)), f = 0 | d, p = 0 | h, d = 0 | s, h = 0 | u, s = 0 | n, u = 0 | r;
                        const j = i.default.add3L(R, _, N);
                        n = i.default.add3H(j, C, L, P), r = 0 | j
                    }
                    ({h: n, l: r} = i.default.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)), ({
                        h: s,
                        l: u
                    } = i.default.add(0 | this.Bh, 0 | this.Bl, 0 | s, 0 | u)), ({
                        h: d,
                        l: h
                    } = i.default.add(0 | this.Ch, 0 | this.Cl, 0 | d, 0 | h)), ({
                        h: f,
                        l: p
                    } = i.default.add(0 | this.Dh, 0 | this.Dl, 0 | f, 0 | p)), ({
                        h: m,
                        l: g
                    } = i.default.add(0 | this.Eh, 0 | this.El, 0 | m, 0 | g)), ({
                        h: y,
                        l: v
                    } = i.default.add(0 | this.Fh, 0 | this.Fl, 0 | y, 0 | v)), ({
                        h: b,
                        l: w
                    } = i.default.add(0 | this.Gh, 0 | this.Gl, 0 | b, 0 | w)), ({
                        h: x,
                        l: E
                    } = i.default.add(0 | this.Hh, 0 | this.Hl, 0 | x, 0 | E)), this.set(n, r, s, u, d, h, f, p, m, g, y, v, b, w, x, E)
                }

                roundClean() {
                    l.fill(0), c.fill(0)
                }

                destroy() {
                    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
                }
            }

            t.SHA512 = u;

            class d extends u {
                constructor() {
                    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28
                }
            }

            class h extends u {
                constructor() {
                    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32
                }
            }

            class f extends u {
                constructor() {
                    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48
                }
            }

            t.sha512 = (0, s.wrapConstructor)((() => new u)), t.sha512_224 = (0, s.wrapConstructor)((() => new d)), t.sha512_256 = (0, s.wrapConstructor)((() => new h)), t.sha384 = (0, s.wrapConstructor)((() => new f))
        }, 64: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.randomBytes = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0;
            const r = n(825);
            if (t.u8 = e => new Uint8Array(e.buffer, e.byteOffset, e.byteLength), t.u32 = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), t.createView = e => new DataView(e.buffer, e.byteOffset, e.byteLength), t.rotr = (e, t) => e << 32 - t | e >>> t, t.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !t.isLE) throw new Error("Non little-endian hardware is not supported");
            const i = Array.from({length: 256}, ((e, t) => t.toString(16).padStart(2, "0")));

            function s(e) {
                if ("string" != typeof e) throw new TypeError("utf8ToBytes expected string, got " + typeof e);
                return (new TextEncoder).encode(e)
            }

            function a(e) {
                if ("string" == typeof e && (e = s(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
                return e
            }

            t.bytesToHex = function (e) {
                if (!(e instanceof Uint8Array)) throw new Error("Uint8Array expected");
                let t = "";
                for (let n = 0; n < e.length; n++) t += i[e[n]];
                return t
            }, t.hexToBytes = function (e) {
                if ("string" != typeof e) throw new TypeError("hexToBytes: expected string, got " + typeof e);
                if (e.length % 2) throw new Error("hexToBytes: received invalid unpadded hex");
                const t = new Uint8Array(e.length / 2);
                for (let n = 0; n < t.length; n++) {
                    const r = 2 * n, i = e.slice(r, r + 2), s = Number.parseInt(i, 16);
                    if (Number.isNaN(s) || s < 0) throw new Error("Invalid byte sequence");
                    t[n] = s
                }
                return t
            }, t.nextTick = async () => {
            }, t.asyncLoop = async function (e, n, r) {
                let i = Date.now();
                for (let s = 0; s < e; s++) {
                    r(s);
                    const e = Date.now() - i;
                    e >= 0 && e < n || (await (0, t.nextTick)(), i += e)
                }
            }, t.utf8ToBytes = s, t.toBytes = a, t.concatBytes = function (...e) {
                if (!e.every((e => e instanceof Uint8Array))) throw new Error("Uint8Array list expected");
                if (1 === e.length) return e[0];
                const t = e.reduce(((e, t) => e + t.length), 0), n = new Uint8Array(t);
                for (let t = 0, r = 0; t < e.length; t++) {
                    const i = e[t];
                    n.set(i, r), r += i.length
                }
                return n
            }, t.Hash = class {
                clone() {
                    return this._cloneInto()
                }
            }, t.checkOpts = function (e, t) {
                if (void 0 !== t && ("object" != typeof t || (n = t, "[object Object]" !== Object.prototype.toString.call(n) || n.constructor !== Object))) throw new TypeError("Options should be object or undefined");
                var n;
                return Object.assign(e, t)
            }, t.wrapConstructor = function (e) {
                const t = t => e().update(a(t)).digest(), n = e();
                return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t
            }, t.wrapConstructorWithOpts = function (e) {
                const t = (t, n) => e(n).update(a(t)).digest(), n = e({});
                return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = t => e(t), t
            }, t.randomBytes = function (e = 32) {
                if (r.crypto && "function" == typeof r.crypto.getRandomValues) return r.crypto.getRandomValues(new Uint8Array(e));
                throw new Error("crypto.getRandomValues must be defined")
            }
        }, 6237: (e, t) => {
            "use strict";

            function n(e) {
                if (!Number.isSafeInteger(e)) throw new Error(`Wrong integer: ${e}`)
            }

            function r(...e) {
                const t = (e, t) => n => e(t(n));
                return {
                    encode: Array.from(e).reverse().reduce(((e, n) => e ? t(e, n.encode) : n.encode), void 0),
                    decode: e.reduce(((e, n) => e ? t(e, n.decode) : n.decode), void 0)
                }
            }

            function i(e) {
                return {
                    encode: t => {
                        if (!Array.isArray(t) || t.length && "number" != typeof t[0]) throw new Error("alphabet.encode input should be an array of numbers");
                        return t.map((t => {
                            if (n(t), t < 0 || t >= e.length) throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${e.length})`);
                            return e[t]
                        }))
                    }, decode: t => {
                        if (!Array.isArray(t) || t.length && "string" != typeof t[0]) throw new Error("alphabet.decode input should be array of strings");
                        return t.map((t => {
                            if ("string" != typeof t) throw new Error(`alphabet.decode: not string element=${t}`);
                            const n = e.indexOf(t);
                            if (-1 === n) throw new Error(`Unknown letter: "${t}". Allowed: ${e}`);
                            return n
                        }))
                    }
                }
            }

            function s(e = "") {
                if ("string" != typeof e) throw new Error("join separator should be string");
                return {
                    encode: t => {
                        if (!Array.isArray(t) || t.length && "string" != typeof t[0]) throw new Error("join.encode input should be array of strings");
                        for (let e of t) if ("string" != typeof e) throw new Error(`join.encode: non-string input=${e}`);
                        return t.join(e)
                    }, decode: t => {
                        if ("string" != typeof t) throw new Error("join.decode input should be string");
                        return t.split(e)
                    }
                }
            }

            function a(e, t = "=") {
                if (n(e), "string" != typeof t) throw new Error("padding chr should be string");
                return {
                    encode(n) {
                        if (!Array.isArray(n) || n.length && "string" != typeof n[0]) throw new Error("padding.encode input should be array of strings");
                        for (let e of n) if ("string" != typeof e) throw new Error(`padding.encode: non-string input=${e}`);
                        for (; n.length * e % 8;) n.push(t);
                        return n
                    }, decode(n) {
                        if (!Array.isArray(n) || n.length && "string" != typeof n[0]) throw new Error("padding.encode input should be array of strings");
                        for (let e of n) if ("string" != typeof e) throw new Error(`padding.decode: non-string input=${e}`);
                        let r = n.length;
                        if (r * e % 8) throw new Error("Invalid padding: string should have whole number of bytes");
                        for (; r > 0 && n[r - 1] === t; r--) if (!((r - 1) * e % 8)) throw new Error("Invalid padding: string has too much padding");
                        return n.slice(0, r)
                    }
                }
            }

            function o(e) {
                if ("function" != typeof e) throw new Error("normalize fn should be function");
                return {encode: e => e, decode: t => e(t)}
            }

            function l(e, t, r) {
                if (t < 2) throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
                if (r < 2) throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
                if (!Array.isArray(e)) throw new Error("convertRadix: data should be array");
                if (!e.length) return [];
                let i = 0;
                const s = [], a = Array.from(e);
                for (a.forEach((e => {
                    if (n(e), e < 0 || e >= t) throw new Error(`Wrong integer: ${e}`)
                })); ;) {
                    let e = 0, n = !0;
                    for (let s = i; s < a.length; s++) {
                        const o = a[s], l = t * e + o;
                        if (!Number.isSafeInteger(l) || t * e / t !== e || l - o != t * e) throw new Error("convertRadix: carry overflow");
                        if (e = l % r, a[s] = Math.floor(l / r), !Number.isSafeInteger(a[s]) || a[s] * r + e !== l) throw new Error("convertRadix: carry overflow");
                        n && (a[s] ? n = !1 : i = s)
                    }
                    if (s.push(e), n) break
                }
                for (let t = 0; t < e.length - 1 && 0 === e[t]; t++) s.push(0);
                return s.reverse()
            }

            Object.defineProperty(t, "__esModule", {value: !0}), t.bytes = t.stringToBytes = t.str = t.bytesToString = t.hex = t.utf8 = t.bech32m = t.bech32 = t.base58check = t.base58xmr = t.base58xrp = t.base58flickr = t.base58 = t.base64url = t.base64 = t.base32crockford = t.base32hex = t.base32 = t.base16 = t.utils = t.assertNumber = void 0, t.assertNumber = n;
            const c = (e, t) => t ? c(t, e % t) : e, u = (e, t) => e + (t - c(e, t));

            function d(e, t, r, i) {
                if (!Array.isArray(e)) throw new Error("convertRadix2: data should be array");
                if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong from=${t}`);
                if (r <= 0 || r > 32) throw new Error(`convertRadix2: wrong to=${r}`);
                if (u(t, r) > 32) throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${u(t, r)}`);
                let s = 0, a = 0;
                const o = 2 ** r - 1, l = [];
                for (const i of e) {
                    if (n(i), i >= 2 ** t) throw new Error(`convertRadix2: invalid data word=${i} from=${t}`);
                    if (s = s << t | i, a + t > 32) throw new Error(`convertRadix2: carry overflow pos=${a} from=${t}`);
                    for (a += t; a >= r; a -= r) l.push((s >> a - r & o) >>> 0);
                    s &= 2 ** a - 1
                }
                if (s = s << r - a & o, !i && a >= t) throw new Error("Excess padding");
                if (!i && s) throw new Error(`Non-zero padding: ${s}`);
                return i && a > 0 && l.push(s >>> 0), l
            }

            function h(e) {
                return n(e), {
                    encode: t => {
                        if (!(t instanceof Uint8Array)) throw new Error("radix.encode input should be Uint8Array");
                        return l(Array.from(t), 256, e)
                    }, decode: t => {
                        if (!Array.isArray(t) || t.length && "number" != typeof t[0]) throw new Error("radix.decode input should be array of strings");
                        return Uint8Array.from(l(t, e, 256))
                    }
                }
            }

            function f(e, t = !1) {
                if (n(e), e <= 0 || e > 32) throw new Error("radix2: bits should be in (0..32]");
                if (u(8, e) > 32 || u(e, 8) > 32) throw new Error("radix2: carry overflow");
                return {
                    encode: n => {
                        if (!(n instanceof Uint8Array)) throw new Error("radix2.encode input should be Uint8Array");
                        return d(Array.from(n), 8, e, !t)
                    }, decode: n => {
                        if (!Array.isArray(n) || n.length && "number" != typeof n[0]) throw new Error("radix2.decode input should be array of strings");
                        return Uint8Array.from(d(n, e, 8, t))
                    }
                }
            }

            function p(e) {
                if ("function" != typeof e) throw new Error("unsafeWrapper fn should be function");
                return function (...t) {
                    try {
                        return e.apply(null, t)
                    } catch (e) {
                    }
                }
            }

            function m(e, t) {
                if (n(e), "function" != typeof t) throw new Error("checksum fn should be function");
                return {
                    encode(n) {
                        if (!(n instanceof Uint8Array)) throw new Error("checksum.encode: input should be Uint8Array");
                        const r = t(n).slice(0, e), i = new Uint8Array(n.length + e);
                        return i.set(n), i.set(r, n.length), i
                    }, decode(n) {
                        if (!(n instanceof Uint8Array)) throw new Error("checksum.decode: input should be Uint8Array");
                        const r = n.slice(0, -e), i = t(r).slice(0, e), s = n.slice(-e);
                        for (let t = 0; t < e; t++) if (i[t] !== s[t]) throw new Error("Invalid checksum");
                        return r
                    }
                }
            }

            t.utils = {
                alphabet: i,
                chain: r,
                checksum: m,
                radix: h,
                radix2: f,
                join: s,
                padding: a
            }, t.base16 = r(f(4), i("0123456789ABCDEF"), s("")), t.base32 = r(f(5), i("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), a(5), s("")), t.base32hex = r(f(5), i("0123456789ABCDEFGHIJKLMNOPQRSTUV"), a(5), s("")), t.base32crockford = r(f(5), i("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), s(""), o((e => e.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")))), t.base64 = r(f(6), i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), a(6), s("")), t.base64url = r(f(6), i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), a(6), s(""));
            const g = e => r(h(58), i(e), s(""));
            t.base58 = g("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), t.base58flickr = g("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), t.base58xrp = g("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
            const y = [0, 2, 3, 5, 6, 7, 9, 10, 11];
            t.base58xmr = {
                encode(e) {
                    let n = "";
                    for (let r = 0; r < e.length; r += 8) {
                        const i = e.subarray(r, r + 8);
                        n += t.base58.encode(i).padStart(y[i.length], "1")
                    }
                    return n
                }, decode(e) {
                    let n = [];
                    for (let r = 0; r < e.length; r += 11) {
                        const i = e.slice(r, r + 11), s = y.indexOf(i.length), a = t.base58.decode(i);
                        for (let e = 0; e < a.length - s; e++) if (0 !== a[e]) throw new Error("base58xmr: wrong padding");
                        n = n.concat(Array.from(a.slice(a.length - s)))
                    }
                    return Uint8Array.from(n)
                }
            }, t.base58check = e => r(m(4, (t => e(e(t)))), t.base58);
            const v = r(i("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), s("")),
                b = [996825010, 642813549, 513874426, 1027748829, 705979059];

            function w(e) {
                const t = e >> 25;
                let n = (33554431 & e) << 5;
                for (let e = 0; e < b.length; e++) 1 == (t >> e & 1) && (n ^= b[e]);
                return n
            }

            function x(e, t, n = 1) {
                const r = e.length;
                let i = 1;
                for (let t = 0; t < r; t++) {
                    const n = e.charCodeAt(t);
                    if (n < 33 || n > 126) throw new Error(`Invalid prefix (${e})`);
                    i = w(i) ^ n >> 5
                }
                i = w(i);
                for (let t = 0; t < r; t++) i = w(i) ^ 31 & e.charCodeAt(t);
                for (let e of t) i = w(i) ^ e;
                for (let e = 0; e < 6; e++) i = w(i);
                return i ^= n, v.encode(d([i % 2 ** 30], 30, 5, !1))
            }

            function E(e) {
                const t = "bech32" === e ? 1 : 734539939, n = f(5), r = n.decode, i = n.encode, s = p(r);

                function a(e, n = 90) {
                    if ("string" != typeof e) throw new Error("bech32.decode input should be string, not " + typeof e);
                    if (e.length < 8 || !1 !== n && e.length > n) throw new TypeError(`Wrong string length: ${e.length} (${e}). Expected (8..${n})`);
                    const r = e.toLowerCase();
                    if (e !== r && e !== e.toUpperCase()) throw new Error("String must be lowercase or uppercase");
                    const i = (e = r).lastIndexOf("1");
                    if (0 === i || -1 === i) throw new Error('Letter "1" must be present between prefix and data only');
                    const s = e.slice(0, i), a = e.slice(i + 1);
                    if (a.length < 6) throw new Error("Data must be at least 6 characters long");
                    const o = v.decode(a).slice(0, -6), l = x(s, o, t);
                    if (!a.endsWith(l)) throw new Error(`Invalid checksum in ${e}: expected "${l}"`);
                    return {prefix: s, words: o}
                }

                return {
                    encode: function (e, n, r = 90) {
                        if ("string" != typeof e) throw new Error("bech32.encode prefix should be string, not " + typeof e);
                        if (!Array.isArray(n) || n.length && "number" != typeof n[0]) throw new Error("bech32.encode words should be array of numbers, not " + typeof n);
                        const i = e.length + 7 + n.length;
                        if (!1 !== r && i > r) throw new TypeError(`Length ${i} exceeds limit ${r}`);
                        return `${e = e.toLowerCase()}1${v.encode(n)}${x(e, n, t)}`
                    }, decode: a, decodeToBytes: function (e) {
                        const {prefix: t, words: n} = a(e, !1);
                        return {prefix: t, words: n, bytes: r(n)}
                    }, decodeUnsafe: p(a), fromWords: r, fromWordsUnsafe: s, toWords: i
                }
            }

            t.bech32 = E("bech32"), t.bech32m = E("bech32m"), t.utf8 = {
                encode: e => (new TextDecoder).decode(e),
                decode: e => (new TextEncoder).encode(e)
            }, t.hex = r(f(4), i("0123456789abcdef"), s(""), o((e => {
                if ("string" != typeof e || e.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);
                return e.toLowerCase()
            })));
            const S = {
                utf8: t.utf8,
                hex: t.hex,
                base16: t.base16,
                base32: t.base32,
                base64: t.base64,
                base64url: t.base64url,
                base58: t.base58,
                base58xmr: t.base58xmr
            }, k = `Invalid encoding type. Available types: ${Object.keys(S).join(", ")}`;
            t.bytesToString = (e, t) => {
                if ("string" != typeof e || !S.hasOwnProperty(e)) throw new TypeError(k);
                if (!(t instanceof Uint8Array)) throw new TypeError("bytesToString() expects Uint8Array");
                return S[e].encode(t)
            }, t.str = t.bytesToString, t.stringToBytes = (e, t) => {
                if (!S.hasOwnProperty(e)) throw new TypeError(k);
                if ("string" != typeof t) throw new TypeError("stringToBytes() expects string");
                return S[e].decode(t)
            }, t.bytes = t.stringToBytes
        }, 5796: (e, t, n) => {
            "use strict";
            t.JJ = t.oy = t.OF = void 0;
            const r = n(3525), i = (n(9179), n(6053)), s = (n(2540), n(64)), a = n(6237);

            function o(e) {
                if ("string" != typeof e) throw new TypeError("Invalid mnemonic type: " + typeof e);
                return e.normalize("NFKD")
            }

            function l(e) {
                r.default.bytes(e, 16, 20, 24, 28, 32)
            }

            t.OF = function (e, t = 128) {
                if (r.default.number(t), t % 32 != 0 || t > 256) throw new TypeError("Invalid entropy");
                return d((0, s.randomBytes)(t / 8), e)
            };
            const c = e => {
                const t = 8 - e.length / 4;
                return new Uint8Array([(0, i.sha256)(e)[0] >> t << t])
            };

            function u(e) {
                if (!Array.isArray(e) || 2048 !== e.length || "string" != typeof e[0]) throw new Error("Worlist: expected array of 2048 strings");
                return e.forEach((e => {
                    if ("string" != typeof e) throw new Error(`Wordlist: non-string element: ${e}`)
                })), a.utils.chain(a.utils.checksum(1, c), a.utils.radix2(11, !0), a.utils.alphabet(e))
            }

            function d(e, t) {
                return l(e), u(t).encode(e).join((e => "" === e[0])(t) ? "" : " ")
            }

            t.oy = function (e, t) {
                const {words: n} = function (e) {
                    const t = o(e), n = t.split(" ");
                    if (![12, 15, 18, 21, 24].includes(n.length)) throw new Error("Invalid mnemonic");
                    return {nfkd: t, words: n}
                }(e), r = u(t).decode(n);
                return l(r), r
            }, t.JJ = d
        }, 8050: (e, t) => {
            "use strict";
            t.U = void 0, t.U = "abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo".split("\n")
        }, 9437: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0});
            var r = n(5457);

            function i(e, t, n) {
                return void 0 === t && (t = new Uint8Array(2)), void 0 === n && (n = 0), t[n + 0] = e >>> 8, t[n + 1] = e >>> 0, t
            }

            function s(e, t, n) {
                return void 0 === t && (t = new Uint8Array(2)), void 0 === n && (n = 0), t[n + 0] = e >>> 0, t[n + 1] = e >>> 8, t
            }

            function a(e, t) {
                return void 0 === t && (t = 0), e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
            }

            function o(e, t) {
                return void 0 === t && (t = 0), (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0
            }

            function l(e, t) {
                return void 0 === t && (t = 0), e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]
            }

            function c(e, t) {
                return void 0 === t && (t = 0), (e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]) >>> 0
            }

            function u(e, t, n) {
                return void 0 === t && (t = new Uint8Array(4)), void 0 === n && (n = 0), t[n + 0] = e >>> 24, t[n + 1] = e >>> 16, t[n + 2] = e >>> 8, t[n + 3] = e >>> 0, t
            }

            function d(e, t, n) {
                return void 0 === t && (t = new Uint8Array(4)), void 0 === n && (n = 0), t[n + 0] = e >>> 0, t[n + 1] = e >>> 8, t[n + 2] = e >>> 16, t[n + 3] = e >>> 24, t
            }

            function h(e, t, n) {
                return void 0 === t && (t = new Uint8Array(8)), void 0 === n && (n = 0), u(e / 4294967296 >>> 0, t, n), u(e >>> 0, t, n + 4), t
            }

            function f(e, t, n) {
                return void 0 === t && (t = new Uint8Array(8)), void 0 === n && (n = 0), d(e >>> 0, t, n), d(e / 4294967296 >>> 0, t, n + 4), t
            }

            t.readInt16BE = function (e, t) {
                return void 0 === t && (t = 0), (e[t + 0] << 8 | e[t + 1]) << 16 >> 16
            }, t.readUint16BE = function (e, t) {
                return void 0 === t && (t = 0), (e[t + 0] << 8 | e[t + 1]) >>> 0
            }, t.readInt16LE = function (e, t) {
                return void 0 === t && (t = 0), (e[t + 1] << 8 | e[t]) << 16 >> 16
            }, t.readUint16LE = function (e, t) {
                return void 0 === t && (t = 0), (e[t + 1] << 8 | e[t]) >>> 0
            }, t.writeUint16BE = i, t.writeInt16BE = i, t.writeUint16LE = s, t.writeInt16LE = s, t.readInt32BE = a, t.readUint32BE = o, t.readInt32LE = l, t.readUint32LE = c, t.writeUint32BE = u, t.writeInt32BE = u, t.writeUint32LE = d, t.writeInt32LE = d, t.readInt64BE = function (e, t) {
                void 0 === t && (t = 0);
                var n = a(e, t), r = a(e, t + 4);
                return 4294967296 * n + r - 4294967296 * (r >> 31)
            }, t.readUint64BE = function (e, t) {
                return void 0 === t && (t = 0), 4294967296 * o(e, t) + o(e, t + 4)
            }, t.readInt64LE = function (e, t) {
                void 0 === t && (t = 0);
                var n = l(e, t);
                return 4294967296 * l(e, t + 4) + n - 4294967296 * (n >> 31)
            }, t.readUint64LE = function (e, t) {
                void 0 === t && (t = 0);
                var n = c(e, t);
                return 4294967296 * c(e, t + 4) + n
            }, t.writeUint64BE = h, t.writeInt64BE = h, t.writeUint64LE = f, t.writeInt64LE = f, t.readUintBE = function (e, t, n) {
                if (void 0 === n && (n = 0), e % 8 != 0) throw new Error("readUintBE supports only bitLengths divisible by 8");
                if (e / 8 > t.length - n) throw new Error("readUintBE: array is too short for the given bitLength");
                for (var r = 0, i = 1, s = e / 8 + n - 1; s >= n; s--) r += t[s] * i, i *= 256;
                return r
            }, t.readUintLE = function (e, t, n) {
                if (void 0 === n && (n = 0), e % 8 != 0) throw new Error("readUintLE supports only bitLengths divisible by 8");
                if (e / 8 > t.length - n) throw new Error("readUintLE: array is too short for the given bitLength");
                for (var r = 0, i = 1, s = n; s < n + e / 8; s++) r += t[s] * i, i *= 256;
                return r
            }, t.writeUintBE = function (e, t, n, i) {
                if (void 0 === n && (n = new Uint8Array(e / 8)), void 0 === i && (i = 0), e % 8 != 0) throw new Error("writeUintBE supports only bitLengths divisible by 8");
                if (!r.isSafeInteger(t)) throw new Error("writeUintBE value must be an integer");
                for (var s = 1, a = e / 8 + i - 1; a >= i; a--) n[a] = t / s & 255, s *= 256;
                return n
            }, t.writeUintLE = function (e, t, n, i) {
                if (void 0 === n && (n = new Uint8Array(e / 8)), void 0 === i && (i = 0), e % 8 != 0) throw new Error("writeUintLE supports only bitLengths divisible by 8");
                if (!r.isSafeInteger(t)) throw new Error("writeUintLE value must be an integer");
                for (var s = 1, a = i; a < i + e / 8; a++) n[a] = t / s & 255, s *= 256;
                return n
            }, t.readFloat32BE = function (e, t) {
                return void 0 === t && (t = 0), new DataView(e.buffer, e.byteOffset, e.byteLength).getFloat32(t)
            }, t.readFloat32LE = function (e, t) {
                return void 0 === t && (t = 0), new DataView(e.buffer, e.byteOffset, e.byteLength).getFloat32(t, !0)
            }, t.readFloat64BE = function (e, t) {
                return void 0 === t && (t = 0), new DataView(e.buffer, e.byteOffset, e.byteLength).getFloat64(t)
            }, t.readFloat64LE = function (e, t) {
                return void 0 === t && (t = 0), new DataView(e.buffer, e.byteOffset, e.byteLength).getFloat64(t, !0)
            }, t.writeFloat32BE = function (e, t, n) {
                return void 0 === t && (t = new Uint8Array(4)), void 0 === n && (n = 0), new DataView(t.buffer, t.byteOffset, t.byteLength).setFloat32(n, e), t
            }, t.writeFloat32LE = function (e, t, n) {
                return void 0 === t && (t = new Uint8Array(4)), void 0 === n && (n = 0), new DataView(t.buffer, t.byteOffset, t.byteLength).setFloat32(n, e, !0), t
            }, t.writeFloat64BE = function (e, t, n) {
                return void 0 === t && (t = new Uint8Array(8)), void 0 === n && (n = 0), new DataView(t.buffer, t.byteOffset, t.byteLength).setFloat64(n, e), t
            }, t.writeFloat64LE = function (e, t, n) {
                return void 0 === t && (t = new Uint8Array(8)), void 0 === n && (n = 0), new DataView(t.buffer, t.byteOffset, t.byteLength).setFloat64(n, e, !0), t
            }
        }, 3832: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0});
            var r = n(9437), i = n(2887), s = 20;

            function a(e, t, n) {
                for (var i = 1634760805, a = 857760878, o = 2036477234, l = 1797285236, c = n[3] << 24 | n[2] << 16 | n[1] << 8 | n[0], u = n[7] << 24 | n[6] << 16 | n[5] << 8 | n[4], d = n[11] << 24 | n[10] << 16 | n[9] << 8 | n[8], h = n[15] << 24 | n[14] << 16 | n[13] << 8 | n[12], f = n[19] << 24 | n[18] << 16 | n[17] << 8 | n[16], p = n[23] << 24 | n[22] << 16 | n[21] << 8 | n[20], m = n[27] << 24 | n[26] << 16 | n[25] << 8 | n[24], g = n[31] << 24 | n[30] << 16 | n[29] << 8 | n[28], y = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], v = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], b = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], w = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], x = i, E = a, S = o, k = l, A = c, T = u, C = d, R = h, L = f, _ = p, P = m, N = g, j = y, I = v, M = b, D = w, O = 0; O < s; O += 2) A = (A ^= L = L + (j = (j ^= x = x + A | 0) >>> 16 | j << 16) | 0) >>> 20 | A << 12, T = (T ^= _ = _ + (I = (I ^= E = E + T | 0) >>> 16 | I << 16) | 0) >>> 20 | T << 12, C = (C ^= P = P + (M = (M ^= S = S + C | 0) >>> 16 | M << 16) | 0) >>> 20 | C << 12, R = (R ^= N = N + (D = (D ^= k = k + R | 0) >>> 16 | D << 16) | 0) >>> 20 | R << 12, C = (C ^= P = P + (M = (M ^= S = S + C | 0) >>> 24 | M << 8) | 0) >>> 25 | C << 7, R = (R ^= N = N + (D = (D ^= k = k + R | 0) >>> 24 | D << 8) | 0) >>> 25 | R << 7, T = (T ^= _ = _ + (I = (I ^= E = E + T | 0) >>> 24 | I << 8) | 0) >>> 25 | T << 7, A = (A ^= L = L + (j = (j ^= x = x + A | 0) >>> 24 | j << 8) | 0) >>> 25 | A << 7, T = (T ^= P = P + (D = (D ^= x = x + T | 0) >>> 16 | D << 16) | 0) >>> 20 | T << 12, C = (C ^= N = N + (j = (j ^= E = E + C | 0) >>> 16 | j << 16) | 0) >>> 20 | C << 12, R = (R ^= L = L + (I = (I ^= S = S + R | 0) >>> 16 | I << 16) | 0) >>> 20 | R << 12, A = (A ^= _ = _ + (M = (M ^= k = k + A | 0) >>> 16 | M << 16) | 0) >>> 20 | A << 12, R = (R ^= L = L + (I = (I ^= S = S + R | 0) >>> 24 | I << 8) | 0) >>> 25 | R << 7, A = (A ^= _ = _ + (M = (M ^= k = k + A | 0) >>> 24 | M << 8) | 0) >>> 25 | A << 7, C = (C ^= N = N + (j = (j ^= E = E + C | 0) >>> 24 | j << 8) | 0) >>> 25 | C << 7, T = (T ^= P = P + (D = (D ^= x = x + T | 0) >>> 24 | D << 8) | 0) >>> 25 | T << 7;
                r.writeUint32LE(x + i | 0, e, 0), r.writeUint32LE(E + a | 0, e, 4), r.writeUint32LE(S + o | 0, e, 8), r.writeUint32LE(k + l | 0, e, 12), r.writeUint32LE(A + c | 0, e, 16), r.writeUint32LE(T + u | 0, e, 20), r.writeUint32LE(C + d | 0, e, 24), r.writeUint32LE(R + h | 0, e, 28), r.writeUint32LE(L + f | 0, e, 32), r.writeUint32LE(_ + p | 0, e, 36), r.writeUint32LE(P + m | 0, e, 40), r.writeUint32LE(N + g | 0, e, 44), r.writeUint32LE(j + y | 0, e, 48), r.writeUint32LE(I + v | 0, e, 52), r.writeUint32LE(M + b | 0, e, 56), r.writeUint32LE(D + w | 0, e, 60)
            }

            function o(e, t, n, r, s) {
                if (void 0 === s && (s = 0), 32 !== e.length) throw new Error("ChaCha: key size must be 32 bytes");
                if (r.length < n.length) throw new Error("ChaCha: destination is shorter than source");
                var o, c;
                if (0 === s) {
                    if (8 !== t.length && 12 !== t.length) throw new Error("ChaCha nonce must be 8 or 12 bytes");
                    c = (o = new Uint8Array(16)).length - t.length, o.set(t, c)
                } else {
                    if (16 !== t.length) throw new Error("ChaCha nonce with counter must be 16 bytes");
                    o = t, c = s
                }
                for (var u = new Uint8Array(64), d = 0; d < n.length; d += 64) {
                    a(u, o, e);
                    for (var h = d; h < d + 64 && h < n.length; h++) r[h] = n[h] ^ u[h - d];
                    l(o, 0, c)
                }
                return i.wipe(u), 0 === s && i.wipe(o), r
            }

            function l(e, t, n) {
                for (var r = 1; n--;) r = r + (255 & e[t]) | 0, e[t] = 255 & r, r >>>= 8, t++;
                if (r > 0) throw new Error("ChaCha: counter overflow")
            }

            t.streamXOR = o, t.stream = function (e, t, n, r) {
                return void 0 === r && (r = 0), i.wipe(n), o(e, t, n, n, r)
            }
        }, 5457: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.mul = Math.imul || function (e, t) {
                var n = 65535 & e, r = 65535 & t;
                return n * r + ((e >>> 16 & 65535) * r + n * (t >>> 16 & 65535) << 16 >>> 0) | 0
            }, t.add = function (e, t) {
                return e + t | 0
            }, t.sub = function (e, t) {
                return e - t | 0
            }, t.rotl = function (e, t) {
                return e << t | e >>> 32 - t
            }, t.rotr = function (e, t) {
                return e << 32 - t | e >>> t
            }, t.isInteger = Number.isInteger || function (e) {
                return "number" == typeof e && isFinite(e) && Math.floor(e) === e
            }, t.MAX_SAFE_INTEGER = 9007199254740991, t.isSafeInteger = function (e) {
                return t.isInteger(e) && e >= -t.MAX_SAFE_INTEGER && e <= t.MAX_SAFE_INTEGER
            }
        }, 2887: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.wipe = function (e) {
                for (var t = 0; t < e.length; t++) e[t] = 0;
                return e
            }
        }, 158: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0});
            var r = n(9437), i = n(2887), s = n(3832), a = 20;

            function o(e, t, n, r) {
                if (24 !== t.length) throw new Error("XChaCha20 nonce must be 24 bytes");
                var a = l(e, t.subarray(0, 16), new Uint8Array(32)), o = new Uint8Array(12);
                o.set(t.subarray(16), 4);
                var c = s.streamXOR(a, o, n, r);
                return i.wipe(a), c
            }

            function l(e, t, n) {
                for (var i = 1634760805, s = 857760878, o = 2036477234, l = 1797285236, c = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], u = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], d = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], h = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], f = e[19] << 24 | e[18] << 16 | e[17] << 8 | e[16], p = e[23] << 24 | e[22] << 16 | e[21] << 8 | e[20], m = e[27] << 24 | e[26] << 16 | e[25] << 8 | e[24], g = e[31] << 24 | e[30] << 16 | e[29] << 8 | e[28], y = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], v = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], b = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], w = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], x = 0; x < a; x += 2) c = (c ^= f = f + (y = (y ^= i = i + c | 0) >>> 16 | y << 16) | 0) >>> 20 | c << 12, u = (u ^= p = p + (v = (v ^= s = s + u | 0) >>> 16 | v << 16) | 0) >>> 20 | u << 12, d = (d ^= m = m + (b = (b ^= o = o + d | 0) >>> 16 | b << 16) | 0) >>> 20 | d << 12, h = (h ^= g = g + (w = (w ^= l = l + h | 0) >>> 16 | w << 16) | 0) >>> 20 | h << 12, d = (d ^= m = m + (b = (b ^= o = o + d | 0) >>> 24 | b << 8) | 0) >>> 25 | d << 7, h = (h ^= g = g + (w = (w ^= l = l + h | 0) >>> 24 | w << 8) | 0) >>> 25 | h << 7, u = (u ^= p = p + (v = (v ^= s = s + u | 0) >>> 24 | v << 8) | 0) >>> 25 | u << 7, c = (c ^= f = f + (y = (y ^= i = i + c | 0) >>> 24 | y << 8) | 0) >>> 25 | c << 7, u = (u ^= m = m + (w = (w ^= i = i + u | 0) >>> 16 | w << 16) | 0) >>> 20 | u << 12, d = (d ^= g = g + (y = (y ^= s = s + d | 0) >>> 16 | y << 16) | 0) >>> 20 | d << 12, h = (h ^= f = f + (v = (v ^= o = o + h | 0) >>> 16 | v << 16) | 0) >>> 20 | h << 12, c = (c ^= p = p + (b = (b ^= l = l + c | 0) >>> 16 | b << 16) | 0) >>> 20 | c << 12, h = (h ^= f = f + (v = (v ^= o = o + h | 0) >>> 24 | v << 8) | 0) >>> 25 | h << 7, c = (c ^= p = p + (b = (b ^= l = l + c | 0) >>> 24 | b << 8) | 0) >>> 25 | c << 7, d = (d ^= g = g + (y = (y ^= s = s + d | 0) >>> 24 | y << 8) | 0) >>> 25 | d << 7, u = (u ^= m = m + (w = (w ^= i = i + u | 0) >>> 24 | w << 8) | 0) >>> 25 | u << 7;
                return r.writeUint32LE(i, n, 0), r.writeUint32LE(s, n, 4), r.writeUint32LE(o, n, 8), r.writeUint32LE(l, n, 12), r.writeUint32LE(y, n, 16), r.writeUint32LE(v, n, 20), r.writeUint32LE(b, n, 24), r.writeUint32LE(w, n, 28), n
            }

            t.streamXOR = o, t.stream = function (e, t, n) {
                return i.wipe(n), o(e, t, n, n)
            }, t.hchacha = l
        }, 4622: e => {
            var t;
            self, t = () => (() => {
                var e = {
                    446: (e, t, n) => {
                        "use strict";
                        var r, i = {
                            cipher: {},
                            hash: {},
                            keyexchange: {},
                            mode: {},
                            misc: {},
                            codec: {},
                            exception: {
                                corrupt: function (e) {
                                    this.toString = function () {
                                        return "CORRUPT: " + this.message
                                    }, this.message = e
                                }, invalid: function (e) {
                                    this.toString = function () {
                                        return "INVALID: " + this.message
                                    }, this.message = e
                                }, bug: function (e) {
                                    this.toString = function () {
                                        return "BUG: " + this.message
                                    }, this.message = e
                                }, notReady: function (e) {
                                    this.toString = function () {
                                        return "NOT READY: " + this.message
                                    }, this.message = e
                                }
                            }
                        };

                        function s(e, t, n) {
                            if (4 !== t.length) throw new i.exception.invalid("invalid aes block size");
                            var r = e.b[n], s = t[0] ^ r[0], a = t[n ? 3 : 1] ^ r[1], o = t[2] ^ r[2];
                            t = t[n ? 1 : 3] ^ r[3];
                            var l, c, u, d, h = r.length / 4 - 2, f = 4, p = [0, 0, 0, 0];
                            e = (l = e.s[n])[0];
                            var m = l[1], g = l[2], y = l[3], v = l[4];
                            for (d = 0; d < h; d++) l = e[s >>> 24] ^ m[a >> 16 & 255] ^ g[o >> 8 & 255] ^ y[255 & t] ^ r[f], c = e[a >>> 24] ^ m[o >> 16 & 255] ^ g[t >> 8 & 255] ^ y[255 & s] ^ r[f + 1], u = e[o >>> 24] ^ m[t >> 16 & 255] ^ g[s >> 8 & 255] ^ y[255 & a] ^ r[f + 2], t = e[t >>> 24] ^ m[s >> 16 & 255] ^ g[a >> 8 & 255] ^ y[255 & o] ^ r[f + 3], f += 4, s = l, a = c, o = u;
                            for (d = 0; 4 > d; d++) p[n ? 3 & -d : d] = v[s >>> 24] << 24 ^ v[a >> 16 & 255] << 16 ^ v[o >> 8 & 255] << 8 ^ v[255 & t] ^ r[f++], l = s, s = a, a = o, o = t, t = l;
                            return p
                        }

                        function a(e, t) {
                            var n, r, i, s = e.F, a = e.b, o = s[0], l = s[1], c = s[2], u = s[3], d = s[4], h = s[5],
                                f = s[6], p = s[7];
                            for (n = 0; 64 > n; n++) 16 > n ? r = t[n] : (r = t[n + 1 & 15], i = t[n + 14 & 15], r = t[15 & n] = (r >>> 7 ^ r >>> 18 ^ r >>> 3 ^ r << 25 ^ r << 14) + (i >>> 17 ^ i >>> 19 ^ i >>> 10 ^ i << 15 ^ i << 13) + t[15 & n] + t[n + 9 & 15] | 0), r = r + p + (d >>> 6 ^ d >>> 11 ^ d >>> 25 ^ d << 26 ^ d << 21 ^ d << 7) + (f ^ d & (h ^ f)) + a[n], p = f, f = h, h = d, d = u + r | 0, u = c, c = l, o = r + ((l = o) & c ^ u & (l ^ c)) + (l >>> 2 ^ l >>> 13 ^ l >>> 22 ^ l << 30 ^ l << 19 ^ l << 10) | 0;
                            s[0] = s[0] + o | 0, s[1] = s[1] + l | 0, s[2] = s[2] + c | 0, s[3] = s[3] + u | 0, s[4] = s[4] + d | 0, s[5] = s[5] + h | 0, s[6] = s[6] + f | 0, s[7] = s[7] + p | 0
                        }

                        function o(e, t) {
                            var n, r = i.random.K[e], s = [];
                            for (n in r) r.hasOwnProperty(n) && s.push(r[n]);
                            for (n = 0; n < s.length; n++) s[n](t)
                        }

                        function l(e, t) {
                            "undefined" != typeof window && window.performance && "function" == typeof window.performance.now ? e.addEntropy(window.performance.now(), t, "loadtime") : e.addEntropy((new Date).valueOf(), t, "loadtime")
                        }

                        function c(e) {
                            e.b = u(e).concat(u(e)), e.L = new i.cipher.aes(e.b)
                        }

                        function u(e) {
                            for (var t = 0; 4 > t && (e.h[t] = e.h[t] + 1 | 0, !e.h[t]); t++) ;
                            return e.L.encrypt(e.h)
                        }

                        function d(e, t) {
                            return function () {
                                t.apply(e, arguments)
                            }
                        }

                        i.cipher.aes = function (e) {
                            this.s[0][0][0] || this.O();
                            var t, n, r, s, a = this.s[0][4], o = this.s[1], l = 1;
                            if (4 !== (t = e.length) && 6 !== t && 8 !== t) throw new i.exception.invalid("invalid aes key size");
                            for (this.b = [r = e.slice(0), s = []], e = t; e < 4 * t + 28; e++) n = r[e - 1], (0 == e % t || 8 === t && 4 == e % t) && (n = a[n >>> 24] << 24 ^ a[n >> 16 & 255] << 16 ^ a[n >> 8 & 255] << 8 ^ a[255 & n], 0 == e % t && (n = n << 8 ^ n >>> 24 ^ l << 24, l = l << 1 ^ 283 * (l >> 7))), r[e] = r[e - t] ^ n;
                            for (t = 0; e; t++, e--) n = r[3 & t ? e : e - 4], s[t] = 4 >= e || 4 > t ? n : o[0][a[n >>> 24]] ^ o[1][a[n >> 16 & 255]] ^ o[2][a[n >> 8 & 255]] ^ o[3][a[255 & n]]
                        }, i.cipher.aes.prototype = {
                            encrypt: function (e) {
                                return s(this, e, 0)
                            }, decrypt: function (e) {
                                return s(this, e, 1)
                            }, s: [[[], [], [], [], []], [[], [], [], [], []]], O: function () {
                                var e, t, n, r, i, s, a, o = this.s[0], l = this.s[1], c = o[4], u = l[4], d = [],
                                    h = [];
                                for (e = 0; 256 > e; e++) h[(d[e] = e << 1 ^ 283 * (e >> 7)) ^ e] = e;
                                for (t = n = 0; !c[t]; t ^= r || 1, n = h[n] || 1) for (s = (s = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4) >> 8 ^ 255 & s ^ 99, c[t] = s, u[s] = t, a = 16843009 * (i = d[e = d[r = d[t]]]) ^ 65537 * e ^ 257 * r ^ 16843008 * t, i = 257 * d[s] ^ 16843008 * s, e = 0; 4 > e; e++) o[e][t] = i = i << 24 ^ i >>> 8, l[e][s] = a = a << 24 ^ a >>> 8;
                                for (e = 0; 5 > e; e++) o[e] = o[e].slice(0), l[e] = l[e].slice(0)
                            }
                        }, i.bitArray = {
                            bitSlice: function (e, t, n) {
                                return e = i.bitArray.$(e.slice(t / 32), 32 - (31 & t)).slice(1), void 0 === n ? e : i.bitArray.clamp(e, n - t)
                            }, extract: function (e, t, n) {
                                var r = Math.floor(-t - n & 31);
                                return (-32 & (t + n - 1 ^ t) ? e[t / 32 | 0] << 32 - r ^ e[t / 32 + 1 | 0] >>> r : e[t / 32 | 0] >>> r) & (1 << n) - 1
                            }, concat: function (e, t) {
                                if (0 === e.length || 0 === t.length) return e.concat(t);
                                var n = e[e.length - 1], r = i.bitArray.getPartial(n);
                                return 32 === r ? e.concat(t) : i.bitArray.$(t, r, 0 | n, e.slice(0, e.length - 1))
                            }, bitLength: function (e) {
                                var t = e.length;
                                return 0 === t ? 0 : 32 * (t - 1) + i.bitArray.getPartial(e[t - 1])
                            }, clamp: function (e, t) {
                                if (32 * e.length < t) return e;
                                var n = (e = e.slice(0, Math.ceil(t / 32))).length;
                                return t &= 31, 0 < n && t && (e[n - 1] = i.bitArray.partial(t, e[n - 1] & 2147483648 >> t - 1, 1)), e
                            }, partial: function (e, t, n) {
                                return 32 === e ? t : (n ? 0 | t : t << 32 - e) + 1099511627776 * e
                            }, getPartial: function (e) {
                                return Math.round(e / 1099511627776) || 32
                            }, equal: function (e, t) {
                                if (i.bitArray.bitLength(e) !== i.bitArray.bitLength(t)) return !1;
                                var n, r = 0;
                                for (n = 0; n < e.length; n++) r |= e[n] ^ t[n];
                                return 0 === r
                            }, $: function (e, t, n, r) {
                                var s;
                                for (s = 0, void 0 === r && (r = []); 32 <= t; t -= 32) r.push(n), n = 0;
                                if (0 === t) return r.concat(e);
                                for (s = 0; s < e.length; s++) r.push(n | e[s] >>> t), n = e[s] << 32 - t;
                                return s = e.length ? e[e.length - 1] : 0, e = i.bitArray.getPartial(s), r.push(i.bitArray.partial(t + e & 31, 32 < t + e ? n : r.pop(), 1)), r
                            }, i: function (e, t) {
                                return [e[0] ^ t[0], e[1] ^ t[1], e[2] ^ t[2], e[3] ^ t[3]]
                            }, byteswapM: function (e) {
                                var t, n;
                                for (t = 0; t < e.length; ++t) n = e[t], e[t] = n >>> 24 | n >>> 8 & 65280 | (65280 & n) << 8 | n << 24;
                                return e
                            }
                        }, i.codec.utf8String = {
                            fromBits: function (e) {
                                var t, n, r = "", s = i.bitArray.bitLength(e);
                                for (t = 0; t < s / 8; t++) 0 == (3 & t) && (n = e[t / 4]), r += String.fromCharCode(n >>> 8 >>> 8 >>> 8), n <<= 8;
                                return decodeURIComponent(escape(r))
                            }, toBits: function (e) {
                                e = unescape(encodeURIComponent(e));
                                var t, n = [], r = 0;
                                for (t = 0; t < e.length; t++) r = r << 8 | e.charCodeAt(t), 3 == (3 & t) && (n.push(r), r = 0);
                                return 3 & t && n.push(i.bitArray.partial(8 * (3 & t), r)), n
                            }
                        }, i.codec.hex = {
                            fromBits: function (e) {
                                var t, n = "";
                                for (t = 0; t < e.length; t++) n += (0xf00000000000 + (0 | e[t])).toString(16).substr(4);
                                return n.substr(0, i.bitArray.bitLength(e) / 4)
                            }, toBits: function (e) {
                                var t, n, r = [];
                                for (n = (e = e.replace(/\s|0x/g, "")).length, e += "00000000", t = 0; t < e.length; t += 8) r.push(0 ^ parseInt(e.substr(t, 8), 16));
                                return i.bitArray.clamp(r, 4 * n)
                            }
                        }, i.codec.base32 = {
                            B: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
                            X: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
                            BITS: 32,
                            BASE: 5,
                            REMAINING: 27,
                            fromBits: function (e, t, n) {
                                var r = i.codec.base32.BASE, s = i.codec.base32.REMAINING, a = "", o = 0,
                                    l = i.codec.base32.B, c = 0, u = i.bitArray.bitLength(e);
                                for (n && (l = i.codec.base32.X), n = 0; a.length * r < u;) a += l.charAt((c ^ e[n] >>> o) >>> s), o < r ? (c = e[n] << r - o, o += s, n++) : (c <<= r, o -= r);
                                for (; 7 & a.length && !t;) a += "=";
                                return a
                            },
                            toBits: function (e, t) {
                                e = e.replace(/\s|=/g, "").toUpperCase();
                                var n, r, s = i.codec.base32.BITS, a = i.codec.base32.BASE,
                                    o = i.codec.base32.REMAINING, l = [], c = 0, u = i.codec.base32.B, d = 0,
                                    h = "base32";
                                for (t && (u = i.codec.base32.X, h = "base32hex"), n = 0; n < e.length; n++) {
                                    if (0 > (r = u.indexOf(e.charAt(n)))) {
                                        if (!t) try {
                                            return i.codec.base32hex.toBits(e)
                                        } catch (e) {
                                        }
                                        throw new i.exception.invalid("this isn't " + h + "!")
                                    }
                                    c > o ? (c -= o, l.push(d ^ r >>> c), d = r << s - c) : d ^= r << s - (c += a)
                                }
                                return 56 & c && l.push(i.bitArray.partial(56 & c, d, 1)), l
                            }
                        }, i.codec.base32hex = {
                            fromBits: function (e, t) {
                                return i.codec.base32.fromBits(e, t, 1)
                            }, toBits: function (e) {
                                return i.codec.base32.toBits(e, 1)
                            }
                        }, i.codec.base64 = {
                            B: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                            fromBits: function (e, t, n) {
                                var r = "", s = 0, a = i.codec.base64.B, o = 0, l = i.bitArray.bitLength(e);
                                for (n && (a = a.substr(0, 62) + "-_"), n = 0; 6 * r.length < l;) r += a.charAt((o ^ e[n] >>> s) >>> 26), 6 > s ? (o = e[n] << 6 - s, s += 26, n++) : (o <<= 6, s -= 6);
                                for (; 3 & r.length && !t;) r += "=";
                                return r
                            },
                            toBits: function (e, t) {
                                e = e.replace(/\s|=/g, "");
                                var n, r, s = [], a = 0, o = i.codec.base64.B, l = 0;
                                for (t && (o = o.substr(0, 62) + "-_"), n = 0; n < e.length; n++) {
                                    if (0 > (r = o.indexOf(e.charAt(n)))) throw new i.exception.invalid("this isn't base64!");
                                    26 < a ? (a -= 26, s.push(l ^ r >>> a), l = r << 32 - a) : l ^= r << 32 - (a += 6)
                                }
                                return 56 & a && s.push(i.bitArray.partial(56 & a, l, 1)), s
                            }
                        }, i.codec.base64url = {
                            fromBits: function (e) {
                                return i.codec.base64.fromBits(e, 1, 1)
                            }, toBits: function (e) {
                                return i.codec.base64.toBits(e, 1)
                            }
                        }, i.hash.sha256 = function (e) {
                            this.b[0] || this.O(), e ? (this.F = e.F.slice(0), this.A = e.A.slice(0), this.l = e.l) : this.reset()
                        }, i.hash.sha256.hash = function (e) {
                            return (new i.hash.sha256).update(e).finalize()
                        }, i.hash.sha256.prototype = {
                            blockSize: 512, reset: function () {
                                return this.F = this.Y.slice(0), this.A = [], this.l = 0, this
                            }, update: function (e) {
                                "string" == typeof e && (e = i.codec.utf8String.toBits(e));
                                var t, n = this.A = i.bitArray.concat(this.A, e);
                                if (t = this.l, 9007199254740991 < (e = this.l = t + i.bitArray.bitLength(e))) throw new i.exception.invalid("Cannot hash more than 2^53 - 1 bits");
                                if ("undefined" != typeof Uint32Array) {
                                    var r = new Uint32Array(n), s = 0;
                                    for (t = 512 + t - (512 + t & 511); t <= e; t += 512) a(this, r.subarray(16 * s, 16 * (s + 1))), s += 1;
                                    n.splice(0, 16 * s)
                                } else for (t = 512 + t - (512 + t & 511); t <= e; t += 512) a(this, n.splice(0, 16));
                                return this
                            }, finalize: function () {
                                var e, t = this.A, n = this.F;
                                for (e = (t = i.bitArray.concat(t, [i.bitArray.partial(1, 1)])).length + 2; 15 & e; e++) t.push(0);
                                for (t.push(Math.floor(this.l / 4294967296)), t.push(0 | this.l); t.length;) a(this, t.splice(0, 16));
                                return this.reset(), n
                            }, Y: [], b: [], O: function () {
                                function e(e) {
                                    return 4294967296 * (e - Math.floor(e)) | 0
                                }

                                for (var t, n, r = 0, i = 2; 64 > r; i++) {
                                    for (n = !0, t = 2; t * t <= i; t++) if (0 == i % t) {
                                        n = !1;
                                        break
                                    }
                                    n && (8 > r && (this.Y[r] = e(Math.pow(i, .5))), this.b[r] = e(Math.pow(i, 1 / 3)), r++)
                                }
                            }
                        }, i.mode.ccm = {
                            name: "ccm", G: [], listenProgress: function (e) {
                                i.mode.ccm.G.push(e)
                            }, unListenProgress: function (e) {
                                -1 < (e = i.mode.ccm.G.indexOf(e)) && i.mode.ccm.G.splice(e, 1)
                            }, fa: function (e) {
                                var t, n = i.mode.ccm.G.slice();
                                for (t = 0; t < n.length; t += 1) n[t](e)
                            }, encrypt: function (e, t, n, r, s) {
                                var a, o = t.slice(0), l = i.bitArray, c = l.bitLength(n) / 8, u = l.bitLength(o) / 8;
                                if (s = s || 64, r = r || [], 7 > c) throw new i.exception.invalid("ccm: iv must be at least 7 bytes");
                                for (a = 2; 4 > a && u >>> 8 * a; a++) ;
                                return a < 15 - c && (a = 15 - c), n = l.clamp(n, 8 * (15 - a)), t = i.mode.ccm.V(e, t, n, r, s, a), o = i.mode.ccm.C(e, o, n, t, s, a), l.concat(o.data, o.tag)
                            }, decrypt: function (e, t, n, r, s) {
                                s = s || 64, r = r || [];
                                var a = i.bitArray, o = a.bitLength(n) / 8, l = a.bitLength(t), c = a.clamp(t, l - s),
                                    u = a.bitSlice(t, l - s);
                                if (l = (l - s) / 8, 7 > o) throw new i.exception.invalid("ccm: iv must be at least 7 bytes");
                                for (t = 2; 4 > t && l >>> 8 * t; t++) ;
                                if (t < 15 - o && (t = 15 - o), n = a.clamp(n, 8 * (15 - t)), c = i.mode.ccm.C(e, c, n, u, s, t), e = i.mode.ccm.V(e, c.data, n, r, s, t), !a.equal(c.tag, e)) throw new i.exception.corrupt("ccm: tag doesn't match");
                                return c.data
                            }, na: function (e, t, n, r, s, a) {
                                var o = [], l = i.bitArray, c = l.i;
                                if (r = [l.partial(8, (t.length ? 64 : 0) | r - 2 << 2 | a - 1)], (r = l.concat(r, n))[3] |= s, r = e.encrypt(r), t.length) for (65279 >= (n = l.bitLength(t) / 8) ? o = [l.partial(16, n)] : 4294967295 >= n && (o = l.concat([l.partial(16, 65534)], [n])), o = l.concat(o, t), t = 0; t < o.length; t += 4) r = e.encrypt(c(r, o.slice(t, t + 4).concat([0, 0, 0])));
                                return r
                            }, V: function (e, t, n, r, s, a) {
                                var o = i.bitArray, l = o.i;
                                if ((s /= 8) % 2 || 4 > s || 16 < s) throw new i.exception.invalid("ccm: invalid tag length");
                                if (4294967295 < r.length || 4294967295 < t.length) throw new i.exception.bug("ccm: can't deal with 4GiB or more data");
                                for (n = i.mode.ccm.na(e, r, n, s, o.bitLength(t) / 8, a), r = 0; r < t.length; r += 4) n = e.encrypt(l(n, t.slice(r, r + 4).concat([0, 0, 0])));
                                return o.clamp(n, 8 * s)
                            }, C: function (e, t, n, r, s, a) {
                                var o, l = i.bitArray;
                                o = l.i;
                                var c = t.length, u = l.bitLength(t), d = c / 50, h = d;
                                if (n = l.concat([l.partial(8, a - 1)], n).concat([0, 0, 0]).slice(0, 4), r = l.bitSlice(o(r, e.encrypt(n)), 0, s), !c) return {
                                    tag: r,
                                    data: []
                                };
                                for (o = 0; o < c; o += 4) o > d && (i.mode.ccm.fa(o / c), d += h), n[3]++, s = e.encrypt(n), t[o] ^= s[0], t[o + 1] ^= s[1], t[o + 2] ^= s[2], t[o + 3] ^= s[3];
                                return {tag: r, data: l.clamp(t, u)}
                            }
                        }, i.mode.ocb2 = {
                            name: "ocb2", encrypt: function (e, t, n, r, s, a) {
                                if (128 !== i.bitArray.bitLength(n)) throw new i.exception.invalid("ocb iv must be 128 bits");
                                var o, l = i.mode.ocb2.S, c = i.bitArray, u = c.i, d = [0, 0, 0, 0];
                                n = l(e.encrypt(n));
                                var h, f = [];
                                for (r = r || [], s = s || 64, o = 0; o + 4 < t.length; o += 4) d = u(d, h = t.slice(o, o + 4)), f = f.concat(u(n, e.encrypt(u(n, h)))), n = l(n);
                                return h = t.slice(o), t = c.bitLength(h), o = e.encrypt(u(n, [0, 0, 0, t])), h = c.clamp(u(h.concat([0, 0, 0]), o), t), d = u(d, u(h.concat([0, 0, 0]), o)), d = e.encrypt(u(d, u(n, l(n)))), r.length && (d = u(d, a ? r : i.mode.ocb2.pmac(e, r))), f.concat(c.concat(h, c.clamp(d, s)))
                            }, decrypt: function (e, t, n, r, s, a) {
                                if (128 !== i.bitArray.bitLength(n)) throw new i.exception.invalid("ocb iv must be 128 bits");
                                s = s || 64;
                                var o, l, c = i.mode.ocb2.S, u = i.bitArray, d = u.i, h = [0, 0, 0, 0],
                                    f = c(e.encrypt(n)), p = i.bitArray.bitLength(t) - s, m = [];
                                for (r = r || [], n = 0; n + 4 < p / 32; n += 4) o = d(f, e.decrypt(d(f, t.slice(n, n + 4)))), h = d(h, o), m = m.concat(o), f = c(f);
                                if (l = p - 32 * n, o = e.encrypt(d(f, [0, 0, 0, l])), o = d(o, u.clamp(t.slice(n), l).concat([0, 0, 0])), h = d(h, o), h = e.encrypt(d(h, d(f, c(f)))), r.length && (h = d(h, a ? r : i.mode.ocb2.pmac(e, r))), !u.equal(u.clamp(h, s), u.bitSlice(t, p))) throw new i.exception.corrupt("ocb: tag doesn't match");
                                return m.concat(u.clamp(o, l))
                            }, pmac: function (e, t) {
                                var n, r = i.mode.ocb2.S, s = i.bitArray, a = s.i, o = [0, 0, 0, 0],
                                    l = a(l = e.encrypt([0, 0, 0, 0]), r(r(l)));
                                for (n = 0; n + 4 < t.length; n += 4) l = r(l), o = a(o, e.encrypt(a(l, t.slice(n, n + 4))));
                                return n = t.slice(n), 128 > s.bitLength(n) && (l = a(l, r(l)), n = s.concat(n, [-2147483648, 0, 0, 0])), o = a(o, n), e.encrypt(a(r(a(l, r(l))), o))
                            }, S: function (e) {
                                return [e[0] << 1 ^ e[1] >>> 31, e[1] << 1 ^ e[2] >>> 31, e[2] << 1 ^ e[3] >>> 31, e[3] << 1 ^ 135 * (e[0] >>> 31)]
                            }
                        }, i.mode.gcm = {
                            name: "gcm", encrypt: function (e, t, n, r, s) {
                                var a = t.slice(0);
                                return t = i.bitArray, r = r || [], e = i.mode.gcm.C(!0, e, a, r, n, s || 128), t.concat(e.data, e.tag)
                            }, decrypt: function (e, t, n, r, s) {
                                var a = t.slice(0), o = i.bitArray, l = o.bitLength(a);
                                if (r = r || [], (s = s || 128) <= l ? (t = o.bitSlice(a, l - s), a = o.bitSlice(a, 0, l - s)) : (t = a, a = []), e = i.mode.gcm.C(!1, e, a, r, n, s), !o.equal(e.tag, t)) throw new i.exception.corrupt("gcm: tag doesn't match");
                                return e.data
                            }, ka: function (e, t) {
                                var n, r, s, a, o, l = i.bitArray.i;
                                for (s = [0, 0, 0, 0], a = t.slice(0), n = 0; 128 > n; n++) {
                                    for ((r = 0 != (e[Math.floor(n / 32)] & 1 << 31 - n % 32)) && (s = l(s, a)), o = 0 != (1 & a[3]), r = 3; 0 < r; r--) a[r] = a[r] >>> 1 | (1 & a[r - 1]) << 31;
                                    a[0] >>>= 1, o && (a[0] ^= -520093696)
                                }
                                return s
                            }, j: function (e, t, n) {
                                var r, s = n.length;
                                for (t = t.slice(0), r = 0; r < s; r += 4) t[0] ^= 4294967295 & n[r], t[1] ^= 4294967295 & n[r + 1], t[2] ^= 4294967295 & n[r + 2], t[3] ^= 4294967295 & n[r + 3], t = i.mode.gcm.ka(t, e);
                                return t
                            }, C: function (e, t, n, r, s, a) {
                                var o, l, c, u, d, h, f, p, m = i.bitArray;
                                for (h = n.length, f = m.bitLength(n), p = m.bitLength(r), l = m.bitLength(s), o = t.encrypt([0, 0, 0, 0]), 96 === l ? (s = s.slice(0), s = m.concat(s, [1])) : (s = i.mode.gcm.j(o, [0, 0, 0, 0], s), s = i.mode.gcm.j(o, s, [0, 0, Math.floor(l / 4294967296), 4294967295 & l])), l = i.mode.gcm.j(o, [0, 0, 0, 0], r), d = s.slice(0), r = l.slice(0), e || (r = i.mode.gcm.j(o, l, n)), u = 0; u < h; u += 4) d[3]++, c = t.encrypt(d), n[u] ^= c[0], n[u + 1] ^= c[1], n[u + 2] ^= c[2], n[u + 3] ^= c[3];
                                return n = m.clamp(n, f), e && (r = i.mode.gcm.j(o, l, n)), e = [Math.floor(p / 4294967296), 4294967295 & p, Math.floor(f / 4294967296), 4294967295 & f], r = i.mode.gcm.j(o, r, e), c = t.encrypt(s), r[0] ^= c[0], r[1] ^= c[1], r[2] ^= c[2], r[3] ^= c[3], {
                                    tag: m.bitSlice(r, 0, a),
                                    data: n
                                }
                            }
                        }, i.misc.hmac = function (e, t) {
                            this.W = t = t || i.hash.sha256;
                            var n, r = [[], []], s = t.prototype.blockSize / 32;
                            for (this.w = [new t, new t], e.length > s && (e = t.hash(e)), n = 0; n < s; n++) r[0][n] = 909522486 ^ e[n], r[1][n] = 1549556828 ^ e[n];
                            this.w[0].update(r[0]), this.w[1].update(r[1]), this.R = new t(this.w[0])
                        }, i.misc.hmac.prototype.encrypt = i.misc.hmac.prototype.mac = function (e) {
                            if (this.aa) throw new i.exception.invalid("encrypt on already updated hmac called!");
                            return this.update(e), this.digest(e)
                        }, i.misc.hmac.prototype.reset = function () {
                            this.R = new this.W(this.w[0]), this.aa = !1
                        }, i.misc.hmac.prototype.update = function (e) {
                            this.aa = !0, this.R.update(e)
                        }, i.misc.hmac.prototype.digest = function () {
                            var e = this.R.finalize();
                            return e = new this.W(this.w[1]).update(e).finalize(), this.reset(), e
                        }, i.misc.pbkdf2 = function (e, t, n, r, s) {
                            if (n = n || 1e4, 0 > r || 0 > n) throw new i.exception.invalid("invalid params to pbkdf2");
                            "string" == typeof e && (e = i.codec.utf8String.toBits(e)), "string" == typeof t && (t = i.codec.utf8String.toBits(t)), e = new (s = s || i.misc.hmac)(e);
                            var a, o, l, c, u = [], d = i.bitArray;
                            for (c = 1; 32 * u.length < (r || 1); c++) {
                                for (s = a = e.encrypt(d.concat(t, [c])), o = 1; o < n; o++) for (a = e.encrypt(a), l = 0; l < a.length; l++) s[l] ^= a[l];
                                u = u.concat(s)
                            }
                            return r && (u = d.clamp(u, r)), u
                        }, i.prng = function (e) {
                            this.c = [new i.hash.sha256], this.m = [0], this.P = 0, this.H = {}, this.N = 0, this.U = {}, this.Z = this.f = this.o = this.ha = 0, this.b = [0, 0, 0, 0, 0, 0, 0, 0], this.h = [0, 0, 0, 0], this.L = void 0, this.M = e, this.D = !1, this.K = {
                                progress: {},
                                seeded: {}
                            }, this.u = this.ga = 0, this.I = 1, this.J = 2, this.ca = 65536, this.T = [0, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024], this.da = 3e4, this.ba = 80
                        }, i.prng.prototype = {
                            randomWords: function (e, t) {
                                var n, r, s = [];
                                if ((n = this.isReady(t)) === this.u) throw new i.exception.notReady("generator isn't seeded");
                                if (n & this.J) {
                                    n = !(n & this.I), r = [];
                                    var a, o = 0;
                                    for (this.Z = r[0] = (new Date).valueOf() + this.da, a = 0; 16 > a; a++) r.push(4294967296 * Math.random() | 0);
                                    for (a = 0; a < this.c.length && (r = r.concat(this.c[a].finalize()), o += this.m[a], this.m[a] = 0, n || !(this.P & 1 << a)); a++) ;
                                    for (this.P >= 1 << this.c.length && (this.c.push(new i.hash.sha256), this.m.push(0)), this.f -= o, o > this.o && (this.o = o), this.P++, this.b = i.hash.sha256.hash(this.b.concat(r)), this.L = new i.cipher.aes(this.b), n = 0; 4 > n && (this.h[n] = this.h[n] + 1 | 0, !this.h[n]); n++) ;
                                }
                                for (n = 0; n < e; n += 4) 0 == (n + 1) % this.ca && c(this), r = u(this), s.push(r[0], r[1], r[2], r[3]);
                                return c(this), s.slice(0, e)
                            }, setDefaultParanoia: function (e, t) {
                                if (0 === e && "Setting paranoia=0 will ruin your security; use it only for testing" !== t) throw new i.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");
                                this.M = e
                            }, addEntropy: function (e, t, n) {
                                n = n || "user";
                                var r, s, a = (new Date).valueOf(), l = this.H[n], c = this.isReady(), u = 0;
                                switch (void 0 === (r = this.U[n]) && (r = this.U[n] = this.ha++), void 0 === l && (l = this.H[n] = 0), this.H[n] = (this.H[n] + 1) % this.c.length, typeof e) {
                                    case"number":
                                        void 0 === t && (t = 1), this.c[l].update([r, this.N++, 1, t, a, 1, 0 | e]);
                                        break;
                                    case"object":
                                        if ("[object Uint32Array]" === (n = Object.prototype.toString.call(e))) {
                                            for (s = [], n = 0; n < e.length; n++) s.push(e[n]);
                                            e = s
                                        } else for ("[object Array]" !== n && (u = 1), n = 0; n < e.length && !u; n++) "number" != typeof e[n] && (u = 1);
                                        if (!u) {
                                            if (void 0 === t) for (n = t = 0; n < e.length; n++) for (s = e[n]; 0 < s;) t++, s >>>= 1;
                                            this.c[l].update([r, this.N++, 2, t, a, e.length].concat(e))
                                        }
                                        break;
                                    case"string":
                                        void 0 === t && (t = e.length), this.c[l].update([r, this.N++, 3, t, a, e.length]), this.c[l].update(e);
                                        break;
                                    default:
                                        u = 1
                                }
                                if (u) throw new i.exception.bug("random: addEntropy only supports number, array of numbers or string");
                                this.m[l] += t, this.f += t, c === this.u && (this.isReady() !== this.u && o("seeded", Math.max(this.o, this.f)), o("progress", this.getProgress()))
                            }, isReady: function (e) {
                                return e = this.T[void 0 !== e ? e : this.M], this.o && this.o >= e ? this.m[0] > this.ba && (new Date).valueOf() > this.Z ? this.J | this.I : this.I : this.f >= e ? this.J | this.u : this.u
                            }, getProgress: function (e) {
                                return e = this.T[e || this.M], this.o >= e || this.f > e ? 1 : this.f / e
                            }, startCollectors: function () {
                                if (!this.D) {
                                    if (this.a = {
                                        loadTimeCollector: d(this, this.ma),
                                        mouseCollector: d(this, this.oa),
                                        keyboardCollector: d(this, this.la),
                                        accelerometerCollector: d(this, this.ea),
                                        touchCollector: d(this, this.qa)
                                    }, window.addEventListener) window.addEventListener("load", this.a.loadTimeCollector, !1), window.addEventListener("mousemove", this.a.mouseCollector, !1), window.addEventListener("keypress", this.a.keyboardCollector, !1), window.addEventListener("devicemotion", this.a.accelerometerCollector, !1), window.addEventListener("touchmove", this.a.touchCollector, !1); else {
                                        if (!document.attachEvent) throw new i.exception.bug("can't attach event");
                                        document.attachEvent("onload", this.a.loadTimeCollector), document.attachEvent("onmousemove", this.a.mouseCollector), document.attachEvent("keypress", this.a.keyboardCollector)
                                    }
                                    this.D = !0
                                }
                            }, stopCollectors: function () {
                                this.D && (window.removeEventListener ? (window.removeEventListener("load", this.a.loadTimeCollector, !1), window.removeEventListener("mousemove", this.a.mouseCollector, !1), window.removeEventListener("keypress", this.a.keyboardCollector, !1), window.removeEventListener("devicemotion", this.a.accelerometerCollector, !1), window.removeEventListener("touchmove", this.a.touchCollector, !1)) : document.detachEvent && (document.detachEvent("onload", this.a.loadTimeCollector), document.detachEvent("onmousemove", this.a.mouseCollector), document.detachEvent("keypress", this.a.keyboardCollector)), this.D = !1)
                            }, addEventListener: function (e, t) {
                                this.K[e][this.ga++] = t
                            }, removeEventListener: function (e, t) {
                                var n, r, i = this.K[e], s = [];
                                for (r in i) i.hasOwnProperty(r) && i[r] === t && s.push(r);
                                for (n = 0; n < s.length; n++) delete i[r = s[n]]
                            }, la: function () {
                                l(this, 1)
                            }, oa: function (e) {
                                var t, n;
                                try {
                                    t = e.x || e.clientX || e.offsetX || 0, n = e.y || e.clientY || e.offsetY || 0
                                } catch (e) {
                                    n = t = 0
                                }
                                0 != t && 0 != n && this.addEntropy([t, n], 2, "mouse"), l(this, 0)
                            }, qa: function (e) {
                                e = e.touches[0] || e.changedTouches[0], this.addEntropy([e.pageX || e.clientX, e.pageY || e.clientY], 1, "touch"), l(this, 0)
                            }, ma: function () {
                                l(this, 2)
                            }, ea: function (e) {
                                if (e = e.accelerationIncludingGravity.x || e.accelerationIncludingGravity.y || e.accelerationIncludingGravity.z, window.orientation) {
                                    var t = window.orientation;
                                    "number" == typeof t && this.addEntropy(t, 1, "accelerometer")
                                }
                                e && this.addEntropy(e, 2, "accelerometer"), l(this, 0)
                            }
                        }, i.random = new i.prng(6);
                        e:try {
                            var h, f, p, m;
                            if (m = e.exports) {
                                var g;
                                try {
                                    g = n(674)
                                } catch (e) {
                                    g = null
                                }
                                m = f = g
                            }
                            if (m && f.randomBytes) h = f.randomBytes(128), h = new Uint32Array(new Uint8Array(h).buffer), i.random.addEntropy(h, 1024, "crypto['randomBytes']"); else if ("undefined" != typeof window && "undefined" != typeof Uint32Array) {
                                if (p = new Uint32Array(32), window.crypto && window.crypto.getRandomValues) window.crypto.getRandomValues(p); else {
                                    if (!window.msCrypto || !window.msCrypto.getRandomValues) break e;
                                    window.msCrypto.getRandomValues(p)
                                }
                                i.random.addEntropy(p, 1024, "crypto['getRandomValues']")
                            }
                        } catch (e) {
                            "undefined" != typeof window && window.console && (console.log("There was an error collecting entropy from the browser:"), console.log(e))
                        }
                        i.json = {
                            defaults: {v: 1, iter: 1e4, ks: 128, ts: 64, mode: "ccm", adata: "", cipher: "aes"},
                            ja: function (e, t, n, r) {
                                n = n || {}, r = r || {};
                                var s, a = i.json, o = a.g({iv: i.random.randomWords(4, 0)}, a.defaults);
                                if (a.g(o, n), n = o.adata, "string" == typeof o.salt && (o.salt = i.codec.base64.toBits(o.salt)), "string" == typeof o.iv && (o.iv = i.codec.base64.toBits(o.iv)), !i.mode[o.mode] || !i.cipher[o.cipher] || "string" == typeof e && 100 >= o.iter || 64 !== o.ts && 96 !== o.ts && 128 !== o.ts || 128 !== o.ks && 192 !== o.ks && 256 !== o.ks || 2 > o.iv.length || 4 < o.iv.length) throw new i.exception.invalid("json encrypt: invalid parameters");
                                return "string" == typeof e ? (e = (s = i.misc.cachedPbkdf2(e, o)).key.slice(0, o.ks / 32), o.salt = s.salt) : i.ecc && e instanceof i.ecc.elGamal.publicKey && (s = e.kem(), o.kemtag = s.tag, e = s.key.slice(0, o.ks / 32)), "string" == typeof t && (t = i.codec.utf8String.toBits(t)), "string" == typeof n && (o.adata = n = i.codec.utf8String.toBits(n)), s = new i.cipher[o.cipher](e), a.g(r, o), r.key = e, o.ct = "ccm" === o.mode && i.arrayBuffer && i.arrayBuffer.ccm && t instanceof ArrayBuffer ? i.arrayBuffer.ccm.encrypt(s, t, o.iv, n, o.ts) : i.mode[o.mode].encrypt(s, t, o.iv, n, o.ts), o
                            },
                            encrypt: function (e, t, n, r) {
                                var s = i.json, a = s.ja.apply(s, arguments);
                                return s.encode(a)
                            },
                            ia: function (e, t, n, r) {
                                n = n || {}, r = r || {};
                                var s, a, o = i.json;
                                if (s = (t = o.g(o.g(o.g({}, o.defaults), t), n, !0)).adata, "string" == typeof t.salt && (t.salt = i.codec.base64.toBits(t.salt)), "string" == typeof t.iv && (t.iv = i.codec.base64.toBits(t.iv)), !i.mode[t.mode] || !i.cipher[t.cipher] || "string" == typeof e && 100 >= t.iter || 64 !== t.ts && 96 !== t.ts && 128 !== t.ts || 128 !== t.ks && 192 !== t.ks && 256 !== t.ks || !t.iv || 2 > t.iv.length || 4 < t.iv.length) throw new i.exception.invalid("json decrypt: invalid parameters");
                                return "string" == typeof e ? (e = (a = i.misc.cachedPbkdf2(e, t)).key.slice(0, t.ks / 32), t.salt = a.salt) : i.ecc && e instanceof i.ecc.elGamal.secretKey && (e = e.unkem(i.codec.base64.toBits(t.kemtag)).slice(0, t.ks / 32)), "string" == typeof s && (s = i.codec.utf8String.toBits(s)), a = new i.cipher[t.cipher](e), s = "ccm" === t.mode && i.arrayBuffer && i.arrayBuffer.ccm && t.ct instanceof ArrayBuffer ? i.arrayBuffer.ccm.decrypt(a, t.ct, t.iv, t.tag, s, t.ts) : i.mode[t.mode].decrypt(a, t.ct, t.iv, s, t.ts), o.g(r, t), r.key = e, 1 === n.raw ? s : i.codec.utf8String.fromBits(s)
                            },
                            decrypt: function (e, t, n, r) {
                                var s = i.json;
                                return s.ia(e, s.decode(t), n, r)
                            },
                            encode: function (e) {
                                var t, n = "{", r = "";
                                for (t in e) if (e.hasOwnProperty(t)) {
                                    if (!t.match(/^[a-z0-9]+$/i)) throw new i.exception.invalid("json encode: invalid property name");
                                    switch (n += r + '"' + t + '":', r = ",", typeof e[t]) {
                                        case"number":
                                        case"boolean":
                                            n += e[t];
                                            break;
                                        case"string":
                                            n += '"' + escape(e[t]) + '"';
                                            break;
                                        case"object":
                                            n += '"' + i.codec.base64.fromBits(e[t], 0) + '"';
                                            break;
                                        default:
                                            throw new i.exception.bug("json encode: unsupported type")
                                    }
                                }
                                return n + "}"
                            },
                            decode: function (e) {
                                if (!(e = e.replace(/\s/g, "")).match(/^\{.*\}$/)) throw new i.exception.invalid("json decode: this isn't json!");
                                e = e.replace(/^\{|\}$/g, "").split(/,/);
                                var t, n, r = {};
                                for (t = 0; t < e.length; t++) {
                                    if (!(n = e[t].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i))) throw new i.exception.invalid("json decode: this isn't json!");
                                    null != n[3] ? r[n[2]] = parseInt(n[3], 10) : null != n[4] ? r[n[2]] = n[2].match(/^(ct|adata|salt|iv)$/) ? i.codec.base64.toBits(n[4]) : unescape(n[4]) : null != n[5] && (r[n[2]] = "true" === n[5])
                                }
                                return r
                            },
                            g: function (e, t, n) {
                                if (void 0 === e && (e = {}), void 0 === t) return e;
                                for (var r in t) if (t.hasOwnProperty(r)) {
                                    if (n && void 0 !== e[r] && e[r] !== t[r]) throw new i.exception.invalid("required parameter overridden");
                                    e[r] = t[r]
                                }
                                return e
                            },
                            sa: function (e, t) {
                                var n, r = {};
                                for (n in e) e.hasOwnProperty(n) && e[n] !== t[n] && (r[n] = e[n]);
                                return r
                            },
                            ra: function (e, t) {
                                var n, r = {};
                                for (n = 0; n < t.length; n++) void 0 !== e[t[n]] && (r[t[n]] = e[t[n]]);
                                return r
                            }
                        }, i.encrypt = i.json.encrypt, i.decrypt = i.json.decrypt, i.misc.pa = {}, i.misc.cachedPbkdf2 = function (e, t) {
                            var n, r = i.misc.pa;
                            return n = (t = t || {}).iter || 1e3, (n = (r = r[e] = r[e] || {})[n] = r[n] || {firstSalt: t.salt && t.salt.length ? t.salt.slice(0) : i.random.randomWords(2, 0)})[r = void 0 === t.salt ? n.firstSalt : t.salt] = n[r] || i.misc.pbkdf2(e, r, t.iter), {
                                key: n[r].slice(0),
                                salt: r.slice(0)
                            }
                        }, e.exports && (e.exports = i), void 0 === (r = function () {
                            return i
                        }.apply(t, [])) || (e.exports = r)
                    }, 338: function (e, t, n) {
                        "use strict";
                        var r, i, s, a, o = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                            if ("m" === r) throw new TypeError("Private method is not writable");
                            if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                            if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                            return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
                        }, l = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
                        };
                        Object.defineProperty(t, "__esModule", {value: !0}), t.VoidApi = void 0;
                        const c = n(920), u = n(609), d = n(2);
                        t.VoidApi = class {
                            constructor(e, t) {
                                r.add(this), i.set(this, void 0), s.set(this, void 0), o(this, i, e, "f"), o(this, s, t, "f")
                            }

                            getUploader(e, t, n, r, a) {
                                return u.StreamUploader.canUse() ? new u.StreamUploader(l(this, i, "f"), e, t, n, r, l(this, s, "f"), a) : new d.XHRUploader(l(this, i, "f"), e, t, n, r, l(this, s, "f"), a)
                            }

                            info() {
                                return l(this, r, "m", a).call(this, "GET", "/info")
                            }

                            fileInfo(e) {
                                return l(this, r, "m", a).call(this, "GET", `/upload/${e}`)
                            }

                            setPaymentConfig(e, t) {
                                return l(this, r, "m", a).call(this, "POST", `/upload/${e}/payment`, t)
                            }

                            createOrder(e) {
                                return l(this, r, "m", a).call(this, "GET", `/upload/${e}/payment`)
                            }

                            getOrder(e, t) {
                                return l(this, r, "m", a).call(this, "GET", `/upload/${e}/payment/${t}`)
                            }

                            login(e, t, n) {
                                return l(this, r, "m", a).call(this, "POST", "/auth/login", {
                                    username: e,
                                    password: t,
                                    captcha: n
                                })
                            }

                            register(e, t, n) {
                                return l(this, r, "m", a).call(this, "POST", "/auth/register", {
                                    username: e,
                                    password: t,
                                    captcha: n
                                })
                            }

                            getUser(e) {
                                return l(this, r, "m", a).call(this, "GET", `/user/${e}`)
                            }

                            updateUser(e) {
                                return l(this, r, "m", a).call(this, "POST", `/user/${e.id}`, e)
                            }

                            listUserFiles(e, t) {
                                return l(this, r, "m", a).call(this, "POST", `/user/${e}/files`, t)
                            }

                            submitVerifyCode(e, t) {
                                return l(this, r, "m", a).call(this, "POST", `/user/${e}/verify`, {code: t})
                            }

                            sendNewCode(e) {
                                return l(this, r, "m", a).call(this, "GET", `/user/${e}/verify`)
                            }

                            updateFileMetadata(e, t) {
                                return l(this, r, "m", a).call(this, "POST", `/upload/${e}/meta`, t)
                            }

                            listApiKeys() {
                                return l(this, r, "m", a).call(this, "GET", "/auth/api-key")
                            }

                            createApiKey(e) {
                                return l(this, r, "m", a).call(this, "POST", "/auth/api-key", e)
                            }

                            adminListFiles(e) {
                                return l(this, r, "m", a).call(this, "POST", "/admin/file", e)
                            }

                            adminDeleteFile(e) {
                                return l(this, r, "m", a).call(this, "DELETE", `/admin/file/${e}`)
                            }

                            adminUserList(e) {
                                return l(this, r, "m", a).call(this, "POST", "/admin/users", e)
                            }

                            adminUpdateUser(e) {
                                return l(this, r, "m", a).call(this, "POST", "/admin/update-user", e)
                            }
                        }, i = new WeakMap, s = new WeakMap, r = new WeakSet, a = async function (e, t, n) {
                            let r = {Accept: "application/json"};
                            l(this, s, "f") && (r.Authorization = `Bearer ${l(this, s, "f")}`), n && (r["Content-Type"] = "application/json");
                            const a = await fetch(`${l(this, i, "f")}${t}`, {
                                method: e,
                                headers: r,
                                mode: "cors",
                                body: n ? JSON.stringify(n) : void 0
                            }), o = await a.text();
                            if (a.ok) return o ? JSON.parse(o) : {};
                            throw new c.ApiError(a.status, o)
                        }
                    }, 410: function (e, t, n) {
                        "use strict";
                        var r, i, s, a, o, l = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                            if ("m" === r) throw new TypeError("Private method is not writable");
                            if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                            if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                            return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
                        }, c = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
                        }, u = this && this.__importDefault || function (e) {
                            return e && e.__esModule ? e : {default: e}
                        };
                        Object.defineProperty(t, "__esModule", {value: !0}), t.StreamEncryption = void 0;
                        const d = n(964), h = u(n(446)), f = n(663);
                        t.StreamEncryption = class {
                            constructor(e, t, n) {
                                if (r.set(this, void 0), i.set(this, void 0), s.set(this, void 0), a.set(this, void 0), o.set(this, void 0), e || t || (e = (0, f.buf2hex)(globalThis.crypto.getRandomValues(new Uint8Array(16))), t = (0, f.buf2hex)(globalThis.crypto.getRandomValues(new Uint8Array(12)))), "string" == typeof e && "string" == typeof t) e = h.default.codec.hex.toBits(e), t = h.default.codec.hex.toBits(t); else if (!Array.isArray(e) || !Array.isArray(t)) throw"Key and IV must be hex string or bitArray";
                                "string" == typeof n && (n = JSON.parse(n)), l(this, r, n?.ts ?? 128, "f"), l(this, i, n?.cs ?? 10485760, "f"), l(this, s, new h.default.cipher.aes(e), "f"), l(this, a, e, "f"), l(this, o, t, "f"), console.log(`ts=${c(this, r, "f")}, cs=${c(this, i, "f")}, key=${e}, iv=${c(this, o, "f")}`)
                            }

                            getKey() {
                                return `${h.default.codec.hex.fromBits(c(this, a, "f"))}:${h.default.codec.hex.fromBits(c(this, o, "f"))}`
                            }

                            getParams() {
                                return {ts: c(this, r, "f"), cs: c(this, i, "f")}
                            }

                            getEncryptionTransform() {
                                return this._getCryptoStream(0)
                            }

                            getDecryptionTransform() {
                                return this._getCryptoStream(1)
                            }

                            _getCryptoStream(e) {
                                let t = 0, n = new Uint8Array(c(this, i, "f") + (1 === e ? c(this, r, "f") / 8 : 0));
                                return new TransformStream({
                                    transform: async (i, a) => {
                                        i = await i;
                                        try {
                                            let l = Math.min(i.byteLength, n.byteLength - t);
                                            if (n.set(i.slice(0, l), t), t += l, t === n.byteLength) {
                                                let u = d.sjclcodec.toBits(n),
                                                    f = d.sjclcodec.fromBits(0 === e ? h.default.mode.gcm.encrypt(c(this, s, "f"), u, c(this, o, "f"), [], c(this, r, "f")) : h.default.mode.gcm.decrypt(c(this, s, "f"), u, c(this, o, "f"), [], c(this, r, "f")));
                                                a.enqueue(new Uint8Array(f)), t = i.byteLength - l, n.set(i.slice(l))
                                            }
                                        } catch (e) {
                                            throw console.error(e), e
                                        }
                                    }, flush: i => {
                                        let a = n.slice(0, t), l = d.sjclcodec.toBits(a),
                                            u = d.sjclcodec.fromBits(0 === e ? h.default.mode.gcm.encrypt(c(this, s, "f"), l, c(this, o, "f"), [], c(this, r, "f")) : h.default.mode.gcm.decrypt(c(this, s, "f"), l, c(this, o, "f"), [], c(this, r, "f")));
                                        i.enqueue(new Uint8Array(u))
                                    }
                                }, {highWaterMark: c(this, i, "f")})
                            }
                        }, r = new WeakMap, i = new WeakMap, s = new WeakMap, a = new WeakMap, o = new WeakMap
                    }, 609: function (e, t, n) {
                        "use strict";
                        var r, i = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                            if ("m" === r) throw new TypeError("Private method is not writable");
                            if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                            if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                            return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
                        }, s = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
                        };
                        Object.defineProperty(t, "__esModule", {value: !0}), t.StreamUploader = void 0;
                        const a = n(496), o = n(410);

                        class l extends a.VoidUploader {
                            constructor() {
                                super(...arguments), r.set(this, void 0)
                            }

                            static canUse() {
                                const e = globalThis.navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
                                return (e ? parseInt(e[2], 10) : 0) >= 105 && "getRandomValues" in globalThis.crypto && "https:" === globalThis.location.protocol
                            }

                            canEncrypt() {
                                return !0
                            }

                            setEncryption(e) {
                                i(this, r, e ? new o.StreamEncryption(void 0, void 0, void 0) : void 0, "f")
                            }

                            getEncryptionKey() {
                                return s(this, r, "f")?.getKey()
                            }

                            async upload(e) {
                                this.onStateChange?.(a.UploadState.Hashing);
                                const t = await this.digest(this.file);
                                let n = 0;
                                const i = 1048576, o = new ReadableStream({
                                    start: async () => {
                                        this.onStateChange?.(a.UploadState.Uploading)
                                    }, pull: async e => {
                                        const t = await this.readChunk(n, e.desiredSize ?? i);
                                        0 !== t.byteLength ? (this.onProgress?.(n + t.byteLength), n += t.byteLength, e.enqueue(t)) : e.close()
                                    }, cancel: e => {
                                        console.log(e)
                                    }, type: "bytes"
                                }, {highWaterMark: i}), l = {
                                    "Content-Type": "application/octet-stream",
                                    "V-Content-Type": this.file.type ? this.file.type : "application/octet-stream",
                                    "V-Filename": "name" in this.file ? this.file.name : "",
                                    "V-Full-Digest": t
                                };
                                s(this, r, "f") && (l["V-EncryptionParams"] = JSON.stringify(s(this, r, "f").getParams())), this.auth && (l.Authorization = `Bearer ${this.auth}`);
                                const c = await fetch(`${this.uri}/upload`, {
                                    method: "POST",
                                    mode: "cors",
                                    body: s(this, r, "f") ? o.pipeThrough(s(this, r, "f").getEncryptionTransform()) : o,
                                    headers: {...l, ...e},
                                    duplex: "half"
                                });
                                if (c.ok) return await c.json();
                                throw new Error("Unknown error")
                            }

                            async readChunk(e, t) {
                                if (e > this.file.size) return new Uint8Array(0);
                                const n = Math.min(e + t, this.file.size), r = this.file.slice(e, n, this.file.type),
                                    i = await r.arrayBuffer();
                                return new Uint8Array(i)
                            }
                        }

                        t.StreamUploader = l, r = new WeakMap
                    }, 496: function (e, t, n) {
                        "use strict";
                        var r = this && this.__importDefault || function (e) {
                            return e && e.__esModule ? e : {default: e}
                        };
                        Object.defineProperty(t, "__esModule", {value: !0}), t.VoidUploader = t.UploadState = void 0;
                        const i = r(n(446)), s = n(964), a = n(663);
                        var o;
                        (o = t.UploadState || (t.UploadState = {}))[o.NotStarted = 0] = "NotStarted", o[o.Starting = 1] = "Starting", o[o.Hashing = 2] = "Hashing", o[o.Uploading = 3] = "Uploading", o[o.Done = 4] = "Done", o[o.Failed = 5] = "Failed", o[o.Challenge = 6] = "Challenge", t.VoidUploader = class {
                            constructor(e, t, n, r, i, s, a) {
                                this.uri = e, this.file = t, this.onStateChange = n, this.onProgress = r, this.onProxyChallenge = i, this.auth = s, this.maxChunkSize = a ?? Number.MAX_VALUE
                            }

                            async digest(e) {
                                const t = 1048576, n = new i.default.hash.sha256;
                                let r = 0;
                                for (let i = 0; i < Math.ceil(e.size / t); i++) {
                                    const a = i * t, o = e.slice(a, a + t), l = await o.arrayBuffer();
                                    n.update(s.sjclcodec.toBits(new Uint8Array(l))), this.onProgress?.(r += l.byteLength)
                                }
                                return (0, a.buf2hex)(s.sjclcodec.fromBits(n.finalize()))
                            }
                        }
                    }, 663: (e, t) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {value: !0}), t.buf2hex = void 0, t.buf2hex = function (e) {
                            return [...new Uint8Array(e)].map((e => e.toString(16).padStart(2, "0"))).join("")
                        }
                    }, 2: function (e, t, n) {
                        "use strict";
                        var r, i, s, a = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
                        };
                        Object.defineProperty(t, "__esModule", {value: !0}), t.XHRUploader = void 0;
                        const o = n(496);

                        class l extends o.VoidUploader {
                            constructor() {
                                super(...arguments), r.add(this)
                            }

                            canEncrypt() {
                                return !1
                            }

                            setEncryption() {
                            }

                            getEncryptionKey() {
                            }

                            async upload(e) {
                                this.onStateChange?.(o.UploadState.Hashing);
                                const t = await this.digest(this.file);
                                return this.file.size > this.maxChunkSize ? await a(this, r, "m", i).call(this, t, this.maxChunkSize, e) : await a(this, r, "m", s).call(this, this.file, t, void 0, void 0, 1, 1, e)
                            }
                        }

                        t.XHRUploader = l, r = new WeakSet, i = async function (e, t, n) {
                            let i = null;
                            const o = Math.ceil(this.file.size / t);
                            for (let l = 0; l < o; l++) {
                                const c = l * t, u = this.file.slice(c, c + t, this.file.type);
                                if (i = await a(this, r, "m", s).call(this, u, e, i?.file?.id, i?.file?.metadata?.editSecret, l + 1, o, n), !i.ok) break
                            }
                            return i
                        }, s = async function (e, t, n, r, i, s, a) {
                            return this.onStateChange?.(o.UploadState.Uploading), await new Promise(((l, c) => {
                                try {
                                    const u = new XMLHttpRequest;
                                    if (u.onreadystatechange = () => {
                                        if (u.readyState === XMLHttpRequest.DONE && 200 === u.status) {
                                            const e = JSON.parse(u.responseText);
                                            l(e)
                                        } else if (u.readyState === XMLHttpRequest.DONE && 403 === u.status) {
                                            const e = u.getResponseHeader("content-type");
                                            0 === e?.toLowerCase().trim().indexOf("text/html") && (this.onProxyChallenge?.(u.response), this.onStateChange?.(o.UploadState.Challenge), c(new Error("CF Challenge")))
                                        }
                                    }, u.upload.onprogress = e => {
                                        e instanceof ProgressEvent && this.onProgress?.(e.loaded)
                                    }, u.open("POST", n ? `${this.uri}/upload/${n}` : `${this.uri}/upload`), u.setRequestHeader("Content-Type", "application/octet-stream"), u.setRequestHeader("V-Content-Type", this.file.type ? this.file.type : "application/octet-stream"), u.setRequestHeader("V-Filename", "name" in this.file ? this.file.name : ""), u.setRequestHeader("V-Full-Digest", t), u.setRequestHeader("V-Segment", `${i}/${s}`), this.auth && (u.withCredentials = !0, u.setRequestHeader("Authorization", `Bearer ${this.auth}`)), r && u.setRequestHeader("V-EditSecret", r), a) for (const [e, t] of Object.entries(a)) u.setRequestHeader(e, t);
                                    u.send(e)
                                } catch (e) {
                                    c(e)
                                }
                            }))
                        }
                    }, 920: (e, t, n) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {value: !0}), t.PageSortOrder = t.PagedSortBy = t.PaymentOrderState = t.PaymentServices = t.PaymentCurrencies = t.ApiError = t.StreamEncryption = t.UploadState = t.VoidApi = void 0;
                        var r = n(338);
                        Object.defineProperty(t, "VoidApi", {
                            enumerable: !0, get: function () {
                                return r.VoidApi
                            }
                        });
                        var i = n(496);
                        Object.defineProperty(t, "UploadState", {
                            enumerable: !0, get: function () {
                                return i.UploadState
                            }
                        });
                        var s, a, o, l, c, u = n(410);
                        Object.defineProperty(t, "StreamEncryption", {
                            enumerable: !0, get: function () {
                                return u.StreamEncryption
                            }
                        });

                        class d extends Error {
                            constructor(e, t) {
                                super(t), this.statusCode = e
                            }
                        }

                        t.ApiError = d, (c = t.PaymentCurrencies || (t.PaymentCurrencies = {}))[c.BTC = 0] = "BTC", c[c.USD = 1] = "USD", c[c.EUR = 2] = "EUR", c[c.GBP = 3] = "GBP", (l = t.PaymentServices || (t.PaymentServices = {}))[l.None = 0] = "None", l[l.Strike = 1] = "Strike", (o = t.PaymentOrderState || (t.PaymentOrderState = {}))[o.Unpaid = 0] = "Unpaid", o[o.Paid = 1] = "Paid", o[o.Expired = 2] = "Expired", (a = t.PagedSortBy || (t.PagedSortBy = {}))[a.Name = 0] = "Name", a[a.Date = 1] = "Date", a[a.Size = 2] = "Size", a[a.Id = 3] = "Id", (s = t.PageSortOrder || (t.PageSortOrder = {}))[s.Asc = 0] = "Asc", s[s.Dsc = 1] = "Dsc"
                    }, 964: (e, t, n) => {
                        "use strict";
                        n.r(t), n.d(t, {sjclcodec: () => s});
                        var r = n(446), i = n.n(r);
                        const s = {
                            fromBits: function (e) {
                                var t, n, r = [], s = i().bitArray.bitLength(e);
                                for (t = 0; t < s / 8; t++) 0 == (3 & t) && (n = e[t / 4]), r.push(n >>> 24), n <<= 8;
                                return r
                            }, toBits: function (e) {
                                var t, n = [], r = 0;
                                for (t = 0; t < e.length; t++) r = r << 8 | e[t], 3 == (3 & t) && (n.push(r), r = 0);
                                return 3 & t && n.push(i().bitArray.partial(8 * (3 & t), r)), n
                            }
                        }
                    }, 674: () => {
                    }
                }, t = {};

                function n(r) {
                    var i = t[r];
                    if (void 0 !== i) return i.exports;
                    var s = t[r] = {exports: {}};
                    return e[r].call(s.exports, s, s.exports, n), s.exports
                }

                return n.n = e => {
                    var t = e && e.__esModule ? () => e.default : () => e;
                    return n.d(t, {a: t}), t
                }, n.d = (e, t) => {
                    for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {enumerable: !0, get: t[r]})
                }, n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => {
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e, "__esModule", {value: !0})
                }, n(920)
            })(), e.exports = t()
        }, 4978: (e, t, n) => {
            "use strict";
            n.d(t, {
                D8: () => A,
                Ds: () => E,
                FX: () => h,
                Fd: () => x,
                JQ: () => c,
                JS: () => P,
                MV: () => D,
                N2: () => y,
                NP: () => T,
                OZ: () => M,
                Os: () => B,
                SA: () => O,
                TR: () => k,
                Uq: () => F,
                Wg: () => C,
                Ym: () => v,
                ZB: () => u,
                _v: () => p,
                aS: () => H,
                gw: () => j,
                iT: () => S,
                jC: () => I,
                jm: () => m,
                le: () => g,
                mY: () => U,
                mp: () => R,
                nm: () => d,
                oK: () => w,
                sC: () => f,
                uB: () => _,
                v1: () => N,
                wo: () => b,
                zb: () => L
            }), n(8995);
            var r = n(7271), i = n(3929), s = n(846), a = n(4658), o = n(5253), l = n(124);
            const c = e => r.ci((0, i.J)(e));

            async function u() {
                return new Promise((e => {
                    const t = document.createElement("input");
                    t.type = "file", t.onchange = t => {
                        const n = t.target;
                        n.files ? e(n.files[0]) : e(void 0)
                    }, t.click()
                }))
            }

            function d(e) {
                const t = ["note", "npub", "nsec"];
                try {
                    if (t.some((t => e.startsWith(t)))) return h(e)
                } catch (e) {
                }
                return e
            }

            function h(e) {
                try {
                    const t = o.gW.decode(e, 1e3), n = o.gW.fromWords(t.words);
                    return r.ci(Uint8Array.from(n))
                } catch (t) {
                    return e
                }
            }

            function f(e, t) {
                return `/e/${t ? (0, l.encodeTLV)(l.NostrPrefix.Event, e, Array.isArray(t) ? t : [t]) : m(l.NostrPrefix.Note, e)}`
            }

            function p(e, t) {
                return `/p/${t ? (0, l.encodeTLV)(l.NostrPrefix.Profile, e, Array.isArray(t) ? t : [t]) : m(l.NostrPrefix.PublicKey, e)}`
            }

            function m(e, t) {
                if ("string" != typeof t || 0 === t.length || t.length % 2 != 0 || (n = t, ![...n].map((e => e.charCodeAt(0))).every((e => e >= 48 && e <= 57 || e >= 65 && e <= 90 || e >= 97 || e <= 122)))) return "";
                var n;
                try {
                    if (e === l.NostrPrefix.Note || e === l.NostrPrefix.PrivateKey || e === l.NostrPrefix.PublicKey) {
                        const n = r.hexToBytes(t);
                        return o.gW.encode(e, o.gW.toWords(n))
                    }
                    return (0, l.encodeTLV)(e, t)
                } catch (e) {
                    return console.warn("Invalid hex", t, e), ""
                }
            }

            const g = {Positive: "+", Negative: "-"};

            function y(e) {
                switch (e) {
                    case"-":
                    case"":
                        return g.Negative;
                    default:
                        return g.Positive
                }
            }

            function v(e, t, n) {
                return (null == e ? void 0 : e.filter((e => e.kind === (null != n ? n : e.kind) && e.tags.some((e => "e" === e[0] && e[1] === t))))) || []
            }

            function b(e, t, n) {
                return (null == e ? void 0 : e.filter((e => e.kind === (null != n ? n : e.kind) && e.tags.some((e => "e" === e[0] && t.includes(e[1])))))) || []
            }

            function w() {
                return Math.floor(x() / 1e3)
            }

            function x() {
                return (new Date).getTime()
            }

            function E(e, t) {
                const n = setTimeout(t, e);
                return () => clearTimeout(n)
            }

            function S(e) {
                return e.reduce(((e, t) => {
                    let {list: n, seen: r} = e;
                    return r.has(t.pubkey) ? {list: n, seen: r} : (r.add(t.pubkey), {seen: r, list: [...n, t]})
                }), {list: [], seen: new Set([])}).list
            }

            function k(e) {
                return e.reduce(((e, t) => {
                    let {list: n, seen: r} = e;
                    return r.has(t.id) ? {list: n, seen: r} : (r.add(t.id), {seen: r, list: [...n, t]})
                }), {list: [], seen: new Set([])}).list
            }

            function A(e) {
                return [...new Set(e)]
            }

            function T(e, t) {
                return A([...null != e ? e : [], ...null != t ? t : []])
            }

            function C(e) {
                if (null == e) throw new Error("missing value");
                return e
            }

            function R(e, t) {
                return [...e].sort((() => Math.random() >= .5 ? 1 : -1)).slice(0, t)
            }

            function L(e) {
                const t = [...e];
                if (t.sort(((e, t) => t.created_at - e.created_at)), t.length > 0) return t[0]
            }

            function _(e, t) {
                const n = L(e);
                if (n) return {
                    keys: n.tags.filter((e => e && 2 === e.length && e[0] === t)).map((e => e[1])),
                    createdAt: n.created_at
                }
            }

            function P(e, t) {
                return (n, r) => "e" === n[0] && "mention" === n[3] && e.content === `#[${r}]` && (!t || n[1] === t)
            }

            function N(e) {
                return e.split(/((?:http|ftp|https|nostr|web\+nostr|magnet):\/?\/?(?:[\w+?.\w+])+(?:[a-zA-Z0-9~!@#$%^&*()_\-=+\\/?.:;',]*)?(?:[-A-Za-z0-9+&@#/%=~()_|]))/i)
            }

            const j = e => new Promise((t => {
                setTimeout(t, e)
            }));

            function I(e) {
                try {
                    const t = {raw: e}, n = e.trim().split("magnet:?")[1];
                    let r;
                    (n && n.length > 0 ? n.split("&") : []).forEach((e => {
                        const n = e.split("="), r = n[0], i = decodeURIComponent(n[1]);
                        switch (t[r] || (t[r] = []), r) {
                            case"dn":
                                t[r].push(i.replace(/\+/g, " "));
                                break;
                            case"kt":
                                i.split("+").forEach((e => {
                                    t[r].push(e)
                                }));
                                break;
                            case"ix":
                                t[r].push(Number(i));
                                break;
                            case"so":
                                break;
                            default:
                                t[r].push(i)
                        }
                    })), t.xt && (Array.isArray(t.xt) ? t.xt : [t.xt]).forEach((e => {
                        if ("string" == typeof e) if (r = e.match(/^urn:btih:(.{40})/)) t.infoHash = [r[1].toLowerCase()]; else if (r = e.match(/^urn:btih:(.{32})/)) {
                            const e = o.eV.decode(r[1]);
                            t.infoHash = [(0, a.ci)(e)]
                        } else (r = e.match(/^urn:btmh:1220(.{64})/)) && (t.infoHashV2 = [r[1].toLowerCase()])
                    })), t.xs && (Array.isArray(t.xs) ? t.xs : [t.xs]).forEach((e => {
                        "string" == typeof e && (r = e.match(/^urn:btpk:(.{64})/)) && (t.publicKey || (t.publicKey = []), t.publicKey.push(r[1].toLowerCase()))
                    }));
                    for (const [e, n] of Object.entries(t)) Array.isArray(n) && (1 === n.length ? t[e] = n[0] : 0 === n.length && (t[e] = void 0));
                    return t
                } catch (e) {
                    console.warn("Failed to parse magnet link", e)
                }
            }

            function M(e, t) {
                const n = [];
                let r = 0, i = e.length / t;
                for (; i > 0;) n.push(e.slice(r, r + t)), r += t, i -= 1;
                return n
            }

            function D(e, t) {
                const n = e.tags.find((e => e[0] === t));
                return n && n[1]
            }

            function O(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++) n[a - 1] = arguments[a];
                return (0, s.b)(i.J, e, r.eV(...n))
            }

            function B(e) {
                const t = new URL(e);
                return t.host + t.search
            }

            function F(e) {
                try {
                    return new URL(null != e ? e : "").hostname
                } catch {
                    var t, n;
                    return null !== (t = null == e || null === (n = e.match(/(\S+\.\S+)/i)) || void 0 === n ? void 0 : n[1]) && void 0 !== t ? t : e
                }
            }

            function U(e) {
                try {
                    return new URL(e).toString()
                } catch {
                }
            }

            function H(e, t) {
                return Object.fromEntries(e.split(null != t ? t : ",").map((e => {
                    const t = e.trim().match(/^(\w+)="(.*)"$/);
                    return t ? [t[1], t[2]] : []
                })))
            }
        }, 4750: (e, t, n) => {
            "use strict";
            n.d(t, {Z: () => s});
            var r = n(3290);
            const i = {Accept: "application/json", "Content-Type": "application/json"};

            class s {
                constructor(e) {
                    if (!e.startsWith("lndhub://")) throw new Error("Invalid config");
                    {
                        const t = /^lndhub:\/\/([\S-]+):([\S-]+)@(.*)$/i, n = e.match(t);
                        if (!n || 4 !== n.length) throw new Error("Invalid LNDHUB config");
                        this.url = new URL(n[3]), this.user = n[1], this.password = n[2], this.type = "lndhub"
                    }
                }

                isReady() {
                    return void 0 !== this.auth
                }

                canAutoLogin() {
                    return !0
                }

                close() {
                    return Promise.resolve(!0)
                }

                async getInfo() {
                    return await this.getJson("GET", "/getinfo")
                }

                async login() {
                    const e = await this.getJson("POST", "/auth?type=auth", {
                        login: this.user,
                        password: this.password
                    });
                    return this.auth = e, !0
                }

                async getBalance() {
                    const e = await this.getJson("GET", "/balance");
                    return Math.floor(e.BTC.AvailableBalance)
                }

                async createInvoice(e) {
                    const t = await this.getJson("POST", "/addinvoice", {amt: e.amount, memo: e.memo});
                    return {
                        pr: t.payment_request,
                        memo: e.memo,
                        amount: e.amount,
                        paymentHash: t.payment_hash,
                        timestamp: t.timestamp
                    }
                }

                async payInvoice(e) {
                    const t = await this.getJson("POST", "/payinvoice", {invoice: e});
                    return {
                        pr: e,
                        paymentHash: t.payment_hash,
                        preimage: t.payment_preimage,
                        state: t.payment_error ? r.kd.Failed : t.payment_preimage ? r.kd.Paid : r.kd.Pending
                    }
                }

                async getInvoices() {
                    return (await this.getJson("GET", "/getuserinvoices")).map((e => {
                        const t = (0, r.BP)(e.payment_request);
                        if (!t) throw new r.lj(r.H8.InvalidInvoice, "Failed to parse invoice");
                        return {
                            ...t,
                            state: e.ispaid ? r.kd.Paid : t.state,
                            paymentHash: e.payment_hash,
                            memo: e.description
                        }
                    }))
                }

                async getJson(e, t, n) {
                    var s;
                    const a = `Bearer ${null === (s = this.auth) || void 0 === s ? void 0 : s.access_token}`,
                        o = `${"/" === this.url.pathname ? this.url.toString().slice(0, -1) : this.url.toString()}${t}`,
                        l = await fetch(o, {
                            method: e,
                            body: n ? JSON.stringify(n) : void 0,
                            headers: {...i, Authorization: a}
                        }), c = await l.json();
                    if ("code" in c && !l.ok) {
                        const e = c;
                        throw new r.lj(e.code, e.message)
                    }
                    return c
                }
            }
        }, 5287: (e, t, n) => {
            "use strict";
            n.d(t, {R: () => m});
            var r, i, s, a, o, l, c = n(124), u = n(3290), d = n(5130), h = n.n(d), f = function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            }, p = function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            };

            class m {
                constructor(e) {
                    r.add(this), i.set(this, void 0), s.set(this, void 0), a.set(this, void 0), f(this, i, m.parseConfigUrl(e), "f"), f(this, a, new Map, "f")
                }

                static parseConfigUrl(e) {
                    const t = new URL(e.replace("nostrwalletconnect://", "http://").replace("nostr+walletconnect://", "http://"));
                    return {
                        relayUrl: t.searchParams.get("relay"),
                        walletPubkey: t.host,
                        secret: t.searchParams.get("secret")
                    }
                }

                canAutoLogin() {
                    return !0
                }

                isReady() {
                    return void 0 !== p(this, s, "f")
                }

                async getInfo() {
                    return await this.login(), await new Promise(((e, t) => {
                        var n;
                        p(this, a, "f").set("info", {
                            resolve: t => {
                                e({alias: "NWC", chains: t.split(" ")})
                            }, reject: t
                        }), null === (n = p(this, s, "f")) || void 0 === n || n.QueueReq(["REQ", "info", {
                            kinds: [13194],
                            limit: 1
                        }], (() => {
                        }))
                    }))
                }

                async login() {
                    return !!p(this, s, "f") || await new Promise((e => {
                        f(this, s, new c.Connection(p(this, i, "f").relayUrl, {
                            read: !0,
                            write: !0
                        }), "f"), p(this, s, "f").OnConnected = () => e(!0), p(this, s, "f").Auth = async (e, t) => {
                            const n = new c.EventBuilder;
                            return n.kind(c.EventKind.Auth).tag(["relay", t]).tag(["challenge", e]), await n.buildAndSign(p(this, i, "f").secret)
                        }, p(this, s, "f").OnEvent = (e, t) => {
                            p(this, r, "m", o).call(this, e, t)
                        }, p(this, s, "f").Connect()
                    }))
                }

                async close() {
                    var e;
                    return null === (e = p(this, s, "f")) || void 0 === e || e.Close(), !0
                }

                async getBalance() {
                    return 0
                }

                createInvoice() {
                    return Promise.reject(new u.lj(u.H8.GeneralError, "Not implemented"))
                }

                async payInvoice(e) {
                    await this.login();
                    const t = await p(this, r, "m", l).call(this, "pay_invoice", {invoice: e});
                    if (t.error) throw new u.lj(u.H8.GeneralError, t.error.message);
                    return {...t.result, pr: e, state: u.kd.Paid}
                }

                getInvoices() {
                    return Promise.resolve([])
                }
            }

            i = new WeakMap, s = new WeakMap, a = new WeakMap, r = new WeakSet, o = async function (e, t) {
                var n;
                if ("info" === e) {
                    const e = p(this, a, "f").get("info");
                    if (!e) throw new u.lj(u.H8.GeneralError, "No pending info command found");
                    return e.resolve(t.content), void p(this, a, "f").delete("info")
                }
                if (23195 !== t.kind) throw new u.lj(u.H8.GeneralError, "Unknown event kind");
                const r = t.tags.find((e => "e" === e[0]));
                if (!r) throw new u.lj(u.H8.GeneralError, "Missing e-tag in command response");
                const i = p(this, a, "f").get(r[1]);
                if (!i) throw new u.lj(u.H8.GeneralError, "No pending command found");
                i.resolve(t.content), p(this, a, "f").delete(r[1]), null === (n = p(this, s, "f")) || void 0 === n || n.CloseReq(e)
            }, l = async function (e, t) {
                if (!p(this, s, "f")) throw new u.lj(u.H8.GeneralError, "Not implemented");
                const n = JSON.stringify({method: e, params: t}), r = new c.EventBuilder;
                r.kind(23194).content(await c.EventExt.encryptDm(n, p(this, i, "f").secret, p(this, i, "f").walletPubkey)).tag(["p", p(this, i, "f").walletPubkey]);
                const o = await r.buildAndSign(p(this, i, "f").secret);
                return p(this, s, "f").QueueReq(["REQ", o.id.slice(0, 12), {
                    kinds: [23195],
                    authors: [p(this, i, "f").walletPubkey],
                    "#e": [o.id]
                }], (() => {
                })), await p(this, s, "f").SendAsync(o), await new Promise(((e, t) => {
                    p(this, a, "f").set(o.id, {
                        resolve: async t => {
                            const n = JSON.parse(await c.EventExt.decryptDm(t, p(this, i, "f").secret, p(this, i, "f").walletPubkey));
                            h()("NWC")("%o", n), e(n)
                        }, reject: t
                    })
                }))
            }
        }, 8142: (e, t, n) => {
            "use strict";
            n.d(t, {V: () => a, n: () => o});
            var r = n(3290), i = n(2036);
            const s = [];

            function a(e) {
                const t = e.list();
                if (window.webln && !t.some((e => e.kind === r.XF.WebLN))) {
                    const n = {id: "webln", kind: r.XF.WebLN, active: 0 === t.length, info: {alias: "WebLN"}};
                    e.add(n)
                }
            }

            (0, i.processWorkQueue)(s);

            class o {
                isReady() {
                    return void 0 !== window.webln && null !== window.webln
                }

                canAutoLogin() {
                    return !0
                }

                async getInfo() {
                    if (await this.login(), this.isReady()) {
                        const e = await (0, i.barrierQueue)(s, (async () => {
                            var e;
                            return await (null === (e = window.webln) || void 0 === e ? void 0 : e.getInfo())
                        }));
                        if (e) return {nodePubKey: e.node.pubkey, alias: e.node.alias};
                        throw new r.lj(r.H8.GeneralError, "Could not load wallet info")
                    }
                    throw new r.lj(r.H8.GeneralError, "WebLN not available")
                }

                async login() {
                    return window.webln && await window.webln.enable(), !0
                }

                close() {
                    return Promise.resolve(!0)
                }

                getBalance() {
                    return Promise.resolve(0)
                }

                async createInvoice(e) {
                    if (await this.login(), this.isReady()) {
                        const t = await (0, i.barrierQueue)(s, (async () => {
                            var t;
                            return await (null === (t = window.webln) || void 0 === t ? void 0 : t.makeInvoice({
                                amount: e.amount,
                                defaultMemo: e.memo
                            }))
                        }));
                        if (t) {
                            const e = (0, r.BP)(t.paymentRequest);
                            if (!e) throw new r.lj(r.H8.InvalidInvoice, "Could not parse invoice");
                            return e
                        }
                    }
                    throw new r.lj(r.H8.GeneralError, "WebLN not available")
                }

                async payInvoice(e) {
                    if (await this.login(), this.isReady()) {
                        const t = (0, r.BP)(e);
                        if (!t) throw new r.lj(r.H8.InvalidInvoice, "Could not parse invoice");
                        const n = await (0, i.barrierQueue)(s, (async () => {
                            var t;
                            return await (null === (t = window.webln) || void 0 === t ? void 0 : t.sendPayment(e))
                        }));
                        return n ? (t.state = r.kd.Paid, t.preimage = n.preimage, t) : (t.state = r.kd.Failed, t)
                    }
                    throw new r.lj(r.H8.GeneralError, "WebLN not available")
                }

                getInvoices() {
                    return Promise.resolve([])
                }
            }
        }, 3290: (e, t, n) => {
            "use strict";
            n.d(t, {BP: () => b, H8: () => l, Os: () => E, XF: () => o, kd: () => c, lj: () => v, uo: () => x});
            var r, i, s, a, o, l, c, u = n(2784), d = n(2036), h = n(4978), f = n(4750), p = n(5287), m = n(8142),
                g = function (e, t, n, r, i) {
                    if ("m" === r) throw new TypeError("Private method is not writable");
                    if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                    if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                    return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
                }, y = function (e, t, n, r) {
                    if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                    if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                    return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
                };
            !function (e) {
                e[e.LNDHub = 1] = "LNDHub", e[e.LNC = 2] = "LNC", e[e.WebLN = 3] = "WebLN", e[e.NWC = 4] = "NWC", e[e.Cashu = 5] = "Cashu"
            }(o || (o = {})), function (e) {
                e[e.BadAuth = 1] = "BadAuth", e[e.NotEnoughBalance = 2] = "NotEnoughBalance", e[e.BadPartner = 3] = "BadPartner", e[e.InvalidInvoice = 4] = "InvalidInvoice", e[e.RouteNotFound = 5] = "RouteNotFound", e[e.GeneralError = 6] = "GeneralError", e[e.NodeFailure = 7] = "NodeFailure"
            }(l || (l = {}));

            class v extends Error {
                constructor(e, t) {
                    super(t), this.code = e
                }
            }

            function b(e) {
                const t = (0, d.decodeInvoice)(e);
                var n, r, i;
                if (t) return {
                    amount: null !== (n = t.amount) && void 0 !== n ? n : 0,
                    memo: t.description,
                    paymentHash: null !== (r = t.paymentHash) && void 0 !== r ? r : "",
                    timestamp: null !== (i = t.timestamp) && void 0 !== i ? i : 0,
                    state: t.expired ? c.Expired : c.Pending,
                    pr: e
                }
            }

            l.GeneralError, function (e) {
                e[e.Pending = 0] = "Pending", e[e.Paid = 1] = "Paid", e[e.Expired = 2] = "Expired", e[e.Failed = 3] = "Failed"
            }(c || (c = {}));

            class w extends d.ExternalStore {
                constructor() {
                    super(), r.add(this), i.set(this, void 0), s.set(this, void 0), g(this, i, [], "f"), g(this, s, new Map, "f"), this.load(!1), (0, m.V)(this), this.notifyChange()
                }

                list() {
                    return Object.freeze([...y(this, i, "f")])
                }

                get() {
                    const e = y(this, i, "f").find((e => e.active));
                    if (!e) {
                        if (0 === y(this, i, "f").length) return;
                        throw new Error("No active wallet config")
                    }
                    if (y(this, s, "f").has(e.id)) return (0, h.Wg)(y(this, s, "f").get(e.id));
                    {
                        const t = y(this, r, "m", a).call(this, e);
                        if (t) return "then" in t ? void t.then((async t => {
                            y(this, s, "f").set(e.id, t), this.notifyChange()
                        })) : t;
                        throw new Error("Unable to activate wallet config")
                    }
                }

                add(e) {
                    y(this, i, "f").push(e), this.save()
                }

                remove(e) {
                    const t = y(this, i, "f").findIndex((t => t.id === e));
                    if (-1 === t) throw new Error("Wallet not found");
                    const [n] = y(this, i, "f").splice(t, 1);
                    n.active && y(this, i, "f").length > 0 && (y(this, i, "f")[0].active = !0), this.save()
                }

                switch(e) {
                    y(this, i, "f").forEach((t => t.active = t.id === e)), this.save()
                }

                save() {
                    const e = JSON.stringify(y(this, i, "f"));
                    window.localStorage.setItem("wallet-config", e), this.notifyChange()
                }

                load() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    const t = window.localStorage.getItem("wallet-config");
                    t && g(this, i, JSON.parse(t), "f"), e && this.notifyChange()
                }

                free() {
                    y(this, s, "f").forEach((e => e.close()))
                }

                takeSnapshot() {
                    return {
                        configs: [...y(this, i, "f")],
                        config: y(this, i, "f").find((e => e.active)),
                        wallet: this.get()
                    }
                }
            }

            i = new WeakMap, s = new WeakMap, r = new WeakSet, a = function (e) {
                switch (e.kind) {
                    case o.LNC:
                        return Promise.all([n.e(669), n.e(516)]).then(n.bind(n, 1516)).then((e => {
                            let {LNCWallet: t} = e;
                            return t.Empty()
                        }));
                    case o.WebLN:
                        return new m.n;
                    case o.LNDHub:
                        return new f.Z((0, h.Wg)(e.data));
                    case o.NWC:
                        return new p.R((0, h.Wg)(e.data));
                    case o.Cashu:
                        return Promise.all([n.e(983), n.e(808)]).then(n.bind(n, 498)).then((t => {
                            let {CashuWallet: n} = t;
                            return new n((0, h.Wg)(e.data))
                        }))
                }
            };
            const x = new w;

            function E() {
                const e = (0, u.useSyncExternalStore)((e => x.hook(e)), (() => x.snapshot()));
                return (0, u.useEffect)((() => {
                    var t;
                    !1 === (null === (t = e.wallet) || void 0 === t ? void 0 : t.isReady()) && e.wallet.canAutoLogin() && e.wallet.login().catch(console.error)
                }), [e]), e
            }

            window.document.addEventListener("close", (() => {
                x.free()
            }))
        }, 2696: (e, t, n) => {
            var r = n.g.CustomEvent;
            e.exports = function () {
                try {
                    var e = new r("cat", {detail: {foo: "bar"}});
                    return "cat" === e.type && "bar" === e.detail.foo
                } catch (e) {
                }
                return !1
            }() ? r : "undefined" != typeof document && "function" == typeof document.createEvent ? function (e, t) {
                var n = document.createEvent("CustomEvent");
                return t ? n.initCustomEvent(e, t.bubbles, t.cancelable, t.detail) : n.initCustomEvent(e, !1, !1, void 0), n
            } : function (e, t) {
                var n = document.createEventObject();
                return n.type = e, t ? (n.bubbles = Boolean(t.bubbles), n.cancelable = Boolean(t.cancelable), n.detail = t.detail) : (n.bubbles = !1, n.cancelable = !1, n.detail = void 0), n
            }
        }, 5130: (e, t, n) => {
            t.formatArgs = function (t) {
                if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors) return;
                const n = "color: " + this.color;
                t.splice(1, 0, n, "color: inherit");
                let r = 0, i = 0;
                t[0].replace(/%[a-zA-Z%]/g, (e => {
                    "%%" !== e && (r++, "%c" === e && (i = r))
                })), t.splice(i, 0, n)
            }, t.save = function (e) {
                try {
                    e ? t.storage.setItem("debug", e) : t.storage.removeItem("debug")
                } catch (e) {
                }
            }, t.load = function () {
                let e;
                try {
                    e = t.storage.getItem("debug")
                } catch (e) {
                }
                return !e && "undefined" != typeof process && "env" in process && (e = process.env.DEBUG), e
            }, t.useColors = function () {
                return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
            }, t.storage = function () {
                try {
                    return localStorage
                } catch (e) {
                }
            }(), t.destroy = (() => {
                let e = !1;
                return () => {
                    e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
                }
            })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => {
            }), e.exports = n(7123)(t);
            const {formatters: r} = e.exports;
            r.j = function (e) {
                try {
                    return JSON.stringify(e)
                } catch (e) {
                    return "[UnexpectedJSONParseError]: " + e.message
                }
            }
        }, 7123: (e, t, n) => {
            e.exports = function (e) {
                function t(e) {
                    let n, i, s, a = null;

                    function o(...e) {
                        if (!o.enabled) return;
                        const r = o, i = Number(new Date), s = i - (n || i);
                        r.diff = s, r.prev = n, r.curr = i, n = i, e[0] = t.coerce(e[0]), "string" != typeof e[0] && e.unshift("%O");
                        let a = 0;
                        e[0] = e[0].replace(/%([a-zA-Z%])/g, ((n, i) => {
                            if ("%%" === n) return "%";
                            a++;
                            const s = t.formatters[i];
                            if ("function" == typeof s) {
                                const t = e[a];
                                n = s.call(r, t), e.splice(a, 1), a--
                            }
                            return n
                        })), t.formatArgs.call(r, e), (r.log || t.log).apply(r, e)
                    }

                    return o.namespace = e, o.useColors = t.useColors(), o.color = t.selectColor(e), o.extend = r, o.destroy = t.destroy, Object.defineProperty(o, "enabled", {
                        enumerable: !0,
                        configurable: !1,
                        get: () => null !== a ? a : (i !== t.namespaces && (i = t.namespaces, s = t.enabled(e)), s),
                        set: e => {
                            a = e
                        }
                    }), "function" == typeof t.init && t.init(o), o
                }

                function r(e, n) {
                    const r = t(this.namespace + (void 0 === n ? ":" : n) + e);
                    return r.log = this.log, r
                }

                function i(e) {
                    return e.toString().substring(2, e.toString().length - 2).replace(/\.\*\?$/, "*")
                }

                return t.debug = t, t.default = t, t.coerce = function (e) {
                    return e instanceof Error ? e.stack || e.message : e
                }, t.disable = function () {
                    const e = [...t.names.map(i), ...t.skips.map(i).map((e => "-" + e))].join(",");
                    return t.enable(""), e
                }, t.enable = function (e) {
                    let n;
                    t.save(e), t.namespaces = e, t.names = [], t.skips = [];
                    const r = ("string" == typeof e ? e : "").split(/[\s,]+/), i = r.length;
                    for (n = 0; n < i; n++) r[n] && ("-" === (e = r[n].replace(/\*/g, ".*?"))[0] ? t.skips.push(new RegExp("^" + e.slice(1) + "$")) : t.names.push(new RegExp("^" + e + "$")))
                }, t.enabled = function (e) {
                    if ("*" === e[e.length - 1]) return !0;
                    let n, r;
                    for (n = 0, r = t.skips.length; n < r; n++) if (t.skips[n].test(e)) return !1;
                    for (n = 0, r = t.names.length; n < r; n++) if (t.names[n].test(e)) return !0;
                    return !1
                }, t.humanize = n(1378), t.destroy = function () {
                    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
                }, Object.keys(e).forEach((n => {
                    t[n] = e[n]
                })), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function (e) {
                    let n = 0;
                    for (let t = 0; t < e.length; t++) n = (n << 5) - n + e.charCodeAt(t), n |= 0;
                    return t.colors[Math.abs(n) % t.colors.length]
                }, t.enable(t.load()), t
            }
        }, 3463: (e, t, n) => {
            "use strict";
            var r = n(8570), i = {
                    childContextTypes: !0,
                    contextType: !0,
                    contextTypes: !0,
                    defaultProps: !0,
                    displayName: !0,
                    getDefaultProps: !0,
                    getDerivedStateFromError: !0,
                    getDerivedStateFromProps: !0,
                    mixins: !0,
                    propTypes: !0,
                    type: !0
                }, s = {name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0},
                a = {$$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0}, o = {};

            function l(e) {
                return r.isMemo(e) ? a : o[e.$$typeof] || i
            }

            o[r.ForwardRef] = {
                $$typeof: !0,
                render: !0,
                defaultProps: !0,
                displayName: !0,
                propTypes: !0
            }, o[r.Memo] = a;
            var c = Object.defineProperty, u = Object.getOwnPropertyNames, d = Object.getOwnPropertySymbols,
                h = Object.getOwnPropertyDescriptor, f = Object.getPrototypeOf, p = Object.prototype;
            e.exports = function e(t, n, r) {
                if ("string" != typeof n) {
                    if (p) {
                        var i = f(n);
                        i && i !== p && e(t, i, r)
                    }
                    var a = u(n);
                    d && (a = a.concat(d(n)));
                    for (var o = l(t), m = l(n), g = 0; g < a.length; ++g) {
                        var y = a[g];
                        if (!(s[y] || r && r[y] || m && m[y] || o && o[y])) {
                            var v = h(n, y);
                            try {
                                c(t, y, v)
                            } catch (e) {
                            }
                        }
                    }
                }
                return t
            }
        }, 1378: e => {
            var t = 1e3, n = 60 * t, r = 60 * n, i = 24 * r;

            function s(e, t, n, r) {
                var i = t >= 1.5 * n;
                return Math.round(e / n) + " " + r + (i ? "s" : "")
            }

            e.exports = function (e, a) {
                a = a || {};
                var o, l, c = typeof e;
                if ("string" === c && e.length > 0) return function (e) {
                    if (!((e = String(e)).length > 100)) {
                        var s = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
                        if (s) {
                            var a = parseFloat(s[1]);
                            switch ((s[2] || "ms").toLowerCase()) {
                                case"years":
                                case"year":
                                case"yrs":
                                case"yr":
                                case"y":
                                    return 315576e5 * a;
                                case"weeks":
                                case"week":
                                case"w":
                                    return 6048e5 * a;
                                case"days":
                                case"day":
                                case"d":
                                    return a * i;
                                case"hours":
                                case"hour":
                                case"hrs":
                                case"hr":
                                case"h":
                                    return a * r;
                                case"minutes":
                                case"minute":
                                case"mins":
                                case"min":
                                case"m":
                                    return a * n;
                                case"seconds":
                                case"second":
                                case"secs":
                                case"sec":
                                case"s":
                                    return a * t;
                                case"milliseconds":
                                case"millisecond":
                                case"msecs":
                                case"msec":
                                case"ms":
                                    return a;
                                default:
                                    return
                            }
                        }
                    }
                }(e);
                if ("number" === c && isFinite(e)) return a.long ? (o = e, (l = Math.abs(o)) >= i ? s(o, l, i, "day") : l >= r ? s(o, l, r, "hour") : l >= n ? s(o, l, n, "minute") : l >= t ? s(o, l, t, "second") : o + " ms") : function (e) {
                    var s = Math.abs(e);
                    return s >= i ? Math.round(e / i) + "d" : s >= r ? Math.round(e / r) + "h" : s >= n ? Math.round(e / n) + "m" : s >= t ? Math.round(e / t) + "s" : e + "ms"
                }(e);
                throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e))
            }
        }, 3542: e => {
            self, e.exports = (() => {
                var e = {
                    192: (e, t) => {
                        var n, r, i = function () {
                            var e = function (e, t) {
                                var n = e, r = a[t], i = null, s = 0, l = null, g = [], y = {}, b = function (e, t) {
                                    i = function (e) {
                                        for (var t = new Array(e), n = 0; n < e; n += 1) {
                                            t[n] = new Array(e);
                                            for (var r = 0; r < e; r += 1) t[n][r] = null
                                        }
                                        return t
                                    }(s = 4 * n + 17), w(0, 0), w(s - 7, 0), w(0, s - 7), E(), x(), k(e, t), n >= 7 && S(e), null == l && (l = T(n, r, g)), A(l, t)
                                }, w = function (e, t) {
                                    for (var n = -1; n <= 7; n += 1) if (!(e + n <= -1 || s <= e + n)) for (var r = -1; r <= 7; r += 1) t + r <= -1 || s <= t + r || (i[e + n][t + r] = 0 <= n && n <= 6 && (0 == r || 6 == r) || 0 <= r && r <= 6 && (0 == n || 6 == n) || 2 <= n && n <= 4 && 2 <= r && r <= 4)
                                }, x = function () {
                                    for (var e = 8; e < s - 8; e += 1) null == i[e][6] && (i[e][6] = e % 2 == 0);
                                    for (var t = 8; t < s - 8; t += 1) null == i[6][t] && (i[6][t] = t % 2 == 0)
                                }, E = function () {
                                    for (var e = o.getPatternPosition(n), t = 0; t < e.length; t += 1) for (var r = 0; r < e.length; r += 1) {
                                        var s = e[t], a = e[r];
                                        if (null == i[s][a]) for (var l = -2; l <= 2; l += 1) for (var c = -2; c <= 2; c += 1) i[s + l][a + c] = -2 == l || 2 == l || -2 == c || 2 == c || 0 == l && 0 == c
                                    }
                                }, S = function (e) {
                                    for (var t = o.getBCHTypeNumber(n), r = 0; r < 18; r += 1) {
                                        var a = !e && 1 == (t >> r & 1);
                                        i[Math.floor(r / 3)][r % 3 + s - 8 - 3] = a
                                    }
                                    for (r = 0; r < 18; r += 1) a = !e && 1 == (t >> r & 1), i[r % 3 + s - 8 - 3][Math.floor(r / 3)] = a
                                }, k = function (e, t) {
                                    for (var n = r << 3 | t, a = o.getBCHTypeInfo(n), l = 0; l < 15; l += 1) {
                                        var c = !e && 1 == (a >> l & 1);
                                        l < 6 ? i[l][8] = c : l < 8 ? i[l + 1][8] = c : i[s - 15 + l][8] = c
                                    }
                                    for (l = 0; l < 15; l += 1) c = !e && 1 == (a >> l & 1), l < 8 ? i[8][s - l - 1] = c : l < 9 ? i[8][15 - l - 1 + 1] = c : i[8][15 - l - 1] = c;
                                    i[s - 8][8] = !e
                                }, A = function (e, t) {
                                    for (var n = -1, r = s - 1, a = 7, l = 0, c = o.getMaskFunction(t), u = s - 1; u > 0; u -= 2) for (6 == u && (u -= 1); ;) {
                                        for (var d = 0; d < 2; d += 1) if (null == i[r][u - d]) {
                                            var h = !1;
                                            l < e.length && (h = 1 == (e[l] >>> a & 1)), c(r, u - d) && (h = !h), i[r][u - d] = h, -1 == (a -= 1) && (l += 1, a = 7)
                                        }
                                        if ((r += n) < 0 || s <= r) {
                                            r -= n, n = -n;
                                            break
                                        }
                                    }
                                }, T = function (e, t, n) {
                                    for (var r = u.getRSBlocks(e, t), i = d(), s = 0; s < n.length; s += 1) {
                                        var a = n[s];
                                        i.put(a.getMode(), 4), i.put(a.getLength(), o.getLengthInBits(a.getMode(), e)), a.write(i)
                                    }
                                    var l = 0;
                                    for (s = 0; s < r.length; s += 1) l += r[s].dataCount;
                                    if (i.getLengthInBits() > 8 * l) throw"code length overflow. (" + i.getLengthInBits() + ">" + 8 * l + ")";
                                    for (i.getLengthInBits() + 4 <= 8 * l && i.put(0, 4); i.getLengthInBits() % 8 != 0;) i.putBit(!1);
                                    for (; !(i.getLengthInBits() >= 8 * l || (i.put(236, 8), i.getLengthInBits() >= 8 * l));) i.put(17, 8);
                                    return function (e, t) {
                                        for (var n = 0, r = 0, i = 0, s = new Array(t.length), a = new Array(t.length), l = 0; l < t.length; l += 1) {
                                            var u = t[l].dataCount, d = t[l].totalCount - u;
                                            r = Math.max(r, u), i = Math.max(i, d), s[l] = new Array(u);
                                            for (var h = 0; h < s[l].length; h += 1) s[l][h] = 255 & e.getBuffer()[h + n];
                                            n += u;
                                            var f = o.getErrorCorrectPolynomial(d),
                                                p = c(s[l], f.getLength() - 1).mod(f);
                                            for (a[l] = new Array(f.getLength() - 1), h = 0; h < a[l].length; h += 1) {
                                                var m = h + p.getLength() - a[l].length;
                                                a[l][h] = m >= 0 ? p.getAt(m) : 0
                                            }
                                        }
                                        var g = 0;
                                        for (h = 0; h < t.length; h += 1) g += t[h].totalCount;
                                        var y = new Array(g), v = 0;
                                        for (h = 0; h < r; h += 1) for (l = 0; l < t.length; l += 1) h < s[l].length && (y[v] = s[l][h], v += 1);
                                        for (h = 0; h < i; h += 1) for (l = 0; l < t.length; l += 1) h < a[l].length && (y[v] = a[l][h], v += 1);
                                        return y
                                    }(i, r)
                                };
                                y.addData = function (e, t) {
                                    var n = null;
                                    switch (t = t || "Byte") {
                                        case"Numeric":
                                            n = h(e);
                                            break;
                                        case"Alphanumeric":
                                            n = f(e);
                                            break;
                                        case"Byte":
                                            n = p(e);
                                            break;
                                        case"Kanji":
                                            n = m(e);
                                            break;
                                        default:
                                            throw"mode:" + t
                                    }
                                    g.push(n), l = null
                                }, y.isDark = function (e, t) {
                                    if (e < 0 || s <= e || t < 0 || s <= t) throw e + "," + t;
                                    return i[e][t]
                                }, y.getModuleCount = function () {
                                    return s
                                }, y.make = function () {
                                    if (n < 1) {
                                        for (var e = 1; e < 40; e++) {
                                            for (var t = u.getRSBlocks(e, r), i = d(), s = 0; s < g.length; s++) {
                                                var a = g[s];
                                                i.put(a.getMode(), 4), i.put(a.getLength(), o.getLengthInBits(a.getMode(), e)), a.write(i)
                                            }
                                            var l = 0;
                                            for (s = 0; s < t.length; s++) l += t[s].dataCount;
                                            if (i.getLengthInBits() <= 8 * l) break
                                        }
                                        n = e
                                    }
                                    b(!1, function () {
                                        for (var e = 0, t = 0, n = 0; n < 8; n += 1) {
                                            b(!0, n);
                                            var r = o.getLostPoint(y);
                                            (0 == n || e > r) && (e = r, t = n)
                                        }
                                        return t
                                    }())
                                }, y.createTableTag = function (e, t) {
                                    e = e || 2;
                                    var n = "";
                                    n += '<table style="', n += " border-width: 0px; border-style: none;", n += " border-collapse: collapse;", n += " padding: 0px; margin: " + (t = void 0 === t ? 4 * e : t) + "px;", n += '">', n += "<tbody>";
                                    for (var r = 0; r < y.getModuleCount(); r += 1) {
                                        n += "<tr>";
                                        for (var i = 0; i < y.getModuleCount(); i += 1) n += '<td style="', n += " border-width: 0px; border-style: none;", n += " border-collapse: collapse;", n += " padding: 0px; margin: 0px;", n += " width: " + e + "px;", n += " height: " + e + "px;", n += " background-color: ", n += y.isDark(r, i) ? "#000000" : "#ffffff", n += ";", n += '"/>';
                                        n += "</tr>"
                                    }
                                    return (n += "</tbody>") + "</table>"
                                }, y.createSvgTag = function (e, t, n, r) {
                                    var i = {};
                                    "object" == typeof arguments[0] && (e = (i = arguments[0]).cellSize, t = i.margin, n = i.alt, r = i.title), e = e || 2, t = void 0 === t ? 4 * e : t, (n = "string" == typeof n ? {text: n} : n || {}).text = n.text || null, n.id = n.text ? n.id || "qrcode-description" : null, (r = "string" == typeof r ? {text: r} : r || {}).text = r.text || null, r.id = r.text ? r.id || "qrcode-title" : null;
                                    var s, a, o, l, c = y.getModuleCount() * e + 2 * t, u = "";
                                    for (l = "l" + e + ",0 0," + e + " -" + e + ",0 0,-" + e + "z ", u += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', u += i.scalable ? "" : ' width="' + c + 'px" height="' + c + 'px"', u += ' viewBox="0 0 ' + c + " " + c + '" ', u += ' preserveAspectRatio="xMinYMin meet"', u += r.text || n.text ? ' role="img" aria-labelledby="' + C([r.id, n.id].join(" ").trim()) + '"' : "", u += ">", u += r.text ? '<title id="' + C(r.id) + '">' + C(r.text) + "</title>" : "", u += n.text ? '<description id="' + C(n.id) + '">' + C(n.text) + "</description>" : "", u += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', u += '<path d="', a = 0; a < y.getModuleCount(); a += 1) for (o = a * e + t, s = 0; s < y.getModuleCount(); s += 1) y.isDark(a, s) && (u += "M" + (s * e + t) + "," + o + l);
                                    return (u += '" stroke="transparent" fill="black"/>') + "</svg>"
                                }, y.createDataURL = function (e, t) {
                                    e = e || 2, t = void 0 === t ? 4 * e : t;
                                    var n = y.getModuleCount() * e + 2 * t, r = t, i = n - t;
                                    return v(n, n, (function (t, n) {
                                        if (r <= t && t < i && r <= n && n < i) {
                                            var s = Math.floor((t - r) / e), a = Math.floor((n - r) / e);
                                            return y.isDark(a, s) ? 0 : 1
                                        }
                                        return 1
                                    }))
                                }, y.createImgTag = function (e, t, n) {
                                    e = e || 2, t = void 0 === t ? 4 * e : t;
                                    var r = y.getModuleCount() * e + 2 * t, i = "";
                                    return i += "<img", i += ' src="', i += y.createDataURL(e, t), i += '"', i += ' width="', i += r, i += '"', i += ' height="', i += r, i += '"', n && (i += ' alt="', i += C(n), i += '"'), i + "/>"
                                };
                                var C = function (e) {
                                    for (var t = "", n = 0; n < e.length; n += 1) {
                                        var r = e.charAt(n);
                                        switch (r) {
                                            case"<":
                                                t += "&lt;";
                                                break;
                                            case">":
                                                t += "&gt;";
                                                break;
                                            case"&":
                                                t += "&amp;";
                                                break;
                                            case'"':
                                                t += "&quot;";
                                                break;
                                            default:
                                                t += r
                                        }
                                    }
                                    return t
                                };
                                return y.createASCII = function (e, t) {
                                    if ((e = e || 1) < 2) return function (e) {
                                        e = void 0 === e ? 2 : e;
                                        var t, n, r, i, s, a = 1 * y.getModuleCount() + 2 * e, o = e, l = a - e,
                                            c = {"": "", " ": "", " ": "", "  ": " "},
                                            u = {"": "", " ": "", " ": " ", "  ": " "}, d = "";
                                        for (t = 0; t < a; t += 2) {
                                            for (r = Math.floor((t - o) / 1), i = Math.floor((t + 1 - o) / 1), n = 0; n < a; n += 1) s = "", o <= n && n < l && o <= t && t < l && y.isDark(r, Math.floor((n - o) / 1)) && (s = " "), o <= n && n < l && o <= t + 1 && t + 1 < l && y.isDark(i, Math.floor((n - o) / 1)) ? s += " " : s += "", d += e < 1 && t + 1 >= l ? u[s] : c[s];
                                            d += "\n"
                                        }
                                        return a % 2 && e > 0 ? d.substring(0, d.length - a - 1) + Array(a + 1).join("") : d.substring(0, d.length - 1)
                                    }(t);
                                    e -= 1, t = void 0 === t ? 2 * e : t;
                                    var n, r, i, s, a = y.getModuleCount() * e + 2 * t, o = t, l = a - t,
                                        c = Array(e + 1).join(""), u = Array(e + 1).join("  "), d = "", h = "";
                                    for (n = 0; n < a; n += 1) {
                                        for (i = Math.floor((n - o) / e), h = "", r = 0; r < a; r += 1) s = 1, o <= r && r < l && o <= n && n < l && y.isDark(i, Math.floor((r - o) / e)) && (s = 0), h += s ? c : u;
                                        for (i = 0; i < e; i += 1) d += h + "\n"
                                    }
                                    return d.substring(0, d.length - 1)
                                }, y.renderTo2dContext = function (e, t) {
                                    t = t || 2;
                                    for (var n = y.getModuleCount(), r = 0; r < n; r++) for (var i = 0; i < n; i++) e.fillStyle = y.isDark(r, i) ? "black" : "white", e.fillRect(r * t, i * t, t, t)
                                }, y
                            };
                            e.stringToBytes = (e.stringToBytesFuncs = {
                                default: function (e) {
                                    for (var t = [], n = 0; n < e.length; n += 1) {
                                        var r = e.charCodeAt(n);
                                        t.push(255 & r)
                                    }
                                    return t
                                }
                            }).default, e.createStringToBytes = function (e, t) {
                                var n = function () {
                                    for (var n = y(e), r = function () {
                                        var e = n.read();
                                        if (-1 == e) throw"eof";
                                        return e
                                    }, i = 0, s = {}; ;) {
                                        var a = n.read();
                                        if (-1 == a) break;
                                        var o = r(), l = r() << 8 | r();
                                        s[String.fromCharCode(a << 8 | o)] = l, i += 1
                                    }
                                    if (i != t) throw i + " != " + t;
                                    return s
                                }(), r = "?".charCodeAt(0);
                                return function (e) {
                                    for (var t = [], i = 0; i < e.length; i += 1) {
                                        var s = e.charCodeAt(i);
                                        if (s < 128) t.push(s); else {
                                            var a = n[e.charAt(i)];
                                            "number" == typeof a ? (255 & a) == a ? t.push(a) : (t.push(a >>> 8), t.push(255 & a)) : t.push(r)
                                        }
                                    }
                                    return t
                                }
                            };
                            var t, n, r, i, s, a = {L: 1, M: 0, Q: 3, H: 2},
                                o = (t = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], n = 1335, r = 7973, s = function (e) {
                                    for (var t = 0; 0 != e;) t += 1, e >>>= 1;
                                    return t
                                }, (i = {}).getBCHTypeInfo = function (e) {
                                    for (var t = e << 10; s(t) - s(n) >= 0;) t ^= n << s(t) - s(n);
                                    return 21522 ^ (e << 10 | t)
                                }, i.getBCHTypeNumber = function (e) {
                                    for (var t = e << 12; s(t) - s(r) >= 0;) t ^= r << s(t) - s(r);
                                    return e << 12 | t
                                }, i.getPatternPosition = function (e) {
                                    return t[e - 1]
                                }, i.getMaskFunction = function (e) {
                                    switch (e) {
                                        case 0:
                                            return function (e, t) {
                                                return (e + t) % 2 == 0
                                            };
                                        case 1:
                                            return function (e, t) {
                                                return e % 2 == 0
                                            };
                                        case 2:
                                            return function (e, t) {
                                                return t % 3 == 0
                                            };
                                        case 3:
                                            return function (e, t) {
                                                return (e + t) % 3 == 0
                                            };
                                        case 4:
                                            return function (e, t) {
                                                return (Math.floor(e / 2) + Math.floor(t / 3)) % 2 == 0
                                            };
                                        case 5:
                                            return function (e, t) {
                                                return e * t % 2 + e * t % 3 == 0
                                            };
                                        case 6:
                                            return function (e, t) {
                                                return (e * t % 2 + e * t % 3) % 2 == 0
                                            };
                                        case 7:
                                            return function (e, t) {
                                                return (e * t % 3 + (e + t) % 2) % 2 == 0
                                            };
                                        default:
                                            throw"bad maskPattern:" + e
                                    }
                                }, i.getErrorCorrectPolynomial = function (e) {
                                    for (var t = c([1], 0), n = 0; n < e; n += 1) t = t.multiply(c([1, l.gexp(n)], 0));
                                    return t
                                }, i.getLengthInBits = function (e, t) {
                                    if (1 <= t && t < 10) switch (e) {
                                        case 1:
                                            return 10;
                                        case 2:
                                            return 9;
                                        case 4:
                                        case 8:
                                            return 8;
                                        default:
                                            throw"mode:" + e
                                    } else if (t < 27) switch (e) {
                                        case 1:
                                            return 12;
                                        case 2:
                                            return 11;
                                        case 4:
                                            return 16;
                                        case 8:
                                            return 10;
                                        default:
                                            throw"mode:" + e
                                    } else {
                                        if (!(t < 41)) throw"type:" + t;
                                        switch (e) {
                                            case 1:
                                                return 14;
                                            case 2:
                                                return 13;
                                            case 4:
                                                return 16;
                                            case 8:
                                                return 12;
                                            default:
                                                throw"mode:" + e
                                        }
                                    }
                                }, i.getLostPoint = function (e) {
                                    for (var t = e.getModuleCount(), n = 0, r = 0; r < t; r += 1) for (var i = 0; i < t; i += 1) {
                                        for (var s = 0, a = e.isDark(r, i), o = -1; o <= 1; o += 1) if (!(r + o < 0 || t <= r + o)) for (var l = -1; l <= 1; l += 1) i + l < 0 || t <= i + l || 0 == o && 0 == l || a == e.isDark(r + o, i + l) && (s += 1);
                                        s > 5 && (n += 3 + s - 5)
                                    }
                                    for (r = 0; r < t - 1; r += 1) for (i = 0; i < t - 1; i += 1) {
                                        var c = 0;
                                        e.isDark(r, i) && (c += 1), e.isDark(r + 1, i) && (c += 1), e.isDark(r, i + 1) && (c += 1), e.isDark(r + 1, i + 1) && (c += 1), 0 != c && 4 != c || (n += 3)
                                    }
                                    for (r = 0; r < t; r += 1) for (i = 0; i < t - 6; i += 1) e.isDark(r, i) && !e.isDark(r, i + 1) && e.isDark(r, i + 2) && e.isDark(r, i + 3) && e.isDark(r, i + 4) && !e.isDark(r, i + 5) && e.isDark(r, i + 6) && (n += 40);
                                    for (i = 0; i < t; i += 1) for (r = 0; r < t - 6; r += 1) e.isDark(r, i) && !e.isDark(r + 1, i) && e.isDark(r + 2, i) && e.isDark(r + 3, i) && e.isDark(r + 4, i) && !e.isDark(r + 5, i) && e.isDark(r + 6, i) && (n += 40);
                                    var u = 0;
                                    for (i = 0; i < t; i += 1) for (r = 0; r < t; r += 1) e.isDark(r, i) && (u += 1);
                                    return n + Math.abs(100 * u / t / t - 50) / 5 * 10
                                }, i), l = function () {
                                    for (var e = new Array(256), t = new Array(256), n = 0; n < 8; n += 1) e[n] = 1 << n;
                                    for (n = 8; n < 256; n += 1) e[n] = e[n - 4] ^ e[n - 5] ^ e[n - 6] ^ e[n - 8];
                                    for (n = 0; n < 255; n += 1) t[e[n]] = n;
                                    return {
                                        glog: function (e) {
                                            if (e < 1) throw"glog(" + e + ")";
                                            return t[e]
                                        }, gexp: function (t) {
                                            for (; t < 0;) t += 255;
                                            for (; t >= 256;) t -= 255;
                                            return e[t]
                                        }
                                    }
                                }();

                            function c(e, t) {
                                if (void 0 === e.length) throw e.length + "/" + t;
                                var n = function () {
                                    for (var n = 0; n < e.length && 0 == e[n];) n += 1;
                                    for (var r = new Array(e.length - n + t), i = 0; i < e.length - n; i += 1) r[i] = e[i + n];
                                    return r
                                }(), r = {
                                    getAt: function (e) {
                                        return n[e]
                                    }, getLength: function () {
                                        return n.length
                                    }, multiply: function (e) {
                                        for (var t = new Array(r.getLength() + e.getLength() - 1), n = 0; n < r.getLength(); n += 1) for (var i = 0; i < e.getLength(); i += 1) t[n + i] ^= l.gexp(l.glog(r.getAt(n)) + l.glog(e.getAt(i)));
                                        return c(t, 0)
                                    }, mod: function (e) {
                                        if (r.getLength() - e.getLength() < 0) return r;
                                        for (var t = l.glog(r.getAt(0)) - l.glog(e.getAt(0)), n = new Array(r.getLength()), i = 0; i < r.getLength(); i += 1) n[i] = r.getAt(i);
                                        for (i = 0; i < e.getLength(); i += 1) n[i] ^= l.gexp(l.glog(e.getAt(i)) + t);
                                        return c(n, 0).mod(e)
                                    }
                                };
                                return r
                            }

                            var u = function () {
                                var e = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]],
                                    t = function (e, t) {
                                        var n = {};
                                        return n.totalCount = e, n.dataCount = t, n
                                    }, n = {
                                        getRSBlocks: function (n, r) {
                                            var i = function (t, n) {
                                                switch (n) {
                                                    case a.L:
                                                        return e[4 * (t - 1) + 0];
                                                    case a.M:
                                                        return e[4 * (t - 1) + 1];
                                                    case a.Q:
                                                        return e[4 * (t - 1) + 2];
                                                    case a.H:
                                                        return e[4 * (t - 1) + 3];
                                                    default:
                                                        return
                                                }
                                            }(n, r);
                                            if (void 0 === i) throw"bad rs block @ typeNumber:" + n + "/errorCorrectionLevel:" + r;
                                            for (var s = i.length / 3, o = [], l = 0; l < s; l += 1) for (var c = i[3 * l + 0], u = i[3 * l + 1], d = i[3 * l + 2], h = 0; h < c; h += 1) o.push(t(u, d));
                                            return o
                                        }
                                    };
                                return n
                            }(), d = function () {
                                var e = [], t = 0, n = {
                                    getBuffer: function () {
                                        return e
                                    }, getAt: function (t) {
                                        var n = Math.floor(t / 8);
                                        return 1 == (e[n] >>> 7 - t % 8 & 1)
                                    }, put: function (e, t) {
                                        for (var r = 0; r < t; r += 1) n.putBit(1 == (e >>> t - r - 1 & 1))
                                    }, getLengthInBits: function () {
                                        return t
                                    }, putBit: function (n) {
                                        var r = Math.floor(t / 8);
                                        e.length <= r && e.push(0), n && (e[r] |= 128 >>> t % 8), t += 1
                                    }
                                };
                                return n
                            }, h = function (e) {
                                var t = e, n = {
                                    getMode: function () {
                                        return 1
                                    }, getLength: function (e) {
                                        return t.length
                                    }, write: function (e) {
                                        for (var n = t, i = 0; i + 2 < n.length;) e.put(r(n.substring(i, i + 3)), 10), i += 3;
                                        i < n.length && (n.length - i == 1 ? e.put(r(n.substring(i, i + 1)), 4) : n.length - i == 2 && e.put(r(n.substring(i, i + 2)), 7))
                                    }
                                }, r = function (e) {
                                    for (var t = 0, n = 0; n < e.length; n += 1) t = 10 * t + i(e.charAt(n));
                                    return t
                                }, i = function (e) {
                                    if ("0" <= e && e <= "9") return e.charCodeAt(0) - "0".charCodeAt(0);
                                    throw"illegal char :" + e
                                };
                                return n
                            }, f = function (e) {
                                var t = e, n = {
                                    getMode: function () {
                                        return 2
                                    }, getLength: function (e) {
                                        return t.length
                                    }, write: function (e) {
                                        for (var n = t, i = 0; i + 1 < n.length;) e.put(45 * r(n.charAt(i)) + r(n.charAt(i + 1)), 11), i += 2;
                                        i < n.length && e.put(r(n.charAt(i)), 6)
                                    }
                                }, r = function (e) {
                                    if ("0" <= e && e <= "9") return e.charCodeAt(0) - "0".charCodeAt(0);
                                    if ("A" <= e && e <= "Z") return e.charCodeAt(0) - "A".charCodeAt(0) + 10;
                                    switch (e) {
                                        case" ":
                                            return 36;
                                        case"$":
                                            return 37;
                                        case"%":
                                            return 38;
                                        case"*":
                                            return 39;
                                        case"+":
                                            return 40;
                                        case"-":
                                            return 41;
                                        case".":
                                            return 42;
                                        case"/":
                                            return 43;
                                        case":":
                                            return 44;
                                        default:
                                            throw"illegal char :" + e
                                    }
                                };
                                return n
                            }, p = function (t) {
                                var n = e.stringToBytes(t);
                                return {
                                    getMode: function () {
                                        return 4
                                    }, getLength: function (e) {
                                        return n.length
                                    }, write: function (e) {
                                        for (var t = 0; t < n.length; t += 1) e.put(n[t], 8)
                                    }
                                }
                            }, m = function (t) {
                                var n = e.stringToBytesFuncs.SJIS;
                                if (!n) throw"sjis not supported.";
                                !function (e, t) {
                                    var r = n("");
                                    if (2 != r.length || 38726 != (r[0] << 8 | r[1])) throw"sjis not supported."
                                }();
                                var r = n(t);
                                return {
                                    getMode: function () {
                                        return 8
                                    }, getLength: function (e) {
                                        return ~~(r.length / 2)
                                    }, write: function (e) {
                                        for (var t = r, n = 0; n + 1 < t.length;) {
                                            var i = (255 & t[n]) << 8 | 255 & t[n + 1];
                                            if (33088 <= i && i <= 40956) i -= 33088; else {
                                                if (!(57408 <= i && i <= 60351)) throw"illegal char at " + (n + 1) + "/" + i;
                                                i -= 49472
                                            }
                                            i = 192 * (i >>> 8 & 255) + (255 & i), e.put(i, 13), n += 2
                                        }
                                        if (n < t.length) throw"illegal char at " + (n + 1)
                                    }
                                }
                            }, g = function () {
                                var e = [], t = {
                                    writeByte: function (t) {
                                        e.push(255 & t)
                                    }, writeShort: function (e) {
                                        t.writeByte(e), t.writeByte(e >>> 8)
                                    }, writeBytes: function (e, n, r) {
                                        n = n || 0, r = r || e.length;
                                        for (var i = 0; i < r; i += 1) t.writeByte(e[i + n])
                                    }, writeString: function (e) {
                                        for (var n = 0; n < e.length; n += 1) t.writeByte(e.charCodeAt(n))
                                    }, toByteArray: function () {
                                        return e
                                    }, toString: function () {
                                        var t = "";
                                        t += "[";
                                        for (var n = 0; n < e.length; n += 1) n > 0 && (t += ","), t += e[n];
                                        return t + "]"
                                    }
                                };
                                return t
                            }, y = function (e) {
                                var t = e, n = 0, r = 0, i = 0, s = {
                                    read: function () {
                                        for (; i < 8;) {
                                            if (n >= t.length) {
                                                if (0 == i) return -1;
                                                throw"unexpected end of file./" + i
                                            }
                                            var e = t.charAt(n);
                                            if (n += 1, "=" == e) return i = 0, -1;
                                            e.match(/^\s$/) || (r = r << 6 | a(e.charCodeAt(0)), i += 6)
                                        }
                                        var s = r >>> i - 8 & 255;
                                        return i -= 8, s
                                    }
                                }, a = function (e) {
                                    if (65 <= e && e <= 90) return e - 65;
                                    if (97 <= e && e <= 122) return e - 97 + 26;
                                    if (48 <= e && e <= 57) return e - 48 + 52;
                                    if (43 == e) return 62;
                                    if (47 == e) return 63;
                                    throw"c:" + e
                                };
                                return s
                            }, v = function (e, t, n) {
                                for (var r = function (e, t) {
                                    var n = e, r = t, i = new Array(e * t), s = {
                                        setPixel: function (e, t, r) {
                                            i[t * n + e] = r
                                        }, write: function (e) {
                                            e.writeString("GIF87a"), e.writeShort(n), e.writeShort(r), e.writeByte(128), e.writeByte(0), e.writeByte(0), e.writeByte(0), e.writeByte(0), e.writeByte(0), e.writeByte(255), e.writeByte(255), e.writeByte(255), e.writeString(","), e.writeShort(0), e.writeShort(0), e.writeShort(n), e.writeShort(r), e.writeByte(0);
                                            var t = a(2);
                                            e.writeByte(2);
                                            for (var i = 0; t.length - i > 255;) e.writeByte(255), e.writeBytes(t, i, 255), i += 255;
                                            e.writeByte(t.length - i), e.writeBytes(t, i, t.length - i), e.writeByte(0), e.writeString(";")
                                        }
                                    }, a = function (e) {
                                        for (var t = 1 << e, n = 1 + (1 << e), r = e + 1, s = o(), a = 0; a < t; a += 1) s.add(String.fromCharCode(a));
                                        s.add(String.fromCharCode(t)), s.add(String.fromCharCode(n));
                                        var l, c, u, d = g(), h = (l = d, c = 0, u = 0, {
                                            write: function (e, t) {
                                                if (e >>> t != 0) throw"length over";
                                                for (; c + t >= 8;) l.writeByte(255 & (e << c | u)), t -= 8 - c, e >>>= 8 - c, u = 0, c = 0;
                                                u |= e << c, c += t
                                            }, flush: function () {
                                                c > 0 && l.writeByte(u)
                                            }
                                        });
                                        h.write(t, r);
                                        var f = 0, p = String.fromCharCode(i[f]);
                                        for (f += 1; f < i.length;) {
                                            var m = String.fromCharCode(i[f]);
                                            f += 1, s.contains(p + m) ? p += m : (h.write(s.indexOf(p), r), s.size() < 4095 && (s.size() == 1 << r && (r += 1), s.add(p + m)), p = m)
                                        }
                                        return h.write(s.indexOf(p), r), h.write(n, r), h.flush(), d.toByteArray()
                                    }, o = function () {
                                        var e = {}, t = 0, n = {
                                            add: function (r) {
                                                if (n.contains(r)) throw"dup key:" + r;
                                                e[r] = t, t += 1
                                            }, size: function () {
                                                return t
                                            }, indexOf: function (t) {
                                                return e[t]
                                            }, contains: function (t) {
                                                return void 0 !== e[t]
                                            }
                                        };
                                        return n
                                    };
                                    return s
                                }(e, t), i = 0; i < t; i += 1) for (var s = 0; s < e; s += 1) r.setPixel(s, i, n(s, i));
                                var a = g();
                                r.write(a);
                                for (var o = function () {
                                    var e = 0, t = 0, n = 0, r = "", i = {}, s = function (e) {
                                        r += String.fromCharCode(a(63 & e))
                                    }, a = function (e) {
                                        if (e < 0) ; else {
                                            if (e < 26) return 65 + e;
                                            if (e < 52) return e - 26 + 97;
                                            if (e < 62) return e - 52 + 48;
                                            if (62 == e) return 43;
                                            if (63 == e) return 47
                                        }
                                        throw"n:" + e
                                    };
                                    return i.writeByte = function (r) {
                                        for (e = e << 8 | 255 & r, t += 8, n += 1; t >= 6;) s(e >>> t - 6), t -= 6
                                    }, i.flush = function () {
                                        if (t > 0 && (s(e << 6 - t), e = 0, t = 0), n % 3 != 0) for (var i = 3 - n % 3, a = 0; a < i; a += 1) r += "="
                                    }, i.toString = function () {
                                        return r
                                    }, i
                                }(), l = a.toByteArray(), c = 0; c < l.length; c += 1) o.writeByte(l[c]);
                                return o.flush(), "data:image/gif;base64," + o
                            };
                            return e
                        }();
                        i.stringToBytesFuncs["UTF-8"] = function (e) {
                            return function (e) {
                                for (var t = [], n = 0; n < e.length; n++) {
                                    var r = e.charCodeAt(n);
                                    r < 128 ? t.push(r) : r < 2048 ? t.push(192 | r >> 6, 128 | 63 & r) : r < 55296 || r >= 57344 ? t.push(224 | r >> 12, 128 | r >> 6 & 63, 128 | 63 & r) : (n++, r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(n)), t.push(240 | r >> 18, 128 | r >> 12 & 63, 128 | r >> 6 & 63, 128 | 63 & r))
                                }
                                return t
                            }(e)
                        }, void 0 === (r = "function" == typeof (n = function () {
                            return i
                        }) ? n.apply(t, []) : n) || (e.exports = r)
                    }, 676: (e, t, n) => {
                        "use strict";
                        n.d(t, {default: () => N});
                        var r = function () {
                            return (r = Object.assign || function (e) {
                                for (var t, n = 1, r = arguments.length; n < r; n++) for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                                return e
                            }).apply(this, arguments)
                        }, i = function (e) {
                            return !!e && "object" == typeof e && !Array.isArray(e)
                        };

                        function s(e) {
                            for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
                            if (!t.length) return e;
                            var a = t.shift();
                            return void 0 !== a && i(e) && i(a) ? (e = r({}, e), Object.keys(a).forEach((function (t) {
                                var n = e[t], r = a[t];
                                Array.isArray(n) && Array.isArray(r) ? e[t] = r : i(n) && i(r) ? e[t] = s(Object.assign({}, n), r) : e[t] = r
                            })), s.apply(void 0, function () {
                                for (var e = 0, t = 0, n = arguments.length; t < n; t++) e += arguments[t].length;
                                var r = Array(e), i = 0;
                                for (t = 0; t < n; t++) for (var s = arguments[t], a = 0, o = s.length; a < o; a++, i++) r[i] = s[a];
                                return r
                            }([e], t))) : e
                        }

                        function a(e, t) {
                            var n = document.createElement("a");
                            n.download = t, n.href = e, document.body.appendChild(n), n.click(), document.body.removeChild(n)
                        }

                        function o(e) {
                            return t = this, void 0, r = function () {
                                return function (e, t) {
                                    var n, r, i, s, a = {
                                        label: 0, sent: function () {
                                            if (1 & i[0]) throw i[1];
                                            return i[1]
                                        }, trys: [], ops: []
                                    };
                                    return s = {
                                        next: o(0),
                                        throw: o(1),
                                        return: o(2)
                                    }, "function" == typeof Symbol && (s[Symbol.iterator] = function () {
                                        return this
                                    }), s;

                                    function o(s) {
                                        return function (o) {
                                            return function (s) {
                                                if (n) throw new TypeError("Generator is already executing.");
                                                for (; a;) try {
                                                    if (n = 1, r && (i = 2 & s[0] ? r.return : s[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, s[1])).done) return i;
                                                    switch (r = 0, i && (s = [2 & s[0], i.value]), s[0]) {
                                                        case 0:
                                                        case 1:
                                                            i = s;
                                                            break;
                                                        case 4:
                                                            return a.label++, {value: s[1], done: !1};
                                                        case 5:
                                                            a.label++, r = s[1], s = [0];
                                                            continue;
                                                        case 7:
                                                            s = a.ops.pop(), a.trys.pop();
                                                            continue;
                                                        default:
                                                            if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                                                a = 0;
                                                                continue
                                                            }
                                                            if (3 === s[0] && (!i || s[1] > i[0] && s[1] < i[3])) {
                                                                a.label = s[1];
                                                                break
                                                            }
                                                            if (6 === s[0] && a.label < i[1]) {
                                                                a.label = i[1], i = s;
                                                                break
                                                            }
                                                            if (i && a.label < i[2]) {
                                                                a.label = i[2], a.ops.push(s);
                                                                break
                                                            }
                                                            i[2] && a.ops.pop(), a.trys.pop();
                                                            continue
                                                    }
                                                    s = t.call(e, a)
                                                } catch (e) {
                                                    s = [6, e], r = 0
                                                } finally {
                                                    n = i = 0
                                                }
                                                if (5 & s[0]) throw s[1];
                                                return {value: s[0] ? s[1] : void 0, done: !0}
                                            }([s, o])
                                        }
                                    }
                                }(this, (function (t) {
                                    return [2, new Promise((function (t) {
                                        var n = new XMLHttpRequest;
                                        n.onload = function () {
                                            var e = new FileReader;
                                            e.onloadend = function () {
                                                t(e.result)
                                            }, e.readAsDataURL(n.response)
                                        }, n.open("GET", e), n.responseType = "blob", n.send()
                                    }))]
                                }))
                            }, new ((n = void 0) || (n = Promise))((function (e, i) {
                                function s(e) {
                                    try {
                                        o(r.next(e))
                                    } catch (e) {
                                        i(e)
                                    }
                                }

                                function a(e) {
                                    try {
                                        o(r.throw(e))
                                    } catch (e) {
                                        i(e)
                                    }
                                }

                                function o(t) {
                                    var r;
                                    t.done ? e(t.value) : (r = t.value, r instanceof n ? r : new n((function (e) {
                                        e(r)
                                    }))).then(s, a)
                                }

                                o((r = r.apply(t, [])).next())
                            }));
                            var t, n, r
                        }

                        const l = {L: .07, M: .15, Q: .25, H: .3};
                        var c = function () {
                            return (c = Object.assign || function (e) {
                                for (var t, n = 1, r = arguments.length; n < r; n++) for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                                return e
                            }).apply(this, arguments)
                        };
                        const u = function () {
                            function e(e) {
                                var t = e.svg, n = e.type;
                                this._svg = t, this._type = n
                            }

                            return e.prototype.draw = function (e, t, n, r) {
                                var i;
                                switch (this._type) {
                                    case"dots":
                                        i = this._drawDot;
                                        break;
                                    case"classy":
                                        i = this._drawClassy;
                                        break;
                                    case"classy-rounded":
                                        i = this._drawClassyRounded;
                                        break;
                                    case"rounded":
                                        i = this._drawRounded;
                                        break;
                                    case"extra-rounded":
                                        i = this._drawExtraRounded;
                                        break;
                                    default:
                                        i = this._drawSquare
                                }
                                i.call(this, {x: e, y: t, size: n, getNeighbor: r})
                            }, e.prototype._rotateFigure = function (e) {
                                var t, n = e.x, r = e.y, i = e.size, s = e.rotation, a = void 0 === s ? 0 : s,
                                    o = n + i / 2, l = r + i / 2;
                                (0, e.draw)(), null === (t = this._element) || void 0 === t || t.setAttribute("transform", "rotate(" + 180 * a / Math.PI + "," + o + "," + l + ")")
                            }, e.prototype._basicDot = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y;
                                this._rotateFigure(c(c({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"), t._element.setAttribute("cx", String(r + n / 2)), t._element.setAttribute("cy", String(i + n / 2)), t._element.setAttribute("r", String(n / 2))
                                    }
                                }))
                            }, e.prototype._basicSquare = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y;
                                this._rotateFigure(c(c({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"), t._element.setAttribute("x", String(r)), t._element.setAttribute("y", String(i)), t._element.setAttribute("width", String(n)), t._element.setAttribute("height", String(n))
                                    }
                                }))
                            }, e.prototype._basicSideRounded = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y;
                                this._rotateFigure(c(c({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), t._element.setAttribute("d", "M " + r + " " + i + "v " + n + "h " + n / 2 + "a " + n / 2 + " " + n / 2 + ", 0, 0, 0, 0 " + -n)
                                    }
                                }))
                            }, e.prototype._basicCornerRounded = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y;
                                this._rotateFigure(c(c({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), t._element.setAttribute("d", "M " + r + " " + i + "v " + n + "h " + n + "v " + -n / 2 + "a " + n / 2 + " " + n / 2 + ", 0, 0, 0, " + -n / 2 + " " + -n / 2)
                                    }
                                }))
                            }, e.prototype._basicCornerExtraRounded = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y;
                                this._rotateFigure(c(c({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), t._element.setAttribute("d", "M " + r + " " + i + "v " + n + "h " + n + "a " + n + " " + n + ", 0, 0, 0, " + -n + " " + -n)
                                    }
                                }))
                            }, e.prototype._basicCornersRounded = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y;
                                this._rotateFigure(c(c({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), t._element.setAttribute("d", "M " + r + " " + i + "v " + n / 2 + "a " + n / 2 + " " + n / 2 + ", 0, 0, 0, " + n / 2 + " " + n / 2 + "h " + n / 2 + "v " + -n / 2 + "a " + n / 2 + " " + n / 2 + ", 0, 0, 0, " + -n / 2 + " " + -n / 2)
                                    }
                                }))
                            }, e.prototype._drawDot = function (e) {
                                var t = e.x, n = e.y, r = e.size;
                                this._basicDot({x: t, y: n, size: r, rotation: 0})
                            }, e.prototype._drawSquare = function (e) {
                                var t = e.x, n = e.y, r = e.size;
                                this._basicSquare({x: t, y: n, size: r, rotation: 0})
                            }, e.prototype._drawRounded = function (e) {
                                var t = e.x, n = e.y, r = e.size, i = e.getNeighbor, s = i ? +i(-1, 0) : 0,
                                    a = i ? +i(1, 0) : 0, o = i ? +i(0, -1) : 0, l = i ? +i(0, 1) : 0,
                                    c = s + a + o + l;
                                if (0 !== c) if (c > 2 || s && a || o && l) this._basicSquare({
                                    x: t,
                                    y: n,
                                    size: r,
                                    rotation: 0
                                }); else {
                                    if (2 === c) {
                                        var u = 0;
                                        return s && o ? u = Math.PI / 2 : o && a ? u = Math.PI : a && l && (u = -Math.PI / 2), void this._basicCornerRounded({
                                            x: t,
                                            y: n,
                                            size: r,
                                            rotation: u
                                        })
                                    }
                                    if (1 === c) return u = 0, o ? u = Math.PI / 2 : a ? u = Math.PI : l && (u = -Math.PI / 2), void this._basicSideRounded({
                                        x: t,
                                        y: n,
                                        size: r,
                                        rotation: u
                                    })
                                } else this._basicDot({x: t, y: n, size: r, rotation: 0})
                            }, e.prototype._drawExtraRounded = function (e) {
                                var t = e.x, n = e.y, r = e.size, i = e.getNeighbor, s = i ? +i(-1, 0) : 0,
                                    a = i ? +i(1, 0) : 0, o = i ? +i(0, -1) : 0, l = i ? +i(0, 1) : 0,
                                    c = s + a + o + l;
                                if (0 !== c) if (c > 2 || s && a || o && l) this._basicSquare({
                                    x: t,
                                    y: n,
                                    size: r,
                                    rotation: 0
                                }); else {
                                    if (2 === c) {
                                        var u = 0;
                                        return s && o ? u = Math.PI / 2 : o && a ? u = Math.PI : a && l && (u = -Math.PI / 2), void this._basicCornerExtraRounded({
                                            x: t,
                                            y: n,
                                            size: r,
                                            rotation: u
                                        })
                                    }
                                    if (1 === c) return u = 0, o ? u = Math.PI / 2 : a ? u = Math.PI : l && (u = -Math.PI / 2), void this._basicSideRounded({
                                        x: t,
                                        y: n,
                                        size: r,
                                        rotation: u
                                    })
                                } else this._basicDot({x: t, y: n, size: r, rotation: 0})
                            }, e.prototype._drawClassy = function (e) {
                                var t = e.x, n = e.y, r = e.size, i = e.getNeighbor, s = i ? +i(-1, 0) : 0,
                                    a = i ? +i(1, 0) : 0, o = i ? +i(0, -1) : 0, l = i ? +i(0, 1) : 0;
                                0 !== s + a + o + l ? s || o ? a || l ? this._basicSquare({
                                    x: t,
                                    y: n,
                                    size: r,
                                    rotation: 0
                                }) : this._basicCornerRounded({
                                    x: t,
                                    y: n,
                                    size: r,
                                    rotation: Math.PI / 2
                                }) : this._basicCornerRounded({
                                    x: t,
                                    y: n,
                                    size: r,
                                    rotation: -Math.PI / 2
                                }) : this._basicCornersRounded({x: t, y: n, size: r, rotation: Math.PI / 2})
                            }, e.prototype._drawClassyRounded = function (e) {
                                var t = e.x, n = e.y, r = e.size, i = e.getNeighbor, s = i ? +i(-1, 0) : 0,
                                    a = i ? +i(1, 0) : 0, o = i ? +i(0, -1) : 0, l = i ? +i(0, 1) : 0;
                                0 !== s + a + o + l ? s || o ? a || l ? this._basicSquare({
                                    x: t,
                                    y: n,
                                    size: r,
                                    rotation: 0
                                }) : this._basicCornerExtraRounded({
                                    x: t,
                                    y: n,
                                    size: r,
                                    rotation: Math.PI / 2
                                }) : this._basicCornerExtraRounded({
                                    x: t,
                                    y: n,
                                    size: r,
                                    rotation: -Math.PI / 2
                                }) : this._basicCornersRounded({x: t, y: n, size: r, rotation: Math.PI / 2})
                            }, e
                        }();
                        var d = function () {
                            return (d = Object.assign || function (e) {
                                for (var t, n = 1, r = arguments.length; n < r; n++) for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                                return e
                            }).apply(this, arguments)
                        };
                        const h = function () {
                            function e(e) {
                                var t = e.svg, n = e.type;
                                this._svg = t, this._type = n
                            }

                            return e.prototype.draw = function (e, t, n, r) {
                                var i;
                                switch (this._type) {
                                    case"square":
                                        i = this._drawSquare;
                                        break;
                                    case"extra-rounded":
                                        i = this._drawExtraRounded;
                                        break;
                                    default:
                                        i = this._drawDot
                                }
                                i.call(this, {x: e, y: t, size: n, rotation: r})
                            }, e.prototype._rotateFigure = function (e) {
                                var t, n = e.x, r = e.y, i = e.size, s = e.rotation, a = void 0 === s ? 0 : s,
                                    o = n + i / 2, l = r + i / 2;
                                (0, e.draw)(), null === (t = this._element) || void 0 === t || t.setAttribute("transform", "rotate(" + 180 * a / Math.PI + "," + o + "," + l + ")")
                            }, e.prototype._basicDot = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y, s = n / 7;
                                this._rotateFigure(d(d({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), t._element.setAttribute("clip-rule", "evenodd"), t._element.setAttribute("d", "M " + (r + n / 2) + " " + i + "a " + n / 2 + " " + n / 2 + " 0 1 0 0.1 0zm 0 " + s + "a " + (n / 2 - s) + " " + (n / 2 - s) + " 0 1 1 -0.1 0Z")
                                    }
                                }))
                            }, e.prototype._basicSquare = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y, s = n / 7;
                                this._rotateFigure(d(d({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), t._element.setAttribute("clip-rule", "evenodd"), t._element.setAttribute("d", "M " + r + " " + i + "v " + n + "h " + n + "v " + -n + "zM " + (r + s) + " " + (i + s) + "h " + (n - 2 * s) + "v " + (n - 2 * s) + "h " + (2 * s - n) + "z")
                                    }
                                }))
                            }, e.prototype._basicExtraRounded = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y, s = n / 7;
                                this._rotateFigure(d(d({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), t._element.setAttribute("clip-rule", "evenodd"), t._element.setAttribute("d", "M " + r + " " + (i + 2.5 * s) + "v " + 2 * s + "a " + 2.5 * s + " " + 2.5 * s + ", 0, 0, 0, " + 2.5 * s + " " + 2.5 * s + "h " + 2 * s + "a " + 2.5 * s + " " + 2.5 * s + ", 0, 0, 0, " + 2.5 * s + " " + 2.5 * -s + "v " + -2 * s + "a " + 2.5 * s + " " + 2.5 * s + ", 0, 0, 0, " + 2.5 * -s + " " + 2.5 * -s + "h " + -2 * s + "a " + 2.5 * s + " " + 2.5 * s + ", 0, 0, 0, " + 2.5 * -s + " " + 2.5 * s + "M " + (r + 2.5 * s) + " " + (i + s) + "h " + 2 * s + "a " + 1.5 * s + " " + 1.5 * s + ", 0, 0, 1, " + 1.5 * s + " " + 1.5 * s + "v " + 2 * s + "a " + 1.5 * s + " " + 1.5 * s + ", 0, 0, 1, " + 1.5 * -s + " " + 1.5 * s + "h " + -2 * s + "a " + 1.5 * s + " " + 1.5 * s + ", 0, 0, 1, " + 1.5 * -s + " " + 1.5 * -s + "v " + -2 * s + "a " + 1.5 * s + " " + 1.5 * s + ", 0, 0, 1, " + 1.5 * s + " " + 1.5 * -s)
                                    }
                                }))
                            }, e.prototype._drawDot = function (e) {
                                var t = e.x, n = e.y, r = e.size, i = e.rotation;
                                this._basicDot({x: t, y: n, size: r, rotation: i})
                            }, e.prototype._drawSquare = function (e) {
                                var t = e.x, n = e.y, r = e.size, i = e.rotation;
                                this._basicSquare({x: t, y: n, size: r, rotation: i})
                            }, e.prototype._drawExtraRounded = function (e) {
                                var t = e.x, n = e.y, r = e.size, i = e.rotation;
                                this._basicExtraRounded({x: t, y: n, size: r, rotation: i})
                            }, e
                        }();
                        var f = function () {
                            return (f = Object.assign || function (e) {
                                for (var t, n = 1, r = arguments.length; n < r; n++) for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                                return e
                            }).apply(this, arguments)
                        };
                        const p = function () {
                            function e(e) {
                                var t = e.svg, n = e.type;
                                this._svg = t, this._type = n
                            }

                            return e.prototype.draw = function (e, t, n, r) {
                                ("square" === this._type ? this._drawSquare : this._drawDot).call(this, {
                                    x: e,
                                    y: t,
                                    size: n,
                                    rotation: r
                                })
                            }, e.prototype._rotateFigure = function (e) {
                                var t, n = e.x, r = e.y, i = e.size, s = e.rotation, a = void 0 === s ? 0 : s,
                                    o = n + i / 2, l = r + i / 2;
                                (0, e.draw)(), null === (t = this._element) || void 0 === t || t.setAttribute("transform", "rotate(" + 180 * a / Math.PI + "," + o + "," + l + ")")
                            }, e.prototype._basicDot = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y;
                                this._rotateFigure(f(f({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"), t._element.setAttribute("cx", String(r + n / 2)), t._element.setAttribute("cy", String(i + n / 2)), t._element.setAttribute("r", String(n / 2))
                                    }
                                }))
                            }, e.prototype._basicSquare = function (e) {
                                var t = this, n = e.size, r = e.x, i = e.y;
                                this._rotateFigure(f(f({}, e), {
                                    draw: function () {
                                        t._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"), t._element.setAttribute("x", String(r)), t._element.setAttribute("y", String(i)), t._element.setAttribute("width", String(n)), t._element.setAttribute("height", String(n))
                                    }
                                }))
                            }, e.prototype._drawDot = function (e) {
                                var t = e.x, n = e.y, r = e.size, i = e.rotation;
                                this._basicDot({x: t, y: n, size: r, rotation: i})
                            }, e.prototype._drawSquare = function (e) {
                                var t = e.x, n = e.y, r = e.size, i = e.rotation;
                                this._basicSquare({x: t, y: n, size: r, rotation: i})
                            }, e
                        }(), m = "circle";
                        var g = function (e, t, n, r) {
                                return new (n || (n = Promise))((function (i, s) {
                                    function a(e) {
                                        try {
                                            l(r.next(e))
                                        } catch (e) {
                                            s(e)
                                        }
                                    }

                                    function o(e) {
                                        try {
                                            l(r.throw(e))
                                        } catch (e) {
                                            s(e)
                                        }
                                    }

                                    function l(e) {
                                        var t;
                                        e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) {
                                            e(t)
                                        }))).then(a, o)
                                    }

                                    l((r = r.apply(e, t || [])).next())
                                }))
                            }, y = function (e, t) {
                                var n, r, i, s, a = {
                                    label: 0, sent: function () {
                                        if (1 & i[0]) throw i[1];
                                        return i[1]
                                    }, trys: [], ops: []
                                };
                                return s = {
                                    next: o(0),
                                    throw: o(1),
                                    return: o(2)
                                }, "function" == typeof Symbol && (s[Symbol.iterator] = function () {
                                    return this
                                }), s;

                                function o(s) {
                                    return function (o) {
                                        return function (s) {
                                            if (n) throw new TypeError("Generator is already executing.");
                                            for (; a;) try {
                                                if (n = 1, r && (i = 2 & s[0] ? r.return : s[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, s[1])).done) return i;
                                                switch (r = 0, i && (s = [2 & s[0], i.value]), s[0]) {
                                                    case 0:
                                                    case 1:
                                                        i = s;
                                                        break;
                                                    case 4:
                                                        return a.label++, {value: s[1], done: !1};
                                                    case 5:
                                                        a.label++, r = s[1], s = [0];
                                                        continue;
                                                    case 7:
                                                        s = a.ops.pop(), a.trys.pop();
                                                        continue;
                                                    default:
                                                        if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                                            a = 0;
                                                            continue
                                                        }
                                                        if (3 === s[0] && (!i || s[1] > i[0] && s[1] < i[3])) {
                                                            a.label = s[1];
                                                            break
                                                        }
                                                        if (6 === s[0] && a.label < i[1]) {
                                                            a.label = i[1], i = s;
                                                            break
                                                        }
                                                        if (i && a.label < i[2]) {
                                                            a.label = i[2], a.ops.push(s);
                                                            break
                                                        }
                                                        i[2] && a.ops.pop(), a.trys.pop();
                                                        continue
                                                }
                                                s = t.call(e, a)
                                            } catch (e) {
                                                s = [6, e], r = 0
                                            } finally {
                                                n = i = 0
                                            }
                                            if (5 & s[0]) throw s[1];
                                            return {value: s[0] ? s[1] : void 0, done: !0}
                                        }([s, o])
                                    }
                                }
                            },
                            v = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]],
                            b = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
                        const w = function () {
                            function e(e) {
                                this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(e.width)), this._element.setAttribute("height", String(e.height)), this._defs = document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._options = e
                            }

                            return Object.defineProperty(e.prototype, "width", {
                                get: function () {
                                    return this._options.width
                                }, enumerable: !1, configurable: !0
                            }), Object.defineProperty(e.prototype, "height", {
                                get: function () {
                                    return this._options.height
                                }, enumerable: !1, configurable: !0
                            }), e.prototype.getElement = function () {
                                return this._element
                            }, e.prototype.drawQR = function (e) {
                                return g(this, void 0, void 0, (function () {
                                    var t, n, r, i, s, a, o, c, u, d, h = this;
                                    return y(this, (function (f) {
                                        switch (f.label) {
                                            case 0:
                                                return t = e.getModuleCount(), n = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, r = this._options.shape === m ? n / Math.sqrt(2) : n, i = Math.floor(r / t), s = {
                                                    hideXDots: 0,
                                                    hideYDots: 0,
                                                    width: 0,
                                                    height: 0
                                                }, this._qr = e, this._options.image ? [4, this.loadImage()] : [3, 2];
                                            case 1:
                                                if (f.sent(), !this._image) return [2];
                                                a = this._options, o = a.imageOptions, c = a.qrOptions, u = o.imageSize * l[c.errorCorrectionLevel], d = Math.floor(u * t * t), s = function (e) {
                                                    var t = e.originalHeight, n = e.originalWidth, r = e.maxHiddenDots,
                                                        i = e.maxHiddenAxisDots, s = e.dotSize, a = {x: 0, y: 0},
                                                        o = {x: 0, y: 0};
                                                    if (t <= 0 || n <= 0 || r <= 0 || s <= 0) return {
                                                        height: 0,
                                                        width: 0,
                                                        hideYDots: 0,
                                                        hideXDots: 0
                                                    };
                                                    var l = t / n;
                                                    return a.x = Math.floor(Math.sqrt(r / l)), a.x <= 0 && (a.x = 1), i && i < a.x && (a.x = i), a.x % 2 == 0 && a.x--, o.x = a.x * s, a.y = 1 + 2 * Math.ceil((a.x * l - 1) / 2), o.y = Math.round(o.x * l), (a.y * a.x > r || i && i < a.y) && (i && i < a.y ? (a.y = i, a.y % 2 == 0 && a.x--) : a.y -= 2, o.y = a.y * s, a.x = 1 + 2 * Math.ceil((a.y / l - 1) / 2), o.x = Math.round(o.y / l)), {
                                                        height: o.y,
                                                        width: o.x,
                                                        hideYDots: a.y,
                                                        hideXDots: a.x
                                                    }
                                                }({
                                                    originalWidth: this._image.width,
                                                    originalHeight: this._image.height,
                                                    maxHiddenDots: d,
                                                    maxHiddenAxisDots: t - 14,
                                                    dotSize: i
                                                }), f.label = 2;
                                            case 2:
                                                return this.drawBackground(), this.drawDots((function (e, n) {
                                                    var r, i, a, o, l, c;
                                                    return !(h._options.imageOptions.hideBackgroundDots && e >= (t - s.hideXDots) / 2 && e < (t + s.hideXDots) / 2 && n >= (t - s.hideYDots) / 2 && n < (t + s.hideYDots) / 2 || (null === (r = v[e]) || void 0 === r ? void 0 : r[n]) || (null === (i = v[e - t + 7]) || void 0 === i ? void 0 : i[n]) || (null === (a = v[e]) || void 0 === a ? void 0 : a[n - t + 7]) || (null === (o = b[e]) || void 0 === o ? void 0 : o[n]) || (null === (l = b[e - t + 7]) || void 0 === l ? void 0 : l[n]) || (null === (c = b[e]) || void 0 === c ? void 0 : c[n - t + 7]))
                                                })), this.drawCorners(), this._options.image ? [4, this.drawImage({
                                                    width: s.width,
                                                    height: s.height,
                                                    count: t,
                                                    dotSize: i
                                                })] : [3, 4];
                                            case 3:
                                                f.sent(), f.label = 4;
                                            case 4:
                                                return [2]
                                        }
                                    }))
                                }))
                            }, e.prototype.drawBackground = function () {
                                var e, t, n, r = this._element, i = this._options;
                                if (r) {
                                    var s = null === (e = i.backgroundOptions) || void 0 === e ? void 0 : e.gradient,
                                        a = null === (t = i.backgroundOptions) || void 0 === t ? void 0 : t.color;
                                    if ((s || a) && this._createColor({
                                        options: s,
                                        color: a,
                                        additionalRotation: 0,
                                        x: 0,
                                        y: 0,
                                        height: i.height,
                                        width: i.width,
                                        name: "background-color"
                                    }), null === (n = i.backgroundOptions) || void 0 === n ? void 0 : n.round) {
                                        var o = Math.min(i.width, i.height),
                                            l = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                                        this._backgroundClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", "clip-path-background-color"), this._defs.appendChild(this._backgroundClipPath), l.setAttribute("x", String((i.width - o) / 2)), l.setAttribute("y", String((i.height - o) / 2)), l.setAttribute("width", String(o)), l.setAttribute("height", String(o)), l.setAttribute("rx", String(o / 2 * i.backgroundOptions.round)), this._backgroundClipPath.appendChild(l)
                                    }
                                }
                            }, e.prototype.drawDots = function (e) {
                                var t, n, r = this;
                                if (!this._qr) throw"QR code is not defined";
                                var i = this._options, s = this._qr.getModuleCount();
                                if (s > i.width || s > i.height) throw"The canvas is too small.";
                                var a = Math.min(i.width, i.height) - 2 * i.margin,
                                    o = i.shape === m ? a / Math.sqrt(2) : a, l = Math.floor(o / s),
                                    c = Math.floor((i.width - s * l) / 2), d = Math.floor((i.height - s * l) / 2),
                                    h = new u({svg: this._element, type: i.dotsOptions.type});
                                this._dotsClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", "clip-path-dot-color"), this._defs.appendChild(this._dotsClipPath), this._createColor({
                                    options: null === (t = i.dotsOptions) || void 0 === t ? void 0 : t.gradient,
                                    color: i.dotsOptions.color,
                                    additionalRotation: 0,
                                    x: 0,
                                    y: 0,
                                    height: i.height,
                                    width: i.width,
                                    name: "dot-color"
                                });
                                for (var f = function (t) {
                                    for (var i = function (i) {
                                        return e && !e(t, i) ? "continue" : (null === (n = p._qr) || void 0 === n ? void 0 : n.isDark(t, i)) ? (h.draw(c + t * l, d + i * l, l, (function (n, a) {
                                            return !(t + n < 0 || i + a < 0 || t + n >= s || i + a >= s) && !(e && !e(t + n, i + a)) && !!r._qr && r._qr.isDark(t + n, i + a)
                                        })), void (h._element && p._dotsClipPath && p._dotsClipPath.appendChild(h._element))) : "continue"
                                    }, a = 0; a < s; a++) i(a)
                                }, p = this, g = 0; g < s; g++) f(g);
                                if (i.shape === m) {
                                    var y = Math.floor((a / l - s) / 2), v = s + 2 * y, b = c - y * l, w = d - y * l,
                                        x = [], E = Math.floor(v / 2);
                                    for (g = 0; g < v; g++) {
                                        x[g] = [];
                                        for (var S = 0; S < v; S++) g >= y - 1 && g <= v - y && S >= y - 1 && S <= v - y || Math.sqrt((g - E) * (g - E) + (S - E) * (S - E)) > E ? x[g][S] = 0 : x[g][S] = this._qr.isDark(S - 2 * y < 0 ? S : S >= s ? S - 2 * y : S - y, g - 2 * y < 0 ? g : g >= s ? g - 2 * y : g - y) ? 1 : 0
                                    }
                                    var k = function (e) {
                                        for (var t = function (t) {
                                            if (!x[e][t]) return "continue";
                                            h.draw(b + e * l, w + t * l, l, (function (n, r) {
                                                var i;
                                                return !!(null === (i = x[e + n]) || void 0 === i ? void 0 : i[t + r])
                                            })), h._element && A._dotsClipPath && A._dotsClipPath.appendChild(h._element)
                                        }, n = 0; n < v; n++) t(n)
                                    }, A = this;
                                    for (g = 0; g < v; g++) k(g)
                                }
                            }, e.prototype.drawCorners = function () {
                                var e = this;
                                if (!this._qr) throw"QR code is not defined";
                                var t = this._element, n = this._options;
                                if (!t) throw"Element code is not defined";
                                var r = this._qr.getModuleCount(), i = Math.min(n.width, n.height) - 2 * n.margin,
                                    s = n.shape === m ? i / Math.sqrt(2) : i, a = Math.floor(s / r), o = 7 * a,
                                    l = 3 * a, c = Math.floor((n.width - r * a) / 2),
                                    d = Math.floor((n.height - r * a) / 2);
                                [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach((function (t) {
                                    var i, s, f, m, g, y, w, x, E, S, k, A, T = t[0], C = t[1], R = t[2],
                                        L = c + T * a * (r - 7), _ = d + C * a * (r - 7), P = e._dotsClipPath,
                                        N = e._dotsClipPath;
                                    if (((null === (i = n.cornersSquareOptions) || void 0 === i ? void 0 : i.gradient) || (null === (s = n.cornersSquareOptions) || void 0 === s ? void 0 : s.color)) && ((P = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-square-color-" + T + "-" + C), e._defs.appendChild(P), e._cornersSquareClipPath = e._cornersDotClipPath = N = P, e._createColor({
                                        options: null === (f = n.cornersSquareOptions) || void 0 === f ? void 0 : f.gradient,
                                        color: null === (m = n.cornersSquareOptions) || void 0 === m ? void 0 : m.color,
                                        additionalRotation: R,
                                        x: L,
                                        y: _,
                                        height: o,
                                        width: o,
                                        name: "corners-square-color-" + T + "-" + C
                                    })), null === (g = n.cornersSquareOptions) || void 0 === g ? void 0 : g.type) {
                                        var j = new h({svg: e._element, type: n.cornersSquareOptions.type});
                                        j.draw(L, _, o, R), j._element && P && P.appendChild(j._element)
                                    } else for (var I = new u({
                                        svg: e._element,
                                        type: n.dotsOptions.type
                                    }), M = function (e) {
                                        for (var t = function (t) {
                                            if (!(null === (y = v[e]) || void 0 === y ? void 0 : y[t])) return "continue";
                                            I.draw(L + e * a, _ + t * a, a, (function (n, r) {
                                                var i;
                                                return !!(null === (i = v[e + n]) || void 0 === i ? void 0 : i[t + r])
                                            })), I._element && P && P.appendChild(I._element)
                                        }, n = 0; n < v[e].length; n++) t(n)
                                    }, D = 0; D < v.length; D++) M(D);
                                    if (((null === (w = n.cornersDotOptions) || void 0 === w ? void 0 : w.gradient) || (null === (x = n.cornersDotOptions) || void 0 === x ? void 0 : x.color)) && ((N = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-dot-color-" + T + "-" + C), e._defs.appendChild(N), e._cornersDotClipPath = N, e._createColor({
                                        options: null === (E = n.cornersDotOptions) || void 0 === E ? void 0 : E.gradient,
                                        color: null === (S = n.cornersDotOptions) || void 0 === S ? void 0 : S.color,
                                        additionalRotation: R,
                                        x: L + 2 * a,
                                        y: _ + 2 * a,
                                        height: l,
                                        width: l,
                                        name: "corners-dot-color-" + T + "-" + C
                                    })), null === (k = n.cornersDotOptions) || void 0 === k ? void 0 : k.type) {
                                        var O = new p({svg: e._element, type: n.cornersDotOptions.type});
                                        O.draw(L + 2 * a, _ + 2 * a, l, R), O._element && N && N.appendChild(O._element)
                                    } else {
                                        I = new u({svg: e._element, type: n.dotsOptions.type});
                                        var B = function (e) {
                                            for (var t = function (t) {
                                                if (!(null === (A = b[e]) || void 0 === A ? void 0 : A[t])) return "continue";
                                                I.draw(L + e * a, _ + t * a, a, (function (n, r) {
                                                    var i;
                                                    return !!(null === (i = b[e + n]) || void 0 === i ? void 0 : i[t + r])
                                                })), I._element && N && N.appendChild(I._element)
                                            }, n = 0; n < b[e].length; n++) t(n)
                                        };
                                        for (D = 0; D < b.length; D++) B(D)
                                    }
                                }))
                            }, e.prototype.loadImage = function () {
                                var e = this;
                                return new Promise((function (t, n) {
                                    var r = e._options, i = new Image;
                                    if (!r.image) return n("Image is not defined");
                                    "string" == typeof r.imageOptions.crossOrigin && (i.crossOrigin = r.imageOptions.crossOrigin), e._image = i, i.onload = function () {
                                        t()
                                    }, i.src = r.image
                                }))
                            }, e.prototype.drawImage = function (e) {
                                var t = e.width, n = e.height, r = e.count, i = e.dotSize;
                                return g(this, void 0, void 0, (function () {
                                    var e, s, a, l, c, u, d, h, f;
                                    return y(this, (function (p) {
                                        switch (p.label) {
                                            case 0:
                                                return e = this._options, s = Math.floor((e.width - r * i) / 2), a = Math.floor((e.height - r * i) / 2), l = s + e.imageOptions.margin + (r * i - t) / 2, c = a + e.imageOptions.margin + (r * i - n) / 2, u = t - 2 * e.imageOptions.margin, d = n - 2 * e.imageOptions.margin, (h = document.createElementNS("http://www.w3.org/2000/svg", "image")).setAttribute("x", String(l)), h.setAttribute("y", String(c)), h.setAttribute("width", u + "px"), h.setAttribute("height", d + "px"), [4, o(e.image || "")];
                                            case 1:
                                                return f = p.sent(), h.setAttribute("href", f || ""), this._element.appendChild(h), [2]
                                        }
                                    }))
                                }))
                            }, e.prototype._createColor = function (e) {
                                var t = e.options, n = e.color, r = e.additionalRotation, i = e.x, s = e.y,
                                    a = e.height, o = e.width, l = e.name, c = o > a ? o : a,
                                    u = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                                if (u.setAttribute("x", String(i)), u.setAttribute("y", String(s)), u.setAttribute("height", String(a)), u.setAttribute("width", String(o)), u.setAttribute("clip-path", "url('#clip-path-" + l + "')"), t) {
                                    var d;
                                    if ("radial" === t.type) (d = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient")).setAttribute("id", l), d.setAttribute("gradientUnits", "userSpaceOnUse"), d.setAttribute("fx", String(i + o / 2)), d.setAttribute("fy", String(s + a / 2)), d.setAttribute("cx", String(i + o / 2)), d.setAttribute("cy", String(s + a / 2)), d.setAttribute("r", String(c / 2)); else {
                                        var h = ((t.rotation || 0) + r) % (2 * Math.PI),
                                            f = (h + 2 * Math.PI) % (2 * Math.PI), p = i + o / 2, m = s + a / 2,
                                            g = i + o / 2, y = s + a / 2;
                                        f >= 0 && f <= .25 * Math.PI || f > 1.75 * Math.PI && f <= 2 * Math.PI ? (p -= o / 2, m -= a / 2 * Math.tan(h), g += o / 2, y += a / 2 * Math.tan(h)) : f > .25 * Math.PI && f <= .75 * Math.PI ? (m -= a / 2, p -= o / 2 / Math.tan(h), y += a / 2, g += o / 2 / Math.tan(h)) : f > .75 * Math.PI && f <= 1.25 * Math.PI ? (p += o / 2, m += a / 2 * Math.tan(h), g -= o / 2, y -= a / 2 * Math.tan(h)) : f > 1.25 * Math.PI && f <= 1.75 * Math.PI && (m += a / 2, p += o / 2 / Math.tan(h), y -= a / 2, g -= o / 2 / Math.tan(h)), (d = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient")).setAttribute("id", l), d.setAttribute("gradientUnits", "userSpaceOnUse"), d.setAttribute("x1", String(Math.round(p))), d.setAttribute("y1", String(Math.round(m))), d.setAttribute("x2", String(Math.round(g))), d.setAttribute("y2", String(Math.round(y)))
                                    }
                                    t.colorStops.forEach((function (e) {
                                        var t = e.offset, n = e.color,
                                            r = document.createElementNS("http://www.w3.org/2000/svg", "stop");
                                        r.setAttribute("offset", 100 * t + "%"), r.setAttribute("stop-color", n), d.appendChild(r)
                                    })), u.setAttribute("fill", "url('#" + l + "')"), this._defs.appendChild(d)
                                } else n && u.setAttribute("fill", n);
                                this._element.appendChild(u)
                            }, e
                        }(), x = "canvas";
                        for (var E = {}, S = 0; S <= 40; S++) E[S] = S;
                        const k = {
                            type: x,
                            shape: "square",
                            width: 300,
                            height: 300,
                            data: "",
                            margin: 0,
                            qrOptions: {typeNumber: E[0], mode: void 0, errorCorrectionLevel: "Q"},
                            imageOptions: {hideBackgroundDots: !0, imageSize: .4, crossOrigin: void 0, margin: 0},
                            dotsOptions: {type: "square", color: "#000"},
                            backgroundOptions: {round: 0, color: "#fff"}
                        };
                        var A = function () {
                            return (A = Object.assign || function (e) {
                                for (var t, n = 1, r = arguments.length; n < r; n++) for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                                return e
                            }).apply(this, arguments)
                        };

                        function T(e) {
                            var t = A({}, e);
                            if (!t.colorStops || !t.colorStops.length) throw"Field 'colorStops' is required in gradient";
                            return t.rotation ? t.rotation = Number(t.rotation) : t.rotation = 0, t.colorStops = t.colorStops.map((function (e) {
                                return A(A({}, e), {offset: Number(e.offset)})
                            })), t
                        }

                        function C(e) {
                            var t = A({}, e);
                            return t.width = Number(t.width), t.height = Number(t.height), t.margin = Number(t.margin), t.imageOptions = A(A({}, t.imageOptions), {
                                hideBackgroundDots: Boolean(t.imageOptions.hideBackgroundDots),
                                imageSize: Number(t.imageOptions.imageSize),
                                margin: Number(t.imageOptions.margin)
                            }), t.margin > Math.min(t.width, t.height) && (t.margin = Math.min(t.width, t.height)), t.dotsOptions = A({}, t.dotsOptions), t.dotsOptions.gradient && (t.dotsOptions.gradient = T(t.dotsOptions.gradient)), t.cornersSquareOptions && (t.cornersSquareOptions = A({}, t.cornersSquareOptions), t.cornersSquareOptions.gradient && (t.cornersSquareOptions.gradient = T(t.cornersSquareOptions.gradient))), t.cornersDotOptions && (t.cornersDotOptions = A({}, t.cornersDotOptions), t.cornersDotOptions.gradient && (t.cornersDotOptions.gradient = T(t.cornersDotOptions.gradient))), t.backgroundOptions && (t.backgroundOptions = A({}, t.backgroundOptions), t.backgroundOptions.gradient && (t.backgroundOptions.gradient = T(t.backgroundOptions.gradient))), t
                        }

                        var R = n(192), L = n.n(R), _ = function (e, t, n, r) {
                            return new (n || (n = Promise))((function (i, s) {
                                function a(e) {
                                    try {
                                        l(r.next(e))
                                    } catch (e) {
                                        s(e)
                                    }
                                }

                                function o(e) {
                                    try {
                                        l(r.throw(e))
                                    } catch (e) {
                                        s(e)
                                    }
                                }

                                function l(e) {
                                    var t;
                                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) {
                                        e(t)
                                    }))).then(a, o)
                                }

                                l((r = r.apply(e, t || [])).next())
                            }))
                        }, P = function (e, t) {
                            var n, r, i, s, a = {
                                label: 0, sent: function () {
                                    if (1 & i[0]) throw i[1];
                                    return i[1]
                                }, trys: [], ops: []
                            };
                            return s = {
                                next: o(0),
                                throw: o(1),
                                return: o(2)
                            }, "function" == typeof Symbol && (s[Symbol.iterator] = function () {
                                return this
                            }), s;

                            function o(s) {
                                return function (o) {
                                    return function (s) {
                                        if (n) throw new TypeError("Generator is already executing.");
                                        for (; a;) try {
                                            if (n = 1, r && (i = 2 & s[0] ? r.return : s[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, s[1])).done) return i;
                                            switch (r = 0, i && (s = [2 & s[0], i.value]), s[0]) {
                                                case 0:
                                                case 1:
                                                    i = s;
                                                    break;
                                                case 4:
                                                    return a.label++, {value: s[1], done: !1};
                                                case 5:
                                                    a.label++, r = s[1], s = [0];
                                                    continue;
                                                case 7:
                                                    s = a.ops.pop(), a.trys.pop();
                                                    continue;
                                                default:
                                                    if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                                        a = 0;
                                                        continue
                                                    }
                                                    if (3 === s[0] && (!i || s[1] > i[0] && s[1] < i[3])) {
                                                        a.label = s[1];
                                                        break
                                                    }
                                                    if (6 === s[0] && a.label < i[1]) {
                                                        a.label = i[1], i = s;
                                                        break
                                                    }
                                                    if (i && a.label < i[2]) {
                                                        a.label = i[2], a.ops.push(s);
                                                        break
                                                    }
                                                    i[2] && a.ops.pop(), a.trys.pop();
                                                    continue
                                            }
                                            s = t.call(e, a)
                                        } catch (e) {
                                            s = [6, e], r = 0
                                        } finally {
                                            n = i = 0
                                        }
                                        if (5 & s[0]) throw s[1];
                                        return {value: s[0] ? s[1] : void 0, done: !0}
                                    }([s, o])
                                }
                            }
                        };
                        const N = function () {
                            function e(e) {
                                this._options = e ? C(s(k, e)) : k, this.update()
                            }

                            return e._clearContainer = function (e) {
                                e && (e.innerHTML = "")
                            }, e.prototype._setupSvg = function () {
                                var e = this;
                                if (this._qr) {
                                    var t = new w(this._options);
                                    this._svg = t.getElement(), this._svgDrawingPromise = t.drawQR(this._qr).then((function () {
                                        var n;
                                        e._svg && (null === (n = e._extension) || void 0 === n || n.call(e, t.getElement(), e._options))
                                    }))
                                }
                            }, e.prototype._setupCanvas = function () {
                                var e, t = this;
                                this._qr && (this._canvas = document.createElement("canvas"), this._canvas.width = this._options.width, this._canvas.height = this._options.height, this._setupSvg(), this._canvasDrawingPromise = null === (e = this._svgDrawingPromise) || void 0 === e ? void 0 : e.then((function () {
                                    if (t._svg) {
                                        var e = t._svg, n = (new XMLSerializer).serializeToString(e),
                                            r = "data:image/svg+xml;base64," + btoa(n), i = new Image;
                                        return new Promise((function (e) {
                                            i.onload = function () {
                                                var n, r;
                                                null === (r = null === (n = t._canvas) || void 0 === n ? void 0 : n.getContext("2d")) || void 0 === r || r.drawImage(i, 0, 0), e()
                                            }, i.src = r
                                        }))
                                    }
                                })))
                            }, e.prototype._getElement = function (e) {
                                return void 0 === e && (e = "png"), _(this, void 0, void 0, (function () {
                                    return P(this, (function (t) {
                                        switch (t.label) {
                                            case 0:
                                                if (!this._qr) throw"QR code is empty";
                                                return "svg" !== e.toLowerCase() ? [3, 2] : (this._svg && this._svgDrawingPromise || this._setupSvg(), [4, this._svgDrawingPromise]);
                                            case 1:
                                                return t.sent(), [2, this._svg];
                                            case 2:
                                                return this._canvas && this._canvasDrawingPromise || this._setupCanvas(), [4, this._canvasDrawingPromise];
                                            case 3:
                                                return t.sent(), [2, this._canvas]
                                        }
                                    }))
                                }))
                            }, e.prototype.update = function (t) {
                                e._clearContainer(this._container), this._options = t ? C(s(this._options, t)) : this._options, this._options.data && (this._qr = L()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function (e) {
                                    switch (!0) {
                                        case/^[0-9]*$/.test(e):
                                            return "Numeric";
                                        case/^[0-9A-Z $%*+\-./:]*$/.test(e):
                                            return "Alphanumeric";
                                        default:
                                            return "Byte"
                                    }
                                }(this._options.data)), this._qr.make(), this._options.type === x ? this._setupCanvas() : this._setupSvg(), this.append(this._container))
                            }, e.prototype.append = function (e) {
                                if (e) {
                                    if ("function" != typeof e.appendChild) throw"Container should be a single DOM node";
                                    this._options.type === x ? this._canvas && e.appendChild(this._canvas) : this._svg && e.appendChild(this._svg), this._container = e
                                }
                            }, e.prototype.applyExtension = function (e) {
                                if (!e) throw"Extension function should be defined.";
                                this._extension = e, this.update()
                            }, e.prototype.deleteExtension = function () {
                                this._extension = void 0, this.update()
                            }, e.prototype.getRawData = function (e) {
                                return void 0 === e && (e = "png"), _(this, void 0, void 0, (function () {
                                    var t, n, r;
                                    return P(this, (function (i) {
                                        switch (i.label) {
                                            case 0:
                                                if (!this._qr) throw"QR code is empty";
                                                return [4, this._getElement(e)];
                                            case 1:
                                                return (t = i.sent()) ? "svg" === e.toLowerCase() ? (n = new XMLSerializer, r = n.serializeToString(t), [2, new Blob(['<?xml version="1.0" standalone="no"?>\r\n' + r], {type: "image/svg+xml"})]) : [2, new Promise((function (n) {
                                                    return t.toBlob(n, "image/" + e, 1)
                                                }))] : [2, null]
                                        }
                                    }))
                                }))
                            }, e.prototype.download = function (e) {
                                return _(this, void 0, void 0, (function () {
                                    var t, n, r, i, s;
                                    return P(this, (function (o) {
                                        switch (o.label) {
                                            case 0:
                                                if (!this._qr) throw"QR code is empty";
                                                return t = "png", n = "qr", "string" == typeof e ? (t = e, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : "object" == typeof e && null !== e && (e.name && (n = e.name), e.extension && (t = e.extension)), [4, this._getElement(t)];
                                            case 1:
                                                return (r = o.sent()) ? ("svg" === t.toLowerCase() ? (i = new XMLSerializer, s = '<?xml version="1.0" standalone="no"?>\r\n' + (s = i.serializeToString(r)), a("data:image/svg+xml;charset=utf-8," + encodeURIComponent(s), n + ".svg")) : a(r.toDataURL("image/" + t), n + "." + t), [2]) : [2]
                                        }
                                    }))
                                }))
                            }, e
                        }()
                    }
                }, t = {};

                function n(r) {
                    if (t[r]) return t[r].exports;
                    var i = t[r] = {exports: {}};
                    return e[r](i, i.exports, n), i.exports
                }

                return n.n = e => {
                    var t = e && e.__esModule ? () => e.default : () => e;
                    return n.d(t, {a: t}), t
                }, n.d = (e, t) => {
                    for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {enumerable: !0, get: t[r]})
                }, n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n(676)
            })().default
        }, 2967: (e, t, n) => {
            "use strict";
            var r = n(2784), i = n(4616);

            function s(e) {
                for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
                return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
            }

            var a = new Set, o = {};

            function l(e, t) {
                c(e, t), c(e + "Capture", t)
            }

            function c(e, t) {
                for (o[e] = t, e = 0; e < t.length; e++) a.add(t[e])
            }

            var u = !("undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement),
                d = Object.prototype.hasOwnProperty,
                h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
                f = {}, p = {};

            function m(e, t, n, r, i, s, a) {
                this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = a
            }

            var g = {};
            "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) {
                g[e] = new m(e, 0, !1, e, null, !1, !1)
            })), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function (e) {
                var t = e[0];
                g[t] = new m(t, 1, !1, e[1], null, !1, !1)
            })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) {
                g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1)
            })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) {
                g[e] = new m(e, 2, !1, e, null, !1, !1)
            })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) {
                g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1)
            })), ["checked", "multiple", "muted", "selected"].forEach((function (e) {
                g[e] = new m(e, 3, !0, e, null, !1, !1)
            })), ["capture", "download"].forEach((function (e) {
                g[e] = new m(e, 4, !1, e, null, !1, !1)
            })), ["cols", "rows", "size", "span"].forEach((function (e) {
                g[e] = new m(e, 6, !1, e, null, !1, !1)
            })), ["rowSpan", "start"].forEach((function (e) {
                g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1)
            }));
            var y = /[\-:]([a-z])/g;

            function v(e) {
                return e[1].toUpperCase()
            }

            function b(e, t, n, r) {
                var i = g.hasOwnProperty(t) ? g[t] : null;
                (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function (e, t, n, r) {
                    if (null == t || function (e, t, n, r) {
                        if (null !== n && 0 === n.type) return !1;
                        switch (typeof t) {
                            case"function":
                            case"symbol":
                                return !0;
                            case"boolean":
                                return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e);
                            default:
                                return !1
                        }
                    }(e, t, n, r)) return !0;
                    if (r) return !1;
                    if (null !== n) switch (n.type) {
                        case 3:
                            return !t;
                        case 4:
                            return !1 === t;
                        case 5:
                            return isNaN(t);
                        case 6:
                            return isNaN(t) || 1 > t
                    }
                    return !1
                }(t, n, i, r) && (n = null), r || null === i ? function (e) {
                    return !!d.call(p, e) || !d.call(f, e) && (h.test(e) ? p[e] = !0 : (f[e] = !0, !1))
                }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
            }

            "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) {
                var t = e.replace(y, v);
                g[t] = new m(t, 1, !1, e, null, !1, !1)
            })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) {
                var t = e.replace(y, v);
                g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
            })), ["xml:base", "xml:lang", "xml:space"].forEach((function (e) {
                var t = e.replace(y, v);
                g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
            })), ["tabIndex", "crossOrigin"].forEach((function (e) {
                g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1)
            })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function (e) {
                g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0)
            }));
            var w = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, x = Symbol.for("react.element"),
                E = Symbol.for("react.portal"), S = Symbol.for("react.fragment"), k = Symbol.for("react.strict_mode"),
                A = Symbol.for("react.profiler"), T = Symbol.for("react.provider"), C = Symbol.for("react.context"),
                R = Symbol.for("react.forward_ref"), L = Symbol.for("react.suspense"),
                _ = Symbol.for("react.suspense_list"), P = Symbol.for("react.memo"), N = Symbol.for("react.lazy");
            Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
            var j = Symbol.for("react.offscreen");
            Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker");
            var I = Symbol.iterator;

            function M(e) {
                return null === e || "object" != typeof e ? null : "function" == typeof (e = I && e[I] || e["@@iterator"]) ? e : null
            }

            var D, O = Object.assign;

            function B(e) {
                if (void 0 === D) try {
                    throw Error()
                } catch (e) {
                    var t = e.stack.trim().match(/\n( *(at )?)/);
                    D = t && t[1] || ""
                }
                return "\n" + D + e
            }

            var F = !1;

            function U(e, t) {
                if (!e || F) return "";
                F = !0;
                var n = Error.prepareStackTrace;
                Error.prepareStackTrace = void 0;
                try {
                    if (t) if (t = function () {
                        throw Error()
                    }, Object.defineProperty(t.prototype, "props", {
                        set: function () {
                            throw Error()
                        }
                    }), "object" == typeof Reflect && Reflect.construct) {
                        try {
                            Reflect.construct(t, [])
                        } catch (e) {
                            var r = e
                        }
                        Reflect.construct(e, [], t)
                    } else {
                        try {
                            t.call()
                        } catch (e) {
                            r = e
                        }
                        e.call(t.prototype)
                    } else {
                        try {
                            throw Error()
                        } catch (e) {
                            r = e
                        }
                        e()
                    }
                } catch (t) {
                    if (t && r && "string" == typeof t.stack) {
                        for (var i = t.stack.split("\n"), s = r.stack.split("\n"), a = i.length - 1, o = s.length - 1; 1 <= a && 0 <= o && i[a] !== s[o];) o--;
                        for (; 1 <= a && 0 <= o; a--, o--) if (i[a] !== s[o]) {
                            if (1 !== a || 1 !== o) do {
                                if (a--, 0 > --o || i[a] !== s[o]) {
                                    var l = "\n" + i[a].replace(" at new ", " at ");
                                    return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
                                }
                            } while (1 <= a && 0 <= o);
                            break
                        }
                    }
                } finally {
                    F = !1, Error.prepareStackTrace = n
                }
                return (e = e ? e.displayName || e.name : "") ? B(e) : ""
            }

            function H(e) {
                switch (e.tag) {
                    case 5:
                        return B(e.type);
                    case 16:
                        return B("Lazy");
                    case 13:
                        return B("Suspense");
                    case 19:
                        return B("SuspenseList");
                    case 0:
                    case 2:
                    case 15:
                        return U(e.type, !1);
                    case 11:
                        return U(e.type.render, !1);
                    case 1:
                        return U(e.type, !0);
                    default:
                        return ""
                }
            }

            function $(e) {
                if (null == e) return null;
                if ("function" == typeof e) return e.displayName || e.name || null;
                if ("string" == typeof e) return e;
                switch (e) {
                    case S:
                        return "Fragment";
                    case E:
                        return "Portal";
                    case A:
                        return "Profiler";
                    case k:
                        return "StrictMode";
                    case L:
                        return "Suspense";
                    case _:
                        return "SuspenseList"
                }
                if ("object" == typeof e) switch (e.$$typeof) {
                    case C:
                        return (e.displayName || "Context") + ".Consumer";
                    case T:
                        return (e._context.displayName || "Context") + ".Provider";
                    case R:
                        var t = e.render;
                        return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
                    case P:
                        return null !== (t = e.displayName || null) ? t : $(e.type) || "Memo";
                    case N:
                        t = e._payload, e = e._init;
                        try {
                            return $(e(t))
                        } catch (e) {
                        }
                }
                return null
            }

            function K(e) {
                var t = e.type;
                switch (e.tag) {
                    case 24:
                        return "Cache";
                    case 9:
                        return (t.displayName || "Context") + ".Consumer";
                    case 10:
                        return (t._context.displayName || "Context") + ".Provider";
                    case 18:
                        return "DehydratedFragment";
                    case 11:
                        return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef");
                    case 7:
                        return "Fragment";
                    case 5:
                        return t;
                    case 4:
                        return "Portal";
                    case 3:
                        return "Root";
                    case 6:
                        return "Text";
                    case 16:
                        return $(t);
                    case 8:
                        return t === k ? "StrictMode" : "Mode";
                    case 22:
                        return "Offscreen";
                    case 12:
                        return "Profiler";
                    case 21:
                        return "Scope";
                    case 13:
                        return "Suspense";
                    case 19:
                        return "SuspenseList";
                    case 25:
                        return "TracingMarker";
                    case 1:
                    case 0:
                    case 17:
                    case 2:
                    case 14:
                    case 15:
                        if ("function" == typeof t) return t.displayName || t.name || null;
                        if ("string" == typeof t) return t
                }
                return null
            }

            function z(e) {
                switch (typeof e) {
                    case"boolean":
                    case"number":
                    case"string":
                    case"undefined":
                    case"object":
                        return e;
                    default:
                        return ""
                }
            }

            function G(e) {
                var t = e.type;
                return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
            }

            function q(e) {
                e._valueTracker || (e._valueTracker = function (e) {
                    var t = G(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
                        r = "" + e[t];
                    if (!e.hasOwnProperty(t) && void 0 !== n && "function" == typeof n.get && "function" == typeof n.set) {
                        var i = n.get, s = n.set;
                        return Object.defineProperty(e, t, {
                            configurable: !0, get: function () {
                                return i.call(this)
                            }, set: function (e) {
                                r = "" + e, s.call(this, e)
                            }
                        }), Object.defineProperty(e, t, {enumerable: n.enumerable}), {
                            getValue: function () {
                                return r
                            }, setValue: function (e) {
                                r = "" + e
                            }, stopTracking: function () {
                                e._valueTracker = null, delete e[t]
                            }
                        }
                    }
                }(e))
            }

            function W(e) {
                if (!e) return !1;
                var t = e._valueTracker;
                if (!t) return !0;
                var n = t.getValue(), r = "";
                return e && (r = G(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0)
            }

            function V(e) {
                if (void 0 === (e = e || ("undefined" != typeof document ? document : void 0))) return null;
                try {
                    return e.activeElement || e.body
                } catch (t) {
                    return e.body
                }
            }

            function Y(e, t) {
                var n = t.checked;
                return O({}, t, {
                    defaultChecked: void 0,
                    defaultValue: void 0,
                    value: void 0,
                    checked: null != n ? n : e._wrapperState.initialChecked
                })
            }

            function Z(e, t) {
                var n = null == t.defaultValue ? "" : t.defaultValue,
                    r = null != t.checked ? t.checked : t.defaultChecked;
                n = z(null != t.value ? t.value : n), e._wrapperState = {
                    initialChecked: r,
                    initialValue: n,
                    controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value
                }
            }

            function X(e, t) {
                null != (t = t.checked) && b(e, "checked", t, !1)
            }

            function Q(e, t) {
                X(e, t);
                var n = z(t.value), r = t.type;
                if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if ("submit" === r || "reset" === r) return void e.removeAttribute("value");
                t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, z(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked)
            }

            function J(e, t, n) {
                if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
                    var r = t.type;
                    if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return;
                    t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t
                }
                "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n)
            }

            function ee(e, t, n) {
                "number" === t && V(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
            }

            var te = Array.isArray;

            function ne(e, t, n, r) {
                if (e = e.options, t) {
                    t = {};
                    for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
                    for (n = 0; n < e.length; n++) i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0)
                } else {
                    for (n = "" + z(n), t = null, i = 0; i < e.length; i++) {
                        if (e[i].value === n) return e[i].selected = !0, void (r && (e[i].defaultSelected = !0));
                        null !== t || e[i].disabled || (t = e[i])
                    }
                    null !== t && (t.selected = !0)
                }
            }

            function re(e, t) {
                if (null != t.dangerouslySetInnerHTML) throw Error(s(91));
                return O({}, t, {value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue})
            }

            function ie(e, t) {
                var n = t.value;
                if (null == n) {
                    if (n = t.children, t = t.defaultValue, null != n) {
                        if (null != t) throw Error(s(92));
                        if (te(n)) {
                            if (1 < n.length) throw Error(s(93));
                            n = n[0]
                        }
                        t = n
                    }
                    null == t && (t = ""), n = t
                }
                e._wrapperState = {initialValue: z(n)}
            }

            function se(e, t) {
                var n = z(t.value), r = z(t.defaultValue);
                null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r)
            }

            function ae(e) {
                var t = e.textContent;
                t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t)
            }

            function oe(e) {
                switch (e) {
                    case"svg":
                        return "http://www.w3.org/2000/svg";
                    case"math":
                        return "http://www.w3.org/1998/Math/MathML";
                    default:
                        return "http://www.w3.org/1999/xhtml"
                }
            }

            function le(e, t) {
                return null == e || "http://www.w3.org/1999/xhtml" === e ? oe(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e
            }

            var ce, ue, de = (ue = function (e, t) {
                if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t; else {
                    for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;) e.removeChild(e.firstChild);
                    for (; t.firstChild;) e.appendChild(t.firstChild)
                }
            }, "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction ? function (e, t, n, r) {
                MSApp.execUnsafeLocalFunction((function () {
                    return ue(e, t)
                }))
            } : ue);

            function he(e, t) {
                if (t) {
                    var n = e.firstChild;
                    if (n && n === e.lastChild && 3 === n.nodeType) return void (n.nodeValue = t)
                }
                e.textContent = t
            }

            var fe = {
                animationIterationCount: !0,
                aspectRatio: !0,
                borderImageOutset: !0,
                borderImageSlice: !0,
                borderImageWidth: !0,
                boxFlex: !0,
                boxFlexGroup: !0,
                boxOrdinalGroup: !0,
                columnCount: !0,
                columns: !0,
                flex: !0,
                flexGrow: !0,
                flexPositive: !0,
                flexShrink: !0,
                flexNegative: !0,
                flexOrder: !0,
                gridArea: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowSpan: !0,
                gridRowStart: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnSpan: !0,
                gridColumnStart: !0,
                fontWeight: !0,
                lineClamp: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                tabSize: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0,
                fillOpacity: !0,
                floodOpacity: !0,
                stopOpacity: !0,
                strokeDasharray: !0,
                strokeDashoffset: !0,
                strokeMiterlimit: !0,
                strokeOpacity: !0,
                strokeWidth: !0
            }, pe = ["Webkit", "ms", "Moz", "O"];

            function me(e, t, n) {
                return null == t || "boolean" == typeof t || "" === t ? "" : n || "number" != typeof t || 0 === t || fe.hasOwnProperty(e) && fe[e] ? ("" + t).trim() : t + "px"
            }

            function ge(e, t) {
                for (var n in e = e.style, t) if (t.hasOwnProperty(n)) {
                    var r = 0 === n.indexOf("--"), i = me(n, t[n], r);
                    "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i
                }
            }

            Object.keys(fe).forEach((function (e) {
                pe.forEach((function (t) {
                    t = t + e.charAt(0).toUpperCase() + e.substring(1), fe[t] = fe[e]
                }))
            }));
            var ye = O({menuitem: !0}, {
                area: !0,
                base: !0,
                br: !0,
                col: !0,
                embed: !0,
                hr: !0,
                img: !0,
                input: !0,
                keygen: !0,
                link: !0,
                meta: !0,
                param: !0,
                source: !0,
                track: !0,
                wbr: !0
            });

            function ve(e, t) {
                if (t) {
                    if (ye[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(s(137, e));
                    if (null != t.dangerouslySetInnerHTML) {
                        if (null != t.children) throw Error(s(60));
                        if ("object" != typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(s(61))
                    }
                    if (null != t.style && "object" != typeof t.style) throw Error(s(62))
                }
            }

            function be(e, t) {
                if (-1 === e.indexOf("-")) return "string" == typeof t.is;
                switch (e) {
                    case"annotation-xml":
                    case"color-profile":
                    case"font-face":
                    case"font-face-src":
                    case"font-face-uri":
                    case"font-face-format":
                    case"font-face-name":
                    case"missing-glyph":
                        return !1;
                    default:
                        return !0
                }
            }

            var we = null;

            function xe(e) {
                return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e
            }

            var Ee = null, Se = null, ke = null;

            function Ae(e) {
                if (e = bi(e)) {
                    if ("function" != typeof Ee) throw Error(s(280));
                    var t = e.stateNode;
                    t && (t = xi(t), Ee(e.stateNode, e.type, t))
                }
            }

            function Te(e) {
                Se ? ke ? ke.push(e) : ke = [e] : Se = e
            }

            function Ce() {
                if (Se) {
                    var e = Se, t = ke;
                    if (ke = Se = null, Ae(e), t) for (e = 0; e < t.length; e++) Ae(t[e])
                }
            }

            function Re(e, t) {
                return e(t)
            }

            function Le() {
            }

            var _e = !1;

            function Pe(e, t, n) {
                if (_e) return e(t, n);
                _e = !0;
                try {
                    return Re(e, t, n)
                } finally {
                    _e = !1, (null !== Se || null !== ke) && (Le(), Ce())
                }
            }

            function Ne(e, t) {
                var n = e.stateNode;
                if (null === n) return null;
                var r = xi(n);
                if (null === r) return null;
                n = r[t];
                e:switch (t) {
                    case"onClick":
                    case"onClickCapture":
                    case"onDoubleClick":
                    case"onDoubleClickCapture":
                    case"onMouseDown":
                    case"onMouseDownCapture":
                    case"onMouseMove":
                    case"onMouseMoveCapture":
                    case"onMouseUp":
                    case"onMouseUpCapture":
                    case"onMouseEnter":
                        (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r;
                        break e;
                    default:
                        e = !1
                }
                if (e) return null;
                if (n && "function" != typeof n) throw Error(s(231, t, typeof n));
                return n
            }

            var je = !1;
            if (u) try {
                var Ie = {};
                Object.defineProperty(Ie, "passive", {
                    get: function () {
                        je = !0
                    }
                }), window.addEventListener("test", Ie, Ie), window.removeEventListener("test", Ie, Ie)
            } catch (ue) {
                je = !1
            }

            function Me(e, t, n, r, i, s, a, o, l) {
                var c = Array.prototype.slice.call(arguments, 3);
                try {
                    t.apply(n, c)
                } catch (e) {
                    this.onError(e)
                }
            }

            var De = !1, Oe = null, Be = !1, Fe = null, Ue = {
                onError: function (e) {
                    De = !0, Oe = e
                }
            };

            function He(e, t, n, r, i, s, a, o, l) {
                De = !1, Oe = null, Me.apply(Ue, arguments)
            }

            function $e(e) {
                var t = e, n = e;
                if (e.alternate) for (; t.return;) t = t.return; else {
                    e = t;
                    do {
                        0 != (4098 & (t = e).flags) && (n = t.return), e = t.return
                    } while (e)
                }
                return 3 === t.tag ? n : null
            }

            function Ke(e) {
                if (13 === e.tag) {
                    var t = e.memoizedState;
                    if (null === t && null !== (e = e.alternate) && (t = e.memoizedState), null !== t) return t.dehydrated
                }
                return null
            }

            function ze(e) {
                if ($e(e) !== e) throw Error(s(188))
            }

            function Ge(e) {
                return null !== (e = function (e) {
                    var t = e.alternate;
                    if (!t) {
                        if (null === (t = $e(e))) throw Error(s(188));
                        return t !== e ? null : e
                    }
                    for (var n = e, r = t; ;) {
                        var i = n.return;
                        if (null === i) break;
                        var a = i.alternate;
                        if (null === a) {
                            if (null !== (r = i.return)) {
                                n = r;
                                continue
                            }
                            break
                        }
                        if (i.child === a.child) {
                            for (a = i.child; a;) {
                                if (a === n) return ze(i), e;
                                if (a === r) return ze(i), t;
                                a = a.sibling
                            }
                            throw Error(s(188))
                        }
                        if (n.return !== r.return) n = i, r = a; else {
                            for (var o = !1, l = i.child; l;) {
                                if (l === n) {
                                    o = !0, n = i, r = a;
                                    break
                                }
                                if (l === r) {
                                    o = !0, r = i, n = a;
                                    break
                                }
                                l = l.sibling
                            }
                            if (!o) {
                                for (l = a.child; l;) {
                                    if (l === n) {
                                        o = !0, n = a, r = i;
                                        break
                                    }
                                    if (l === r) {
                                        o = !0, r = a, n = i;
                                        break
                                    }
                                    l = l.sibling
                                }
                                if (!o) throw Error(s(189))
                            }
                        }
                        if (n.alternate !== r) throw Error(s(190))
                    }
                    if (3 !== n.tag) throw Error(s(188));
                    return n.stateNode.current === n ? e : t
                }(e)) ? qe(e) : null
            }

            function qe(e) {
                if (5 === e.tag || 6 === e.tag) return e;
                for (e = e.child; null !== e;) {
                    var t = qe(e);
                    if (null !== t) return t;
                    e = e.sibling
                }
                return null
            }

            var We = i.unstable_scheduleCallback, Ve = i.unstable_cancelCallback, Ye = i.unstable_shouldYield,
                Ze = i.unstable_requestPaint, Xe = i.unstable_now, Qe = i.unstable_getCurrentPriorityLevel,
                Je = i.unstable_ImmediatePriority, et = i.unstable_UserBlockingPriority, tt = i.unstable_NormalPriority,
                nt = i.unstable_LowPriority, rt = i.unstable_IdlePriority, it = null, st = null,
                at = Math.clz32 ? Math.clz32 : function (e) {
                    return 0 === (e >>>= 0) ? 32 : 31 - (ot(e) / lt | 0) | 0
                }, ot = Math.log, lt = Math.LN2, ct = 64, ut = 4194304;

            function dt(e) {
                switch (e & -e) {
                    case 1:
                        return 1;
                    case 2:
                        return 2;
                    case 4:
                        return 4;
                    case 8:
                        return 8;
                    case 16:
                        return 16;
                    case 32:
                        return 32;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                        return 4194240 & e;
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                        return 130023424 & e;
                    case 134217728:
                        return 134217728;
                    case 268435456:
                        return 268435456;
                    case 536870912:
                        return 536870912;
                    case 1073741824:
                        return 1073741824;
                    default:
                        return e
                }
            }

            function ht(e, t) {
                var n = e.pendingLanes;
                if (0 === n) return 0;
                var r = 0, i = e.suspendedLanes, s = e.pingedLanes, a = 268435455 & n;
                if (0 !== a) {
                    var o = a & ~i;
                    0 !== o ? r = dt(o) : 0 != (s &= a) && (r = dt(s))
                } else 0 != (a = n & ~i) ? r = dt(a) : 0 !== s && (r = dt(s));
                if (0 === r) return 0;
                if (0 !== t && t !== r && 0 == (t & i) && ((i = r & -r) >= (s = t & -t) || 16 === i && 0 != (4194240 & s))) return t;
                if (0 != (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes)) for (e = e.entanglements, t &= r; 0 < t;) i = 1 << (n = 31 - at(t)), r |= e[n], t &= ~i;
                return r
            }

            function ft(e, t) {
                switch (e) {
                    case 1:
                    case 2:
                    case 4:
                        return t + 250;
                    case 8:
                    case 16:
                    case 32:
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                        return t + 5e3;
                    default:
                        return -1
                }
            }

            function pt(e) {
                return 0 != (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
            }

            function mt() {
                var e = ct;
                return 0 == (4194240 & (ct <<= 1)) && (ct = 64), e
            }

            function gt(e) {
                for (var t = [], n = 0; 31 > n; n++) t.push(e);
                return t
            }

            function yt(e, t, n) {
                e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - at(t)] = n
            }

            function vt(e, t) {
                var n = e.entangledLanes |= t;
                for (e = e.entanglements; n;) {
                    var r = 31 - at(n), i = 1 << r;
                    i & t | e[r] & t && (e[r] |= t), n &= ~i
                }
            }

            var bt = 0;

            function wt(e) {
                return 1 < (e &= -e) ? 4 < e ? 0 != (268435455 & e) ? 16 : 536870912 : 4 : 1
            }

            var xt, Et, St, kt, At, Tt = !1, Ct = [], Rt = null, Lt = null, _t = null, Pt = new Map, Nt = new Map,
                jt = [],
                It = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

            function Mt(e, t) {
                switch (e) {
                    case"focusin":
                    case"focusout":
                        Rt = null;
                        break;
                    case"dragenter":
                    case"dragleave":
                        Lt = null;
                        break;
                    case"mouseover":
                    case"mouseout":
                        _t = null;
                        break;
                    case"pointerover":
                    case"pointerout":
                        Pt.delete(t.pointerId);
                        break;
                    case"gotpointercapture":
                    case"lostpointercapture":
                        Nt.delete(t.pointerId)
                }
            }

            function Dt(e, t, n, r, i, s) {
                return null === e || e.nativeEvent !== s ? (e = {
                    blockedOn: t,
                    domEventName: n,
                    eventSystemFlags: r,
                    nativeEvent: s,
                    targetContainers: [i]
                }, null !== t && null !== (t = bi(t)) && Et(t), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e)
            }

            function Ot(e) {
                var t = vi(e.target);
                if (null !== t) {
                    var n = $e(t);
                    if (null !== n) if (13 === (t = n.tag)) {
                        if (null !== (t = Ke(n))) return e.blockedOn = t, void At(e.priority, (function () {
                            St(n)
                        }))
                    } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
                }
                e.blockedOn = null
            }

            function Bt(e) {
                if (null !== e.blockedOn) return !1;
                for (var t = e.targetContainers; 0 < t.length;) {
                    var n = Yt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
                    if (null !== n) return null !== (t = bi(n)) && Et(t), e.blockedOn = n, !1;
                    var r = new (n = e.nativeEvent).constructor(n.type, n);
                    we = r, n.target.dispatchEvent(r), we = null, t.shift()
                }
                return !0
            }

            function Ft(e, t, n) {
                Bt(e) && n.delete(t)
            }

            function Ut() {
                Tt = !1, null !== Rt && Bt(Rt) && (Rt = null), null !== Lt && Bt(Lt) && (Lt = null), null !== _t && Bt(_t) && (_t = null), Pt.forEach(Ft), Nt.forEach(Ft)
            }

            function Ht(e, t) {
                e.blockedOn === t && (e.blockedOn = null, Tt || (Tt = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, Ut)))
            }

            function $t(e) {
                function t(t) {
                    return Ht(t, e)
                }

                if (0 < Ct.length) {
                    Ht(Ct[0], e);
                    for (var n = 1; n < Ct.length; n++) {
                        var r = Ct[n];
                        r.blockedOn === e && (r.blockedOn = null)
                    }
                }
                for (null !== Rt && Ht(Rt, e), null !== Lt && Ht(Lt, e), null !== _t && Ht(_t, e), Pt.forEach(t), Nt.forEach(t), n = 0; n < jt.length; n++) (r = jt[n]).blockedOn === e && (r.blockedOn = null);
                for (; 0 < jt.length && null === (n = jt[0]).blockedOn;) Ot(n), null === n.blockedOn && jt.shift()
            }

            var Kt = w.ReactCurrentBatchConfig, zt = !0;

            function Gt(e, t, n, r) {
                var i = bt, s = Kt.transition;
                Kt.transition = null;
                try {
                    bt = 1, Wt(e, t, n, r)
                } finally {
                    bt = i, Kt.transition = s
                }
            }

            function qt(e, t, n, r) {
                var i = bt, s = Kt.transition;
                Kt.transition = null;
                try {
                    bt = 4, Wt(e, t, n, r)
                } finally {
                    bt = i, Kt.transition = s
                }
            }

            function Wt(e, t, n, r) {
                if (zt) {
                    var i = Yt(e, t, n, r);
                    if (null === i) zr(e, t, r, Vt, n), Mt(e, r); else if (function (e, t, n, r, i) {
                        switch (t) {
                            case"focusin":
                                return Rt = Dt(Rt, e, t, n, r, i), !0;
                            case"dragenter":
                                return Lt = Dt(Lt, e, t, n, r, i), !0;
                            case"mouseover":
                                return _t = Dt(_t, e, t, n, r, i), !0;
                            case"pointerover":
                                var s = i.pointerId;
                                return Pt.set(s, Dt(Pt.get(s) || null, e, t, n, r, i)), !0;
                            case"gotpointercapture":
                                return s = i.pointerId, Nt.set(s, Dt(Nt.get(s) || null, e, t, n, r, i)), !0
                        }
                        return !1
                    }(i, e, t, n, r)) r.stopPropagation(); else if (Mt(e, r), 4 & t && -1 < It.indexOf(e)) {
                        for (; null !== i;) {
                            var s = bi(i);
                            if (null !== s && xt(s), null === (s = Yt(e, t, n, r)) && zr(e, t, r, Vt, n), s === i) break;
                            i = s
                        }
                        null !== i && r.stopPropagation()
                    } else zr(e, t, r, null, n)
                }
            }

            var Vt = null;

            function Yt(e, t, n, r) {
                if (Vt = null, null !== (e = vi(e = xe(r)))) if (null === (t = $e(e))) e = null; else if (13 === (n = t.tag)) {
                    if (null !== (e = Ke(t))) return e;
                    e = null
                } else if (3 === n) {
                    if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null;
                    e = null
                } else t !== e && (e = null);
                return Vt = e, null
            }

            function Zt(e) {
                switch (e) {
                    case"cancel":
                    case"click":
                    case"close":
                    case"contextmenu":
                    case"copy":
                    case"cut":
                    case"auxclick":
                    case"dblclick":
                    case"dragend":
                    case"dragstart":
                    case"drop":
                    case"focusin":
                    case"focusout":
                    case"input":
                    case"invalid":
                    case"keydown":
                    case"keypress":
                    case"keyup":
                    case"mousedown":
                    case"mouseup":
                    case"paste":
                    case"pause":
                    case"play":
                    case"pointercancel":
                    case"pointerdown":
                    case"pointerup":
                    case"ratechange":
                    case"reset":
                    case"resize":
                    case"seeked":
                    case"submit":
                    case"touchcancel":
                    case"touchend":
                    case"touchstart":
                    case"volumechange":
                    case"change":
                    case"selectionchange":
                    case"textInput":
                    case"compositionstart":
                    case"compositionend":
                    case"compositionupdate":
                    case"beforeblur":
                    case"afterblur":
                    case"beforeinput":
                    case"blur":
                    case"fullscreenchange":
                    case"focus":
                    case"hashchange":
                    case"popstate":
                    case"select":
                    case"selectstart":
                        return 1;
                    case"drag":
                    case"dragenter":
                    case"dragexit":
                    case"dragleave":
                    case"dragover":
                    case"mousemove":
                    case"mouseout":
                    case"mouseover":
                    case"pointermove":
                    case"pointerout":
                    case"pointerover":
                    case"scroll":
                    case"toggle":
                    case"touchmove":
                    case"wheel":
                    case"mouseenter":
                    case"mouseleave":
                    case"pointerenter":
                    case"pointerleave":
                        return 4;
                    case"message":
                        switch (Qe()) {
                            case Je:
                                return 1;
                            case et:
                                return 4;
                            case tt:
                            case nt:
                                return 16;
                            case rt:
                                return 536870912;
                            default:
                                return 16
                        }
                    default:
                        return 16
                }
            }

            var Xt = null, Qt = null, Jt = null;

            function en() {
                if (Jt) return Jt;
                var e, t, n = Qt, r = n.length, i = "value" in Xt ? Xt.value : Xt.textContent, s = i.length;
                for (e = 0; e < r && n[e] === i[e]; e++) ;
                var a = r - e;
                for (t = 1; t <= a && n[r - t] === i[s - t]; t++) ;
                return Jt = i.slice(e, 1 < t ? 1 - t : void 0)
            }

            function tn(e) {
                var t = e.keyCode;
                return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0
            }

            function nn() {
                return !0
            }

            function rn() {
                return !1
            }

            function sn(e) {
                function t(t, n, r, i, s) {
                    for (var a in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = s, this.currentTarget = null, e) e.hasOwnProperty(a) && (t = e[a], this[a] = t ? t(i) : i[a]);
                    return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this
                }

                return O(t.prototype, {
                    preventDefault: function () {
                        this.defaultPrevented = !0;
                        var e = this.nativeEvent;
                        e && (e.preventDefault ? e.preventDefault() : "unknown" != typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn)
                    }, stopPropagation: function () {
                        var e = this.nativeEvent;
                        e && (e.stopPropagation ? e.stopPropagation() : "unknown" != typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn)
                    }, persist: function () {
                    }, isPersistent: nn
                }), t
            }

            var an, on, ln, cn = {
                    eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) {
                        return e.timeStamp || Date.now()
                    }, defaultPrevented: 0, isTrusted: 0
                }, un = sn(cn), dn = O({}, cn, {view: 0, detail: 0}), hn = sn(dn), fn = O({}, dn, {
                    screenX: 0,
                    screenY: 0,
                    clientX: 0,
                    clientY: 0,
                    pageX: 0,
                    pageY: 0,
                    ctrlKey: 0,
                    shiftKey: 0,
                    altKey: 0,
                    metaKey: 0,
                    getModifierState: An,
                    button: 0,
                    buttons: 0,
                    relatedTarget: function (e) {
                        return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
                    },
                    movementX: function (e) {
                        return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (an = e.screenX - ln.screenX, on = e.screenY - ln.screenY) : on = an = 0, ln = e), an)
                    },
                    movementY: function (e) {
                        return "movementY" in e ? e.movementY : on
                    }
                }), pn = sn(fn), mn = sn(O({}, fn, {dataTransfer: 0})), gn = sn(O({}, dn, {relatedTarget: 0})),
                yn = sn(O({}, cn, {animationName: 0, elapsedTime: 0, pseudoElement: 0})), vn = O({}, cn, {
                    clipboardData: function (e) {
                        return "clipboardData" in e ? e.clipboardData : window.clipboardData
                    }
                }), bn = sn(vn), wn = sn(O({}, cn, {data: 0})), xn = {
                    Esc: "Escape",
                    Spacebar: " ",
                    Left: "ArrowLeft",
                    Up: "ArrowUp",
                    Right: "ArrowRight",
                    Down: "ArrowDown",
                    Del: "Delete",
                    Win: "OS",
                    Menu: "ContextMenu",
                    Apps: "ContextMenu",
                    Scroll: "ScrollLock",
                    MozPrintableKey: "Unidentified"
                }, En = {
                    8: "Backspace",
                    9: "Tab",
                    12: "Clear",
                    13: "Enter",
                    16: "Shift",
                    17: "Control",
                    18: "Alt",
                    19: "Pause",
                    20: "CapsLock",
                    27: "Escape",
                    32: " ",
                    33: "PageUp",
                    34: "PageDown",
                    35: "End",
                    36: "Home",
                    37: "ArrowLeft",
                    38: "ArrowUp",
                    39: "ArrowRight",
                    40: "ArrowDown",
                    45: "Insert",
                    46: "Delete",
                    112: "F1",
                    113: "F2",
                    114: "F3",
                    115: "F4",
                    116: "F5",
                    117: "F6",
                    118: "F7",
                    119: "F8",
                    120: "F9",
                    121: "F10",
                    122: "F11",
                    123: "F12",
                    144: "NumLock",
                    145: "ScrollLock",
                    224: "Meta"
                }, Sn = {Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey"};

            function kn(e) {
                var t = this.nativeEvent;
                return t.getModifierState ? t.getModifierState(e) : !!(e = Sn[e]) && !!t[e]
            }

            function An() {
                return kn
            }

            var Tn = O({}, dn, {
                key: function (e) {
                    if (e.key) {
                        var t = xn[e.key] || e.key;
                        if ("Unidentified" !== t) return t
                    }
                    return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? En[e.keyCode] || "Unidentified" : ""
                },
                code: 0,
                location: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                repeat: 0,
                locale: 0,
                getModifierState: An,
                charCode: function (e) {
                    return "keypress" === e.type ? tn(e) : 0
                },
                keyCode: function (e) {
                    return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                },
                which: function (e) {
                    return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                }
            }), Cn = sn(Tn), Rn = sn(O({}, fn, {
                pointerId: 0,
                width: 0,
                height: 0,
                pressure: 0,
                tangentialPressure: 0,
                tiltX: 0,
                tiltY: 0,
                twist: 0,
                pointerType: 0,
                isPrimary: 0
            })), Ln = sn(O({}, dn, {
                touches: 0,
                targetTouches: 0,
                changedTouches: 0,
                altKey: 0,
                metaKey: 0,
                ctrlKey: 0,
                shiftKey: 0,
                getModifierState: An
            })), _n = sn(O({}, cn, {propertyName: 0, elapsedTime: 0, pseudoElement: 0})), Pn = O({}, fn, {
                deltaX: function (e) {
                    return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
                }, deltaY: function (e) {
                    return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
                }, deltaZ: 0, deltaMode: 0
            }), Nn = sn(Pn), jn = [9, 13, 27, 32], In = u && "CompositionEvent" in window, Mn = null;
            u && "documentMode" in document && (Mn = document.documentMode);
            var Dn = u && "TextEvent" in window && !Mn, On = u && (!In || Mn && 8 < Mn && 11 >= Mn),
                Bn = String.fromCharCode(32), Fn = !1;

            function Un(e, t) {
                switch (e) {
                    case"keyup":
                        return -1 !== jn.indexOf(t.keyCode);
                    case"keydown":
                        return 229 !== t.keyCode;
                    case"keypress":
                    case"mousedown":
                    case"focusout":
                        return !0;
                    default:
                        return !1
                }
            }

            function Hn(e) {
                return "object" == typeof (e = e.detail) && "data" in e ? e.data : null
            }

            var $n = !1, Kn = {
                color: !0,
                date: !0,
                datetime: !0,
                "datetime-local": !0,
                email: !0,
                month: !0,
                number: !0,
                password: !0,
                range: !0,
                search: !0,
                tel: !0,
                text: !0,
                time: !0,
                url: !0,
                week: !0
            };

            function zn(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return "input" === t ? !!Kn[e.type] : "textarea" === t
            }

            function Gn(e, t, n, r) {
                Te(r), 0 < (t = qr(t, "onChange")).length && (n = new un("onChange", "change", null, n, r), e.push({
                    event: n,
                    listeners: t
                }))
            }

            var qn = null, Wn = null;

            function Vn(e) {
                Br(e, 0)
            }

            function Yn(e) {
                if (W(wi(e))) return e
            }

            function Zn(e, t) {
                if ("change" === e) return t
            }

            var Xn = !1;
            if (u) {
                var Qn;
                if (u) {
                    var Jn = "oninput" in document;
                    if (!Jn) {
                        var er = document.createElement("div");
                        er.setAttribute("oninput", "return;"), Jn = "function" == typeof er.oninput
                    }
                    Qn = Jn
                } else Qn = !1;
                Xn = Qn && (!document.documentMode || 9 < document.documentMode)
            }

            function tr() {
                qn && (qn.detachEvent("onpropertychange", nr), Wn = qn = null)
            }

            function nr(e) {
                if ("value" === e.propertyName && Yn(Wn)) {
                    var t = [];
                    Gn(t, Wn, e, xe(e)), Pe(Vn, t)
                }
            }

            function rr(e, t, n) {
                "focusin" === e ? (tr(), Wn = n, (qn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr()
            }

            function ir(e) {
                if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Yn(Wn)
            }

            function sr(e, t) {
                if ("click" === e) return Yn(t)
            }

            function ar(e, t) {
                if ("input" === e || "change" === e) return Yn(t)
            }

            var or = "function" == typeof Object.is ? Object.is : function (e, t) {
                return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t
            };

            function lr(e, t) {
                if (or(e, t)) return !0;
                if ("object" != typeof e || null === e || "object" != typeof t || null === t) return !1;
                var n = Object.keys(e), r = Object.keys(t);
                if (n.length !== r.length) return !1;
                for (r = 0; r < n.length; r++) {
                    var i = n[r];
                    if (!d.call(t, i) || !or(e[i], t[i])) return !1
                }
                return !0
            }

            function cr(e) {
                for (; e && e.firstChild;) e = e.firstChild;
                return e
            }

            function ur(e, t) {
                var n, r = cr(e);
                for (e = 0; r;) {
                    if (3 === r.nodeType) {
                        if (n = e + r.textContent.length, e <= t && n >= t) return {node: r, offset: t - e};
                        e = n
                    }
                    e:{
                        for (; r;) {
                            if (r.nextSibling) {
                                r = r.nextSibling;
                                break e
                            }
                            r = r.parentNode
                        }
                        r = void 0
                    }
                    r = cr(r)
                }
            }

            function dr(e, t) {
                return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
            }

            function hr() {
                for (var e = window, t = V(); t instanceof e.HTMLIFrameElement;) {
                    try {
                        var n = "string" == typeof t.contentWindow.location.href
                    } catch (e) {
                        n = !1
                    }
                    if (!n) break;
                    t = V((e = t.contentWindow).document)
                }
                return t
            }

            function fr(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
            }

            function pr(e) {
                var t = hr(), n = e.focusedElem, r = e.selectionRange;
                if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) {
                    if (null !== r && fr(n)) if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) {
                        e = e.getSelection();
                        var i = n.textContent.length, s = Math.min(r.start, i);
                        r = void 0 === r.end ? s : Math.min(r.end, i), !e.extend && s > r && (i = r, r = s, s = i), i = ur(n, s);
                        var a = ur(n, r);
                        i && a && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), s > r ? (e.addRange(t), e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset), e.addRange(t)))
                    }
                    for (t = [], e = n; e = e.parentNode;) 1 === e.nodeType && t.push({
                        element: e,
                        left: e.scrollLeft,
                        top: e.scrollTop
                    });
                    for ("function" == typeof n.focus && n.focus(), n = 0; n < t.length; n++) (e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top
                }
            }

            var mr = u && "documentMode" in document && 11 >= document.documentMode, gr = null, yr = null, vr = null,
                br = !1;

            function wr(e, t, n) {
                var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
                br || null == gr || gr !== V(r) || (r = "selectionStart" in (r = gr) && fr(r) ? {
                    start: r.selectionStart,
                    end: r.selectionEnd
                } : {
                    anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
                    anchorOffset: r.anchorOffset,
                    focusNode: r.focusNode,
                    focusOffset: r.focusOffset
                }, vr && lr(vr, r) || (vr = r, 0 < (r = qr(yr, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({
                    event: t,
                    listeners: r
                }), t.target = gr)))
            }

            function xr(e, t) {
                var n = {};
                return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
            }

            var Er = {
                animationend: xr("Animation", "AnimationEnd"),
                animationiteration: xr("Animation", "AnimationIteration"),
                animationstart: xr("Animation", "AnimationStart"),
                transitionend: xr("Transition", "TransitionEnd")
            }, Sr = {}, kr = {};

            function Ar(e) {
                if (Sr[e]) return Sr[e];
                if (!Er[e]) return e;
                var t, n = Er[e];
                for (t in n) if (n.hasOwnProperty(t) && t in kr) return Sr[e] = n[t];
                return e
            }

            u && (kr = document.createElement("div").style, "AnimationEvent" in window || (delete Er.animationend.animation, delete Er.animationiteration.animation, delete Er.animationstart.animation), "TransitionEvent" in window || delete Er.transitionend.transition);
            var Tr = Ar("animationend"), Cr = Ar("animationiteration"), Rr = Ar("animationstart"),
                Lr = Ar("transitionend"), _r = new Map,
                Pr = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

            function Nr(e, t) {
                _r.set(e, t), l(t, [e])
            }

            for (var jr = 0; jr < Pr.length; jr++) {
                var Ir = Pr[jr];
                Nr(Ir.toLowerCase(), "on" + (Ir[0].toUpperCase() + Ir.slice(1)))
            }
            Nr(Tr, "onAnimationEnd"), Nr(Cr, "onAnimationIteration"), Nr(Rr, "onAnimationStart"), Nr("dblclick", "onDoubleClick"), Nr("focusin", "onFocus"), Nr("focusout", "onBlur"), Nr(Lr, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
            var Mr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
                Dr = new Set("cancel close invalid load scroll toggle".split(" ").concat(Mr));

            function Or(e, t, n) {
                var r = e.type || "unknown-event";
                e.currentTarget = n, function (e, t, n, r, i, a, o, l, c) {
                    if (He.apply(this, arguments), De) {
                        if (!De) throw Error(s(198));
                        var u = Oe;
                        De = !1, Oe = null, Be || (Be = !0, Fe = u)
                    }
                }(r, t, void 0, e), e.currentTarget = null
            }

            function Br(e, t) {
                t = 0 != (4 & t);
                for (var n = 0; n < e.length; n++) {
                    var r = e[n], i = r.event;
                    r = r.listeners;
                    e:{
                        var s = void 0;
                        if (t) for (var a = r.length - 1; 0 <= a; a--) {
                            var o = r[a], l = o.instance, c = o.currentTarget;
                            if (o = o.listener, l !== s && i.isPropagationStopped()) break e;
                            Or(i, o, c), s = l
                        } else for (a = 0; a < r.length; a++) {
                            if (l = (o = r[a]).instance, c = o.currentTarget, o = o.listener, l !== s && i.isPropagationStopped()) break e;
                            Or(i, o, c), s = l
                        }
                    }
                }
                if (Be) throw e = Fe, Be = !1, Fe = null, e
            }

            function Fr(e, t) {
                var n = t[mi];
                void 0 === n && (n = t[mi] = new Set);
                var r = e + "__bubble";
                n.has(r) || (Kr(t, e, 2, !1), n.add(r))
            }

            function Ur(e, t, n) {
                var r = 0;
                t && (r |= 4), Kr(n, e, r, t)
            }

            var Hr = "_reactListening" + Math.random().toString(36).slice(2);

            function $r(e) {
                if (!e[Hr]) {
                    e[Hr] = !0, a.forEach((function (t) {
                        "selectionchange" !== t && (Dr.has(t) || Ur(t, !1, e), Ur(t, !0, e))
                    }));
                    var t = 9 === e.nodeType ? e : e.ownerDocument;
                    null === t || t[Hr] || (t[Hr] = !0, Ur("selectionchange", !1, t))
                }
            }

            function Kr(e, t, n, r) {
                switch (Zt(t)) {
                    case 1:
                        var i = Gt;
                        break;
                    case 4:
                        i = qt;
                        break;
                    default:
                        i = Wt
                }
                n = i.bind(null, t, n, e), i = void 0, !je || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, {
                    capture: !0,
                    passive: i
                }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, {passive: i}) : e.addEventListener(t, n, !1)
            }

            function zr(e, t, n, r, i) {
                var s = r;
                if (0 == (1 & t) && 0 == (2 & t) && null !== r) e:for (; ;) {
                    if (null === r) return;
                    var a = r.tag;
                    if (3 === a || 4 === a) {
                        var o = r.stateNode.containerInfo;
                        if (o === i || 8 === o.nodeType && o.parentNode === i) break;
                        if (4 === a) for (a = r.return; null !== a;) {
                            var l = a.tag;
                            if ((3 === l || 4 === l) && ((l = a.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return;
                            a = a.return
                        }
                        for (; null !== o;) {
                            if (null === (a = vi(o))) return;
                            if (5 === (l = a.tag) || 6 === l) {
                                r = s = a;
                                continue e
                            }
                            o = o.parentNode
                        }
                    }
                    r = r.return
                }
                Pe((function () {
                    var r = s, i = xe(n), a = [];
                    e:{
                        var o = _r.get(e);
                        if (void 0 !== o) {
                            var l = un, c = e;
                            switch (e) {
                                case"keypress":
                                    if (0 === tn(n)) break e;
                                case"keydown":
                                case"keyup":
                                    l = Cn;
                                    break;
                                case"focusin":
                                    c = "focus", l = gn;
                                    break;
                                case"focusout":
                                    c = "blur", l = gn;
                                    break;
                                case"beforeblur":
                                case"afterblur":
                                    l = gn;
                                    break;
                                case"click":
                                    if (2 === n.button) break e;
                                case"auxclick":
                                case"dblclick":
                                case"mousedown":
                                case"mousemove":
                                case"mouseup":
                                case"mouseout":
                                case"mouseover":
                                case"contextmenu":
                                    l = pn;
                                    break;
                                case"drag":
                                case"dragend":
                                case"dragenter":
                                case"dragexit":
                                case"dragleave":
                                case"dragover":
                                case"dragstart":
                                case"drop":
                                    l = mn;
                                    break;
                                case"touchcancel":
                                case"touchend":
                                case"touchmove":
                                case"touchstart":
                                    l = Ln;
                                    break;
                                case Tr:
                                case Cr:
                                case Rr:
                                    l = yn;
                                    break;
                                case Lr:
                                    l = _n;
                                    break;
                                case"scroll":
                                    l = hn;
                                    break;
                                case"wheel":
                                    l = Nn;
                                    break;
                                case"copy":
                                case"cut":
                                case"paste":
                                    l = bn;
                                    break;
                                case"gotpointercapture":
                                case"lostpointercapture":
                                case"pointercancel":
                                case"pointerdown":
                                case"pointermove":
                                case"pointerout":
                                case"pointerover":
                                case"pointerup":
                                    l = Rn
                            }
                            var u = 0 != (4 & t), d = !u && "scroll" === e,
                                h = u ? null !== o ? o + "Capture" : null : o;
                            u = [];
                            for (var f, p = r; null !== p;) {
                                var m = (f = p).stateNode;
                                if (5 === f.tag && null !== m && (f = m, null !== h && null != (m = Ne(p, h)) && u.push(Gr(p, m, f))), d) break;
                                p = p.return
                            }
                            0 < u.length && (o = new l(o, c, null, n, i), a.push({event: o, listeners: u}))
                        }
                    }
                    if (0 == (7 & t)) {
                        if (l = "mouseout" === e || "pointerout" === e, (!(o = "mouseover" === e || "pointerover" === e) || n === we || !(c = n.relatedTarget || n.fromElement) || !vi(c) && !c[pi]) && (l || o) && (o = i.window === i ? i : (o = i.ownerDocument) ? o.defaultView || o.parentWindow : window, l ? (l = r, null !== (c = (c = n.relatedTarget || n.toElement) ? vi(c) : null) && (c !== (d = $e(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null, c = r), l !== c)) {
                            if (u = pn, m = "onMouseLeave", h = "onMouseEnter", p = "mouse", "pointerout" !== e && "pointerover" !== e || (u = Rn, m = "onPointerLeave", h = "onPointerEnter", p = "pointer"), d = null == l ? o : wi(l), f = null == c ? o : wi(c), (o = new u(m, p + "leave", l, n, i)).target = d, o.relatedTarget = f, m = null, vi(i) === r && ((u = new u(h, p + "enter", c, n, i)).target = f, u.relatedTarget = d, m = u), d = m, l && c) e:{
                                for (h = c, p = 0, f = u = l; f; f = Wr(f)) p++;
                                for (f = 0, m = h; m; m = Wr(m)) f++;
                                for (; 0 < p - f;) u = Wr(u), p--;
                                for (; 0 < f - p;) h = Wr(h), f--;
                                for (; p--;) {
                                    if (u === h || null !== h && u === h.alternate) break e;
                                    u = Wr(u), h = Wr(h)
                                }
                                u = null
                            } else u = null;
                            null !== l && Vr(a, o, l, u, !1), null !== c && null !== d && Vr(a, d, c, u, !0)
                        }
                        if ("select" === (l = (o = r ? wi(r) : window).nodeName && o.nodeName.toLowerCase()) || "input" === l && "file" === o.type) var g = Zn; else if (zn(o)) if (Xn) g = ar; else {
                            g = ir;
                            var y = rr
                        } else (l = o.nodeName) && "input" === l.toLowerCase() && ("checkbox" === o.type || "radio" === o.type) && (g = sr);
                        switch (g && (g = g(e, r)) ? Gn(a, g, n, i) : (y && y(e, o, r), "focusout" === e && (y = o._wrapperState) && y.controlled && "number" === o.type && ee(o, "number", o.value)), y = r ? wi(r) : window, e) {
                            case"focusin":
                                (zn(y) || "true" === y.contentEditable) && (gr = y, yr = r, vr = null);
                                break;
                            case"focusout":
                                vr = yr = gr = null;
                                break;
                            case"mousedown":
                                br = !0;
                                break;
                            case"contextmenu":
                            case"mouseup":
                            case"dragend":
                                br = !1, wr(a, n, i);
                                break;
                            case"selectionchange":
                                if (mr) break;
                            case"keydown":
                            case"keyup":
                                wr(a, n, i)
                        }
                        var v;
                        if (In) e:{
                            switch (e) {
                                case"compositionstart":
                                    var b = "onCompositionStart";
                                    break e;
                                case"compositionend":
                                    b = "onCompositionEnd";
                                    break e;
                                case"compositionupdate":
                                    b = "onCompositionUpdate";
                                    break e
                            }
                            b = void 0
                        } else $n ? Un(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart");
                        b && (On && "ko" !== n.locale && ($n || "onCompositionStart" !== b ? "onCompositionEnd" === b && $n && (v = en()) : (Qt = "value" in (Xt = i) ? Xt.value : Xt.textContent, $n = !0)), 0 < (y = qr(r, b)).length && (b = new wn(b, e, null, n, i), a.push({
                            event: b,
                            listeners: y
                        }), (v || null !== (v = Hn(n))) && (b.data = v))), (v = Dn ? function (e, t) {
                            switch (e) {
                                case"compositionend":
                                    return Hn(t);
                                case"keypress":
                                    return 32 !== t.which ? null : (Fn = !0, Bn);
                                case"textInput":
                                    return (e = t.data) === Bn && Fn ? null : e;
                                default:
                                    return null
                            }
                        }(e, n) : function (e, t) {
                            if ($n) return "compositionend" === e || !In && Un(e, t) ? (e = en(), Jt = Qt = Xt = null, $n = !1, e) : null;
                            switch (e) {
                                case"paste":
                                default:
                                    return null;
                                case"keypress":
                                    if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                                        if (t.char && 1 < t.char.length) return t.char;
                                        if (t.which) return String.fromCharCode(t.which)
                                    }
                                    return null;
                                case"compositionend":
                                    return On && "ko" !== t.locale ? null : t.data
                            }
                        }(e, n)) && 0 < (r = qr(r, "onBeforeInput")).length && (i = new wn("onBeforeInput", "beforeinput", null, n, i), a.push({
                            event: i,
                            listeners: r
                        }), i.data = v)
                    }
                    Br(a, t)
                }))
            }

            function Gr(e, t, n) {
                return {instance: e, listener: t, currentTarget: n}
            }

            function qr(e, t) {
                for (var n = t + "Capture", r = []; null !== e;) {
                    var i = e, s = i.stateNode;
                    5 === i.tag && null !== s && (i = s, null != (s = Ne(e, n)) && r.unshift(Gr(e, s, i)), null != (s = Ne(e, t)) && r.push(Gr(e, s, i))), e = e.return
                }
                return r
            }

            function Wr(e) {
                if (null === e) return null;
                do {
                    e = e.return
                } while (e && 5 !== e.tag);
                return e || null
            }

            function Vr(e, t, n, r, i) {
                for (var s = t._reactName, a = []; null !== n && n !== r;) {
                    var o = n, l = o.alternate, c = o.stateNode;
                    if (null !== l && l === r) break;
                    5 === o.tag && null !== c && (o = c, i ? null != (l = Ne(n, s)) && a.unshift(Gr(n, l, o)) : i || null != (l = Ne(n, s)) && a.push(Gr(n, l, o))), n = n.return
                }
                0 !== a.length && e.push({event: t, listeners: a})
            }

            var Yr = /\r\n?/g, Zr = /\u0000|\uFFFD/g;

            function Xr(e) {
                return ("string" == typeof e ? e : "" + e).replace(Yr, "\n").replace(Zr, "")
            }

            function Qr(e, t, n) {
                if (t = Xr(t), Xr(e) !== t && n) throw Error(s(425))
            }

            function Jr() {
            }

            var ei = null, ti = null;

            function ni(e, t) {
                return "textarea" === e || "noscript" === e || "string" == typeof t.children || "number" == typeof t.children || "object" == typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
            }

            var ri = "function" == typeof setTimeout ? setTimeout : void 0,
                ii = "function" == typeof clearTimeout ? clearTimeout : void 0,
                si = "function" == typeof Promise ? Promise : void 0,
                ai = "function" == typeof queueMicrotask ? queueMicrotask : void 0 !== si ? function (e) {
                    return si.resolve(null).then(e).catch(oi)
                } : ri;

            function oi(e) {
                setTimeout((function () {
                    throw e
                }))
            }

            function li(e, t) {
                var n = t, r = 0;
                do {
                    var i = n.nextSibling;
                    if (e.removeChild(n), i && 8 === i.nodeType) if ("/$" === (n = i.data)) {
                        if (0 === r) return e.removeChild(i), void $t(t);
                        r--
                    } else "$" !== n && "$?" !== n && "$!" !== n || r++;
                    n = i
                } while (n);
                $t(t)
            }

            function ci(e) {
                for (; null != e; e = e.nextSibling) {
                    var t = e.nodeType;
                    if (1 === t || 3 === t) break;
                    if (8 === t) {
                        if ("$" === (t = e.data) || "$!" === t || "$?" === t) break;
                        if ("/$" === t) return null
                    }
                }
                return e
            }

            function ui(e) {
                e = e.previousSibling;
                for (var t = 0; e;) {
                    if (8 === e.nodeType) {
                        var n = e.data;
                        if ("$" === n || "$!" === n || "$?" === n) {
                            if (0 === t) return e;
                            t--
                        } else "/$" === n && t++
                    }
                    e = e.previousSibling
                }
                return null
            }

            var di = Math.random().toString(36).slice(2), hi = "__reactFiber$" + di, fi = "__reactProps$" + di,
                pi = "__reactContainer$" + di, mi = "__reactEvents$" + di, gi = "__reactListeners$" + di,
                yi = "__reactHandles$" + di;

            function vi(e) {
                var t = e[hi];
                if (t) return t;
                for (var n = e.parentNode; n;) {
                    if (t = n[pi] || n[hi]) {
                        if (n = t.alternate, null !== t.child || null !== n && null !== n.child) for (e = ui(e); null !== e;) {
                            if (n = e[hi]) return n;
                            e = ui(e)
                        }
                        return t
                    }
                    n = (e = n).parentNode
                }
                return null
            }

            function bi(e) {
                return !(e = e[hi] || e[pi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e
            }

            function wi(e) {
                if (5 === e.tag || 6 === e.tag) return e.stateNode;
                throw Error(s(33))
            }

            function xi(e) {
                return e[fi] || null
            }

            var Ei = [], Si = -1;

            function ki(e) {
                return {current: e}
            }

            function Ai(e) {
                0 > Si || (e.current = Ei[Si], Ei[Si] = null, Si--)
            }

            function Ti(e, t) {
                Si++, Ei[Si] = e.current, e.current = t
            }

            var Ci = {}, Ri = ki(Ci), Li = ki(!1), _i = Ci;

            function Pi(e, t) {
                var n = e.type.contextTypes;
                if (!n) return Ci;
                var r = e.stateNode;
                if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
                var i, s = {};
                for (i in n) s[i] = t[i];
                return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s
            }

            function Ni(e) {
                return null != e.childContextTypes
            }

            function ji() {
                Ai(Li), Ai(Ri)
            }

            function Ii(e, t, n) {
                if (Ri.current !== Ci) throw Error(s(168));
                Ti(Ri, t), Ti(Li, n)
            }

            function Mi(e, t, n) {
                var r = e.stateNode;
                if (t = t.childContextTypes, "function" != typeof r.getChildContext) return n;
                for (var i in r = r.getChildContext()) if (!(i in t)) throw Error(s(108, K(e) || "Unknown", i));
                return O({}, n, r)
            }

            function Di(e) {
                return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Ci, _i = Ri.current, Ti(Ri, e), Ti(Li, Li.current), !0
            }

            function Oi(e, t, n) {
                var r = e.stateNode;
                if (!r) throw Error(s(169));
                n ? (e = Mi(e, t, _i), r.__reactInternalMemoizedMergedChildContext = e, Ai(Li), Ai(Ri), Ti(Ri, e)) : Ai(Li), Ti(Li, n)
            }

            var Bi = null, Fi = !1, Ui = !1;

            function Hi(e) {
                null === Bi ? Bi = [e] : Bi.push(e)
            }

            function $i() {
                if (!Ui && null !== Bi) {
                    Ui = !0;
                    var e = 0, t = bt;
                    try {
                        var n = Bi;
                        for (bt = 1; e < n.length; e++) {
                            var r = n[e];
                            do {
                                r = r(!0)
                            } while (null !== r)
                        }
                        Bi = null, Fi = !1
                    } catch (t) {
                        throw null !== Bi && (Bi = Bi.slice(e + 1)), We(Je, $i), t
                    } finally {
                        bt = t, Ui = !1
                    }
                }
                return null
            }

            var Ki = [], zi = 0, Gi = null, qi = 0, Wi = [], Vi = 0, Yi = null, Zi = 1, Xi = "";

            function Qi(e, t) {
                Ki[zi++] = qi, Ki[zi++] = Gi, Gi = e, qi = t
            }

            function Ji(e, t, n) {
                Wi[Vi++] = Zi, Wi[Vi++] = Xi, Wi[Vi++] = Yi, Yi = e;
                var r = Zi;
                e = Xi;
                var i = 32 - at(r) - 1;
                r &= ~(1 << i), n += 1;
                var s = 32 - at(t) + i;
                if (30 < s) {
                    var a = i - i % 5;
                    s = (r & (1 << a) - 1).toString(32), r >>= a, i -= a, Zi = 1 << 32 - at(t) + i | n << i | r, Xi = s + e
                } else Zi = 1 << s | n << i | r, Xi = e
            }

            function es(e) {
                null !== e.return && (Qi(e, 1), Ji(e, 1, 0))
            }

            function ts(e) {
                for (; e === Gi;) Gi = Ki[--zi], Ki[zi] = null, qi = Ki[--zi], Ki[zi] = null;
                for (; e === Yi;) Yi = Wi[--Vi], Wi[Vi] = null, Xi = Wi[--Vi], Wi[Vi] = null, Zi = Wi[--Vi], Wi[Vi] = null
            }

            var ns = null, rs = null, is = !1, ss = null;

            function as(e, t) {
                var n = Nc(5, null, null, 0);
                n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n)
            }

            function os(e, t) {
                switch (e.tag) {
                    case 5:
                        var n = e.type;
                        return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, ns = e, rs = ci(t.firstChild), !0);
                    case 6:
                        return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, ns = e, rs = null, !0);
                    case 13:
                        return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Yi ? {
                            id: Zi,
                            overflow: Xi
                        } : null, e.memoizedState = {
                            dehydrated: t,
                            treeContext: n,
                            retryLane: 1073741824
                        }, (n = Nc(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, ns = e, rs = null, !0);
                    default:
                        return !1
                }
            }

            function ls(e) {
                return 0 != (1 & e.mode) && 0 == (128 & e.flags)
            }

            function cs(e) {
                if (is) {
                    var t = rs;
                    if (t) {
                        var n = t;
                        if (!os(e, t)) {
                            if (ls(e)) throw Error(s(418));
                            t = ci(n.nextSibling);
                            var r = ns;
                            t && os(e, t) ? as(r, n) : (e.flags = -4097 & e.flags | 2, is = !1, ns = e)
                        }
                    } else {
                        if (ls(e)) throw Error(s(418));
                        e.flags = -4097 & e.flags | 2, is = !1, ns = e
                    }
                }
            }

            function us(e) {
                for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;) e = e.return;
                ns = e
            }

            function ds(e) {
                if (e !== ns) return !1;
                if (!is) return us(e), is = !0, !1;
                var t;
                if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = rs)) {
                    if (ls(e)) throw hs(), Error(s(418));
                    for (; t;) as(e, t), t = ci(t.nextSibling)
                }
                if (us(e), 13 === e.tag) {
                    if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(s(317));
                    e:{
                        for (e = e.nextSibling, t = 0; e;) {
                            if (8 === e.nodeType) {
                                var n = e.data;
                                if ("/$" === n) {
                                    if (0 === t) {
                                        rs = ci(e.nextSibling);
                                        break e
                                    }
                                    t--
                                } else "$" !== n && "$!" !== n && "$?" !== n || t++
                            }
                            e = e.nextSibling
                        }
                        rs = null
                    }
                } else rs = ns ? ci(e.stateNode.nextSibling) : null;
                return !0
            }

            function hs() {
                for (var e = rs; e;) e = ci(e.nextSibling)
            }

            function fs() {
                rs = ns = null, is = !1
            }

            function ps(e) {
                null === ss ? ss = [e] : ss.push(e)
            }

            var ms = w.ReactCurrentBatchConfig;

            function gs(e, t) {
                if (e && e.defaultProps) {
                    for (var n in t = O({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]);
                    return t
                }
                return t
            }

            var ys = ki(null), vs = null, bs = null, ws = null;

            function xs() {
                ws = bs = vs = null
            }

            function Es(e) {
                var t = ys.current;
                Ai(ys), e._currentValue = t
            }

            function Ss(e, t, n) {
                for (; null !== e;) {
                    var r = e.alternate;
                    if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
                    e = e.return
                }
            }

            function ks(e, t) {
                vs = e, ws = bs = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 != (e.lanes & t) && (wo = !0), e.firstContext = null)
            }

            function As(e) {
                var t = e._currentValue;
                if (ws !== e) if (e = {context: e, memoizedValue: t, next: null}, null === bs) {
                    if (null === vs) throw Error(s(308));
                    bs = e, vs.dependencies = {lanes: 0, firstContext: e}
                } else bs = bs.next = e;
                return t
            }

            var Ts = null;

            function Cs(e) {
                null === Ts ? Ts = [e] : Ts.push(e)
            }

            function Rs(e, t, n, r) {
                var i = t.interleaved;
                return null === i ? (n.next = n, Cs(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Ls(e, r)
            }

            function Ls(e, t) {
                e.lanes |= t;
                var n = e.alternate;
                for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;) e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return;
                return 3 === n.tag ? n.stateNode : null
            }

            var _s = !1;

            function Ps(e) {
                e.updateQueue = {
                    baseState: e.memoizedState,
                    firstBaseUpdate: null,
                    lastBaseUpdate: null,
                    shared: {pending: null, interleaved: null, lanes: 0},
                    effects: null
                }
            }

            function Ns(e, t) {
                e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
                    baseState: e.baseState,
                    firstBaseUpdate: e.firstBaseUpdate,
                    lastBaseUpdate: e.lastBaseUpdate,
                    shared: e.shared,
                    effects: e.effects
                })
            }

            function js(e, t) {
                return {eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null}
            }

            function Is(e, t, n) {
                var r = e.updateQueue;
                if (null === r) return null;
                if (r = r.shared, 0 != (2 & Ll)) {
                    var i = r.pending;
                    return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Ls(e, n)
                }
                return null === (i = r.interleaved) ? (t.next = t, Cs(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Ls(e, n)
            }

            function Ms(e, t, n) {
                if (null !== (t = t.updateQueue) && (t = t.shared, 0 != (4194240 & n))) {
                    var r = t.lanes;
                    n |= r &= e.pendingLanes, t.lanes = n, vt(e, n)
                }
            }

            function Ds(e, t) {
                var n = e.updateQueue, r = e.alternate;
                if (null !== r && n === (r = r.updateQueue)) {
                    var i = null, s = null;
                    if (null !== (n = n.firstBaseUpdate)) {
                        do {
                            var a = {
                                eventTime: n.eventTime,
                                lane: n.lane,
                                tag: n.tag,
                                payload: n.payload,
                                callback: n.callback,
                                next: null
                            };
                            null === s ? i = s = a : s = s.next = a, n = n.next
                        } while (null !== n);
                        null === s ? i = s = t : s = s.next = t
                    } else i = s = t;
                    return n = {
                        baseState: r.baseState,
                        firstBaseUpdate: i,
                        lastBaseUpdate: s,
                        shared: r.shared,
                        effects: r.effects
                    }, void (e.updateQueue = n)
                }
                null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
            }

            function Os(e, t, n, r) {
                var i = e.updateQueue;
                _s = !1;
                var s = i.firstBaseUpdate, a = i.lastBaseUpdate, o = i.shared.pending;
                if (null !== o) {
                    i.shared.pending = null;
                    var l = o, c = l.next;
                    l.next = null, null === a ? s = c : a.next = c, a = l;
                    var u = e.alternate;
                    null !== u && (o = (u = u.updateQueue).lastBaseUpdate) !== a && (null === o ? u.firstBaseUpdate = c : o.next = c, u.lastBaseUpdate = l)
                }
                if (null !== s) {
                    var d = i.baseState;
                    for (a = 0, u = c = l = null, o = s; ;) {
                        var h = o.lane, f = o.eventTime;
                        if ((r & h) === h) {
                            null !== u && (u = u.next = {
                                eventTime: f,
                                lane: 0,
                                tag: o.tag,
                                payload: o.payload,
                                callback: o.callback,
                                next: null
                            });
                            e:{
                                var p = e, m = o;
                                switch (h = t, f = n, m.tag) {
                                    case 1:
                                        if ("function" == typeof (p = m.payload)) {
                                            d = p.call(f, d, h);
                                            break e
                                        }
                                        d = p;
                                        break e;
                                    case 3:
                                        p.flags = -65537 & p.flags | 128;
                                    case 0:
                                        if (null == (h = "function" == typeof (p = m.payload) ? p.call(f, d, h) : p)) break e;
                                        d = O({}, d, h);
                                        break e;
                                    case 2:
                                        _s = !0
                                }
                            }
                            null !== o.callback && 0 !== o.lane && (e.flags |= 64, null === (h = i.effects) ? i.effects = [o] : h.push(o))
                        } else f = {
                            eventTime: f,
                            lane: h,
                            tag: o.tag,
                            payload: o.payload,
                            callback: o.callback,
                            next: null
                        }, null === u ? (c = u = f, l = d) : u = u.next = f, a |= h;
                        if (null === (o = o.next)) {
                            if (null === (o = i.shared.pending)) break;
                            o = (h = o).next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null
                        }
                    }
                    if (null === u && (l = d), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, null !== (t = i.shared.interleaved)) {
                        i = t;
                        do {
                            a |= i.lane, i = i.next
                        } while (i !== t)
                    } else null === s && (i.shared.lanes = 0);
                    Ol |= a, e.lanes = a, e.memoizedState = d
                }
            }

            function Bs(e, t, n) {
                if (e = t.effects, t.effects = null, null !== e) for (t = 0; t < e.length; t++) {
                    var r = e[t], i = r.callback;
                    if (null !== i) {
                        if (r.callback = null, r = n, "function" != typeof i) throw Error(s(191, i));
                        i.call(r)
                    }
                }
            }

            var Fs = (new r.Component).refs;

            function Us(e, t, n, r) {
                n = null == (n = n(r, t = e.memoizedState)) ? t : O({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n)
            }

            var Hs = {
                isMounted: function (e) {
                    return !!(e = e._reactInternals) && $e(e) === e
                }, enqueueSetState: function (e, t, n) {
                    e = e._reactInternals;
                    var r = tc(), i = nc(e), s = js(r, i);
                    s.payload = t, null != n && (s.callback = n), null !== (t = Is(e, s, i)) && (rc(t, e, i, r), Ms(t, e, i))
                }, enqueueReplaceState: function (e, t, n) {
                    e = e._reactInternals;
                    var r = tc(), i = nc(e), s = js(r, i);
                    s.tag = 1, s.payload = t, null != n && (s.callback = n), null !== (t = Is(e, s, i)) && (rc(t, e, i, r), Ms(t, e, i))
                }, enqueueForceUpdate: function (e, t) {
                    e = e._reactInternals;
                    var n = tc(), r = nc(e), i = js(n, r);
                    i.tag = 2, null != t && (i.callback = t), null !== (t = Is(e, i, r)) && (rc(t, e, r, n), Ms(t, e, r))
                }
            };

            function $s(e, t, n, r, i, s, a) {
                return "function" == typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, s, a) : !(t.prototype && t.prototype.isPureReactComponent && lr(n, r) && lr(i, s))
            }

            function Ks(e, t, n) {
                var r = !1, i = Ci, s = t.contextType;
                return "object" == typeof s && null !== s ? s = As(s) : (i = Ni(t) ? _i : Ri.current, s = (r = null != (r = t.contextTypes)) ? Pi(e, i) : Ci), t = new t(n, s), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = Hs, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = s), t
            }

            function zs(e, t, n, r) {
                e = t.state, "function" == typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" == typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Hs.enqueueReplaceState(t, t.state, null)
            }

            function Gs(e, t, n, r) {
                var i = e.stateNode;
                i.props = n, i.state = e.memoizedState, i.refs = Fs, Ps(e);
                var s = t.contextType;
                "object" == typeof s && null !== s ? i.context = As(s) : (s = Ni(t) ? _i : Ri.current, i.context = Pi(e, s)), i.state = e.memoizedState, "function" == typeof (s = t.getDerivedStateFromProps) && (Us(e, t, s, n), i.state = e.memoizedState), "function" == typeof t.getDerivedStateFromProps || "function" == typeof i.getSnapshotBeforeUpdate || "function" != typeof i.UNSAFE_componentWillMount && "function" != typeof i.componentWillMount || (t = i.state, "function" == typeof i.componentWillMount && i.componentWillMount(), "function" == typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && Hs.enqueueReplaceState(i, i.state, null), Os(e, n, i, r), i.state = e.memoizedState), "function" == typeof i.componentDidMount && (e.flags |= 4194308)
            }

            function qs(e, t, n) {
                if (null !== (e = n.ref) && "function" != typeof e && "object" != typeof e) {
                    if (n._owner) {
                        if (n = n._owner) {
                            if (1 !== n.tag) throw Error(s(309));
                            var r = n.stateNode
                        }
                        if (!r) throw Error(s(147, e));
                        var i = r, a = "" + e;
                        return null !== t && null !== t.ref && "function" == typeof t.ref && t.ref._stringRef === a ? t.ref : (t = function (e) {
                            var t = i.refs;
                            t === Fs && (t = i.refs = {}), null === e ? delete t[a] : t[a] = e
                        }, t._stringRef = a, t)
                    }
                    if ("string" != typeof e) throw Error(s(284));
                    if (!n._owner) throw Error(s(290, e))
                }
                return e
            }

            function Ws(e, t) {
                throw e = Object.prototype.toString.call(t), Error(s(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
            }

            function Vs(e) {
                return (0, e._init)(e._payload)
            }

            function Ys(e) {
                function t(t, n) {
                    if (e) {
                        var r = t.deletions;
                        null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n)
                    }
                }

                function n(n, r) {
                    if (!e) return null;
                    for (; null !== r;) t(n, r), r = r.sibling;
                    return null
                }

                function r(e, t) {
                    for (e = new Map; null !== t;) null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling;
                    return e
                }

                function i(e, t) {
                    return (e = Ic(e, t)).index = 0, e.sibling = null, e
                }

                function a(t, n, r) {
                    return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n)
                }

                function o(t) {
                    return e && null === t.alternate && (t.flags |= 2), t
                }

                function l(e, t, n, r) {
                    return null === t || 6 !== t.tag ? ((t = Bc(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t)
                }

                function c(e, t, n, r) {
                    var s = n.type;
                    return s === S ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === s || "object" == typeof s && null !== s && s.$$typeof === N && Vs(s) === t.type) ? ((r = i(t, n.props)).ref = qs(e, t, n), r.return = e, r) : ((r = Mc(n.type, n.key, n.props, null, e.mode, r)).ref = qs(e, t, n), r.return = e, r)
                }

                function u(e, t, n, r) {
                    return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Fc(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t)
                }

                function d(e, t, n, r, s) {
                    return null === t || 7 !== t.tag ? ((t = Dc(n, e.mode, r, s)).return = e, t) : ((t = i(t, n)).return = e, t)
                }

                function h(e, t, n) {
                    if ("string" == typeof t && "" !== t || "number" == typeof t) return (t = Bc("" + t, e.mode, n)).return = e, t;
                    if ("object" == typeof t && null !== t) {
                        switch (t.$$typeof) {
                            case x:
                                return (n = Mc(t.type, t.key, t.props, null, e.mode, n)).ref = qs(e, null, t), n.return = e, n;
                            case E:
                                return (t = Fc(t, e.mode, n)).return = e, t;
                            case N:
                                return h(e, (0, t._init)(t._payload), n)
                        }
                        if (te(t) || M(t)) return (t = Dc(t, e.mode, n, null)).return = e, t;
                        Ws(e, t)
                    }
                    return null
                }

                function f(e, t, n, r) {
                    var i = null !== t ? t.key : null;
                    if ("string" == typeof n && "" !== n || "number" == typeof n) return null !== i ? null : l(e, t, "" + n, r);
                    if ("object" == typeof n && null !== n) {
                        switch (n.$$typeof) {
                            case x:
                                return n.key === i ? c(e, t, n, r) : null;
                            case E:
                                return n.key === i ? u(e, t, n, r) : null;
                            case N:
                                return f(e, t, (i = n._init)(n._payload), r)
                        }
                        if (te(n) || M(n)) return null !== i ? null : d(e, t, n, r, null);
                        Ws(e, n)
                    }
                    return null
                }

                function p(e, t, n, r, i) {
                    if ("string" == typeof r && "" !== r || "number" == typeof r) return l(t, e = e.get(n) || null, "" + r, i);
                    if ("object" == typeof r && null !== r) {
                        switch (r.$$typeof) {
                            case x:
                                return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                            case E:
                                return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                            case N:
                                return p(e, t, n, (0, r._init)(r._payload), i)
                        }
                        if (te(r) || M(r)) return d(t, e = e.get(n) || null, r, i, null);
                        Ws(t, r)
                    }
                    return null
                }

                function m(i, s, o, l) {
                    for (var c = null, u = null, d = s, m = s = 0, g = null; null !== d && m < o.length; m++) {
                        d.index > m ? (g = d, d = null) : g = d.sibling;
                        var y = f(i, d, o[m], l);
                        if (null === y) {
                            null === d && (d = g);
                            break
                        }
                        e && d && null === y.alternate && t(i, d), s = a(y, s, m), null === u ? c = y : u.sibling = y, u = y, d = g
                    }
                    if (m === o.length) return n(i, d), is && Qi(i, m), c;
                    if (null === d) {
                        for (; m < o.length; m++) null !== (d = h(i, o[m], l)) && (s = a(d, s, m), null === u ? c = d : u.sibling = d, u = d);
                        return is && Qi(i, m), c
                    }
                    for (d = r(i, d); m < o.length; m++) null !== (g = p(d, i, m, o[m], l)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key), s = a(g, s, m), null === u ? c = g : u.sibling = g, u = g);
                    return e && d.forEach((function (e) {
                        return t(i, e)
                    })), is && Qi(i, m), c
                }

                function g(i, o, l, c) {
                    var u = M(l);
                    if ("function" != typeof u) throw Error(s(150));
                    if (null == (l = u.call(l))) throw Error(s(151));
                    for (var d = u = null, m = o, g = o = 0, y = null, v = l.next(); null !== m && !v.done; g++, v = l.next()) {
                        m.index > g ? (y = m, m = null) : y = m.sibling;
                        var b = f(i, m, v.value, c);
                        if (null === b) {
                            null === m && (m = y);
                            break
                        }
                        e && m && null === b.alternate && t(i, m), o = a(b, o, g), null === d ? u = b : d.sibling = b, d = b, m = y
                    }
                    if (v.done) return n(i, m), is && Qi(i, g), u;
                    if (null === m) {
                        for (; !v.done; g++, v = l.next()) null !== (v = h(i, v.value, c)) && (o = a(v, o, g), null === d ? u = v : d.sibling = v, d = v);
                        return is && Qi(i, g), u
                    }
                    for (m = r(i, m); !v.done; g++, v = l.next()) null !== (v = p(m, i, g, v.value, c)) && (e && null !== v.alternate && m.delete(null === v.key ? g : v.key), o = a(v, o, g), null === d ? u = v : d.sibling = v, d = v);
                    return e && m.forEach((function (e) {
                        return t(i, e)
                    })), is && Qi(i, g), u
                }

                return function e(r, s, a, l) {
                    if ("object" == typeof a && null !== a && a.type === S && null === a.key && (a = a.props.children), "object" == typeof a && null !== a) {
                        switch (a.$$typeof) {
                            case x:
                                e:{
                                    for (var c = a.key, u = s; null !== u;) {
                                        if (u.key === c) {
                                            if ((c = a.type) === S) {
                                                if (7 === u.tag) {
                                                    n(r, u.sibling), (s = i(u, a.props.children)).return = r, r = s;
                                                    break e
                                                }
                                            } else if (u.elementType === c || "object" == typeof c && null !== c && c.$$typeof === N && Vs(c) === u.type) {
                                                n(r, u.sibling), (s = i(u, a.props)).ref = qs(r, u, a), s.return = r, r = s;
                                                break e
                                            }
                                            n(r, u);
                                            break
                                        }
                                        t(r, u), u = u.sibling
                                    }
                                    a.type === S ? ((s = Dc(a.props.children, r.mode, l, a.key)).return = r, r = s) : ((l = Mc(a.type, a.key, a.props, null, r.mode, l)).ref = qs(r, s, a), l.return = r, r = l)
                                }
                                return o(r);
                            case E:
                                e:{
                                    for (u = a.key; null !== s;) {
                                        if (s.key === u) {
                                            if (4 === s.tag && s.stateNode.containerInfo === a.containerInfo && s.stateNode.implementation === a.implementation) {
                                                n(r, s.sibling), (s = i(s, a.children || [])).return = r, r = s;
                                                break e
                                            }
                                            n(r, s);
                                            break
                                        }
                                        t(r, s), s = s.sibling
                                    }
                                    (s = Fc(a, r.mode, l)).return = r, r = s
                                }
                                return o(r);
                            case N:
                                return e(r, s, (u = a._init)(a._payload), l)
                        }
                        if (te(a)) return m(r, s, a, l);
                        if (M(a)) return g(r, s, a, l);
                        Ws(r, a)
                    }
                    return "string" == typeof a && "" !== a || "number" == typeof a ? (a = "" + a, null !== s && 6 === s.tag ? (n(r, s.sibling), (s = i(s, a)).return = r, r = s) : (n(r, s), (s = Bc(a, r.mode, l)).return = r, r = s), o(r)) : n(r, s)
                }
            }

            var Zs = Ys(!0), Xs = Ys(!1), Qs = {}, Js = ki(Qs), ea = ki(Qs), ta = ki(Qs);

            function na(e) {
                if (e === Qs) throw Error(s(174));
                return e
            }

            function ra(e, t) {
                switch (Ti(ta, t), Ti(ea, e), Ti(Js, Qs), e = t.nodeType) {
                    case 9:
                    case 11:
                        t = (t = t.documentElement) ? t.namespaceURI : le(null, "");
                        break;
                    default:
                        t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName)
                }
                Ai(Js), Ti(Js, t)
            }

            function ia() {
                Ai(Js), Ai(ea), Ai(ta)
            }

            function sa(e) {
                na(ta.current);
                var t = na(Js.current), n = le(t, e.type);
                t !== n && (Ti(ea, e), Ti(Js, n))
            }

            function aa(e) {
                ea.current === e && (Ai(Js), Ai(ea))
            }

            var oa = ki(0);

            function la(e) {
                for (var t = e; null !== t;) {
                    if (13 === t.tag) {
                        var n = t.memoizedState;
                        if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t
                    } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                        if (0 != (128 & t.flags)) return t
                    } else if (null !== t.child) {
                        t.child.return = t, t = t.child;
                        continue
                    }
                    if (t === e) break;
                    for (; null === t.sibling;) {
                        if (null === t.return || t.return === e) return null;
                        t = t.return
                    }
                    t.sibling.return = t.return, t = t.sibling
                }
                return null
            }

            var ca = [];

            function ua() {
                for (var e = 0; e < ca.length; e++) ca[e]._workInProgressVersionPrimary = null;
                ca.length = 0
            }

            var da = w.ReactCurrentDispatcher, ha = w.ReactCurrentBatchConfig, fa = 0, pa = null, ma = null, ga = null,
                ya = !1, va = !1, ba = 0, wa = 0;

            function xa() {
                throw Error(s(321))
            }

            function Ea(e, t) {
                if (null === t) return !1;
                for (var n = 0; n < t.length && n < e.length; n++) if (!or(e[n], t[n])) return !1;
                return !0
            }

            function Sa(e, t, n, r, i, a) {
                if (fa = a, pa = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, da.current = null === e || null === e.memoizedState ? ao : oo, e = n(r, i), va) {
                    a = 0;
                    do {
                        if (va = !1, ba = 0, 25 <= a) throw Error(s(301));
                        a += 1, ga = ma = null, t.updateQueue = null, da.current = lo, e = n(r, i)
                    } while (va)
                }
                if (da.current = so, t = null !== ma && null !== ma.next, fa = 0, ga = ma = pa = null, ya = !1, t) throw Error(s(300));
                return e
            }

            function ka() {
                var e = 0 !== ba;
                return ba = 0, e
            }

            function Aa() {
                var e = {memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null};
                return null === ga ? pa.memoizedState = ga = e : ga = ga.next = e, ga
            }

            function Ta() {
                if (null === ma) {
                    var e = pa.alternate;
                    e = null !== e ? e.memoizedState : null
                } else e = ma.next;
                var t = null === ga ? pa.memoizedState : ga.next;
                if (null !== t) ga = t, ma = e; else {
                    if (null === e) throw Error(s(310));
                    e = {
                        memoizedState: (ma = e).memoizedState,
                        baseState: ma.baseState,
                        baseQueue: ma.baseQueue,
                        queue: ma.queue,
                        next: null
                    }, null === ga ? pa.memoizedState = ga = e : ga = ga.next = e
                }
                return ga
            }

            function Ca(e, t) {
                return "function" == typeof t ? t(e) : t
            }

            function Ra(e) {
                var t = Ta(), n = t.queue;
                if (null === n) throw Error(s(311));
                n.lastRenderedReducer = e;
                var r = ma, i = r.baseQueue, a = n.pending;
                if (null !== a) {
                    if (null !== i) {
                        var o = i.next;
                        i.next = a.next, a.next = o
                    }
                    r.baseQueue = i = a, n.pending = null
                }
                if (null !== i) {
                    a = i.next, r = r.baseState;
                    var l = o = null, c = null, u = a;
                    do {
                        var d = u.lane;
                        if ((fa & d) === d) null !== c && (c = c.next = {
                            lane: 0,
                            action: u.action,
                            hasEagerState: u.hasEagerState,
                            eagerState: u.eagerState,
                            next: null
                        }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else {
                            var h = {
                                lane: d,
                                action: u.action,
                                hasEagerState: u.hasEagerState,
                                eagerState: u.eagerState,
                                next: null
                            };
                            null === c ? (l = c = h, o = r) : c = c.next = h, pa.lanes |= d, Ol |= d
                        }
                        u = u.next
                    } while (null !== u && u !== a);
                    null === c ? o = r : c.next = l, or(r, t.memoizedState) || (wo = !0), t.memoizedState = r, t.baseState = o, t.baseQueue = c, n.lastRenderedState = r
                }
                if (null !== (e = n.interleaved)) {
                    i = e;
                    do {
                        a = i.lane, pa.lanes |= a, Ol |= a, i = i.next
                    } while (i !== e)
                } else null === i && (n.lanes = 0);
                return [t.memoizedState, n.dispatch]
            }

            function La(e) {
                var t = Ta(), n = t.queue;
                if (null === n) throw Error(s(311));
                n.lastRenderedReducer = e;
                var r = n.dispatch, i = n.pending, a = t.memoizedState;
                if (null !== i) {
                    n.pending = null;
                    var o = i = i.next;
                    do {
                        a = e(a, o.action), o = o.next
                    } while (o !== i);
                    or(a, t.memoizedState) || (wo = !0), t.memoizedState = a, null === t.baseQueue && (t.baseState = a), n.lastRenderedState = a
                }
                return [a, r]
            }

            function _a() {
            }

            function Pa(e, t) {
                var n = pa, r = Ta(), i = t(), a = !or(r.memoizedState, i);
                if (a && (r.memoizedState = i, wo = !0), r = r.queue, Ka(Ia.bind(null, n, r, e), [e]), r.getSnapshot !== t || a || null !== ga && 1 & ga.memoizedState.tag) {
                    if (n.flags |= 2048, Ba(9, ja.bind(null, n, r, i, t), void 0, null), null === _l) throw Error(s(349));
                    0 != (30 & fa) || Na(n, t, i)
                }
                return i
            }

            function Na(e, t, n) {
                e.flags |= 16384, e = {
                    getSnapshot: t,
                    value: n
                }, null === (t = pa.updateQueue) ? (t = {
                    lastEffect: null,
                    stores: null
                }, pa.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e)
            }

            function ja(e, t, n, r) {
                t.value = n, t.getSnapshot = r, Ma(t) && Da(e)
            }

            function Ia(e, t, n) {
                return n((function () {
                    Ma(t) && Da(e)
                }))
            }

            function Ma(e) {
                var t = e.getSnapshot;
                e = e.value;
                try {
                    var n = t();
                    return !or(e, n)
                } catch (e) {
                    return !0
                }
            }

            function Da(e) {
                var t = Ls(e, 1);
                null !== t && rc(t, e, 1, -1)
            }

            function Oa(e) {
                var t = Aa();
                return "function" == typeof e && (e = e()), t.memoizedState = t.baseState = e, e = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: Ca,
                    lastRenderedState: e
                }, t.queue = e, e = e.dispatch = to.bind(null, pa, e), [t.memoizedState, e]
            }

            function Ba(e, t, n, r) {
                return e = {
                    tag: e,
                    create: t,
                    destroy: n,
                    deps: r,
                    next: null
                }, null === (t = pa.updateQueue) ? (t = {
                    lastEffect: null,
                    stores: null
                }, pa.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e
            }

            function Fa() {
                return Ta().memoizedState
            }

            function Ua(e, t, n, r) {
                var i = Aa();
                pa.flags |= e, i.memoizedState = Ba(1 | t, n, void 0, void 0 === r ? null : r)
            }

            function Ha(e, t, n, r) {
                var i = Ta();
                r = void 0 === r ? null : r;
                var s = void 0;
                if (null !== ma) {
                    var a = ma.memoizedState;
                    if (s = a.destroy, null !== r && Ea(r, a.deps)) return void (i.memoizedState = Ba(t, n, s, r))
                }
                pa.flags |= e, i.memoizedState = Ba(1 | t, n, s, r)
            }

            function $a(e, t) {
                return Ua(8390656, 8, e, t)
            }

            function Ka(e, t) {
                return Ha(2048, 8, e, t)
            }

            function za(e, t) {
                return Ha(4, 2, e, t)
            }

            function Ga(e, t) {
                return Ha(4, 4, e, t)
            }

            function qa(e, t) {
                return "function" == typeof t ? (e = e(), t(e), function () {
                    t(null)
                }) : null != t ? (e = e(), t.current = e, function () {
                    t.current = null
                }) : void 0
            }

            function Wa(e, t, n) {
                return n = null != n ? n.concat([e]) : null, Ha(4, 4, qa.bind(null, t, e), n)
            }

            function Va() {
            }

            function Ya(e, t) {
                var n = Ta();
                t = void 0 === t ? null : t;
                var r = n.memoizedState;
                return null !== r && null !== t && Ea(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
            }

            function Za(e, t) {
                var n = Ta();
                t = void 0 === t ? null : t;
                var r = n.memoizedState;
                return null !== r && null !== t && Ea(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
            }

            function Xa(e, t, n) {
                return 0 == (21 & fa) ? (e.baseState && (e.baseState = !1, wo = !0), e.memoizedState = n) : (or(n, t) || (n = mt(), pa.lanes |= n, Ol |= n, e.baseState = !0), t)
            }

            function Qa(e, t) {
                var n = bt;
                bt = 0 !== n && 4 > n ? n : 4, e(!0);
                var r = ha.transition;
                ha.transition = {};
                try {
                    e(!1), t()
                } finally {
                    bt = n, ha.transition = r
                }
            }

            function Ja() {
                return Ta().memoizedState
            }

            function eo(e, t, n) {
                var r = nc(e);
                n = {
                    lane: r,
                    action: n,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                }, no(e) ? ro(t, n) : null !== (n = Rs(e, t, n, r)) && (rc(n, e, r, tc()), io(n, t, r))
            }

            function to(e, t, n) {
                var r = nc(e), i = {lane: r, action: n, hasEagerState: !1, eagerState: null, next: null};
                if (no(e)) ro(t, i); else {
                    var s = e.alternate;
                    if (0 === e.lanes && (null === s || 0 === s.lanes) && null !== (s = t.lastRenderedReducer)) try {
                        var a = t.lastRenderedState, o = s(a, n);
                        if (i.hasEagerState = !0, i.eagerState = o, or(o, a)) {
                            var l = t.interleaved;
                            return null === l ? (i.next = i, Cs(t)) : (i.next = l.next, l.next = i), void (t.interleaved = i)
                        }
                    } catch (e) {
                    }
                    null !== (n = Rs(e, t, i, r)) && (rc(n, e, r, i = tc()), io(n, t, r))
                }
            }

            function no(e) {
                var t = e.alternate;
                return e === pa || null !== t && t === pa
            }

            function ro(e, t) {
                va = ya = !0;
                var n = e.pending;
                null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
            }

            function io(e, t, n) {
                if (0 != (4194240 & n)) {
                    var r = t.lanes;
                    n |= r &= e.pendingLanes, t.lanes = n, vt(e, n)
                }
            }

            var so = {
                readContext: As,
                useCallback: xa,
                useContext: xa,
                useEffect: xa,
                useImperativeHandle: xa,
                useInsertionEffect: xa,
                useLayoutEffect: xa,
                useMemo: xa,
                useReducer: xa,
                useRef: xa,
                useState: xa,
                useDebugValue: xa,
                useDeferredValue: xa,
                useTransition: xa,
                useMutableSource: xa,
                useSyncExternalStore: xa,
                useId: xa,
                unstable_isNewReconciler: !1
            }, ao = {
                readContext: As, useCallback: function (e, t) {
                    return Aa().memoizedState = [e, void 0 === t ? null : t], e
                }, useContext: As, useEffect: $a, useImperativeHandle: function (e, t, n) {
                    return n = null != n ? n.concat([e]) : null, Ua(4194308, 4, qa.bind(null, t, e), n)
                }, useLayoutEffect: function (e, t) {
                    return Ua(4194308, 4, e, t)
                }, useInsertionEffect: function (e, t) {
                    return Ua(4, 2, e, t)
                }, useMemo: function (e, t) {
                    var n = Aa();
                    return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e
                }, useReducer: function (e, t, n) {
                    var r = Aa();
                    return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: e,
                        lastRenderedState: t
                    }, r.queue = e, e = e.dispatch = eo.bind(null, pa, e), [r.memoizedState, e]
                }, useRef: function (e) {
                    return e = {current: e}, Aa().memoizedState = e
                }, useState: Oa, useDebugValue: Va, useDeferredValue: function (e) {
                    return Aa().memoizedState = e
                }, useTransition: function () {
                    var e = Oa(!1), t = e[0];
                    return e = Qa.bind(null, e[1]), Aa().memoizedState = e, [t, e]
                }, useMutableSource: function () {
                }, useSyncExternalStore: function (e, t, n) {
                    var r = pa, i = Aa();
                    if (is) {
                        if (void 0 === n) throw Error(s(407));
                        n = n()
                    } else {
                        if (n = t(), null === _l) throw Error(s(349));
                        0 != (30 & fa) || Na(r, t, n)
                    }
                    i.memoizedState = n;
                    var a = {value: n, getSnapshot: t};
                    return i.queue = a, $a(Ia.bind(null, r, a, e), [e]), r.flags |= 2048, Ba(9, ja.bind(null, r, a, n, t), void 0, null), n
                }, useId: function () {
                    var e = Aa(), t = _l.identifierPrefix;
                    if (is) {
                        var n = Xi;
                        t = ":" + t + "R" + (n = (Zi & ~(1 << 32 - at(Zi) - 1)).toString(32) + n), 0 < (n = ba++) && (t += "H" + n.toString(32)), t += ":"
                    } else t = ":" + t + "r" + (n = wa++).toString(32) + ":";
                    return e.memoizedState = t
                }, unstable_isNewReconciler: !1
            }, oo = {
                readContext: As,
                useCallback: Ya,
                useContext: As,
                useEffect: Ka,
                useImperativeHandle: Wa,
                useInsertionEffect: za,
                useLayoutEffect: Ga,
                useMemo: Za,
                useReducer: Ra,
                useRef: Fa,
                useState: function () {
                    return Ra(Ca)
                },
                useDebugValue: Va,
                useDeferredValue: function (e) {
                    return Xa(Ta(), ma.memoizedState, e)
                },
                useTransition: function () {
                    return [Ra(Ca)[0], Ta().memoizedState]
                },
                useMutableSource: _a,
                useSyncExternalStore: Pa,
                useId: Ja,
                unstable_isNewReconciler: !1
            }, lo = {
                readContext: As,
                useCallback: Ya,
                useContext: As,
                useEffect: Ka,
                useImperativeHandle: Wa,
                useInsertionEffect: za,
                useLayoutEffect: Ga,
                useMemo: Za,
                useReducer: La,
                useRef: Fa,
                useState: function () {
                    return La(Ca)
                },
                useDebugValue: Va,
                useDeferredValue: function (e) {
                    var t = Ta();
                    return null === ma ? t.memoizedState = e : Xa(t, ma.memoizedState, e)
                },
                useTransition: function () {
                    return [La(Ca)[0], Ta().memoizedState]
                },
                useMutableSource: _a,
                useSyncExternalStore: Pa,
                useId: Ja,
                unstable_isNewReconciler: !1
            };

            function co(e, t) {
                try {
                    var n = "", r = t;
                    do {
                        n += H(r), r = r.return
                    } while (r);
                    var i = n
                } catch (e) {
                    i = "\nError generating stack: " + e.message + "\n" + e.stack
                }
                return {value: e, source: t, stack: i, digest: null}
            }

            function uo(e, t, n) {
                return {value: e, source: null, stack: null != n ? n : null, digest: null != t ? t : null}
            }

            function ho(e, t) {
                try {
                    console.error(t.value)
                } catch (e) {
                    setTimeout((function () {
                        throw e
                    }))
                }
            }

            var fo = "function" == typeof WeakMap ? WeakMap : Map;

            function po(e, t, n) {
                (n = js(-1, n)).tag = 3, n.payload = {element: null};
                var r = t.value;
                return n.callback = function () {
                    Gl || (Gl = !0, ql = r), ho(0, t)
                }, n
            }

            function mo(e, t, n) {
                (n = js(-1, n)).tag = 3;
                var r = e.type.getDerivedStateFromError;
                if ("function" == typeof r) {
                    var i = t.value;
                    n.payload = function () {
                        return r(i)
                    }, n.callback = function () {
                        ho(0, t)
                    }
                }
                var s = e.stateNode;
                return null !== s && "function" == typeof s.componentDidCatch && (n.callback = function () {
                    ho(0, t), "function" != typeof r && (null === Wl ? Wl = new Set([this]) : Wl.add(this));
                    var e = t.stack;
                    this.componentDidCatch(t.value, {componentStack: null !== e ? e : ""})
                }), n
            }

            function go(e, t, n) {
                var r = e.pingCache;
                if (null === r) {
                    r = e.pingCache = new fo;
                    var i = new Set;
                    r.set(t, i)
                } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i));
                i.has(n) || (i.add(n), e = Tc.bind(null, e, t, n), t.then(e, e))
            }

            function yo(e) {
                do {
                    var t;
                    if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e;
                    e = e.return
                } while (null !== e);
                return null
            }

            function vo(e, t, n, r, i) {
                return 0 == (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = js(-1, 1)).tag = 2, Is(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e)
            }

            var bo = w.ReactCurrentOwner, wo = !1;

            function xo(e, t, n, r) {
                t.child = null === e ? Xs(t, null, n, r) : Zs(t, e.child, n, r)
            }

            function Eo(e, t, n, r, i) {
                n = n.render;
                var s = t.ref;
                return ks(t, i), r = Sa(e, t, n, r, s, i), n = ka(), null === e || wo ? (is && n && es(t), t.flags |= 1, xo(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Go(e, t, i))
            }

            function So(e, t, n, r, i) {
                if (null === e) {
                    var s = n.type;
                    return "function" != typeof s || jc(s) || void 0 !== s.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Mc(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = s, ko(e, t, s, r, i))
                }
                if (s = e.child, 0 == (e.lanes & i)) {
                    var a = s.memoizedProps;
                    if ((n = null !== (n = n.compare) ? n : lr)(a, r) && e.ref === t.ref) return Go(e, t, i)
                }
                return t.flags |= 1, (e = Ic(s, r)).ref = t.ref, e.return = t, t.child = e
            }

            function ko(e, t, n, r, i) {
                if (null !== e) {
                    var s = e.memoizedProps;
                    if (lr(s, r) && e.ref === t.ref) {
                        if (wo = !1, t.pendingProps = r = s, 0 == (e.lanes & i)) return t.lanes = e.lanes, Go(e, t, i);
                        0 != (131072 & e.flags) && (wo = !0)
                    }
                }
                return Co(e, t, n, r, i)
            }

            function Ao(e, t, n) {
                var r = t.pendingProps, i = r.children, s = null !== e ? e.memoizedState : null;
                if ("hidden" === r.mode) if (0 == (1 & t.mode)) t.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                }, Ti(Il, jl), jl |= n; else {
                    if (0 == (1073741824 & n)) return e = null !== s ? s.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
                        baseLanes: e,
                        cachePool: null,
                        transitions: null
                    }, t.updateQueue = null, Ti(Il, jl), jl |= e, null;
                    t.memoizedState = {
                        baseLanes: 0,
                        cachePool: null,
                        transitions: null
                    }, r = null !== s ? s.baseLanes : n, Ti(Il, jl), jl |= r
                } else null !== s ? (r = s.baseLanes | n, t.memoizedState = null) : r = n, Ti(Il, jl), jl |= r;
                return xo(e, t, i, n), t.child
            }

            function To(e, t) {
                var n = t.ref;
                (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152)
            }

            function Co(e, t, n, r, i) {
                var s = Ni(n) ? _i : Ri.current;
                return s = Pi(t, s), ks(t, i), n = Sa(e, t, n, r, s, i), r = ka(), null === e || wo ? (is && r && es(t), t.flags |= 1, xo(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Go(e, t, i))
            }

            function Ro(e, t, n, r, i) {
                if (Ni(n)) {
                    var s = !0;
                    Di(t)
                } else s = !1;
                if (ks(t, i), null === t.stateNode) zo(e, t), Ks(t, n, r), Gs(t, n, r, i), r = !0; else if (null === e) {
                    var a = t.stateNode, o = t.memoizedProps;
                    a.props = o;
                    var l = a.context, c = n.contextType;
                    c = "object" == typeof c && null !== c ? As(c) : Pi(t, c = Ni(n) ? _i : Ri.current);
                    var u = n.getDerivedStateFromProps,
                        d = "function" == typeof u || "function" == typeof a.getSnapshotBeforeUpdate;
                    d || "function" != typeof a.UNSAFE_componentWillReceiveProps && "function" != typeof a.componentWillReceiveProps || (o !== r || l !== c) && zs(t, a, r, c), _s = !1;
                    var h = t.memoizedState;
                    a.state = h, Os(t, r, a, i), l = t.memoizedState, o !== r || h !== l || Li.current || _s ? ("function" == typeof u && (Us(t, n, u, r), l = t.memoizedState), (o = _s || $s(t, n, o, r, h, l, c)) ? (d || "function" != typeof a.UNSAFE_componentWillMount && "function" != typeof a.componentWillMount || ("function" == typeof a.componentWillMount && a.componentWillMount(), "function" == typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()), "function" == typeof a.componentDidMount && (t.flags |= 4194308)) : ("function" == typeof a.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), a.props = r, a.state = l, a.context = c, r = o) : ("function" == typeof a.componentDidMount && (t.flags |= 4194308), r = !1)
                } else {
                    a = t.stateNode, Ns(e, t), o = t.memoizedProps, c = t.type === t.elementType ? o : gs(t.type, o), a.props = c, d = t.pendingProps, h = a.context, l = "object" == typeof (l = n.contextType) && null !== l ? As(l) : Pi(t, l = Ni(n) ? _i : Ri.current);
                    var f = n.getDerivedStateFromProps;
                    (u = "function" == typeof f || "function" == typeof a.getSnapshotBeforeUpdate) || "function" != typeof a.UNSAFE_componentWillReceiveProps && "function" != typeof a.componentWillReceiveProps || (o !== d || h !== l) && zs(t, a, r, l), _s = !1, h = t.memoizedState, a.state = h, Os(t, r, a, i);
                    var p = t.memoizedState;
                    o !== d || h !== p || Li.current || _s ? ("function" == typeof f && (Us(t, n, f, r), p = t.memoizedState), (c = _s || $s(t, n, c, r, h, p, l) || !1) ? (u || "function" != typeof a.UNSAFE_componentWillUpdate && "function" != typeof a.componentWillUpdate || ("function" == typeof a.componentWillUpdate && a.componentWillUpdate(r, p, l), "function" == typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(r, p, l)), "function" == typeof a.componentDidUpdate && (t.flags |= 4), "function" == typeof a.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" != typeof a.componentDidUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" != typeof a.getSnapshotBeforeUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = p), a.props = r, a.state = p, a.context = l, r = c) : ("function" != typeof a.componentDidUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" != typeof a.getSnapshotBeforeUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1)
                }
                return Lo(e, t, n, r, s, i)
            }

            function Lo(e, t, n, r, i, s) {
                To(e, t);
                var a = 0 != (128 & t.flags);
                if (!r && !a) return i && Oi(t, n, !1), Go(e, t, s);
                r = t.stateNode, bo.current = t;
                var o = a && "function" != typeof n.getDerivedStateFromError ? null : r.render();
                return t.flags |= 1, null !== e && a ? (t.child = Zs(t, e.child, null, s), t.child = Zs(t, null, o, s)) : xo(e, t, o, s), t.memoizedState = r.state, i && Oi(t, n, !0), t.child
            }

            function _o(e) {
                var t = e.stateNode;
                t.pendingContext ? Ii(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Ii(0, t.context, !1), ra(e, t.containerInfo)
            }

            function Po(e, t, n, r, i) {
                return fs(), ps(i), t.flags |= 256, xo(e, t, n, r), t.child
            }

            var No, jo, Io, Mo, Do = {dehydrated: null, treeContext: null, retryLane: 0};

            function Oo(e) {
                return {baseLanes: e, cachePool: null, transitions: null}
            }

            function Bo(e, t, n) {
                var r, i = t.pendingProps, a = oa.current, o = !1, l = 0 != (128 & t.flags);
                if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 != (2 & a)), r ? (o = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (a |= 1), Ti(oa, 1 & a), null === e) return cs(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 == (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (l = i.children, e = i.fallback, o ? (i = t.mode, o = t.child, l = {
                    mode: "hidden",
                    children: l
                }, 0 == (1 & i) && null !== o ? (o.childLanes = 0, o.pendingProps = l) : o = Oc(l, i, 0, null), e = Dc(e, i, n, null), o.return = t, e.return = t, o.sibling = e, t.child = o, t.child.memoizedState = Oo(n), t.memoizedState = Do, e) : Fo(t, l));
                if (null !== (a = e.memoizedState) && null !== (r = a.dehydrated)) return function (e, t, n, r, i, a, o) {
                    if (n) return 256 & t.flags ? (t.flags &= -257, Uo(e, t, o, r = uo(Error(s(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (a = r.fallback, i = t.mode, r = Oc({
                        mode: "visible",
                        children: r.children
                    }, i, 0, null), (a = Dc(a, i, o, null)).flags |= 2, r.return = t, a.return = t, r.sibling = a, t.child = r, 0 != (1 & t.mode) && Zs(t, e.child, null, o), t.child.memoizedState = Oo(o), t.memoizedState = Do, a);
                    if (0 == (1 & t.mode)) return Uo(e, t, o, null);
                    if ("$!" === i.data) {
                        if (r = i.nextSibling && i.nextSibling.dataset) var l = r.dgst;
                        return r = l, Uo(e, t, o, r = uo(a = Error(s(419)), r, void 0))
                    }
                    if (l = 0 != (o & e.childLanes), wo || l) {
                        if (null !== (r = _l)) {
                            switch (o & -o) {
                                case 4:
                                    i = 2;
                                    break;
                                case 16:
                                    i = 8;
                                    break;
                                case 64:
                                case 128:
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                case 67108864:
                                    i = 32;
                                    break;
                                case 536870912:
                                    i = 268435456;
                                    break;
                                default:
                                    i = 0
                            }
                            0 !== (i = 0 != (i & (r.suspendedLanes | o)) ? 0 : i) && i !== a.retryLane && (a.retryLane = i, Ls(e, i), rc(r, e, i, -1))
                        }
                        return gc(), Uo(e, t, o, r = uo(Error(s(421))))
                    }
                    return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = Rc.bind(null, e), i._reactRetry = t, null) : (e = a.treeContext, rs = ci(i.nextSibling), ns = t, is = !0, ss = null, null !== e && (Wi[Vi++] = Zi, Wi[Vi++] = Xi, Wi[Vi++] = Yi, Zi = e.id, Xi = e.overflow, Yi = t), (t = Fo(t, r.children)).flags |= 4096, t)
                }(e, t, l, i, r, a, n);
                if (o) {
                    o = i.fallback, l = t.mode, r = (a = e.child).sibling;
                    var c = {mode: "hidden", children: i.children};
                    return 0 == (1 & l) && t.child !== a ? ((i = t.child).childLanes = 0, i.pendingProps = c, t.deletions = null) : (i = Ic(a, c)).subtreeFlags = 14680064 & a.subtreeFlags, null !== r ? o = Ic(r, o) : (o = Dc(o, l, n, null)).flags |= 2, o.return = t, i.return = t, i.sibling = o, t.child = i, i = o, o = t.child, l = null === (l = e.child.memoizedState) ? Oo(n) : {
                        baseLanes: l.baseLanes | n,
                        cachePool: null,
                        transitions: l.transitions
                    }, o.memoizedState = l, o.childLanes = e.childLanes & ~n, t.memoizedState = Do, i
                }
                return e = (o = e.child).sibling, i = Ic(o, {
                    mode: "visible",
                    children: i.children
                }), 0 == (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i
            }

            function Fo(e, t) {
                return (t = Oc({mode: "visible", children: t}, e.mode, 0, null)).return = e, e.child = t
            }

            function Uo(e, t, n, r) {
                return null !== r && ps(r), Zs(t, e.child, null, n), (e = Fo(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e
            }

            function Ho(e, t, n) {
                e.lanes |= t;
                var r = e.alternate;
                null !== r && (r.lanes |= t), Ss(e.return, t, n)
            }

            function $o(e, t, n, r, i) {
                var s = e.memoizedState;
                null === s ? e.memoizedState = {
                    isBackwards: t,
                    rendering: null,
                    renderingStartTime: 0,
                    last: r,
                    tail: n,
                    tailMode: i
                } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i)
            }

            function Ko(e, t, n) {
                var r = t.pendingProps, i = r.revealOrder, s = r.tail;
                if (xo(e, t, r.children, n), 0 != (2 & (r = oa.current))) r = 1 & r | 2, t.flags |= 128; else {
                    if (null !== e && 0 != (128 & e.flags)) e:for (e = t.child; null !== e;) {
                        if (13 === e.tag) null !== e.memoizedState && Ho(e, n, t); else if (19 === e.tag) Ho(e, n, t); else if (null !== e.child) {
                            e.child.return = e, e = e.child;
                            continue
                        }
                        if (e === t) break e;
                        for (; null === e.sibling;) {
                            if (null === e.return || e.return === t) break e;
                            e = e.return
                        }
                        e.sibling.return = e.return, e = e.sibling
                    }
                    r &= 1
                }
                if (Ti(oa, r), 0 == (1 & t.mode)) t.memoizedState = null; else switch (i) {
                    case"forwards":
                        for (n = t.child, i = null; null !== n;) null !== (e = n.alternate) && null === la(e) && (i = n), n = n.sibling;
                        null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), $o(t, !1, i, n, s);
                        break;
                    case"backwards":
                        for (n = null, i = t.child, t.child = null; null !== i;) {
                            if (null !== (e = i.alternate) && null === la(e)) {
                                t.child = i;
                                break
                            }
                            e = i.sibling, i.sibling = n, n = i, i = e
                        }
                        $o(t, !0, n, null, s);
                        break;
                    case"together":
                        $o(t, !1, null, null, void 0);
                        break;
                    default:
                        t.memoizedState = null
                }
                return t.child
            }

            function zo(e, t) {
                0 == (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2)
            }

            function Go(e, t, n) {
                if (null !== e && (t.dependencies = e.dependencies), Ol |= t.lanes, 0 == (n & t.childLanes)) return null;
                if (null !== e && t.child !== e.child) throw Error(s(153));
                if (null !== t.child) {
                    for (n = Ic(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;) e = e.sibling, (n = n.sibling = Ic(e, e.pendingProps)).return = t;
                    n.sibling = null
                }
                return t.child
            }

            function qo(e, t) {
                if (!is) switch (e.tailMode) {
                    case"hidden":
                        t = e.tail;
                        for (var n = null; null !== t;) null !== t.alternate && (n = t), t = t.sibling;
                        null === n ? e.tail = null : n.sibling = null;
                        break;
                    case"collapsed":
                        n = e.tail;
                        for (var r = null; null !== n;) null !== n.alternate && (r = n), n = n.sibling;
                        null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
                }
            }

            function Wo(e) {
                var t = null !== e.alternate && e.alternate.child === e.child, n = 0, r = 0;
                if (t) for (var i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling;
                return e.subtreeFlags |= r, e.childLanes = n, t
            }

            function Vo(e, t, n) {
                var r = t.pendingProps;
                switch (ts(t), t.tag) {
                    case 2:
                    case 16:
                    case 15:
                    case 0:
                    case 11:
                    case 7:
                    case 8:
                    case 12:
                    case 9:
                    case 14:
                        return Wo(t), null;
                    case 1:
                    case 17:
                        return Ni(t.type) && ji(), Wo(t), null;
                    case 3:
                        return r = t.stateNode, ia(), Ai(Li), Ai(Ri), ua(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (ds(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 == (256 & t.flags) || (t.flags |= 1024, null !== ss && (oc(ss), ss = null))), jo(e, t), Wo(t), null;
                    case 5:
                        aa(t);
                        var i = na(ta.current);
                        if (n = t.type, null !== e && null != t.stateNode) Io(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else {
                            if (!r) {
                                if (null === t.stateNode) throw Error(s(166));
                                return Wo(t), null
                            }
                            if (e = na(Js.current), ds(t)) {
                                r = t.stateNode, n = t.type;
                                var a = t.memoizedProps;
                                switch (r[hi] = t, r[fi] = a, e = 0 != (1 & t.mode), n) {
                                    case"dialog":
                                        Fr("cancel", r), Fr("close", r);
                                        break;
                                    case"iframe":
                                    case"object":
                                    case"embed":
                                        Fr("load", r);
                                        break;
                                    case"video":
                                    case"audio":
                                        for (i = 0; i < Mr.length; i++) Fr(Mr[i], r);
                                        break;
                                    case"source":
                                        Fr("error", r);
                                        break;
                                    case"img":
                                    case"image":
                                    case"link":
                                        Fr("error", r), Fr("load", r);
                                        break;
                                    case"details":
                                        Fr("toggle", r);
                                        break;
                                    case"input":
                                        Z(r, a), Fr("invalid", r);
                                        break;
                                    case"select":
                                        r._wrapperState = {wasMultiple: !!a.multiple}, Fr("invalid", r);
                                        break;
                                    case"textarea":
                                        ie(r, a), Fr("invalid", r)
                                }
                                for (var l in ve(n, a), i = null, a) if (a.hasOwnProperty(l)) {
                                    var c = a[l];
                                    "children" === l ? "string" == typeof c ? r.textContent !== c && (!0 !== a.suppressHydrationWarning && Qr(r.textContent, c, e), i = ["children", c]) : "number" == typeof c && r.textContent !== "" + c && (!0 !== a.suppressHydrationWarning && Qr(r.textContent, c, e), i = ["children", "" + c]) : o.hasOwnProperty(l) && null != c && "onScroll" === l && Fr("scroll", r)
                                }
                                switch (n) {
                                    case"input":
                                        q(r), J(r, a, !0);
                                        break;
                                    case"textarea":
                                        q(r), ae(r);
                                        break;
                                    case"select":
                                    case"option":
                                        break;
                                    default:
                                        "function" == typeof a.onClick && (r.onclick = Jr)
                                }
                                r = i, t.updateQueue = r, null !== r && (t.flags |= 4)
                            } else {
                                l = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = oe(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" == typeof r.is ? e = l.createElement(n, {is: r.is}) : (e = l.createElement(n), "select" === n && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[hi] = t, e[fi] = r, No(e, t, !1, !1), t.stateNode = e;
                                e:{
                                    switch (l = be(n, r), n) {
                                        case"dialog":
                                            Fr("cancel", e), Fr("close", e), i = r;
                                            break;
                                        case"iframe":
                                        case"object":
                                        case"embed":
                                            Fr("load", e), i = r;
                                            break;
                                        case"video":
                                        case"audio":
                                            for (i = 0; i < Mr.length; i++) Fr(Mr[i], e);
                                            i = r;
                                            break;
                                        case"source":
                                            Fr("error", e), i = r;
                                            break;
                                        case"img":
                                        case"image":
                                        case"link":
                                            Fr("error", e), Fr("load", e), i = r;
                                            break;
                                        case"details":
                                            Fr("toggle", e), i = r;
                                            break;
                                        case"input":
                                            Z(e, r), i = Y(e, r), Fr("invalid", e);
                                            break;
                                        case"option":
                                        default:
                                            i = r;
                                            break;
                                        case"select":
                                            e._wrapperState = {wasMultiple: !!r.multiple}, i = O({}, r, {value: void 0}), Fr("invalid", e);
                                            break;
                                        case"textarea":
                                            ie(e, r), i = re(e, r), Fr("invalid", e)
                                    }
                                    for (a in ve(n, i), c = i) if (c.hasOwnProperty(a)) {
                                        var u = c[a];
                                        "style" === a ? ge(e, u) : "dangerouslySetInnerHTML" === a ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === a ? "string" == typeof u ? ("textarea" !== n || "" !== u) && he(e, u) : "number" == typeof u && he(e, "" + u) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (o.hasOwnProperty(a) ? null != u && "onScroll" === a && Fr("scroll", e) : null != u && b(e, a, u, l))
                                    }
                                    switch (n) {
                                        case"input":
                                            q(e), J(e, r, !1);
                                            break;
                                        case"textarea":
                                            q(e), ae(e);
                                            break;
                                        case"option":
                                            null != r.value && e.setAttribute("value", "" + z(r.value));
                                            break;
                                        case"select":
                                            e.multiple = !!r.multiple, null != (a = r.value) ? ne(e, !!r.multiple, a, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0);
                                            break;
                                        default:
                                            "function" == typeof i.onClick && (e.onclick = Jr)
                                    }
                                    switch (n) {
                                        case"button":
                                        case"input":
                                        case"select":
                                        case"textarea":
                                            r = !!r.autoFocus;
                                            break e;
                                        case"img":
                                            r = !0;
                                            break e;
                                        default:
                                            r = !1
                                    }
                                }
                                r && (t.flags |= 4)
                            }
                            null !== t.ref && (t.flags |= 512, t.flags |= 2097152)
                        }
                        return Wo(t), null;
                    case 6:
                        if (e && null != t.stateNode) Mo(e, t, e.memoizedProps, r); else {
                            if ("string" != typeof r && null === t.stateNode) throw Error(s(166));
                            if (n = na(ta.current), na(Js.current), ds(t)) {
                                if (r = t.stateNode, n = t.memoizedProps, r[hi] = t, (a = r.nodeValue !== n) && null !== (e = ns)) switch (e.tag) {
                                    case 3:
                                        Qr(r.nodeValue, n, 0 != (1 & e.mode));
                                        break;
                                    case 5:
                                        !0 !== e.memoizedProps.suppressHydrationWarning && Qr(r.nodeValue, n, 0 != (1 & e.mode))
                                }
                                a && (t.flags |= 4)
                            } else (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[hi] = t, t.stateNode = r
                        }
                        return Wo(t), null;
                    case 13:
                        if (Ai(oa), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) {
                            if (is && null !== rs && 0 != (1 & t.mode) && 0 == (128 & t.flags)) hs(), fs(), t.flags |= 98560, a = !1; else if (a = ds(t), null !== r && null !== r.dehydrated) {
                                if (null === e) {
                                    if (!a) throw Error(s(318));
                                    if (!(a = null !== (a = t.memoizedState) ? a.dehydrated : null)) throw Error(s(317));
                                    a[hi] = t
                                } else fs(), 0 == (128 & t.flags) && (t.memoizedState = null), t.flags |= 4;
                                Wo(t), a = !1
                            } else null !== ss && (oc(ss), ss = null), a = !0;
                            if (!a) return 65536 & t.flags ? t : null
                        }
                        return 0 != (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) != (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 != (1 & t.mode) && (null === e || 0 != (1 & oa.current) ? 0 === Ml && (Ml = 3) : gc())), null !== t.updateQueue && (t.flags |= 4), Wo(t), null);
                    case 4:
                        return ia(), jo(e, t), null === e && $r(t.stateNode.containerInfo), Wo(t), null;
                    case 10:
                        return Es(t.type._context), Wo(t), null;
                    case 19:
                        if (Ai(oa), null === (a = t.memoizedState)) return Wo(t), null;
                        if (r = 0 != (128 & t.flags), null === (l = a.rendering)) if (r) qo(a, !1); else {
                            if (0 !== Ml || null !== e && 0 != (128 & e.flags)) for (e = t.child; null !== e;) {
                                if (null !== (l = la(e))) {
                                    for (t.flags |= 128, qo(a, !1), null !== (r = l.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;) e = r, (a = n).flags &= 14680066, null === (l = a.alternate) ? (a.childLanes = 0, a.lanes = e, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = l.childLanes, a.lanes = l.lanes, a.child = l.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = l.memoizedProps, a.memoizedState = l.memoizedState, a.updateQueue = l.updateQueue, a.type = l.type, e = l.dependencies, a.dependencies = null === e ? null : {
                                        lanes: e.lanes,
                                        firstContext: e.firstContext
                                    }), n = n.sibling;
                                    return Ti(oa, 1 & oa.current | 2), t.child
                                }
                                e = e.sibling
                            }
                            null !== a.tail && Xe() > Kl && (t.flags |= 128, r = !0, qo(a, !1), t.lanes = 4194304)
                        } else {
                            if (!r) if (null !== (e = la(l))) {
                                if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), qo(a, !0), null === a.tail && "hidden" === a.tailMode && !l.alternate && !is) return Wo(t), null
                            } else 2 * Xe() - a.renderingStartTime > Kl && 1073741824 !== n && (t.flags |= 128, r = !0, qo(a, !1), t.lanes = 4194304);
                            a.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = a.last) ? n.sibling = l : t.child = l, a.last = l)
                        }
                        return null !== a.tail ? (t = a.tail, a.rendering = t, a.tail = t.sibling, a.renderingStartTime = Xe(), t.sibling = null, n = oa.current, Ti(oa, r ? 1 & n | 2 : 1 & n), t) : (Wo(t), null);
                    case 22:
                    case 23:
                        return hc(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 != (1 & t.mode) ? 0 != (1073741824 & jl) && (Wo(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Wo(t), null;
                    case 24:
                    case 25:
                        return null
                }
                throw Error(s(156, t.tag))
            }

            function Yo(e, t) {
                switch (ts(t), t.tag) {
                    case 1:
                        return Ni(t.type) && ji(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                    case 3:
                        return ia(), Ai(Li), Ai(Ri), ua(), 0 != (65536 & (e = t.flags)) && 0 == (128 & e) ? (t.flags = -65537 & e | 128, t) : null;
                    case 5:
                        return aa(t), null;
                    case 13:
                        if (Ai(oa), null !== (e = t.memoizedState) && null !== e.dehydrated) {
                            if (null === t.alternate) throw Error(s(340));
                            fs()
                        }
                        return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                    case 19:
                        return Ai(oa), null;
                    case 4:
                        return ia(), null;
                    case 10:
                        return Es(t.type._context), null;
                    case 22:
                    case 23:
                        return hc(), null;
                    default:
                        return null
                }
            }

            No = function (e, t) {
                for (var n = t.child; null !== n;) {
                    if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode); else if (4 !== n.tag && null !== n.child) {
                        n.child.return = n, n = n.child;
                        continue
                    }
                    if (n === t) break;
                    for (; null === n.sibling;) {
                        if (null === n.return || n.return === t) return;
                        n = n.return
                    }
                    n.sibling.return = n.return, n = n.sibling
                }
            }, jo = function () {
            }, Io = function (e, t, n, r) {
                var i = e.memoizedProps;
                if (i !== r) {
                    e = t.stateNode, na(Js.current);
                    var s, a = null;
                    switch (n) {
                        case"input":
                            i = Y(e, i), r = Y(e, r), a = [];
                            break;
                        case"select":
                            i = O({}, i, {value: void 0}), r = O({}, r, {value: void 0}), a = [];
                            break;
                        case"textarea":
                            i = re(e, i), r = re(e, r), a = [];
                            break;
                        default:
                            "function" != typeof i.onClick && "function" == typeof r.onClick && (e.onclick = Jr)
                    }
                    for (u in ve(n, r), n = null, i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u]) if ("style" === u) {
                        var l = i[u];
                        for (s in l) l.hasOwnProperty(s) && (n || (n = {}), n[s] = "")
                    } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (o.hasOwnProperty(u) ? a || (a = []) : (a = a || []).push(u, null));
                    for (u in r) {
                        var c = r[u];
                        if (l = null != i ? i[u] : void 0, r.hasOwnProperty(u) && c !== l && (null != c || null != l)) if ("style" === u) if (l) {
                            for (s in l) !l.hasOwnProperty(s) || c && c.hasOwnProperty(s) || (n || (n = {}), n[s] = "");
                            for (s in c) c.hasOwnProperty(s) && l[s] !== c[s] && (n || (n = {}), n[s] = c[s])
                        } else n || (a || (a = []), a.push(u, n)), n = c; else "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, null != c && l !== c && (a = a || []).push(u, c)) : "children" === u ? "string" != typeof c && "number" != typeof c || (a = a || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (o.hasOwnProperty(u) ? (null != c && "onScroll" === u && Fr("scroll", e), a || l === c || (a = [])) : (a = a || []).push(u, c))
                    }
                    n && (a = a || []).push("style", n);
                    var u = a;
                    (t.updateQueue = u) && (t.flags |= 4)
                }
            }, Mo = function (e, t, n, r) {
                n !== r && (t.flags |= 4)
            };
            var Zo = !1, Xo = !1, Qo = "function" == typeof WeakSet ? WeakSet : Set, Jo = null;

            function el(e, t) {
                var n = e.ref;
                if (null !== n) if ("function" == typeof n) try {
                    n(null)
                } catch (n) {
                    Ac(e, t, n)
                } else n.current = null
            }

            function tl(e, t, n) {
                try {
                    n()
                } catch (n) {
                    Ac(e, t, n)
                }
            }

            var nl = !1;

            function rl(e, t, n) {
                var r = t.updateQueue;
                if (null !== (r = null !== r ? r.lastEffect : null)) {
                    var i = r = r.next;
                    do {
                        if ((i.tag & e) === e) {
                            var s = i.destroy;
                            i.destroy = void 0, void 0 !== s && tl(t, n, s)
                        }
                        i = i.next
                    } while (i !== r)
                }
            }

            function il(e, t) {
                if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) {
                    var n = t = t.next;
                    do {
                        if ((n.tag & e) === e) {
                            var r = n.create;
                            n.destroy = r()
                        }
                        n = n.next
                    } while (n !== t)
                }
            }

            function sl(e) {
                var t = e.ref;
                if (null !== t) {
                    var n = e.stateNode;
                    e.tag, e = n, "function" == typeof t ? t(e) : t.current = e
                }
            }

            function al(e) {
                var t = e.alternate;
                null !== t && (e.alternate = null, al(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && null !== (t = e.stateNode) && (delete t[hi], delete t[fi], delete t[mi], delete t[gi], delete t[yi]), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
            }

            function ol(e) {
                return 5 === e.tag || 3 === e.tag || 4 === e.tag
            }

            function ll(e) {
                e:for (; ;) {
                    for (; null === e.sibling;) {
                        if (null === e.return || ol(e.return)) return null;
                        e = e.return
                    }
                    for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) {
                        if (2 & e.flags) continue e;
                        if (null === e.child || 4 === e.tag) continue e;
                        e.child.return = e, e = e.child
                    }
                    if (!(2 & e.flags)) return e.stateNode
                }
            }

            function cl(e, t, n) {
                var r = e.tag;
                if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null != (n = n._reactRootContainer) || null !== t.onclick || (t.onclick = Jr)); else if (4 !== r && null !== (e = e.child)) for (cl(e, t, n), e = e.sibling; null !== e;) cl(e, t, n), e = e.sibling
            }

            function ul(e, t, n) {
                var r = e.tag;
                if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (4 !== r && null !== (e = e.child)) for (ul(e, t, n), e = e.sibling; null !== e;) ul(e, t, n), e = e.sibling
            }

            var dl = null, hl = !1;

            function fl(e, t, n) {
                for (n = n.child; null !== n;) pl(e, t, n), n = n.sibling
            }

            function pl(e, t, n) {
                if (st && "function" == typeof st.onCommitFiberUnmount) try {
                    st.onCommitFiberUnmount(it, n)
                } catch (e) {
                }
                switch (n.tag) {
                    case 5:
                        Xo || el(n, t);
                    case 6:
                        var r = dl, i = hl;
                        dl = null, fl(e, t, n), hl = i, null !== (dl = r) && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : dl.removeChild(n.stateNode));
                        break;
                    case 18:
                        null !== dl && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n), $t(e)) : li(dl, n.stateNode));
                        break;
                    case 4:
                        r = dl, i = hl, dl = n.stateNode.containerInfo, hl = !0, fl(e, t, n), dl = r, hl = i;
                        break;
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        if (!Xo && null !== (r = n.updateQueue) && null !== (r = r.lastEffect)) {
                            i = r = r.next;
                            do {
                                var s = i, a = s.destroy;
                                s = s.tag, void 0 !== a && (0 != (2 & s) || 0 != (4 & s)) && tl(n, t, a), i = i.next
                            } while (i !== r)
                        }
                        fl(e, t, n);
                        break;
                    case 1:
                        if (!Xo && (el(n, t), "function" == typeof (r = n.stateNode).componentWillUnmount)) try {
                            r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
                        } catch (e) {
                            Ac(n, t, e)
                        }
                        fl(e, t, n);
                        break;
                    case 21:
                        fl(e, t, n);
                        break;
                    case 22:
                        1 & n.mode ? (Xo = (r = Xo) || null !== n.memoizedState, fl(e, t, n), Xo = r) : fl(e, t, n);
                        break;
                    default:
                        fl(e, t, n)
                }
            }

            function ml(e) {
                var t = e.updateQueue;
                if (null !== t) {
                    e.updateQueue = null;
                    var n = e.stateNode;
                    null === n && (n = e.stateNode = new Qo), t.forEach((function (t) {
                        var r = Lc.bind(null, e, t);
                        n.has(t) || (n.add(t), t.then(r, r))
                    }))
                }
            }

            function gl(e, t) {
                var n = t.deletions;
                if (null !== n) for (var r = 0; r < n.length; r++) {
                    var i = n[r];
                    try {
                        var a = e, o = t, l = o;
                        e:for (; null !== l;) {
                            switch (l.tag) {
                                case 5:
                                    dl = l.stateNode, hl = !1;
                                    break e;
                                case 3:
                                case 4:
                                    dl = l.stateNode.containerInfo, hl = !0;
                                    break e
                            }
                            l = l.return
                        }
                        if (null === dl) throw Error(s(160));
                        pl(a, o, i), dl = null, hl = !1;
                        var c = i.alternate;
                        null !== c && (c.return = null), i.return = null
                    } catch (e) {
                        Ac(i, t, e)
                    }
                }
                if (12854 & t.subtreeFlags) for (t = t.child; null !== t;) yl(t, e), t = t.sibling
            }

            function yl(e, t) {
                var n = e.alternate, r = e.flags;
                switch (e.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        if (gl(t, e), vl(e), 4 & r) {
                            try {
                                rl(3, e, e.return), il(3, e)
                            } catch (t) {
                                Ac(e, e.return, t)
                            }
                            try {
                                rl(5, e, e.return)
                            } catch (t) {
                                Ac(e, e.return, t)
                            }
                        }
                        break;
                    case 1:
                        gl(t, e), vl(e), 512 & r && null !== n && el(n, n.return);
                        break;
                    case 5:
                        if (gl(t, e), vl(e), 512 & r && null !== n && el(n, n.return), 32 & e.flags) {
                            var i = e.stateNode;
                            try {
                                he(i, "")
                            } catch (t) {
                                Ac(e, e.return, t)
                            }
                        }
                        if (4 & r && null != (i = e.stateNode)) {
                            var a = e.memoizedProps, o = null !== n ? n.memoizedProps : a, l = e.type,
                                c = e.updateQueue;
                            if (e.updateQueue = null, null !== c) try {
                                "input" === l && "radio" === a.type && null != a.name && X(i, a), be(l, o);
                                var u = be(l, a);
                                for (o = 0; o < c.length; o += 2) {
                                    var d = c[o], h = c[o + 1];
                                    "style" === d ? ge(i, h) : "dangerouslySetInnerHTML" === d ? de(i, h) : "children" === d ? he(i, h) : b(i, d, h, u)
                                }
                                switch (l) {
                                    case"input":
                                        Q(i, a);
                                        break;
                                    case"textarea":
                                        se(i, a);
                                        break;
                                    case"select":
                                        var f = i._wrapperState.wasMultiple;
                                        i._wrapperState.wasMultiple = !!a.multiple;
                                        var p = a.value;
                                        null != p ? ne(i, !!a.multiple, p, !1) : f !== !!a.multiple && (null != a.defaultValue ? ne(i, !!a.multiple, a.defaultValue, !0) : ne(i, !!a.multiple, a.multiple ? [] : "", !1))
                                }
                                i[fi] = a
                            } catch (t) {
                                Ac(e, e.return, t)
                            }
                        }
                        break;
                    case 6:
                        if (gl(t, e), vl(e), 4 & r) {
                            if (null === e.stateNode) throw Error(s(162));
                            i = e.stateNode, a = e.memoizedProps;
                            try {
                                i.nodeValue = a
                            } catch (t) {
                                Ac(e, e.return, t)
                            }
                        }
                        break;
                    case 3:
                        if (gl(t, e), vl(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try {
                            $t(t.containerInfo)
                        } catch (t) {
                            Ac(e, e.return, t)
                        }
                        break;
                    case 4:
                    default:
                        gl(t, e), vl(e);
                        break;
                    case 13:
                        gl(t, e), vl(e), 8192 & (i = e.child).flags && (a = null !== i.memoizedState, i.stateNode.isHidden = a, !a || null !== i.alternate && null !== i.alternate.memoizedState || ($l = Xe())), 4 & r && ml(e);
                        break;
                    case 22:
                        if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (Xo = (u = Xo) || d, gl(t, e), Xo = u) : gl(t, e), vl(e), 8192 & r) {
                            if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !d && 0 != (1 & e.mode)) for (Jo = e, d = e.child; null !== d;) {
                                for (h = Jo = d; null !== Jo;) {
                                    switch (p = (f = Jo).child, f.tag) {
                                        case 0:
                                        case 11:
                                        case 14:
                                        case 15:
                                            rl(4, f, f.return);
                                            break;
                                        case 1:
                                            el(f, f.return);
                                            var m = f.stateNode;
                                            if ("function" == typeof m.componentWillUnmount) {
                                                r = f, n = f.return;
                                                try {
                                                    t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount()
                                                } catch (e) {
                                                    Ac(r, n, e)
                                                }
                                            }
                                            break;
                                        case 5:
                                            el(f, f.return);
                                            break;
                                        case 22:
                                            if (null !== f.memoizedState) {
                                                El(h);
                                                continue
                                            }
                                    }
                                    null !== p ? (p.return = f, Jo = p) : El(h)
                                }
                                d = d.sibling
                            }
                            e:for (d = null, h = e; ;) {
                                if (5 === h.tag) {
                                    if (null === d) {
                                        d = h;
                                        try {
                                            i = h.stateNode, u ? "function" == typeof (a = i.style).setProperty ? a.setProperty("display", "none", "important") : a.display = "none" : (l = h.stateNode, o = null != (c = h.memoizedProps.style) && c.hasOwnProperty("display") ? c.display : null, l.style.display = me("display", o))
                                        } catch (t) {
                                            Ac(e, e.return, t)
                                        }
                                    }
                                } else if (6 === h.tag) {
                                    if (null === d) try {
                                        h.stateNode.nodeValue = u ? "" : h.memoizedProps
                                    } catch (t) {
                                        Ac(e, e.return, t)
                                    }
                                } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) {
                                    h.child.return = h, h = h.child;
                                    continue
                                }
                                if (h === e) break e;
                                for (; null === h.sibling;) {
                                    if (null === h.return || h.return === e) break e;
                                    d === h && (d = null), h = h.return
                                }
                                d === h && (d = null), h.sibling.return = h.return, h = h.sibling
                            }
                        }
                        break;
                    case 19:
                        gl(t, e), vl(e), 4 & r && ml(e);
                    case 21:
                }
            }

            function vl(e) {
                var t = e.flags;
                if (2 & t) {
                    try {
                        e:{
                            for (var n = e.return; null !== n;) {
                                if (ol(n)) {
                                    var r = n;
                                    break e
                                }
                                n = n.return
                            }
                            throw Error(s(160))
                        }
                        switch (r.tag) {
                            case 5:
                                var i = r.stateNode;
                                32 & r.flags && (he(i, ""), r.flags &= -33), ul(e, ll(e), i);
                                break;
                            case 3:
                            case 4:
                                var a = r.stateNode.containerInfo;
                                cl(e, ll(e), a);
                                break;
                            default:
                                throw Error(s(161))
                        }
                    } catch (t) {
                        Ac(e, e.return, t)
                    }
                    e.flags &= -3
                }
                4096 & t && (e.flags &= -4097)
            }

            function bl(e, t, n) {
                Jo = e, wl(e, t, n)
            }

            function wl(e, t, n) {
                for (var r = 0 != (1 & e.mode); null !== Jo;) {
                    var i = Jo, s = i.child;
                    if (22 === i.tag && r) {
                        var a = null !== i.memoizedState || Zo;
                        if (!a) {
                            var o = i.alternate, l = null !== o && null !== o.memoizedState || Xo;
                            o = Zo;
                            var c = Xo;
                            if (Zo = a, (Xo = l) && !c) for (Jo = i; null !== Jo;) l = (a = Jo).child, 22 === a.tag && null !== a.memoizedState ? Sl(i) : null !== l ? (l.return = a, Jo = l) : Sl(i);
                            for (; null !== s;) Jo = s, wl(s, t, n), s = s.sibling;
                            Jo = i, Zo = o, Xo = c
                        }
                        xl(e)
                    } else 0 != (8772 & i.subtreeFlags) && null !== s ? (s.return = i, Jo = s) : xl(e)
                }
            }

            function xl(e) {
                for (; null !== Jo;) {
                    var t = Jo;
                    if (0 != (8772 & t.flags)) {
                        var n = t.alternate;
                        try {
                            if (0 != (8772 & t.flags)) switch (t.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Xo || il(5, t);
                                    break;
                                case 1:
                                    var r = t.stateNode;
                                    if (4 & t.flags && !Xo) if (null === n) r.componentDidMount(); else {
                                        var i = t.elementType === t.type ? n.memoizedProps : gs(t.type, n.memoizedProps);
                                        r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                    }
                                    var a = t.updateQueue;
                                    null !== a && Bs(t, a, r);
                                    break;
                                case 3:
                                    var o = t.updateQueue;
                                    if (null !== o) {
                                        if (n = null, null !== t.child) switch (t.child.tag) {
                                            case 5:
                                            case 1:
                                                n = t.child.stateNode
                                        }
                                        Bs(t, o, n)
                                    }
                                    break;
                                case 5:
                                    var l = t.stateNode;
                                    if (null === n && 4 & t.flags) {
                                        n = l;
                                        var c = t.memoizedProps;
                                        switch (t.type) {
                                            case"button":
                                            case"input":
                                            case"select":
                                            case"textarea":
                                                c.autoFocus && n.focus();
                                                break;
                                            case"img":
                                                c.src && (n.src = c.src)
                                        }
                                    }
                                    break;
                                case 6:
                                case 4:
                                case 12:
                                case 19:
                                case 17:
                                case 21:
                                case 22:
                                case 23:
                                case 25:
                                    break;
                                case 13:
                                    if (null === t.memoizedState) {
                                        var u = t.alternate;
                                        if (null !== u) {
                                            var d = u.memoizedState;
                                            if (null !== d) {
                                                var h = d.dehydrated;
                                                null !== h && $t(h)
                                            }
                                        }
                                    }
                                    break;
                                default:
                                    throw Error(s(163))
                            }
                            Xo || 512 & t.flags && sl(t)
                        } catch (e) {
                            Ac(t, t.return, e)
                        }
                    }
                    if (t === e) {
                        Jo = null;
                        break
                    }
                    if (null !== (n = t.sibling)) {
                        n.return = t.return, Jo = n;
                        break
                    }
                    Jo = t.return
                }
            }

            function El(e) {
                for (; null !== Jo;) {
                    var t = Jo;
                    if (t === e) {
                        Jo = null;
                        break
                    }
                    var n = t.sibling;
                    if (null !== n) {
                        n.return = t.return, Jo = n;
                        break
                    }
                    Jo = t.return
                }
            }

            function Sl(e) {
                for (; null !== Jo;) {
                    var t = Jo;
                    try {
                        switch (t.tag) {
                            case 0:
                            case 11:
                            case 15:
                                var n = t.return;
                                try {
                                    il(4, t)
                                } catch (e) {
                                    Ac(t, n, e)
                                }
                                break;
                            case 1:
                                var r = t.stateNode;
                                if ("function" == typeof r.componentDidMount) {
                                    var i = t.return;
                                    try {
                                        r.componentDidMount()
                                    } catch (e) {
                                        Ac(t, i, e)
                                    }
                                }
                                var s = t.return;
                                try {
                                    sl(t)
                                } catch (e) {
                                    Ac(t, s, e)
                                }
                                break;
                            case 5:
                                var a = t.return;
                                try {
                                    sl(t)
                                } catch (e) {
                                    Ac(t, a, e)
                                }
                        }
                    } catch (e) {
                        Ac(t, t.return, e)
                    }
                    if (t === e) {
                        Jo = null;
                        break
                    }
                    var o = t.sibling;
                    if (null !== o) {
                        o.return = t.return, Jo = o;
                        break
                    }
                    Jo = t.return
                }
            }

            var kl, Al = Math.ceil, Tl = w.ReactCurrentDispatcher, Cl = w.ReactCurrentOwner,
                Rl = w.ReactCurrentBatchConfig, Ll = 0, _l = null, Pl = null, Nl = 0, jl = 0, Il = ki(0), Ml = 0,
                Dl = null, Ol = 0, Bl = 0, Fl = 0, Ul = null, Hl = null, $l = 0, Kl = 1 / 0, zl = null, Gl = !1,
                ql = null, Wl = null, Vl = !1, Yl = null, Zl = 0, Xl = 0, Ql = null, Jl = -1, ec = 0;

            function tc() {
                return 0 != (6 & Ll) ? Xe() : -1 !== Jl ? Jl : Jl = Xe()
            }

            function nc(e) {
                return 0 == (1 & e.mode) ? 1 : 0 != (2 & Ll) && 0 !== Nl ? Nl & -Nl : null !== ms.transition ? (0 === ec && (ec = mt()), ec) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Zt(e.type)
            }

            function rc(e, t, n, r) {
                if (50 < Xl) throw Xl = 0, Ql = null, Error(s(185));
                yt(e, n, r), 0 != (2 & Ll) && e === _l || (e === _l && (0 == (2 & Ll) && (Bl |= n), 4 === Ml && lc(e, Nl)), ic(e, r), 1 === n && 0 === Ll && 0 == (1 & t.mode) && (Kl = Xe() + 500, Fi && $i()))
            }

            function ic(e, t) {
                var n = e.callbackNode;
                !function (e, t) {
                    for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, s = e.pendingLanes; 0 < s;) {
                        var a = 31 - at(s), o = 1 << a, l = i[a];
                        -1 === l ? 0 != (o & n) && 0 == (o & r) || (i[a] = ft(o, t)) : l <= t && (e.expiredLanes |= o), s &= ~o
                    }
                }(e, t);
                var r = ht(e, e === _l ? Nl : 0);
                if (0 === r) null !== n && Ve(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) {
                    if (null != n && Ve(n), 1 === t) 0 === e.tag ? function (e) {
                        Fi = !0, Hi(e)
                    }(cc.bind(null, e)) : Hi(cc.bind(null, e)), ai((function () {
                        0 == (6 & Ll) && $i()
                    })), n = null; else {
                        switch (wt(r)) {
                            case 1:
                                n = Je;
                                break;
                            case 4:
                                n = et;
                                break;
                            case 16:
                            default:
                                n = tt;
                                break;
                            case 536870912:
                                n = rt
                        }
                        n = _c(n, sc.bind(null, e))
                    }
                    e.callbackPriority = t, e.callbackNode = n
                }
            }

            function sc(e, t) {
                if (Jl = -1, ec = 0, 0 != (6 & Ll)) throw Error(s(327));
                var n = e.callbackNode;
                if (Sc() && e.callbackNode !== n) return null;
                var r = ht(e, e === _l ? Nl : 0);
                if (0 === r) return null;
                if (0 != (30 & r) || 0 != (r & e.expiredLanes) || t) t = yc(e, r); else {
                    t = r;
                    var i = Ll;
                    Ll |= 2;
                    var a = mc();
                    for (_l === e && Nl === t || (zl = null, Kl = Xe() + 500, fc(e, t)); ;) try {
                        bc();
                        break
                    } catch (t) {
                        pc(e, t)
                    }
                    xs(), Tl.current = a, Ll = i, null !== Pl ? t = 0 : (_l = null, Nl = 0, t = Ml)
                }
                if (0 !== t) {
                    if (2 === t && 0 !== (i = pt(e)) && (r = i, t = ac(e, i)), 1 === t) throw n = Dl, fc(e, 0), lc(e, r), ic(e, Xe()), n;
                    if (6 === t) lc(e, r); else {
                        if (i = e.current.alternate, 0 == (30 & r) && !function (e) {
                            for (var t = e; ;) {
                                if (16384 & t.flags) {
                                    var n = t.updateQueue;
                                    if (null !== n && null !== (n = n.stores)) for (var r = 0; r < n.length; r++) {
                                        var i = n[r], s = i.getSnapshot;
                                        i = i.value;
                                        try {
                                            if (!or(s(), i)) return !1
                                        } catch (e) {
                                            return !1
                                        }
                                    }
                                }
                                if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n; else {
                                    if (t === e) break;
                                    for (; null === t.sibling;) {
                                        if (null === t.return || t.return === e) return !0;
                                        t = t.return
                                    }
                                    t.sibling.return = t.return, t = t.sibling
                                }
                            }
                            return !0
                        }(i) && (2 === (t = yc(e, r)) && 0 !== (a = pt(e)) && (r = a, t = ac(e, a)), 1 === t)) throw n = Dl, fc(e, 0), lc(e, r), ic(e, Xe()), n;
                        switch (e.finishedWork = i, e.finishedLanes = r, t) {
                            case 0:
                            case 1:
                                throw Error(s(345));
                            case 2:
                            case 5:
                                Ec(e, Hl, zl);
                                break;
                            case 3:
                                if (lc(e, r), (130023424 & r) === r && 10 < (t = $l + 500 - Xe())) {
                                    if (0 !== ht(e, 0)) break;
                                    if (((i = e.suspendedLanes) & r) !== r) {
                                        tc(), e.pingedLanes |= e.suspendedLanes & i;
                                        break
                                    }
                                    e.timeoutHandle = ri(Ec.bind(null, e, Hl, zl), t);
                                    break
                                }
                                Ec(e, Hl, zl);
                                break;
                            case 4:
                                if (lc(e, r), (4194240 & r) === r) break;
                                for (t = e.eventTimes, i = -1; 0 < r;) {
                                    var o = 31 - at(r);
                                    a = 1 << o, (o = t[o]) > i && (i = o), r &= ~a
                                }
                                if (r = i, 10 < (r = (120 > (r = Xe() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Al(r / 1960)) - r)) {
                                    e.timeoutHandle = ri(Ec.bind(null, e, Hl, zl), r);
                                    break
                                }
                                Ec(e, Hl, zl);
                                break;
                            default:
                                throw Error(s(329))
                        }
                    }
                }
                return ic(e, Xe()), e.callbackNode === n ? sc.bind(null, e) : null
            }

            function ac(e, t) {
                var n = Ul;
                return e.current.memoizedState.isDehydrated && (fc(e, t).flags |= 256), 2 !== (e = yc(e, t)) && (t = Hl, Hl = n, null !== t && oc(t)), e
            }

            function oc(e) {
                null === Hl ? Hl = e : Hl.push.apply(Hl, e)
            }

            function lc(e, t) {
                for (t &= ~Fl, t &= ~Bl, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
                    var n = 31 - at(t), r = 1 << n;
                    e[n] = -1, t &= ~r
                }
            }

            function cc(e) {
                if (0 != (6 & Ll)) throw Error(s(327));
                Sc();
                var t = ht(e, 0);
                if (0 == (1 & t)) return ic(e, Xe()), null;
                var n = yc(e, t);
                if (0 !== e.tag && 2 === n) {
                    var r = pt(e);
                    0 !== r && (t = r, n = ac(e, r))
                }
                if (1 === n) throw n = Dl, fc(e, 0), lc(e, t), ic(e, Xe()), n;
                if (6 === n) throw Error(s(345));
                return e.finishedWork = e.current.alternate, e.finishedLanes = t, Ec(e, Hl, zl), ic(e, Xe()), null
            }

            function uc(e, t) {
                var n = Ll;
                Ll |= 1;
                try {
                    return e(t)
                } finally {
                    0 === (Ll = n) && (Kl = Xe() + 500, Fi && $i())
                }
            }

            function dc(e) {
                null !== Yl && 0 === Yl.tag && 0 == (6 & Ll) && Sc();
                var t = Ll;
                Ll |= 1;
                var n = Rl.transition, r = bt;
                try {
                    if (Rl.transition = null, bt = 1, e) return e()
                } finally {
                    bt = r, Rl.transition = n, 0 == (6 & (Ll = t)) && $i()
                }
            }

            function hc() {
                jl = Il.current, Ai(Il)
            }

            function fc(e, t) {
                e.finishedWork = null, e.finishedLanes = 0;
                var n = e.timeoutHandle;
                if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Pl) for (n = Pl.return; null !== n;) {
                    var r = n;
                    switch (ts(r), r.tag) {
                        case 1:
                            null != (r = r.type.childContextTypes) && ji();
                            break;
                        case 3:
                            ia(), Ai(Li), Ai(Ri), ua();
                            break;
                        case 5:
                            aa(r);
                            break;
                        case 4:
                            ia();
                            break;
                        case 13:
                        case 19:
                            Ai(oa);
                            break;
                        case 10:
                            Es(r.type._context);
                            break;
                        case 22:
                        case 23:
                            hc()
                    }
                    n = n.return
                }
                if (_l = e, Pl = e = Ic(e.current, null), Nl = jl = t, Ml = 0, Dl = null, Fl = Bl = Ol = 0, Hl = Ul = null, null !== Ts) {
                    for (t = 0; t < Ts.length; t++) if (null !== (r = (n = Ts[t]).interleaved)) {
                        n.interleaved = null;
                        var i = r.next, s = n.pending;
                        if (null !== s) {
                            var a = s.next;
                            s.next = i, r.next = a
                        }
                        n.pending = r
                    }
                    Ts = null
                }
                return e
            }

            function pc(e, t) {
                for (; ;) {
                    var n = Pl;
                    try {
                        if (xs(), da.current = so, ya) {
                            for (var r = pa.memoizedState; null !== r;) {
                                var i = r.queue;
                                null !== i && (i.pending = null), r = r.next
                            }
                            ya = !1
                        }
                        if (fa = 0, ga = ma = pa = null, va = !1, ba = 0, Cl.current = null, null === n || null === n.return) {
                            Ml = 1, Dl = t, Pl = null;
                            break
                        }
                        e:{
                            var a = e, o = n.return, l = n, c = t;
                            if (t = Nl, l.flags |= 32768, null !== c && "object" == typeof c && "function" == typeof c.then) {
                                var u = c, d = l, h = d.tag;
                                if (0 == (1 & d.mode) && (0 === h || 11 === h || 15 === h)) {
                                    var f = d.alternate;
                                    f ? (d.updateQueue = f.updateQueue, d.memoizedState = f.memoizedState, d.lanes = f.lanes) : (d.updateQueue = null, d.memoizedState = null)
                                }
                                var p = yo(o);
                                if (null !== p) {
                                    p.flags &= -257, vo(p, o, l, 0, t), 1 & p.mode && go(a, u, t), c = u;
                                    var m = (t = p).updateQueue;
                                    if (null === m) {
                                        var g = new Set;
                                        g.add(c), t.updateQueue = g
                                    } else m.add(c);
                                    break e
                                }
                                if (0 == (1 & t)) {
                                    go(a, u, t), gc();
                                    break e
                                }
                                c = Error(s(426))
                            } else if (is && 1 & l.mode) {
                                var y = yo(o);
                                if (null !== y) {
                                    0 == (65536 & y.flags) && (y.flags |= 256), vo(y, o, l, 0, t), ps(co(c, l));
                                    break e
                                }
                            }
                            a = c = co(c, l), 4 !== Ml && (Ml = 2), null === Ul ? Ul = [a] : Ul.push(a), a = o;
                            do {
                                switch (a.tag) {
                                    case 3:
                                        a.flags |= 65536, t &= -t, a.lanes |= t, Ds(a, po(0, c, t));
                                        break e;
                                    case 1:
                                        l = c;
                                        var v = a.type, b = a.stateNode;
                                        if (0 == (128 & a.flags) && ("function" == typeof v.getDerivedStateFromError || null !== b && "function" == typeof b.componentDidCatch && (null === Wl || !Wl.has(b)))) {
                                            a.flags |= 65536, t &= -t, a.lanes |= t, Ds(a, mo(a, l, t));
                                            break e
                                        }
                                }
                                a = a.return
                            } while (null !== a)
                        }
                        xc(n)
                    } catch (e) {
                        t = e, Pl === n && null !== n && (Pl = n = n.return);
                        continue
                    }
                    break
                }
            }

            function mc() {
                var e = Tl.current;
                return Tl.current = so, null === e ? so : e
            }

            function gc() {
                0 !== Ml && 3 !== Ml && 2 !== Ml || (Ml = 4), null === _l || 0 == (268435455 & Ol) && 0 == (268435455 & Bl) || lc(_l, Nl)
            }

            function yc(e, t) {
                var n = Ll;
                Ll |= 2;
                var r = mc();
                for (_l === e && Nl === t || (zl = null, fc(e, t)); ;) try {
                    vc();
                    break
                } catch (t) {
                    pc(e, t)
                }
                if (xs(), Ll = n, Tl.current = r, null !== Pl) throw Error(s(261));
                return _l = null, Nl = 0, Ml
            }

            function vc() {
                for (; null !== Pl;) wc(Pl)
            }

            function bc() {
                for (; null !== Pl && !Ye();) wc(Pl)
            }

            function wc(e) {
                var t = kl(e.alternate, e, jl);
                e.memoizedProps = e.pendingProps, null === t ? xc(e) : Pl = t, Cl.current = null
            }

            function xc(e) {
                var t = e;
                do {
                    var n = t.alternate;
                    if (e = t.return, 0 == (32768 & t.flags)) {
                        if (null !== (n = Vo(n, t, jl))) return void (Pl = n)
                    } else {
                        if (null !== (n = Yo(n, t))) return n.flags &= 32767, void (Pl = n);
                        if (null === e) return Ml = 6, void (Pl = null);
                        e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null
                    }
                    if (null !== (t = t.sibling)) return void (Pl = t);
                    Pl = t = e
                } while (null !== t);
                0 === Ml && (Ml = 5)
            }

            function Ec(e, t, n) {
                var r = bt, i = Rl.transition;
                try {
                    Rl.transition = null, bt = 1, function (e, t, n, r) {
                        do {
                            Sc()
                        } while (null !== Yl);
                        if (0 != (6 & Ll)) throw Error(s(327));
                        n = e.finishedWork;
                        var i = e.finishedLanes;
                        if (null === n) return null;
                        if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(s(177));
                        e.callbackNode = null, e.callbackPriority = 0;
                        var a = n.lanes | n.childLanes;
                        if (function (e, t) {
                            var n = e.pendingLanes & ~t;
                            e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
                            var r = e.eventTimes;
                            for (e = e.expirationTimes; 0 < n;) {
                                var i = 31 - at(n), s = 1 << i;
                                t[i] = 0, r[i] = -1, e[i] = -1, n &= ~s
                            }
                        }(e, a), e === _l && (Pl = _l = null, Nl = 0), 0 == (2064 & n.subtreeFlags) && 0 == (2064 & n.flags) || Vl || (Vl = !0, _c(tt, (function () {
                            return Sc(), null
                        }))), a = 0 != (15990 & n.flags), 0 != (15990 & n.subtreeFlags) || a) {
                            a = Rl.transition, Rl.transition = null;
                            var o = bt;
                            bt = 1;
                            var l = Ll;
                            Ll |= 4, Cl.current = null, function (e, t) {
                                if (ei = zt, fr(e = hr())) {
                                    if ("selectionStart" in e) var n = {
                                        start: e.selectionStart,
                                        end: e.selectionEnd
                                    }; else e:{
                                        var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection();
                                        if (r && 0 !== r.rangeCount) {
                                            n = r.anchorNode;
                                            var i = r.anchorOffset, a = r.focusNode;
                                            r = r.focusOffset;
                                            try {
                                                n.nodeType, a.nodeType
                                            } catch (e) {
                                                n = null;
                                                break e
                                            }
                                            var o = 0, l = -1, c = -1, u = 0, d = 0, h = e, f = null;
                                            t:for (; ;) {
                                                for (var p; h !== n || 0 !== i && 3 !== h.nodeType || (l = o + i), h !== a || 0 !== r && 3 !== h.nodeType || (c = o + r), 3 === h.nodeType && (o += h.nodeValue.length), null !== (p = h.firstChild);) f = h, h = p;
                                                for (; ;) {
                                                    if (h === e) break t;
                                                    if (f === n && ++u === i && (l = o), f === a && ++d === r && (c = o), null !== (p = h.nextSibling)) break;
                                                    f = (h = f).parentNode
                                                }
                                                h = p
                                            }
                                            n = -1 === l || -1 === c ? null : {start: l, end: c}
                                        } else n = null
                                    }
                                    n = n || {start: 0, end: 0}
                                } else n = null;
                                for (ti = {
                                    focusedElem: e,
                                    selectionRange: n
                                }, zt = !1, Jo = t; null !== Jo;) if (e = (t = Jo).child, 0 != (1028 & t.subtreeFlags) && null !== e) e.return = t, Jo = e; else for (; null !== Jo;) {
                                    t = Jo;
                                    try {
                                        var m = t.alternate;
                                        if (0 != (1024 & t.flags)) switch (t.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                            case 5:
                                            case 6:
                                            case 4:
                                            case 17:
                                                break;
                                            case 1:
                                                if (null !== m) {
                                                    var g = m.memoizedProps, y = m.memoizedState, v = t.stateNode,
                                                        b = v.getSnapshotBeforeUpdate(t.elementType === t.type ? g : gs(t.type, g), y);
                                                    v.__reactInternalSnapshotBeforeUpdate = b
                                                }
                                                break;
                                            case 3:
                                                var w = t.stateNode.containerInfo;
                                                1 === w.nodeType ? w.textContent = "" : 9 === w.nodeType && w.documentElement && w.removeChild(w.documentElement);
                                                break;
                                            default:
                                                throw Error(s(163))
                                        }
                                    } catch (e) {
                                        Ac(t, t.return, e)
                                    }
                                    if (null !== (e = t.sibling)) {
                                        e.return = t.return, Jo = e;
                                        break
                                    }
                                    Jo = t.return
                                }
                                m = nl, nl = !1
                            }(e, n), yl(n, e), pr(ti), zt = !!ei, ti = ei = null, e.current = n, bl(n, e, i), Ze(), Ll = l, bt = o, Rl.transition = a
                        } else e.current = n;
                        if (Vl && (Vl = !1, Yl = e, Zl = i), 0 === (a = e.pendingLanes) && (Wl = null), function (e) {
                            if (st && "function" == typeof st.onCommitFiberRoot) try {
                                st.onCommitFiberRoot(it, e, void 0, 128 == (128 & e.current.flags))
                            } catch (e) {
                            }
                        }(n.stateNode), ic(e, Xe()), null !== t) for (r = e.onRecoverableError, n = 0; n < t.length; n++) r((i = t[n]).value, {
                            componentStack: i.stack,
                            digest: i.digest
                        });
                        if (Gl) throw Gl = !1, e = ql, ql = null, e;
                        0 != (1 & Zl) && 0 !== e.tag && Sc(), 0 != (1 & (a = e.pendingLanes)) ? e === Ql ? Xl++ : (Xl = 0, Ql = e) : Xl = 0, $i()
                    }(e, t, n, r)
                } finally {
                    Rl.transition = i, bt = r
                }
                return null
            }

            function Sc() {
                if (null !== Yl) {
                    var e = wt(Zl), t = Rl.transition, n = bt;
                    try {
                        if (Rl.transition = null, bt = 16 > e ? 16 : e, null === Yl) var r = !1; else {
                            if (e = Yl, Yl = null, Zl = 0, 0 != (6 & Ll)) throw Error(s(331));
                            var i = Ll;
                            for (Ll |= 4, Jo = e.current; null !== Jo;) {
                                var a = Jo, o = a.child;
                                if (0 != (16 & Jo.flags)) {
                                    var l = a.deletions;
                                    if (null !== l) {
                                        for (var c = 0; c < l.length; c++) {
                                            var u = l[c];
                                            for (Jo = u; null !== Jo;) {
                                                var d = Jo;
                                                switch (d.tag) {
                                                    case 0:
                                                    case 11:
                                                    case 15:
                                                        rl(8, d, a)
                                                }
                                                var h = d.child;
                                                if (null !== h) h.return = d, Jo = h; else for (; null !== Jo;) {
                                                    var f = (d = Jo).sibling, p = d.return;
                                                    if (al(d), d === u) {
                                                        Jo = null;
                                                        break
                                                    }
                                                    if (null !== f) {
                                                        f.return = p, Jo = f;
                                                        break
                                                    }
                                                    Jo = p
                                                }
                                            }
                                        }
                                        var m = a.alternate;
                                        if (null !== m) {
                                            var g = m.child;
                                            if (null !== g) {
                                                m.child = null;
                                                do {
                                                    var y = g.sibling;
                                                    g.sibling = null, g = y
                                                } while (null !== g)
                                            }
                                        }
                                        Jo = a
                                    }
                                }
                                if (0 != (2064 & a.subtreeFlags) && null !== o) o.return = a, Jo = o; else e:for (; null !== Jo;) {
                                    if (0 != (2048 & (a = Jo).flags)) switch (a.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            rl(9, a, a.return)
                                    }
                                    var v = a.sibling;
                                    if (null !== v) {
                                        v.return = a.return, Jo = v;
                                        break e
                                    }
                                    Jo = a.return
                                }
                            }
                            var b = e.current;
                            for (Jo = b; null !== Jo;) {
                                var w = (o = Jo).child;
                                if (0 != (2064 & o.subtreeFlags) && null !== w) w.return = o, Jo = w; else e:for (o = b; null !== Jo;) {
                                    if (0 != (2048 & (l = Jo).flags)) try {
                                        switch (l.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                il(9, l)
                                        }
                                    } catch (e) {
                                        Ac(l, l.return, e)
                                    }
                                    if (l === o) {
                                        Jo = null;
                                        break e
                                    }
                                    var x = l.sibling;
                                    if (null !== x) {
                                        x.return = l.return, Jo = x;
                                        break e
                                    }
                                    Jo = l.return
                                }
                            }
                            if (Ll = i, $i(), st && "function" == typeof st.onPostCommitFiberRoot) try {
                                st.onPostCommitFiberRoot(it, e)
                            } catch (e) {
                            }
                            r = !0
                        }
                        return r
                    } finally {
                        bt = n, Rl.transition = t
                    }
                }
                return !1
            }

            function kc(e, t, n) {
                e = Is(e, t = po(0, t = co(n, t), 1), 1), t = tc(), null !== e && (yt(e, 1, t), ic(e, t))
            }

            function Ac(e, t, n) {
                if (3 === e.tag) kc(e, e, n); else for (; null !== t;) {
                    if (3 === t.tag) {
                        kc(t, e, n);
                        break
                    }
                    if (1 === t.tag) {
                        var r = t.stateNode;
                        if ("function" == typeof t.type.getDerivedStateFromError || "function" == typeof r.componentDidCatch && (null === Wl || !Wl.has(r))) {
                            t = Is(t, e = mo(t, e = co(n, e), 1), 1), e = tc(), null !== t && (yt(t, 1, e), ic(t, e));
                            break
                        }
                    }
                    t = t.return
                }
            }

            function Tc(e, t, n) {
                var r = e.pingCache;
                null !== r && r.delete(t), t = tc(), e.pingedLanes |= e.suspendedLanes & n, _l === e && (Nl & n) === n && (4 === Ml || 3 === Ml && (130023424 & Nl) === Nl && 500 > Xe() - $l ? fc(e, 0) : Fl |= n), ic(e, t)
            }

            function Cc(e, t) {
                0 === t && (0 == (1 & e.mode) ? t = 1 : (t = ut, 0 == (130023424 & (ut <<= 1)) && (ut = 4194304)));
                var n = tc();
                null !== (e = Ls(e, t)) && (yt(e, t, n), ic(e, n))
            }

            function Rc(e) {
                var t = e.memoizedState, n = 0;
                null !== t && (n = t.retryLane), Cc(e, n)
            }

            function Lc(e, t) {
                var n = 0;
                switch (e.tag) {
                    case 13:
                        var r = e.stateNode, i = e.memoizedState;
                        null !== i && (n = i.retryLane);
                        break;
                    case 19:
                        r = e.stateNode;
                        break;
                    default:
                        throw Error(s(314))
                }
                null !== r && r.delete(t), Cc(e, n)
            }

            function _c(e, t) {
                return We(e, t)
            }

            function Pc(e, t, n, r) {
                this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
            }

            function Nc(e, t, n, r) {
                return new Pc(e, t, n, r)
            }

            function jc(e) {
                return !(!(e = e.prototype) || !e.isReactComponent)
            }

            function Ic(e, t) {
                var n = e.alternate;
                return null === n ? ((n = Nc(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : {
                    lanes: t.lanes,
                    firstContext: t.firstContext
                }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
            }

            function Mc(e, t, n, r, i, a) {
                var o = 2;
                if (r = e, "function" == typeof e) jc(e) && (o = 1); else if ("string" == typeof e) o = 5; else e:switch (e) {
                    case S:
                        return Dc(n.children, i, a, t);
                    case k:
                        o = 8, i |= 8;
                        break;
                    case A:
                        return (e = Nc(12, n, t, 2 | i)).elementType = A, e.lanes = a, e;
                    case L:
                        return (e = Nc(13, n, t, i)).elementType = L, e.lanes = a, e;
                    case _:
                        return (e = Nc(19, n, t, i)).elementType = _, e.lanes = a, e;
                    case j:
                        return Oc(n, i, a, t);
                    default:
                        if ("object" == typeof e && null !== e) switch (e.$$typeof) {
                            case T:
                                o = 10;
                                break e;
                            case C:
                                o = 9;
                                break e;
                            case R:
                                o = 11;
                                break e;
                            case P:
                                o = 14;
                                break e;
                            case N:
                                o = 16, r = null;
                                break e
                        }
                        throw Error(s(130, null == e ? e : typeof e, ""))
                }
                return (t = Nc(o, n, t, i)).elementType = e, t.type = r, t.lanes = a, t
            }

            function Dc(e, t, n, r) {
                return (e = Nc(7, e, r, t)).lanes = n, e
            }

            function Oc(e, t, n, r) {
                return (e = Nc(22, e, r, t)).elementType = j, e.lanes = n, e.stateNode = {isHidden: !1}, e
            }

            function Bc(e, t, n) {
                return (e = Nc(6, e, null, t)).lanes = n, e
            }

            function Fc(e, t, n) {
                return (t = Nc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = {
                    containerInfo: e.containerInfo,
                    pendingChildren: null,
                    implementation: e.implementation
                }, t
            }

            function Uc(e, t, n, r, i) {
                this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
            }

            function Hc(e, t, n, r, i, s, a, o, l) {
                return e = new Uc(e, t, n, o, l), 1 === t ? (t = 1, !0 === s && (t |= 8)) : t = 0, s = Nc(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = {
                    element: r,
                    isDehydrated: n,
                    cache: null,
                    transitions: null,
                    pendingSuspenseBoundaries: null
                }, Ps(s), e
            }

            function $c(e) {
                if (!e) return Ci;
                e:{
                    if ($e(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(s(170));
                    var t = e;
                    do {
                        switch (t.tag) {
                            case 3:
                                t = t.stateNode.context;
                                break e;
                            case 1:
                                if (Ni(t.type)) {
                                    t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                                    break e
                                }
                        }
                        t = t.return
                    } while (null !== t);
                    throw Error(s(171))
                }
                if (1 === e.tag) {
                    var n = e.type;
                    if (Ni(n)) return Mi(e, n, t)
                }
                return t
            }

            function Kc(e, t, n, r, i, s, a, o, l) {
                return (e = Hc(n, r, !0, e, 0, s, 0, o, l)).context = $c(null), n = e.current, (s = js(r = tc(), i = nc(n))).callback = null != t ? t : null, Is(n, s, i), e.current.lanes = i, yt(e, i, r), ic(e, r), e
            }

            function zc(e, t, n, r) {
                var i = t.current, s = tc(), a = nc(i);
                return n = $c(n), null === t.context ? t.context = n : t.pendingContext = n, (t = js(s, a)).payload = {element: e}, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = Is(i, t, a)) && (rc(e, i, a, s), Ms(e, i, a)), a
            }

            function Gc(e) {
                return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null
            }

            function qc(e, t) {
                if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                    var n = e.retryLane;
                    e.retryLane = 0 !== n && n < t ? n : t
                }
            }

            function Wc(e, t) {
                qc(e, t), (e = e.alternate) && qc(e, t)
            }

            kl = function (e, t, n) {
                if (null !== e) if (e.memoizedProps !== t.pendingProps || Li.current) wo = !0; else {
                    if (0 == (e.lanes & n) && 0 == (128 & t.flags)) return wo = !1, function (e, t, n) {
                        switch (t.tag) {
                            case 3:
                                _o(t), fs();
                                break;
                            case 5:
                                sa(t);
                                break;
                            case 1:
                                Ni(t.type) && Di(t);
                                break;
                            case 4:
                                ra(t, t.stateNode.containerInfo);
                                break;
                            case 10:
                                var r = t.type._context, i = t.memoizedProps.value;
                                Ti(ys, r._currentValue), r._currentValue = i;
                                break;
                            case 13:
                                if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ti(oa, 1 & oa.current), t.flags |= 128, null) : 0 != (n & t.child.childLanes) ? Bo(e, t, n) : (Ti(oa, 1 & oa.current), null !== (e = Go(e, t, n)) ? e.sibling : null);
                                Ti(oa, 1 & oa.current);
                                break;
                            case 19:
                                if (r = 0 != (n & t.childLanes), 0 != (128 & e.flags)) {
                                    if (r) return Ko(e, t, n);
                                    t.flags |= 128
                                }
                                if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ti(oa, oa.current), r) break;
                                return null;
                            case 22:
                            case 23:
                                return t.lanes = 0, Ao(e, t, n)
                        }
                        return Go(e, t, n)
                    }(e, t, n);
                    wo = 0 != (131072 & e.flags)
                } else wo = !1, is && 0 != (1048576 & t.flags) && Ji(t, qi, t.index);
                switch (t.lanes = 0, t.tag) {
                    case 2:
                        var r = t.type;
                        zo(e, t), e = t.pendingProps;
                        var i = Pi(t, Ri.current);
                        ks(t, n), i = Sa(null, t, r, e, i, n);
                        var a = ka();
                        return t.flags |= 1, "object" == typeof i && null !== i && "function" == typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ni(r) ? (a = !0, Di(t)) : a = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, Ps(t), i.updater = Hs, t.stateNode = i, i._reactInternals = t, Gs(t, r, e, n), t = Lo(null, t, r, !0, a, n)) : (t.tag = 0, is && a && es(t), xo(null, t, i, n), t = t.child), t;
                    case 16:
                        r = t.elementType;
                        e:{
                            switch (zo(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function (e) {
                                if ("function" == typeof e) return jc(e) ? 1 : 0;
                                if (null != e) {
                                    if ((e = e.$$typeof) === R) return 11;
                                    if (e === P) return 14
                                }
                                return 2
                            }(r), e = gs(r, e), i) {
                                case 0:
                                    t = Co(null, t, r, e, n);
                                    break e;
                                case 1:
                                    t = Ro(null, t, r, e, n);
                                    break e;
                                case 11:
                                    t = Eo(null, t, r, e, n);
                                    break e;
                                case 14:
                                    t = So(null, t, r, gs(r.type, e), n);
                                    break e
                            }
                            throw Error(s(306, r, ""))
                        }
                        return t;
                    case 0:
                        return r = t.type, i = t.pendingProps, Co(e, t, r, i = t.elementType === r ? i : gs(r, i), n);
                    case 1:
                        return r = t.type, i = t.pendingProps, Ro(e, t, r, i = t.elementType === r ? i : gs(r, i), n);
                    case 3:
                        e:{
                            if (_o(t), null === e) throw Error(s(387));
                            r = t.pendingProps, i = (a = t.memoizedState).element, Ns(e, t), Os(t, r, null, n);
                            var o = t.memoizedState;
                            if (r = o.element, a.isDehydrated) {
                                if (a = {
                                    element: r,
                                    isDehydrated: !1,
                                    cache: o.cache,
                                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                                    transitions: o.transitions
                                }, t.updateQueue.baseState = a, t.memoizedState = a, 256 & t.flags) {
                                    t = Po(e, t, r, n, i = co(Error(s(423)), t));
                                    break e
                                }
                                if (r !== i) {
                                    t = Po(e, t, r, n, i = co(Error(s(424)), t));
                                    break e
                                }
                                for (rs = ci(t.stateNode.containerInfo.firstChild), ns = t, is = !0, ss = null, n = Xs(t, null, r, n), t.child = n; n;) n.flags = -3 & n.flags | 4096, n = n.sibling
                            } else {
                                if (fs(), r === i) {
                                    t = Go(e, t, n);
                                    break e
                                }
                                xo(e, t, r, n)
                            }
                            t = t.child
                        }
                        return t;
                    case 5:
                        return sa(t), null === e && cs(t), r = t.type, i = t.pendingProps, a = null !== e ? e.memoizedProps : null, o = i.children, ni(r, i) ? o = null : null !== a && ni(r, a) && (t.flags |= 32), To(e, t), xo(e, t, o, n), t.child;
                    case 6:
                        return null === e && cs(t), null;
                    case 13:
                        return Bo(e, t, n);
                    case 4:
                        return ra(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = Zs(t, null, r, n) : xo(e, t, r, n), t.child;
                    case 11:
                        return r = t.type, i = t.pendingProps, Eo(e, t, r, i = t.elementType === r ? i : gs(r, i), n);
                    case 7:
                        return xo(e, t, t.pendingProps, n), t.child;
                    case 8:
                    case 12:
                        return xo(e, t, t.pendingProps.children, n), t.child;
                    case 10:
                        e:{
                            if (r = t.type._context, i = t.pendingProps, a = t.memoizedProps, o = i.value, Ti(ys, r._currentValue), r._currentValue = o, null !== a) if (or(a.value, o)) {
                                if (a.children === i.children && !Li.current) {
                                    t = Go(e, t, n);
                                    break e
                                }
                            } else for (null !== (a = t.child) && (a.return = t); null !== a;) {
                                var l = a.dependencies;
                                if (null !== l) {
                                    o = a.child;
                                    for (var c = l.firstContext; null !== c;) {
                                        if (c.context === r) {
                                            if (1 === a.tag) {
                                                (c = js(-1, n & -n)).tag = 2;
                                                var u = a.updateQueue;
                                                if (null !== u) {
                                                    var d = (u = u.shared).pending;
                                                    null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c
                                                }
                                            }
                                            a.lanes |= n, null !== (c = a.alternate) && (c.lanes |= n), Ss(a.return, n, t), l.lanes |= n;
                                            break
                                        }
                                        c = c.next
                                    }
                                } else if (10 === a.tag) o = a.type === t.type ? null : a.child; else if (18 === a.tag) {
                                    if (null === (o = a.return)) throw Error(s(341));
                                    o.lanes |= n, null !== (l = o.alternate) && (l.lanes |= n), Ss(o, n, t), o = a.sibling
                                } else o = a.child;
                                if (null !== o) o.return = a; else for (o = a; null !== o;) {
                                    if (o === t) {
                                        o = null;
                                        break
                                    }
                                    if (null !== (a = o.sibling)) {
                                        a.return = o.return, o = a;
                                        break
                                    }
                                    o = o.return
                                }
                                a = o
                            }
                            xo(e, t, i.children, n), t = t.child
                        }
                        return t;
                    case 9:
                        return i = t.type, r = t.pendingProps.children, ks(t, n), r = r(i = As(i)), t.flags |= 1, xo(e, t, r, n), t.child;
                    case 14:
                        return i = gs(r = t.type, t.pendingProps), So(e, t, r, i = gs(r.type, i), n);
                    case 15:
                        return ko(e, t, t.type, t.pendingProps, n);
                    case 17:
                        return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : gs(r, i), zo(e, t), t.tag = 1, Ni(r) ? (e = !0, Di(t)) : e = !1, ks(t, n), Ks(t, r, i), Gs(t, r, i, n), Lo(null, t, r, !0, e, n);
                    case 19:
                        return Ko(e, t, n);
                    case 22:
                        return Ao(e, t, n)
                }
                throw Error(s(156, t.tag))
            };
            var Vc = "function" == typeof reportError ? reportError : function (e) {
                console.error(e)
            };

            function Yc(e) {
                this._internalRoot = e
            }

            function Zc(e) {
                this._internalRoot = e
            }

            function Xc(e) {
                return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
            }

            function Qc(e) {
                return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue))
            }

            function Jc() {
            }

            function eu(e, t, n, r, i) {
                var s = n._reactRootContainer;
                if (s) {
                    var a = s;
                    if ("function" == typeof i) {
                        var o = i;
                        i = function () {
                            var e = Gc(a);
                            o.call(e)
                        }
                    }
                    zc(t, a, e, i)
                } else a = function (e, t, n, r, i) {
                    if (i) {
                        if ("function" == typeof r) {
                            var s = r;
                            r = function () {
                                var e = Gc(a);
                                s.call(e)
                            }
                        }
                        var a = Kc(t, r, e, 0, null, !1, 0, "", Jc);
                        return e._reactRootContainer = a, e[pi] = a.current, $r(8 === e.nodeType ? e.parentNode : e), dc(), a
                    }
                    for (; i = e.lastChild;) e.removeChild(i);
                    if ("function" == typeof r) {
                        var o = r;
                        r = function () {
                            var e = Gc(l);
                            o.call(e)
                        }
                    }
                    var l = Hc(e, 0, !1, null, 0, !1, 0, "", Jc);
                    return e._reactRootContainer = l, e[pi] = l.current, $r(8 === e.nodeType ? e.parentNode : e), dc((function () {
                        zc(t, l, n, r)
                    })), l
                }(n, t, e, i, r);
                return Gc(a)
            }

            Zc.prototype.render = Yc.prototype.render = function (e) {
                var t = this._internalRoot;
                if (null === t) throw Error(s(409));
                zc(e, t, null, null)
            }, Zc.prototype.unmount = Yc.prototype.unmount = function () {
                var e = this._internalRoot;
                if (null !== e) {
                    this._internalRoot = null;
                    var t = e.containerInfo;
                    dc((function () {
                        zc(null, e, null, null)
                    })), t[pi] = null
                }
            }, Zc.prototype.unstable_scheduleHydration = function (e) {
                if (e) {
                    var t = kt();
                    e = {blockedOn: null, target: e, priority: t};
                    for (var n = 0; n < jt.length && 0 !== t && t < jt[n].priority; n++) ;
                    jt.splice(n, 0, e), 0 === n && Ot(e)
                }
            }, xt = function (e) {
                switch (e.tag) {
                    case 3:
                        var t = e.stateNode;
                        if (t.current.memoizedState.isDehydrated) {
                            var n = dt(t.pendingLanes);
                            0 !== n && (vt(t, 1 | n), ic(t, Xe()), 0 == (6 & Ll) && (Kl = Xe() + 500, $i()))
                        }
                        break;
                    case 13:
                        dc((function () {
                            var t = Ls(e, 1);
                            if (null !== t) {
                                var n = tc();
                                rc(t, e, 1, n)
                            }
                        })), Wc(e, 1)
                }
            }, Et = function (e) {
                if (13 === e.tag) {
                    var t = Ls(e, 134217728);
                    null !== t && rc(t, e, 134217728, tc()), Wc(e, 134217728)
                }
            }, St = function (e) {
                if (13 === e.tag) {
                    var t = nc(e), n = Ls(e, t);
                    null !== n && rc(n, e, t, tc()), Wc(e, t)
                }
            }, kt = function () {
                return bt
            }, At = function (e, t) {
                var n = bt;
                try {
                    return bt = e, t()
                } finally {
                    bt = n
                }
            }, Ee = function (e, t, n) {
                switch (t) {
                    case"input":
                        if (Q(e, n), t = n.name, "radio" === n.type && null != t) {
                            for (n = e; n.parentNode;) n = n.parentNode;
                            for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
                                var r = n[t];
                                if (r !== e && r.form === e.form) {
                                    var i = xi(r);
                                    if (!i) throw Error(s(90));
                                    W(r), Q(r, i)
                                }
                            }
                        }
                        break;
                    case"textarea":
                        se(e, n);
                        break;
                    case"select":
                        null != (t = n.value) && ne(e, !!n.multiple, t, !1)
                }
            }, Re = uc, Le = dc;
            var tu = {usingClientEntryPoint: !1, Events: [bi, wi, xi, Te, Ce, uc]},
                nu = {findFiberByHostInstance: vi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom"},
                ru = {
                    bundleType: nu.bundleType,
                    version: nu.version,
                    rendererPackageName: nu.rendererPackageName,
                    rendererConfig: nu.rendererConfig,
                    overrideHookState: null,
                    overrideHookStateDeletePath: null,
                    overrideHookStateRenamePath: null,
                    overrideProps: null,
                    overridePropsDeletePath: null,
                    overridePropsRenamePath: null,
                    setErrorHandler: null,
                    setSuspenseHandler: null,
                    scheduleUpdate: null,
                    currentDispatcherRef: w.ReactCurrentDispatcher,
                    findHostInstanceByFiber: function (e) {
                        return null === (e = Ge(e)) ? null : e.stateNode
                    },
                    findFiberByHostInstance: nu.findFiberByHostInstance || function () {
                        return null
                    },
                    findHostInstancesForRefresh: null,
                    scheduleRefresh: null,
                    scheduleRoot: null,
                    setRefreshHandler: null,
                    getCurrentFiber: null,
                    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
                };
            if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                var iu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (!iu.isDisabled && iu.supportsFiber) try {
                    it = iu.inject(ru), st = iu
                } catch (ue) {
                }
            }
            t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu, t.createPortal = function (e, t) {
                var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                if (!Xc(t)) throw Error(s(200));
                return function (e, t, n) {
                    var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                    return {
                        $$typeof: E,
                        key: null == r ? null : "" + r,
                        children: e,
                        containerInfo: t,
                        implementation: n
                    }
                }(e, t, null, n)
            }, t.createRoot = function (e, t) {
                if (!Xc(e)) throw Error(s(299));
                var n = !1, r = "", i = Vc;
                return null != t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Hc(e, 1, !1, null, 0, n, 0, r, i), e[pi] = t.current, $r(8 === e.nodeType ? e.parentNode : e), new Yc(t)
            }, t.findDOMNode = function (e) {
                if (null == e) return null;
                if (1 === e.nodeType) return e;
                var t = e._reactInternals;
                if (void 0 === t) {
                    if ("function" == typeof e.render) throw Error(s(188));
                    throw e = Object.keys(e).join(","), Error(s(268, e))
                }
                return null === (e = Ge(t)) ? null : e.stateNode
            }, t.flushSync = function (e) {
                return dc(e)
            }, t.hydrate = function (e, t, n) {
                if (!Qc(t)) throw Error(s(200));
                return eu(null, e, t, !0, n)
            }, t.hydrateRoot = function (e, t, n) {
                if (!Xc(e)) throw Error(s(405));
                var r = null != n && n.hydratedSources || null, i = !1, a = "", o = Vc;
                if (null != n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (a = n.identifierPrefix), void 0 !== n.onRecoverableError && (o = n.onRecoverableError)), t = Kc(t, null, e, 1, null != n ? n : null, i, 0, a, o), e[pi] = t.current, $r(e), r) for (e = 0; e < r.length; e++) i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
                return new Zc(t)
            }, t.render = function (e, t, n) {
                if (!Qc(t)) throw Error(s(200));
                return eu(null, e, t, !1, n)
            }, t.unmountComponentAtNode = function (e) {
                if (!Qc(e)) throw Error(s(40));
                return !!e._reactRootContainer && (dc((function () {
                    eu(null, null, e, !1, (function () {
                        e._reactRootContainer = null, e[pi] = null
                    }))
                })), !0)
            }, t.unstable_batchedUpdates = uc, t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
                if (!Qc(n)) throw Error(s(200));
                if (null == e || void 0 === e._reactInternals) throw Error(s(38));
                return eu(e, t, n, !1, r)
            }, t.version = "18.2.0-next-9e3b772b8-20220608"
        }, 7029: (e, t, n) => {
            "use strict";
            var r = n(8316);
            t.s = r.createRoot, r.hydrateRoot
        }, 8316: (e, t, n) => {
            "use strict";
            !function e() {
                if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try {
                    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
                } catch (e) {
                    console.error(e)
                }
            }(), e.exports = n(2967)
        }, 6866: (e, t) => {
            "use strict";
            var n = "function" == typeof Symbol && Symbol.for, r = n ? Symbol.for("react.element") : 60103,
                i = n ? Symbol.for("react.portal") : 60106, s = n ? Symbol.for("react.fragment") : 60107,
                a = n ? Symbol.for("react.strict_mode") : 60108, o = n ? Symbol.for("react.profiler") : 60114,
                l = n ? Symbol.for("react.provider") : 60109, c = n ? Symbol.for("react.context") : 60110,
                u = n ? Symbol.for("react.async_mode") : 60111, d = n ? Symbol.for("react.concurrent_mode") : 60111,
                h = n ? Symbol.for("react.forward_ref") : 60112, f = n ? Symbol.for("react.suspense") : 60113,
                p = n ? Symbol.for("react.suspense_list") : 60120, m = n ? Symbol.for("react.memo") : 60115,
                g = n ? Symbol.for("react.lazy") : 60116, y = n ? Symbol.for("react.block") : 60121,
                v = n ? Symbol.for("react.fundamental") : 60117, b = n ? Symbol.for("react.responder") : 60118,
                w = n ? Symbol.for("react.scope") : 60119;

            function x(e) {
                if ("object" == typeof e && null !== e) {
                    var t = e.$$typeof;
                    switch (t) {
                        case r:
                            switch (e = e.type) {
                                case u:
                                case d:
                                case s:
                                case o:
                                case a:
                                case f:
                                    return e;
                                default:
                                    switch (e = e && e.$$typeof) {
                                        case c:
                                        case h:
                                        case g:
                                        case m:
                                        case l:
                                            return e;
                                        default:
                                            return t
                                    }
                            }
                        case i:
                            return t
                    }
                }
            }

            function E(e) {
                return x(e) === d
            }

            t.AsyncMode = u, t.ConcurrentMode = d, t.ContextConsumer = c, t.ContextProvider = l, t.Element = r, t.ForwardRef = h, t.Fragment = s, t.Lazy = g, t.Memo = m, t.Portal = i, t.Profiler = o, t.StrictMode = a, t.Suspense = f, t.isAsyncMode = function (e) {
                return E(e) || x(e) === u
            }, t.isConcurrentMode = E, t.isContextConsumer = function (e) {
                return x(e) === c
            }, t.isContextProvider = function (e) {
                return x(e) === l
            }, t.isElement = function (e) {
                return "object" == typeof e && null !== e && e.$$typeof === r
            }, t.isForwardRef = function (e) {
                return x(e) === h
            }, t.isFragment = function (e) {
                return x(e) === s
            }, t.isLazy = function (e) {
                return x(e) === g
            }, t.isMemo = function (e) {
                return x(e) === m
            }, t.isPortal = function (e) {
                return x(e) === i
            }, t.isProfiler = function (e) {
                return x(e) === o
            }, t.isStrictMode = function (e) {
                return x(e) === a
            }, t.isSuspense = function (e) {
                return x(e) === f
            }, t.isValidElementType = function (e) {
                return "string" == typeof e || "function" == typeof e || e === s || e === d || e === o || e === a || e === f || e === p || "object" == typeof e && null !== e && (e.$$typeof === g || e.$$typeof === m || e.$$typeof === l || e.$$typeof === c || e.$$typeof === h || e.$$typeof === v || e.$$typeof === b || e.$$typeof === w || e.$$typeof === y)
            }, t.typeOf = x
        }, 8570: (e, t, n) => {
            "use strict";
            e.exports = n(6866)
        }, 8559: (e, t) => {
            "use strict";
            Symbol.for("react.element"), Symbol.for("react.portal"), Symbol.for("react.fragment"), Symbol.for("react.strict_mode"), Symbol.for("react.profiler"), Symbol.for("react.provider"), Symbol.for("react.context"), Symbol.for("react.server_context"), Symbol.for("react.forward_ref"), Symbol.for("react.suspense"), Symbol.for("react.suspense_list"), Symbol.for("react.memo"), Symbol.for("react.lazy"), Symbol.for("react.offscreen");
            Symbol.for("react.module.reference")
        }, 3920: (e, t, n) => {
            "use strict";
            n(8559)
        }, 1837: (e, t, n) => {
            "use strict";
            var r = n(2784), i = Symbol.for("react.element"), s = Symbol.for("react.fragment"),
                a = Object.prototype.hasOwnProperty,
                o = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
                l = {key: !0, ref: !0, __self: !0, __source: !0};

            function c(e, t, n) {
                var r, s = {}, c = null, u = null;
                for (r in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (u = t.ref), t) a.call(t, r) && !l.hasOwnProperty(r) && (s[r] = t[r]);
                if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === s[r] && (s[r] = t[r]);
                return {$$typeof: i, type: e, key: c, ref: u, props: s, _owner: o.current}
            }

            t.Fragment = s, t.jsx = c, t.jsxs = c
        }, 3426: (e, t) => {
            "use strict";
            var n = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"),
                s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"),
                l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"),
                d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.iterator, p = {
                    isMounted: function () {
                        return !1
                    }, enqueueForceUpdate: function () {
                    }, enqueueReplaceState: function () {
                    }, enqueueSetState: function () {
                    }
                }, m = Object.assign, g = {};

            function y(e, t, n) {
                this.props = e, this.context = t, this.refs = g, this.updater = n || p
            }

            function v() {
            }

            function b(e, t, n) {
                this.props = e, this.context = t, this.refs = g, this.updater = n || p
            }

            y.prototype.isReactComponent = {}, y.prototype.setState = function (e, t) {
                if ("object" != typeof e && "function" != typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                this.updater.enqueueSetState(this, e, t, "setState")
            }, y.prototype.forceUpdate = function (e) {
                this.updater.enqueueForceUpdate(this, e, "forceUpdate")
            }, v.prototype = y.prototype;
            var w = b.prototype = new v;
            w.constructor = b, m(w, y.prototype), w.isPureReactComponent = !0;
            var x = Array.isArray, E = Object.prototype.hasOwnProperty, S = {current: null},
                k = {key: !0, ref: !0, __self: !0, __source: !0};

            function A(e, t, r) {
                var i, s = {}, a = null, o = null;
                if (null != t) for (i in void 0 !== t.ref && (o = t.ref), void 0 !== t.key && (a = "" + t.key), t) E.call(t, i) && !k.hasOwnProperty(i) && (s[i] = t[i]);
                var l = arguments.length - 2;
                if (1 === l) s.children = r; else if (1 < l) {
                    for (var c = Array(l), u = 0; u < l; u++) c[u] = arguments[u + 2];
                    s.children = c
                }
                if (e && e.defaultProps) for (i in l = e.defaultProps) void 0 === s[i] && (s[i] = l[i]);
                return {$$typeof: n, type: e, key: a, ref: o, props: s, _owner: S.current}
            }

            function T(e) {
                return "object" == typeof e && null !== e && e.$$typeof === n
            }

            var C = /\/+/g;

            function R(e, t) {
                return "object" == typeof e && null !== e && null != e.key ? function (e) {
                    var t = {"=": "=0", ":": "=2"};
                    return "$" + e.replace(/[=:]/g, (function (e) {
                        return t[e]
                    }))
                }("" + e.key) : t.toString(36)
            }

            function L(e, t, i, s, a) {
                var o = typeof e;
                "undefined" !== o && "boolean" !== o || (e = null);
                var l = !1;
                if (null === e) l = !0; else switch (o) {
                    case"string":
                    case"number":
                        l = !0;
                        break;
                    case"object":
                        switch (e.$$typeof) {
                            case n:
                            case r:
                                l = !0
                        }
                }
                if (l) return a = a(l = e), e = "" === s ? "." + R(l, 0) : s, x(a) ? (i = "", null != e && (i = e.replace(C, "$&/") + "/"), L(a, t, i, "", (function (e) {
                    return e
                }))) : null != a && (T(a) && (a = function (e, t) {
                    return {$$typeof: n, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner}
                }(a, i + (!a.key || l && l.key === a.key ? "" : ("" + a.key).replace(C, "$&/") + "/") + e)), t.push(a)), 1;
                if (l = 0, s = "" === s ? "." : s + ":", x(e)) for (var c = 0; c < e.length; c++) {
                    var u = s + R(o = e[c], c);
                    l += L(o, t, i, u, a)
                } else if (u = function (e) {
                    return null === e || "object" != typeof e ? null : "function" == typeof (e = f && e[f] || e["@@iterator"]) ? e : null
                }(e), "function" == typeof u) for (e = u.call(e), c = 0; !(o = e.next()).done;) l += L(o = o.value, t, i, u = s + R(o, c++), a); else if ("object" === o) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
                return l
            }

            function _(e, t, n) {
                if (null == e) return e;
                var r = [], i = 0;
                return L(e, r, "", "", (function (e) {
                    return t.call(n, e, i++)
                })), r
            }

            function P(e) {
                if (-1 === e._status) {
                    var t = e._result;
                    (t = t()).then((function (t) {
                        0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t)
                    }), (function (t) {
                        0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t)
                    })), -1 === e._status && (e._status = 0, e._result = t)
                }
                if (1 === e._status) return e._result.default;
                throw e._result
            }

            var N = {current: null}, j = {transition: null},
                I = {ReactCurrentDispatcher: N, ReactCurrentBatchConfig: j, ReactCurrentOwner: S};
            t.Children = {
                map: _, forEach: function (e, t, n) {
                    _(e, (function () {
                        t.apply(this, arguments)
                    }), n)
                }, count: function (e) {
                    var t = 0;
                    return _(e, (function () {
                        t++
                    })), t
                }, toArray: function (e) {
                    return _(e, (function (e) {
                        return e
                    })) || []
                }, only: function (e) {
                    if (!T(e)) throw Error("React.Children.only expected to receive a single React element child.");
                    return e
                }
            }, t.Component = y, t.Fragment = i, t.Profiler = a, t.PureComponent = b, t.StrictMode = s, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = I, t.cloneElement = function (e, t, r) {
                if (null == e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
                var i = m({}, e.props), s = e.key, a = e.ref, o = e._owner;
                if (null != t) {
                    if (void 0 !== t.ref && (a = t.ref, o = S.current), void 0 !== t.key && (s = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps;
                    for (c in t) E.call(t, c) && !k.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c])
                }
                var c = arguments.length - 2;
                if (1 === c) i.children = r; else if (1 < c) {
                    l = Array(c);
                    for (var u = 0; u < c; u++) l[u] = arguments[u + 2];
                    i.children = l
                }
                return {$$typeof: n, type: e.type, key: s, ref: a, props: i, _owner: o}
            }, t.createContext = function (e) {
                return (e = {
                    $$typeof: l,
                    _currentValue: e,
                    _currentValue2: e,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null,
                    _defaultValue: null,
                    _globalName: null
                }).Provider = {$$typeof: o, _context: e}, e.Consumer = e
            }, t.createElement = A, t.createFactory = function (e) {
                var t = A.bind(null, e);
                return t.type = e, t
            }, t.createRef = function () {
                return {current: null}
            }, t.forwardRef = function (e) {
                return {$$typeof: c, render: e}
            }, t.isValidElement = T, t.lazy = function (e) {
                return {$$typeof: h, _payload: {_status: -1, _result: e}, _init: P}
            }, t.memo = function (e, t) {
                return {$$typeof: d, type: e, compare: void 0 === t ? null : t}
            }, t.startTransition = function (e) {
                var t = j.transition;
                j.transition = {};
                try {
                    e()
                } finally {
                    j.transition = t
                }
            }, t.unstable_act = function () {
                throw Error("act(...) is not supported in production builds of React.")
            }, t.useCallback = function (e, t) {
                return N.current.useCallback(e, t)
            }, t.useContext = function (e) {
                return N.current.useContext(e)
            }, t.useDebugValue = function () {
            }, t.useDeferredValue = function (e) {
                return N.current.useDeferredValue(e)
            }, t.useEffect = function (e, t) {
                return N.current.useEffect(e, t)
            }, t.useId = function () {
                return N.current.useId()
            }, t.useImperativeHandle = function (e, t, n) {
                return N.current.useImperativeHandle(e, t, n)
            }, t.useInsertionEffect = function (e, t) {
                return N.current.useInsertionEffect(e, t)
            }, t.useLayoutEffect = function (e, t) {
                return N.current.useLayoutEffect(e, t)
            }, t.useMemo = function (e, t) {
                return N.current.useMemo(e, t)
            }, t.useReducer = function (e, t, n) {
                return N.current.useReducer(e, t, n)
            }, t.useRef = function (e) {
                return N.current.useRef(e)
            }, t.useState = function (e) {
                return N.current.useState(e)
            }, t.useSyncExternalStore = function (e, t, n) {
                return N.current.useSyncExternalStore(e, t, n)
            }, t.useTransition = function () {
                return N.current.useTransition()
            }, t.version = "18.2.0"
        }, 2784: (e, t, n) => {
            "use strict";
            e.exports = n(3426)
        }, 2322: (e, t, n) => {
            "use strict";
            e.exports = n(1837)
        }, 6475: (e, t) => {
            "use strict";

            function n(e, t) {
                var n = e.length;
                e.push(t);
                e:for (; 0 < n;) {
                    var r = n - 1 >>> 1, i = e[r];
                    if (!(0 < s(i, t))) break e;
                    e[r] = t, e[n] = i, n = r
                }
            }

            function r(e) {
                return 0 === e.length ? null : e[0]
            }

            function i(e) {
                if (0 === e.length) return null;
                var t = e[0], n = e.pop();
                if (n !== t) {
                    e[0] = n;
                    e:for (var r = 0, i = e.length, a = i >>> 1; r < a;) {
                        var o = 2 * (r + 1) - 1, l = e[o], c = o + 1, u = e[c];
                        if (0 > s(l, n)) c < i && 0 > s(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[o] = n, r = o); else {
                            if (!(c < i && 0 > s(u, n))) break e;
                            e[r] = u, e[c] = n, r = c
                        }
                    }
                }
                return t
            }

            function s(e, t) {
                var n = e.sortIndex - t.sortIndex;
                return 0 !== n ? n : e.id - t.id
            }

            if ("object" == typeof performance && "function" == typeof performance.now) {
                var a = performance;
                t.unstable_now = function () {
                    return a.now()
                }
            } else {
                var o = Date, l = o.now();
                t.unstable_now = function () {
                    return o.now() - l
                }
            }
            var c = [], u = [], d = 1, h = null, f = 3, p = !1, m = !1, g = !1,
                y = "function" == typeof setTimeout ? setTimeout : null,
                v = "function" == typeof clearTimeout ? clearTimeout : null,
                b = "undefined" != typeof setImmediate ? setImmediate : null;

            function w(e) {
                for (var t = r(u); null !== t;) {
                    if (null === t.callback) i(u); else {
                        if (!(t.startTime <= e)) break;
                        i(u), t.sortIndex = t.expirationTime, n(c, t)
                    }
                    t = r(u)
                }
            }

            function x(e) {
                if (g = !1, w(e), !m) if (null !== r(c)) m = !0, j(E); else {
                    var t = r(u);
                    null !== t && I(x, t.startTime - e)
                }
            }

            function E(e, n) {
                m = !1, g && (g = !1, v(T), T = -1), p = !0;
                var s = f;
                try {
                    for (w(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !L());) {
                        var a = h.callback;
                        if ("function" == typeof a) {
                            h.callback = null, f = h.priorityLevel;
                            var o = a(h.expirationTime <= n);
                            n = t.unstable_now(), "function" == typeof o ? h.callback = o : h === r(c) && i(c), w(n)
                        } else i(c);
                        h = r(c)
                    }
                    if (null !== h) var l = !0; else {
                        var d = r(u);
                        null !== d && I(x, d.startTime - n), l = !1
                    }
                    return l
                } finally {
                    h = null, f = s, p = !1
                }
            }

            "undefined" != typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
            var S, k = !1, A = null, T = -1, C = 5, R = -1;

            function L() {
                return !(t.unstable_now() - R < C)
            }

            function _() {
                if (null !== A) {
                    var e = t.unstable_now();
                    R = e;
                    var n = !0;
                    try {
                        n = A(!0, e)
                    } finally {
                        n ? S() : (k = !1, A = null)
                    }
                } else k = !1
            }

            if ("function" == typeof b) S = function () {
                b(_)
            }; else if ("undefined" != typeof MessageChannel) {
                var P = new MessageChannel, N = P.port2;
                P.port1.onmessage = _, S = function () {
                    N.postMessage(null)
                }
            } else S = function () {
                y(_, 0)
            };

            function j(e) {
                A = e, k || (k = !0, S())
            }

            function I(e, n) {
                T = y((function () {
                    e(t.unstable_now())
                }), n)
            }

            t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) {
                e.callback = null
            }, t.unstable_continueExecution = function () {
                m || p || (m = !0, j(E))
            }, t.unstable_forceFrameRate = function (e) {
                0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < e ? Math.floor(1e3 / e) : 5
            }, t.unstable_getCurrentPriorityLevel = function () {
                return f
            }, t.unstable_getFirstCallbackNode = function () {
                return r(c)
            }, t.unstable_next = function (e) {
                switch (f) {
                    case 1:
                    case 2:
                    case 3:
                        var t = 3;
                        break;
                    default:
                        t = f
                }
                var n = f;
                f = t;
                try {
                    return e()
                } finally {
                    f = n
                }
            }, t.unstable_pauseExecution = function () {
            }, t.unstable_requestPaint = function () {
            }, t.unstable_runWithPriority = function (e, t) {
                switch (e) {
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    default:
                        e = 3
                }
                var n = f;
                f = e;
                try {
                    return t()
                } finally {
                    f = n
                }
            }, t.unstable_scheduleCallback = function (e, i, s) {
                var a = t.unstable_now();
                switch (s = "object" == typeof s && null !== s && "number" == typeof (s = s.delay) && 0 < s ? a + s : a, e) {
                    case 1:
                        var o = -1;
                        break;
                    case 2:
                        o = 250;
                        break;
                    case 5:
                        o = 1073741823;
                        break;
                    case 4:
                        o = 1e4;
                        break;
                    default:
                        o = 5e3
                }
                return e = {
                    id: d++,
                    callback: i,
                    priorityLevel: e,
                    startTime: s,
                    expirationTime: o = s + o,
                    sortIndex: -1
                }, s > a ? (e.sortIndex = s, n(u, e), null === r(c) && e === r(u) && (g ? (v(T), T = -1) : g = !0, I(x, s - a))) : (e.sortIndex = o, n(c, e), m || p || (m = !0, j(E))), e
            }, t.unstable_shouldYield = L, t.unstable_wrapCallback = function (e) {
                var t = f;
                return function () {
                    var n = f;
                    f = t;
                    try {
                        return e.apply(this, arguments)
                    } finally {
                        f = n
                    }
                }
            }
        }, 4616: (e, t, n) => {
            "use strict";
            e.exports = n(6475)
        }, 8391: (e, t, n) => {
            var r, i, s;
            s = function () {
                var e, t, n = document, r = n.getElementsByTagName("head")[0], i = !1, s = "push", a = "readyState",
                    o = "onreadystatechange", l = {}, c = {}, u = {}, d = {};

                function h(e, t) {
                    for (var n = 0, r = e.length; n < r; ++n) if (!t(e[n])) return i;
                    return 1
                }

                function f(e, t) {
                    h(e, (function (e) {
                        return t(e), 1
                    }))
                }

                function p(t, n, r) {
                    t = t[s] ? t : [t];
                    var i = n && n.call, a = i ? n : r, o = i ? t.join("") : n, g = t.length;

                    function y(e) {
                        return e.call ? e() : l[e]
                    }

                    function v() {
                        if (!--g) for (var e in l[o] = 1, a && a(), u) h(e.split("|"), y) && !f(u[e], y) && (u[e] = [])
                    }

                    return setTimeout((function () {
                        f(t, (function t(n, r) {
                            return null === n ? v() : (r || /^https?:\/\//.test(n) || !e || (n = -1 === n.indexOf(".js") ? e + n + ".js" : e + n), d[n] ? (o && (c[o] = 1), 2 == d[n] ? v() : setTimeout((function () {
                                t(n, !0)
                            }), 0)) : (d[n] = 1, o && (c[o] = 1), void m(n, v)))
                        }))
                    }), 0), p
                }

                function m(e, i) {
                    var s, l = n.createElement("script");
                    l.onload = l.onerror = l[o] = function () {
                        l[a] && !/^c|loade/.test(l[a]) || s || (l.onload = l[o] = null, s = 1, d[e] = 2, i())
                    }, l.async = 1, l.src = t ? e + (-1 === e.indexOf("?") ? "?" : "&") + t : e, r.insertBefore(l, r.lastChild)
                }

                return p.get = m, p.order = function (e, t, n) {
                    !function r(i) {
                        i = e.shift(), e.length ? p(i, r) : p(i, t, n)
                    }()
                }, p.path = function (t) {
                    e = t
                }, p.urlArgs = function (e) {
                    t = e
                }, p.ready = function (e, t, n) {
                    e = e[s] ? e : [e];
                    var r, i = [];
                    return !f(e, (function (e) {
                        l[e] || i[s](e)
                    })) && h(e, (function (e) {
                        return l[e]
                    })) ? t() : (r = e.join("|"), u[r] = u[r] || [], u[r][s](t), n && n(i)), p
                }, p.done = function (e) {
                    p([null], e)
                }, p
            }, e.exports ? e.exports = s() : void 0 === (i = "function" == typeof (r = s) ? r.call(t, n, t, e) : r) || (e.exports = i)
        }, 4124: e => {
            !function () {
                var t = ["direction", "boxSizing", "width", "height", "overflowX", "overflowY", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "borderStyle", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontStyle", "fontVariant", "fontWeight", "fontStretch", "fontSize", "fontSizeAdjust", "lineHeight", "fontFamily", "textAlign", "textTransform", "textIndent", "textDecoration", "letterSpacing", "wordSpacing", "tabSize", "MozTabSize"],
                    n = "undefined" != typeof window, r = n && null != window.mozInnerScreenX;

                function i(e, i, s) {
                    if (!n) throw new Error("textarea-caret-position#getCaretCoordinates should only be called in a browser");
                    var a = s && s.debug || !1;
                    if (a) {
                        var o = document.querySelector("#input-textarea-caret-position-mirror-div");
                        o && o.parentNode.removeChild(o)
                    }
                    var l = document.createElement("div");
                    l.id = "input-textarea-caret-position-mirror-div", document.body.appendChild(l);
                    var c = l.style, u = window.getComputedStyle ? getComputedStyle(e) : e.currentStyle;
                    c.whiteSpace = "pre-wrap", "INPUT" !== e.nodeName && (c.wordWrap = "break-word"), c.position = "absolute", a || (c.visibility = "hidden"), t.forEach((function (e) {
                        c[e] = u[e]
                    })), r ? e.scrollHeight > parseInt(u.height) && (c.overflowY = "scroll") : c.overflow = "hidden", l.textContent = e.value.substring(0, i), "INPUT" === e.nodeName && (l.textContent = l.textContent.replace(/\s/g, ""));
                    var d = document.createElement("span");
                    d.textContent = e.value.substring(i) || ".", l.appendChild(d);
                    var h = {
                        top: d.offsetTop + parseInt(u.borderTopWidth),
                        left: d.offsetLeft + parseInt(u.borderLeftWidth)
                    };
                    return a ? d.style.backgroundColor = "#aaa" : document.body.removeChild(l), h
                }

                void 0 !== e.exports ? e.exports = i : n && (window.getCaretCoordinates = i)
            }()
        }, 452: (e, t, n) => {
            "use strict";
            var r = n(2784), i = "function" == typeof Object.is ? Object.is : function (e, t) {
                return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t
            }, s = r.useState, a = r.useEffect, o = r.useLayoutEffect, l = r.useDebugValue;

            function c(e) {
                var t = e.getSnapshot;
                e = e.value;
                try {
                    var n = t();
                    return !i(e, n)
                } catch (e) {
                    return !0
                }
            }

            var u = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function (e, t) {
                return t()
            } : function (e, t) {
                var n = t(), r = s({inst: {value: n, getSnapshot: t}}), i = r[0].inst, u = r[1];
                return o((function () {
                    i.value = n, i.getSnapshot = t, c(i) && u({inst: i})
                }), [e, n, t]), a((function () {
                    return c(i) && u({inst: i}), e((function () {
                        c(i) && u({inst: i})
                    }))
                }), [e]), l(n), n
            };
            t.useSyncExternalStore = void 0 !== r.useSyncExternalStore ? r.useSyncExternalStore : u
        }, 402: (e, t, n) => {
            "use strict";
            var r = n(2784), i = n(3100), s = "function" == typeof Object.is ? Object.is : function (e, t) {
                return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t
            }, a = i.useSyncExternalStore, o = r.useRef, l = r.useEffect, c = r.useMemo, u = r.useDebugValue;
            t.useSyncExternalStoreWithSelector = function (e, t, n, r, i) {
                var d = o(null);
                if (null === d.current) {
                    var h = {hasValue: !1, value: null};
                    d.current = h
                } else h = d.current;
                d = c((function () {
                    function e(e) {
                        if (!l) {
                            if (l = !0, a = e, e = r(e), void 0 !== i && h.hasValue) {
                                var t = h.value;
                                if (i(t, e)) return o = t
                            }
                            return o = e
                        }
                        if (t = o, s(a, e)) return t;
                        var n = r(e);
                        return void 0 !== i && i(t, n) ? t : (a = e, o = n)
                    }

                    var a, o, l = !1, c = void 0 === n ? null : n;
                    return [function () {
                        return e(t())
                    }, null === c ? void 0 : function () {
                        return e(c())
                    }]
                }), [t, n, r, i]);
                var f = a(e, d[0], d[1]);
                return l((function () {
                    h.hasValue = !0, h.value = f
                }), [f]), u(f), f
            }
        }, 3100: (e, t, n) => {
            "use strict";
            e.exports = n(452)
        }, 1110: (e, t, n) => {
            "use strict";
            e.exports = n(402)
        }, 130: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), Object.defineProperty(t, "NIL", {
                enumerable: !0,
                get: function () {
                    return o.default
                }
            }), Object.defineProperty(t, "parse", {
                enumerable: !0, get: function () {
                    return d.default
                }
            }), Object.defineProperty(t, "stringify", {
                enumerable: !0, get: function () {
                    return u.default
                }
            }), Object.defineProperty(t, "v1", {
                enumerable: !0, get: function () {
                    return r.default
                }
            }), Object.defineProperty(t, "v3", {
                enumerable: !0, get: function () {
                    return i.default
                }
            }), Object.defineProperty(t, "v4", {
                enumerable: !0, get: function () {
                    return s.default
                }
            }), Object.defineProperty(t, "v5", {
                enumerable: !0, get: function () {
                    return a.default
                }
            }), Object.defineProperty(t, "validate", {
                enumerable: !0, get: function () {
                    return c.default
                }
            }), Object.defineProperty(t, "version", {
                enumerable: !0, get: function () {
                    return l.default
                }
            });
            var r = h(n(7343)), i = h(n(6076)), s = h(n(5854)), a = h(n(3940)), o = h(n(5384)), l = h(n(5791)),
                c = h(n(7888)), u = h(n(9926)), d = h(n(9964));

            function h(e) {
                return e && e.__esModule ? e : {default: e}
            }
        }, 2763: (e, t) => {
            "use strict";

            function n(e) {
                return 14 + (e + 64 >>> 9 << 4) + 1
            }

            function r(e, t) {
                const n = (65535 & e) + (65535 & t);
                return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
            }

            function i(e, t, n, i, s, a) {
                return r((o = r(r(t, e), r(i, a))) << (l = s) | o >>> 32 - l, n);
                var o, l
            }

            function s(e, t, n, r, s, a, o) {
                return i(t & n | ~t & r, e, t, s, a, o)
            }

            function a(e, t, n, r, s, a, o) {
                return i(t & r | n & ~r, e, t, s, a, o)
            }

            function o(e, t, n, r, s, a, o) {
                return i(t ^ n ^ r, e, t, s, a, o)
            }

            function l(e, t, n, r, s, a, o) {
                return i(n ^ (t | ~r), e, t, s, a, o)
            }

            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
            t.default = function (e) {
                if ("string" == typeof e) {
                    const t = unescape(encodeURIComponent(e));
                    e = new Uint8Array(t.length);
                    for (let n = 0; n < t.length; ++n) e[n] = t.charCodeAt(n)
                }
                return function (e) {
                    const t = [], n = 32 * e.length, r = "0123456789abcdef";
                    for (let i = 0; i < n; i += 8) {
                        const n = e[i >> 5] >>> i % 32 & 255,
                            s = parseInt(r.charAt(n >>> 4 & 15) + r.charAt(15 & n), 16);
                        t.push(s)
                    }
                    return t
                }(function (e, t) {
                    e[t >> 5] |= 128 << t % 32, e[n(t) - 1] = t;
                    let i = 1732584193, c = -271733879, u = -1732584194, d = 271733878;
                    for (let t = 0; t < e.length; t += 16) {
                        const n = i, h = c, f = u, p = d;
                        i = s(i, c, u, d, e[t], 7, -680876936), d = s(d, i, c, u, e[t + 1], 12, -389564586), u = s(u, d, i, c, e[t + 2], 17, 606105819), c = s(c, u, d, i, e[t + 3], 22, -1044525330), i = s(i, c, u, d, e[t + 4], 7, -176418897), d = s(d, i, c, u, e[t + 5], 12, 1200080426), u = s(u, d, i, c, e[t + 6], 17, -1473231341), c = s(c, u, d, i, e[t + 7], 22, -45705983), i = s(i, c, u, d, e[t + 8], 7, 1770035416), d = s(d, i, c, u, e[t + 9], 12, -1958414417), u = s(u, d, i, c, e[t + 10], 17, -42063), c = s(c, u, d, i, e[t + 11], 22, -1990404162), i = s(i, c, u, d, e[t + 12], 7, 1804603682), d = s(d, i, c, u, e[t + 13], 12, -40341101), u = s(u, d, i, c, e[t + 14], 17, -1502002290), c = s(c, u, d, i, e[t + 15], 22, 1236535329), i = a(i, c, u, d, e[t + 1], 5, -165796510), d = a(d, i, c, u, e[t + 6], 9, -1069501632), u = a(u, d, i, c, e[t + 11], 14, 643717713), c = a(c, u, d, i, e[t], 20, -373897302), i = a(i, c, u, d, e[t + 5], 5, -701558691), d = a(d, i, c, u, e[t + 10], 9, 38016083), u = a(u, d, i, c, e[t + 15], 14, -660478335), c = a(c, u, d, i, e[t + 4], 20, -405537848), i = a(i, c, u, d, e[t + 9], 5, 568446438), d = a(d, i, c, u, e[t + 14], 9, -1019803690), u = a(u, d, i, c, e[t + 3], 14, -187363961), c = a(c, u, d, i, e[t + 8], 20, 1163531501), i = a(i, c, u, d, e[t + 13], 5, -1444681467), d = a(d, i, c, u, e[t + 2], 9, -51403784), u = a(u, d, i, c, e[t + 7], 14, 1735328473), c = a(c, u, d, i, e[t + 12], 20, -1926607734), i = o(i, c, u, d, e[t + 5], 4, -378558), d = o(d, i, c, u, e[t + 8], 11, -2022574463), u = o(u, d, i, c, e[t + 11], 16, 1839030562), c = o(c, u, d, i, e[t + 14], 23, -35309556), i = o(i, c, u, d, e[t + 1], 4, -1530992060), d = o(d, i, c, u, e[t + 4], 11, 1272893353), u = o(u, d, i, c, e[t + 7], 16, -155497632), c = o(c, u, d, i, e[t + 10], 23, -1094730640), i = o(i, c, u, d, e[t + 13], 4, 681279174), d = o(d, i, c, u, e[t], 11, -358537222), u = o(u, d, i, c, e[t + 3], 16, -722521979), c = o(c, u, d, i, e[t + 6], 23, 76029189), i = o(i, c, u, d, e[t + 9], 4, -640364487), d = o(d, i, c, u, e[t + 12], 11, -421815835), u = o(u, d, i, c, e[t + 15], 16, 530742520), c = o(c, u, d, i, e[t + 2], 23, -995338651), i = l(i, c, u, d, e[t], 6, -198630844), d = l(d, i, c, u, e[t + 7], 10, 1126891415), u = l(u, d, i, c, e[t + 14], 15, -1416354905), c = l(c, u, d, i, e[t + 5], 21, -57434055), i = l(i, c, u, d, e[t + 12], 6, 1700485571), d = l(d, i, c, u, e[t + 3], 10, -1894986606), u = l(u, d, i, c, e[t + 10], 15, -1051523), c = l(c, u, d, i, e[t + 1], 21, -2054922799), i = l(i, c, u, d, e[t + 8], 6, 1873313359), d = l(d, i, c, u, e[t + 15], 10, -30611744), u = l(u, d, i, c, e[t + 6], 15, -1560198380), c = l(c, u, d, i, e[t + 13], 21, 1309151649), i = l(i, c, u, d, e[t + 4], 6, -145523070), d = l(d, i, c, u, e[t + 11], 10, -1120210379), u = l(u, d, i, c, e[t + 2], 15, 718787259), c = l(c, u, d, i, e[t + 9], 21, -343485551), i = r(i, n), c = r(c, h), u = r(u, f), d = r(d, p)
                    }
                    return [i, c, u, d]
                }(function (e) {
                    if (0 === e.length) return [];
                    const t = 8 * e.length, r = new Uint32Array(n(t));
                    for (let n = 0; n < t; n += 8) r[n >> 5] |= (255 & e[n / 8]) << n % 32;
                    return r
                }(e), 8 * e.length))
            }
        }, 4267: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
            var n = {randomUUID: "undefined" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto)};
            t.default = n
        }, 5384: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0, t.default = "00000000-0000-0000-0000-000000000000"
        }, 9964: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
            var r, i = (r = n(7888)) && r.__esModule ? r : {default: r};
            t.default = function (e) {
                if (!(0, i.default)(e)) throw TypeError("Invalid UUID");
                let t;
                const n = new Uint8Array(16);
                return n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24, n[1] = t >>> 16 & 255, n[2] = t >>> 8 & 255, n[3] = 255 & t, n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8, n[5] = 255 & t, n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8, n[7] = 255 & t, n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8, n[9] = 255 & t, n[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255, n[11] = t / 4294967296 & 255, n[12] = t >>> 24 & 255, n[13] = t >>> 16 & 255, n[14] = t >>> 8 & 255, n[15] = 255 & t, n
            }
        }, 6678: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0, t.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
        }, 1874: (e, t) => {
            "use strict";
            let n;
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = function () {
                if (!n && (n = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !n)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                return n(r)
            };
            const r = new Uint8Array(16)
        }, 3254: (e, t) => {
            "use strict";

            function n(e, t, n, r) {
                switch (e) {
                    case 0:
                        return t & n ^ ~t & r;
                    case 1:
                    case 3:
                        return t ^ n ^ r;
                    case 2:
                        return t & n ^ t & r ^ n & r
                }
            }

            function r(e, t) {
                return e << t | e >>> 32 - t
            }

            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
            t.default = function (e) {
                const t = [1518500249, 1859775393, 2400959708, 3395469782],
                    i = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
                if ("string" == typeof e) {
                    const t = unescape(encodeURIComponent(e));
                    e = [];
                    for (let n = 0; n < t.length; ++n) e.push(t.charCodeAt(n))
                } else Array.isArray(e) || (e = Array.prototype.slice.call(e));
                e.push(128);
                const s = e.length / 4 + 2, a = Math.ceil(s / 16), o = new Array(a);
                for (let t = 0; t < a; ++t) {
                    const n = new Uint32Array(16);
                    for (let r = 0; r < 16; ++r) n[r] = e[64 * t + 4 * r] << 24 | e[64 * t + 4 * r + 1] << 16 | e[64 * t + 4 * r + 2] << 8 | e[64 * t + 4 * r + 3];
                    o[t] = n
                }
                o[a - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), o[a - 1][14] = Math.floor(o[a - 1][14]), o[a - 1][15] = 8 * (e.length - 1) & 4294967295;
                for (let e = 0; e < a; ++e) {
                    const s = new Uint32Array(80);
                    for (let t = 0; t < 16; ++t) s[t] = o[e][t];
                    for (let e = 16; e < 80; ++e) s[e] = r(s[e - 3] ^ s[e - 8] ^ s[e - 14] ^ s[e - 16], 1);
                    let a = i[0], l = i[1], c = i[2], u = i[3], d = i[4];
                    for (let e = 0; e < 80; ++e) {
                        const i = Math.floor(e / 20), o = r(a, 5) + n(i, l, c, u) + d + t[i] + s[e] >>> 0;
                        d = u, u = c, c = r(l, 30) >>> 0, l = a, a = o
                    }
                    i[0] = i[0] + a >>> 0, i[1] = i[1] + l >>> 0, i[2] = i[2] + c >>> 0, i[3] = i[3] + u >>> 0, i[4] = i[4] + d >>> 0
                }
                return [i[0] >> 24 & 255, i[0] >> 16 & 255, i[0] >> 8 & 255, 255 & i[0], i[1] >> 24 & 255, i[1] >> 16 & 255, i[1] >> 8 & 255, 255 & i[1], i[2] >> 24 & 255, i[2] >> 16 & 255, i[2] >> 8 & 255, 255 & i[2], i[3] >> 24 & 255, i[3] >> 16 & 255, i[3] >> 8 & 255, 255 & i[3], i[4] >> 24 & 255, i[4] >> 16 & 255, i[4] >> 8 & 255, 255 & i[4]]
            }
        }, 9926: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0, t.unsafeStringify = a;
            var r, i = (r = n(7888)) && r.__esModule ? r : {default: r};
            const s = [];
            for (let e = 0; e < 256; ++e) s.push((e + 256).toString(16).slice(1));

            function a(e, t = 0) {
                return (s[e[t + 0]] + s[e[t + 1]] + s[e[t + 2]] + s[e[t + 3]] + "-" + s[e[t + 4]] + s[e[t + 5]] + "-" + s[e[t + 6]] + s[e[t + 7]] + "-" + s[e[t + 8]] + s[e[t + 9]] + "-" + s[e[t + 10]] + s[e[t + 11]] + s[e[t + 12]] + s[e[t + 13]] + s[e[t + 14]] + s[e[t + 15]]).toLowerCase()
            }

            t.default = function (e, t = 0) {
                const n = a(e, t);
                if (!(0, i.default)(n)) throw TypeError("Stringified UUID is invalid");
                return n
            }
        }, 7343: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
            var r, i = (r = n(1874)) && r.__esModule ? r : {default: r}, s = n(9926);
            let a, o, l = 0, c = 0;
            t.default = function (e, t, n) {
                let r = t && n || 0;
                const u = t || new Array(16);
                let d = (e = e || {}).node || a, h = void 0 !== e.clockseq ? e.clockseq : o;
                if (null == d || null == h) {
                    const t = e.random || (e.rng || i.default)();
                    null == d && (d = a = [1 | t[0], t[1], t[2], t[3], t[4], t[5]]), null == h && (h = o = 16383 & (t[6] << 8 | t[7]))
                }
                let f = void 0 !== e.msecs ? e.msecs : Date.now(), p = void 0 !== e.nsecs ? e.nsecs : c + 1;
                const m = f - l + (p - c) / 1e4;
                if (m < 0 && void 0 === e.clockseq && (h = h + 1 & 16383), (m < 0 || f > l) && void 0 === e.nsecs && (p = 0), p >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                l = f, c = p, o = h, f += 122192928e5;
                const g = (1e4 * (268435455 & f) + p) % 4294967296;
                u[r++] = g >>> 24 & 255, u[r++] = g >>> 16 & 255, u[r++] = g >>> 8 & 255, u[r++] = 255 & g;
                const y = f / 4294967296 * 1e4 & 268435455;
                u[r++] = y >>> 8 & 255, u[r++] = 255 & y, u[r++] = y >>> 24 & 15 | 16, u[r++] = y >>> 16 & 255, u[r++] = h >>> 8 | 128, u[r++] = 255 & h;
                for (let e = 0; e < 6; ++e) u[r + e] = d[e];
                return t || (0, s.unsafeStringify)(u)
            }
        }, 6076: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
            var r = s(n(8679)), i = s(n(2763));

            function s(e) {
                return e && e.__esModule ? e : {default: e}
            }

            var a = (0, r.default)("v3", 48, i.default);
            t.default = a
        }, 8679: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.URL = t.DNS = void 0, t.default = function (e, t, n) {
                function r(e, r, a, o) {
                    var l;
                    if ("string" == typeof e && (e = function (e) {
                        e = unescape(encodeURIComponent(e));
                        const t = [];
                        for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n));
                        return t
                    }(e)), "string" == typeof r && (r = (0, s.default)(r)), 16 !== (null === (l = r) || void 0 === l ? void 0 : l.length)) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
                    let c = new Uint8Array(16 + e.length);
                    if (c.set(r), c.set(e, r.length), c = n(c), c[6] = 15 & c[6] | t, c[8] = 63 & c[8] | 128, a) {
                        o = o || 0;
                        for (let e = 0; e < 16; ++e) a[o + e] = c[e];
                        return a
                    }
                    return (0, i.unsafeStringify)(c)
                }

                try {
                    r.name = e
                } catch (e) {
                }
                return r.DNS = a, r.URL = o, r
            };
            var r, i = n(9926), s = (r = n(9964)) && r.__esModule ? r : {default: r};
            const a = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
            t.DNS = a;
            const o = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
            t.URL = o
        }, 5854: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
            var r = a(n(4267)), i = a(n(1874)), s = n(9926);

            function a(e) {
                return e && e.__esModule ? e : {default: e}
            }

            t.default = function (e, t, n) {
                if (r.default.randomUUID && !t && !e) return r.default.randomUUID();
                const a = (e = e || {}).random || (e.rng || i.default)();
                if (a[6] = 15 & a[6] | 64, a[8] = 63 & a[8] | 128, t) {
                    n = n || 0;
                    for (let e = 0; e < 16; ++e) t[n + e] = a[e];
                    return t
                }
                return (0, s.unsafeStringify)(a)
            }
        }, 3940: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
            var r = s(n(8679)), i = s(n(3254));

            function s(e) {
                return e && e.__esModule ? e : {default: e}
            }

            var a = (0, r.default)("v5", 80, i.default);
            t.default = a
        }, 7888: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
            var r, i = (r = n(6678)) && r.__esModule ? r : {default: r};
            t.default = function (e) {
                return "string" == typeof e && i.default.test(e)
            }
        }, 5791: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
            var r, i = (r = n(7888)) && r.__esModule ? r : {default: r};
            t.default = function (e) {
                if (!(0, i.default)(e)) throw TypeError("Invalid UUID");
                return parseInt(e.slice(14, 15), 16)
            }
        }, 4704: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.EmailRegex = void 0, t.EmailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
        }, 8070: function (e, t) {
            "use strict";
            var n, r, i, s = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            }, a = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.ExternalStore = void 0, t.ExternalStore = class {
                constructor() {
                    n.set(this, []), r.set(this, {}), i.set(this, !0)
                }

                hook(e) {
                    return s(this, n, "f").push({fn: e}), () => {
                        const t = s(this, n, "f").findIndex((t => t.fn === e));
                        t >= 0 && s(this, n, "f").splice(t, 1)
                    }
                }

                snapshot() {
                    return s(this, i, "f") && (a(this, r, this.takeSnapshot(), "f"), a(this, i, !1, "f")), s(this, r, "f")
                }

                notifyChange(e) {
                    a(this, i, !0, "f"), s(this, n, "f").length > 0 && s(this, n, "f").forEach((t => t.fn(e)))
                }
            }, n = new WeakMap, r = new WeakMap, i = new WeakMap
        }, 9887: function (e, t, n) {
            "use strict";
            var r, i, s, a, o, l, c = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            }, u = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            }, d = this && this.__importDefault || function (e) {
                return e && e.__esModule ? e : {default: e}
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.FeedCache = void 0;
            const h = d(n(5130)), f = n(1963);
            t.FeedCache = class {
                constructor(e, t) {
                    r.set(this, void 0), i.set(this, []), s.set(this, []), a.set(this, !0), o.set(this, 0), l.set(this, 0), this.onTable = new Set, this.cache = new Map, c(this, r, e, "f"), this.table = t, setInterval((() => {
                        (0, h.default)(u(this, r, "f"))("%d loaded, %d on-disk, %d hooks, %d% hit", this.cache.size, this.onTable.size, u(this, i, "f").length, (u(this, o, "f") / (u(this, o, "f") + u(this, l, "f")) * 100).toFixed(1))
                    }), 3e4)
                }

                async preload() {
                    const e = await (this.table?.toCollection().primaryKeys()) ?? [];
                    this.onTable = new Set(e.map((e => e)))
                }

                hook(e, t) {
                    return t ? (u(this, i, "f").push({key: t, fn: e}), () => {
                        const t = u(this, i, "f").findIndex((t => t.fn === e));
                        t >= 0 && u(this, i, "f").splice(t, 1)
                    }) : () => {
                    }
                }

                getFromCache(e) {
                    var t, n;
                    if (e) {
                        const r = this.cache.get(e);
                        return r ? c(this, o, (t = u(this, o, "f"), ++t), "f") : c(this, l, (n = u(this, l, "f"), ++n), "f"), r
                    }
                }

                async get(e) {
                    if (e && !this.cache.has(e) && this.table) {
                        const t = await this.table.get(e);
                        if (t) return this.cache.set(this.key(t), t), this.notifyChange([e]), t
                    }
                    return e ? this.cache.get(e) : void 0
                }

                async bulkGet(e) {
                    const t = e.filter((e => !this.cache.has(e)));
                    return t.length > 0 && this.table && (await this.table.bulkGet(t)).forEach((e => {
                        e && this.cache.set(this.key(e), e)
                    })), e.map((e => this.cache.get(e))).filter((e => e)).map((e => (0, f.unwrap)(e)))
                }

                async set(e) {
                    const t = this.key(e);
                    this.cache.set(t, e), this.table && (await this.table.put(e), this.onTable.add(t)), this.notifyChange([t])
                }

                async bulkSet(e) {
                    this.table && (await this.table.bulkPut(e), e.forEach((e => this.onTable.add(this.key(e))))), e.forEach((e => this.cache.set(this.key(e), e))), this.notifyChange(e.map((e => this.key(e))))
                }

                async update(e) {
                    const t = this.key(e), n = this.getFromCache(t),
                        i = n ? n.created < e.created ? "updated" : n && n.loaded < e.loaded ? "refresh" : "no_change" : "new";
                    if ((0, h.default)(u(this, r, "f"))("Updating %s %s %o", t, i, e), "no_change" !== i) {
                        const t = {...n, ...e};
                        await this.set(t)
                    }
                    return i
                }

                async buffer(e) {
                    const t = e.filter((e => !this.cache.has(e)));
                    if (this.table && t.length > 0) {
                        const n = t.map((e => ({has: this.onTable.has(e), key: e}))), i = (0, f.unixNowMs)(),
                            s = (await this.table.bulkGet(n.filter((e => e.has)).map((e => e.key)))).filter((e => void 0 !== e)).map((e => (0, f.unwrap)(e)));
                        return s.forEach((e => {
                            this.cache.set(this.key(e), e)
                        })), this.notifyChange(s.map((e => this.key(e)))), (0, h.default)(u(this, r, "f"))("Loaded %d/%d in %d ms", s.length, e.length, ((0, f.unixNowMs)() - i).toLocaleString()), n.filter((e => !e.has)).map((e => e.key))
                    }
                    return t
                }

                async clear() {
                    await (this.table?.clear()), this.cache.clear(), this.onTable.clear()
                }

                snapshot() {
                    return u(this, a, "f") && (c(this, s, this.takeSnapshot(), "f"), c(this, a, !1, "f")), u(this, s, "f")
                }

                notifyChange(e) {
                    c(this, a, !0, "f"), u(this, i, "f").filter((t => e.includes(t.key) || "*" === t.key)).forEach((e => e.fn()))
                }
            }, r = new WeakMap, i = new WeakMap, s = new WeakMap, a = new WeakMap, o = new WeakMap, l = new WeakMap
        }, 2036: function (e, t, n) {
            "use strict";
            var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                i && !("get" in i ? !t.__esModule : i.writable || i.configurable) || (i = {
                    enumerable: !0,
                    get: function () {
                        return t[n]
                    }
                }), Object.defineProperty(e, r, i)
            } : function (e, t, n, r) {
                void 0 === r && (r = n), e[r] = t[n]
            }), i = this && this.__exportStar || function (e, t) {
                for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n)
            };
            Object.defineProperty(t, "__esModule", {value: !0}), i(n(8070), t), i(n(5561), t), i(n(1963), t), i(n(3349), t), i(n(9887), t), i(n(5701), t)
        }, 5701: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.decodeInvoice = void 0;
            const r = n(2331), i = n(9512);
            t.decodeInvoice = function (e) {
                try {
                    const t = (0, i.decode)(e), n = t.sections.find((e => "amount" === e.name)),
                        s = n ? Number(n.value) : void 0, a = t.sections.find((e => "timestamp" === e.name)),
                        o = a ? Number(a.value) : void 0, l = t.sections.find((e => "expiry" === e.name)),
                        c = l ? Number(l.value) : void 0, u = t.sections.find((e => "description" === e.name))?.value,
                        d = t.sections.find((e => "description_hash" === e.name))?.value,
                        h = t.sections.find((e => "payment_hash" === e.name))?.value, f = {
                            pr: e,
                            amount: s,
                            expire: o && c ? o + c : void 0,
                            timestamp: o,
                            description: u,
                            descriptionHash: d ? "string" == typeof d ? d : (0, r.bytesToHex)(d) : void 0,
                            paymentHash: h ? "string" == typeof h ? h : (0, r.bytesToHex)(h) : void 0,
                            expired: !1
                        };
                    return f.expire && (f.expired = f.expire < (new Date).getTime() / 1e3), f
                } catch (e) {
                    console.error(e)
                }
            }
        }, 5561: function (e, t, n) {
            "use strict";
            var r, i, s, a, o = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            }, l = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.LNURL = t.LNURLError = t.LNURLErrorCode = void 0;
            const c = n(4704), u = n(1963);
            var d;
            !function (e) {
                e[e.ServiceUnavailable = 1] = "ServiceUnavailable", e[e.InvalidLNURL = 2] = "InvalidLNURL"
            }(d = t.LNURLErrorCode || (t.LNURLErrorCode = {}));

            class h extends Error {
                constructor(e, t) {
                    super(t), this.code = e
                }
            }

            t.LNURLError = h, t.LNURL = class {
                constructor(e) {
                    if (r.add(this), i.set(this, void 0), s.set(this, void 0), (e = e.toLowerCase().trim()).startsWith("lnurl")) {
                        const t = (0, u.bech32ToText)(e);
                        if (!t.startsWith("http")) throw new h(d.InvalidLNURL, "Not a url");
                        o(this, i, new URL(t), "f")
                    } else if (e.match(c.EmailRegex)) {
                        const [t, n] = e.split("@");
                        o(this, i, new URL(`https://${n}/.well-known/lnurlp/${t}`), "f")
                    } else if (e.startsWith("https:")) o(this, i, new URL(e), "f"); else {
                        if (!e.startsWith("lnurlp:")) throw new h(d.InvalidLNURL, "Could not determine service url");
                        {
                            const t = new URL(e);
                            t.protocol = "https:", o(this, i, t, "f")
                        }
                    }
                }

                get url() {
                    return l(this, i, "f")
                }

                get lnurl() {
                    return this.isLNAddress ? this.getLNAddress() : l(this, i, "f").toString()
                }

                get name() {
                    return this.isLNAddress ? this.getLNAddress() : l(this, i, "f").hostname
                }

                get isLNAddress() {
                    return l(this, i, "f").pathname.startsWith("/.well-known/lnurlp/")
                }

                getLNAddress() {
                    const e = l(this, i, "f").pathname.split("/");
                    return `${e[e.length - 1]}@${l(this, i, "f").hostname}`
                }

                getZapTag() {
                    return this.isLNAddress ? ["zap", this.getLNAddress(), "lud16"] : ["zap", l(this, i, "f").toString(), "lud06"]
                }

                async load() {
                    const e = await fetch(l(this, i, "f"));
                    e.ok && (o(this, s, await e.json(), "f"), l(this, r, "m", a).call(this))
                }

                async getInvoice(e, t, n) {
                    const r = new URL((0, u.unwrap)(l(this, s, "f")?.callback)), i = new Map;
                    r.search.length > 0 && r.search.slice(1).split("&").forEach((e => {
                        const t = e.split("=");
                        i.set(t[0], t[1])
                    })), i.set("amount", Math.floor(1e3 * e).toString()), t && l(this, s, "f")?.commentAllowed && i.set("comment", t), l(this, s, "f")?.nostrPubkey && n && i.set("nostr", JSON.stringify(n));
                    const a = `${r.protocol}//${r.host}${r.pathname}`,
                        o = [...i.entries()].map((e => `${e[0]}=${encodeURIComponent(e[1])}`)).join("&");
                    try {
                        const e = await fetch(`${a}?${o}`);
                        if (e.ok) {
                            const t = await e.json();
                            if (console.debug("[LNURL]: ", t), "ERROR" === t.status) throw new Error(t.reason);
                            return t
                        }
                        throw new h(d.ServiceUnavailable, `Failed to fetch invoice (${e.statusText})`)
                    } catch (e) {
                        throw new h(d.ServiceUnavailable, "Failed to load callback")
                    }
                }

                get canZap() {
                    return !!l(this, s, "f")?.nostrPubkey
                }

                get zapperPubkey() {
                    return l(this, s, "f")?.nostrPubkey
                }

                get maxCommentLength() {
                    return l(this, s, "f")?.commentAllowed ?? 0
                }

                get min() {
                    return l(this, s, "f")?.minSendable ?? 1e3
                }

                get max() {
                    return l(this, s, "f")?.maxSendable ?? 1e11
                }
            }, i = new WeakMap, s = new WeakMap, r = new WeakSet, a = function () {
                if ("payRequest" !== l(this, s, "f")?.tag) throw new h(d.InvalidLNURL, "Only LNURLp is supported");
                if (!l(this, s, "f")?.callback) throw new h(d.InvalidLNURL, "No callback url")
            }
        }, 1963: function (e, t, n) {
            "use strict";
            var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                i && !("get" in i ? !t.__esModule : i.writable || i.configurable) || (i = {
                    enumerable: !0,
                    get: function () {
                        return t[n]
                    }
                }), Object.defineProperty(e, r, i)
            } : function (e, t, n, r) {
                void 0 === r && (r = n), e[r] = t[n]
            }), i = this && this.__setModuleDefault || (Object.create ? function (e, t) {
                Object.defineProperty(e, "default", {enumerable: !0, value: t})
            } : function (e, t) {
                e.default = t
            }), s = this && this.__importStar || function (e) {
                if (e && e.__esModule) return e;
                var t = {};
                if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
                return i(t, e), t
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.fetchNip05Pubkey = t.bech32ToText = t.bech32ToHex = t.getPublicKey = t.sha256 = t.appendDedupe = t.dedupe = t.distance = t.equalProp = t.countMembers = t.deepEqual = t.deepClone = t.unixNowMs = t.unixNow = t.sanitizeRelayUrl = t.hexToBech32 = t.unwrap = void 0;
            const a = s(n(3595)), o = s(n(3491)), l = n(1206), c = n(6237);

            function u() {
                return (new Date).getTime()
            }

            function d(e) {
                return [...new Set(e)]
            }

            t.unwrap = function (e) {
                if (null == e) throw new Error("missing value");
                return e
            }, t.hexToBech32 = function (e, t) {
                if ("string" != typeof t || 0 === t.length || t.length % 2 != 0) return "";
                try {
                    const n = a.hexToBytes(t);
                    return c.bech32.encode(e, c.bech32.toWords(n))
                } catch (e) {
                    return console.warn("Invalid hex", t, e), ""
                }
            }, t.sanitizeRelayUrl = function (e) {
                try {
                    return new URL(e).toString()
                } catch {
                }
            }, t.unixNow = function () {
                return Math.floor(u() / 1e3)
            }, t.unixNowMs = u, t.deepClone = function (e) {
                return "structuredClone" in window ? structuredClone(e) : JSON.parse(JSON.stringify(e))
            }, t.deepEqual = function e(t, n) {
                const r = Object.keys, i = typeof t;
                return t && n && "object" === i && i === typeof n ? r(t).length === r(n).length && r(t).every((r => e(t[r], n[r]))) : t === n
            }, t.countMembers = function (e) {
                let t = 0;
                for (const [n, r] of Object.entries(e)) Array.isArray(r) && (t += r.length);
                return t
            }, t.equalProp = function (e, t) {
                if (void 0 !== e && void 0 === t || void 0 === e && void 0 !== t) return !1;
                if (Array.isArray(e) && Array.isArray(t)) {
                    if (e.length !== t.length) return !1;
                    if (!e.every((e => t.includes(e)))) return !1
                }
                return e === t
            }, t.distance = function (e, t) {
                const n = Object.keys(e), r = Object.keys(t), i = n.length > r.length ? n : r;
                let s = 0;
                for (const n of i) if (n in e && n in t) if (Array.isArray(e[n]) && Array.isArray(t[n])) {
                    const r = e[n], i = t[n];
                    r.length === i.length ? r.some((e => !i.includes(e))) && s++ : s++
                } else e[n] !== t[n] && s++; else s += 10;
                return s
            }, t.dedupe = d, t.appendDedupe = function (e, t) {
                return d([...e ?? [], ...t ?? []])
            }, t.sha256 = e => a.bytesToHex((0, l.sha256)(e)), t.getPublicKey = function (e) {
                return a.bytesToHex(o.schnorr.getPublicKey(e))
            }, t.bech32ToHex = function (e) {
                try {
                    const t = c.bech32.decode(e, 1e3), n = c.bech32.fromWords(t.words);
                    return a.bytesToHex(Uint8Array.from(n))
                } catch (t) {
                    return e
                }
            }, t.bech32ToText = function (e) {
                try {
                    const t = c.bech32.decode(e, 1e3), n = c.bech32.fromWords(t.words);
                    return (new TextDecoder).decode(Uint8Array.from(n))
                } catch {
                    return ""
                }
            }, t.fetchNip05Pubkey = async function (e, t, n = 2e3) {
                if (e && t) try {
                    const r = await fetch(`https://${t}/.well-known/nostr.json?name=${encodeURIComponent(e)}`, {signal: AbortSignal.timeout(n)}),
                        i = await r.json(), s = Object.keys(i.names).find((t => t.toLowerCase() === e.toLowerCase()));
                    return s ? i.names[s] : void 0
                } catch {
                }
            }
        }, 3349: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.barrierQueue = t.processWorkQueue = void 0, t.processWorkQueue = async function e(t, n = 200) {
                for (; t && t.length > 0;) {
                    const e = t.shift();
                    if (e) try {
                        const t = await e.next();
                        e.resolve(t)
                    } catch (t) {
                        e.reject(t)
                    }
                }
                setTimeout((() => e(t, n)), n)
            }, t.barrierQueue = async (e, t) => new Promise(((n, r) => {
                e.push({next: t, resolve: n, reject: r})
            }))
        }, 1374: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.createCurve = t.getHash = void 0;
            const r = n(7606), i = n(2331), s = n(4151);

            function a(e) {
                return {
                    hash: e,
                    hmac: (t, ...n) => (0, r.hmac)(e, t, (0, i.concatBytes)(...n)),
                    randomBytes: i.randomBytes
                }
            }

            t.getHash = a, t.createCurve = function (e, t) {
                const n = t => (0, s.weierstrass)({...e, ...a(t)});
                return Object.freeze({...n(t), create: n})
            }
        }, 4667: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.validateBasic = t.wNAF = void 0;
            const r = n(4346), i = n(3595), s = BigInt(0), a = BigInt(1);
            t.wNAF = function (e, t) {
                const n = (e, t) => {
                    const n = t.negate();
                    return e ? n : t
                }, r = e => ({windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1)});
                return {
                    constTimeNegate: n, unsafeLadder(t, n) {
                        let r = e.ZERO, i = t;
                        for (; n > s;) n & a && (r = r.add(i)), i = i.double(), n >>= a;
                        return r
                    }, precomputeWindow(e, t) {
                        const {windows: n, windowSize: i} = r(t), s = [];
                        let a = e, o = a;
                        for (let e = 0; e < n; e++) {
                            o = a, s.push(o);
                            for (let e = 1; e < i; e++) o = o.add(a), s.push(o);
                            a = o.double()
                        }
                        return s
                    }, wNAF(t, i, s) {
                        const {windows: o, windowSize: l} = r(t);
                        let c = e.ZERO, u = e.BASE;
                        const d = BigInt(2 ** t - 1), h = 2 ** t, f = BigInt(t);
                        for (let e = 0; e < o; e++) {
                            const t = e * l;
                            let r = Number(s & d);
                            s >>= f, r > l && (r -= h, s += a);
                            const o = t, p = t + Math.abs(r) - 1, m = e % 2 != 0, g = r < 0;
                            0 === r ? u = u.add(n(m, i[o])) : c = c.add(n(g, i[p]))
                        }
                        return {p: c, f: u}
                    }, wNAFCached(e, t, n, r) {
                        const i = e._WINDOW_SIZE || 1;
                        let s = t.get(e);
                        return s || (s = this.precomputeWindow(e, i), 1 !== i && t.set(e, r(s))), this.wNAF(i, s, n)
                    }
                }
            }, t.validateBasic = function (e) {
                return (0, r.validateField)(e.Fp), (0, i.validateObject)(e, {
                    n: "bigint",
                    h: "bigint",
                    Gx: "field",
                    Gy: "field"
                }, {
                    nBitLength: "isSafeInteger",
                    nByteLength: "isSafeInteger"
                }), Object.freeze({...(0, r.nLength)(e.n, e.nBitLength), ...e, p: e.Fp.ORDER})
            }
        }, 4713: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.createHasher = t.isogenyMap = t.hash_to_field = t.expand_message_xof = t.expand_message_xmd = void 0;
            const r = n(4346), i = n(3595), s = i.bytesToNumberBE;

            function a(e, t) {
                if (e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`);
                const n = Array.from({length: t}).fill(0);
                for (let r = t - 1; r >= 0; r--) n[r] = 255 & e, e >>>= 8;
                return new Uint8Array(n)
            }

            function o(e, t) {
                const n = new Uint8Array(e.length);
                for (let r = 0; r < e.length; r++) n[r] = e[r] ^ t[r];
                return n
            }

            function l(e) {
                if (!(e instanceof Uint8Array)) throw new Error("Uint8Array expected")
            }

            function c(e) {
                if (!Number.isSafeInteger(e)) throw new Error("number expected")
            }

            function u(e, t, n, r) {
                l(e), l(t), c(n), t.length > 255 && (t = r((0, i.concatBytes)((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
                const {outputLen: s, blockLen: u} = r, d = Math.ceil(n / s);
                if (d > 255) throw new Error("Invalid xmd length");
                const h = (0, i.concatBytes)(t, a(t.length, 1)), f = a(0, u), p = a(n, 2), m = new Array(d),
                    g = r((0, i.concatBytes)(f, e, p, a(0, 1), h));
                m[0] = r((0, i.concatBytes)(g, a(1, 1), h));
                for (let e = 1; e <= d; e++) {
                    const t = [o(g, m[e - 1]), a(e + 1, 1), h];
                    m[e] = r((0, i.concatBytes)(...t))
                }
                return (0, i.concatBytes)(...m).slice(0, n)
            }

            function d(e, t, n, r, s) {
                if (l(e), l(t), c(n), t.length > 255) {
                    const e = Math.ceil(2 * r / 8);
                    t = s.create({dkLen: e}).update((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest()
                }
                if (n > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
                return s.create({dkLen: n}).update(e).update(a(n, 2)).update(t).update(a(t.length, 1)).digest()
            }

            function h(e, t, n) {
                (0, i.validateObject)(n, {
                    DST: "string",
                    p: "bigint",
                    m: "isSafeInteger",
                    k: "isSafeInteger",
                    hash: "hash"
                });
                const {p: a, k: o, m: h, hash: f, expand: p, DST: m} = n;
                l(e), c(t);
                const g = function (e) {
                    if (e instanceof Uint8Array) return e;
                    if ("string" == typeof e) return (0, i.utf8ToBytes)(e);
                    throw new Error("DST must be Uint8Array or string")
                }(m), y = a.toString(2).length, v = Math.ceil((y + o) / 8), b = t * h * v;
                let w;
                if ("xmd" === p) w = u(e, g, b, f); else if ("xof" === p) w = d(e, g, b, o, f); else {
                    if ("_internal_pass" !== p) throw new Error('expand must be "xmd" or "xof"');
                    w = e
                }
                const x = new Array(t);
                for (let e = 0; e < t; e++) {
                    const t = new Array(h);
                    for (let n = 0; n < h; n++) {
                        const i = v * (n + e * h), o = w.subarray(i, i + v);
                        t[n] = (0, r.mod)(s(o), a)
                    }
                    x[e] = t
                }
                return x
            }

            t.expand_message_xmd = u, t.expand_message_xof = d, t.hash_to_field = h, t.isogenyMap = function (e, t) {
                const n = t.map((e => Array.from(e).reverse()));
                return (t, r) => {
                    const [i, s, a, o] = n.map((n => n.reduce(((n, r) => e.add(e.mul(n, t), r)))));
                    return t = e.div(i, s), r = e.mul(r, e.div(a, o)), {x: t, y: r}
                }
            }, t.createHasher = function (e, t, n) {
                if ("function" != typeof t) throw new Error("mapToCurve() must be defined");
                return {
                    hashToCurve(r, i) {
                        const s = h(r, 2, {...n, DST: n.DST, ...i}), a = e.fromAffine(t(s[0])),
                            o = e.fromAffine(t(s[1])), l = a.add(o).clearCofactor();
                        return l.assertValidity(), l
                    }, encodeToCurve(r, i) {
                        const s = h(r, 1, {...n, DST: n.encodeDST, ...i}), a = e.fromAffine(t(s[0])).clearCofactor();
                        return a.assertValidity(), a
                    }
                }
            }
        }, 4346: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.hashToPrivateScalar = t.FpSqrtEven = t.FpSqrtOdd = t.Field = t.nLength = t.FpIsSquare = t.FpDiv = t.FpInvertBatch = t.FpPow = t.validateField = t.isNegativeLE = t.FpSqrt = t.tonelliShanks = t.invert = t.pow2 = t.pow = t.mod = void 0;
            const r = n(3595), i = BigInt(0), s = BigInt(1), a = BigInt(2), o = BigInt(3), l = BigInt(4), c = BigInt(5),
                u = BigInt(8);

            function d(e, t) {
                const n = e % t;
                return n >= i ? n : t + n
            }

            function h(e, t, n) {
                if (n <= i || t < i) throw new Error("Expected power/modulo > 0");
                if (n === s) return i;
                let r = s;
                for (; t > i;) t & s && (r = r * e % n), e = e * e % n, t >>= s;
                return r
            }

            function f(e, t) {
                if (e === i || t <= i) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
                let n = d(e, t), r = t, a = i, o = s, l = s, c = i;
                for (; n !== i;) {
                    const e = r / n, t = r % n, i = a - l * e, s = o - c * e;
                    r = n, n = t, a = l, o = c, l = i, c = s
                }
                if (r !== s) throw new Error("invert: does not exist");
                return d(a, t)
            }

            function p(e) {
                const t = (e - s) / a;
                let n, r, o;
                for (n = e - s, r = 0; n % a === i; n /= a, r++) ;
                for (o = a; o < e && h(o, t, e) !== e - s; o++) ;
                if (1 === r) {
                    const t = (e + s) / l;
                    return function (e, n) {
                        const r = e.pow(n, t);
                        if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
                        return r
                    }
                }
                const c = (n + s) / a;
                return function (e, i) {
                    if (e.pow(i, t) === e.neg(e.ONE)) throw new Error("Cannot find square root");
                    let a = r, l = e.pow(e.mul(e.ONE, o), n), u = e.pow(i, c), d = e.pow(i, n);
                    for (; !e.eql(d, e.ONE);) {
                        if (e.eql(d, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let n = e.sqr(d); t < a && !e.eql(n, e.ONE); t++) n = e.sqr(n);
                        const n = e.pow(l, s << BigInt(a - t - 1));
                        l = e.sqr(n), u = e.mul(u, n), d = e.mul(d, l), a = t
                    }
                    return u
                }
            }

            function m(e) {
                if (e % l === o) {
                    const t = (e + s) / l;
                    return function (e, n) {
                        const r = e.pow(n, t);
                        if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
                        return r
                    }
                }
                if (e % u === c) {
                    const t = (e - c) / u;
                    return function (e, n) {
                        const r = e.mul(n, a), i = e.pow(r, t), s = e.mul(n, i), o = e.mul(e.mul(s, a), i),
                            l = e.mul(s, e.sub(o, e.ONE));
                        if (!e.eql(e.sqr(l), n)) throw new Error("Cannot find square root");
                        return l
                    }
                }
                return p(e)
            }

            BigInt(9), BigInt(16), t.mod = d, t.pow = h, t.pow2 = function (e, t, n) {
                let r = e;
                for (; t-- > i;) r *= r, r %= n;
                return r
            }, t.invert = f, t.tonelliShanks = p, t.FpSqrt = m, t.isNegativeLE = (e, t) => (d(e, t) & s) === s;
            const g = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

            function y(e, t, n) {
                if (n < i) throw new Error("Expected power > 0");
                if (n === i) return e.ONE;
                if (n === s) return t;
                let r = e.ONE, a = t;
                for (; n > i;) n & s && (r = e.mul(r, a)), a = e.sqr(a), n >>= s;
                return r
            }

            function v(e, t) {
                const n = new Array(t.length),
                    r = t.reduce(((t, r, i) => e.is0(r) ? t : (n[i] = t, e.mul(t, r))), e.ONE), i = e.inv(r);
                return t.reduceRight(((t, r, i) => e.is0(r) ? t : (n[i] = e.mul(t, n[i]), e.mul(t, r))), i), n
            }

            function b(e, t) {
                const n = void 0 !== t ? t : e.toString(2).length;
                return {nBitLength: n, nByteLength: Math.ceil(n / 8)}
            }

            t.validateField = function (e) {
                const t = g.reduce(((e, t) => (e[t] = "function", e)), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger"
                });
                return (0, r.validateObject)(e, t)
            }, t.FpPow = y, t.FpInvertBatch = v, t.FpDiv = function (e, t, n) {
                return e.mul(t, "bigint" == typeof n ? f(n, e.ORDER) : e.inv(n))
            }, t.FpIsSquare = function (e) {
                const t = (e.ORDER - s) / a;
                return n => {
                    const r = e.pow(n, t);
                    return e.eql(r, e.ZERO) || e.eql(r, e.ONE)
                }
            }, t.nLength = b, t.Field = function (e, t, n = !1, a = {}) {
                if (e <= i) throw new Error(`Expected Fp ORDER > 0, got ${e}`);
                const {nBitLength: o, nByteLength: l} = b(e, t);
                if (l > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
                const c = m(e), u = Object.freeze({
                    ORDER: e,
                    BITS: o,
                    BYTES: l,
                    MASK: (0, r.bitMask)(o),
                    ZERO: i,
                    ONE: s,
                    create: t => d(t, e),
                    isValid: t => {
                        if ("bigint" != typeof t) throw new Error("Invalid field element: expected bigint, got " + typeof t);
                        return i <= t && t < e
                    },
                    is0: e => e === i,
                    isOdd: e => (e & s) === s,
                    neg: t => d(-t, e),
                    eql: (e, t) => e === t,
                    sqr: t => d(t * t, e),
                    add: (t, n) => d(t + n, e),
                    sub: (t, n) => d(t - n, e),
                    mul: (t, n) => d(t * n, e),
                    pow: (e, t) => y(u, e, t),
                    div: (t, n) => d(t * f(n, e), e),
                    sqrN: e => e * e,
                    addN: (e, t) => e + t,
                    subN: (e, t) => e - t,
                    mulN: (e, t) => e * t,
                    inv: t => f(t, e),
                    sqrt: a.sqrt || (e => c(u, e)),
                    invertBatch: e => v(u, e),
                    cmov: (e, t, n) => n ? t : e,
                    toBytes: e => n ? (0, r.numberToBytesLE)(e, l) : (0, r.numberToBytesBE)(e, l),
                    fromBytes: e => {
                        if (e.length !== l) throw new Error(`Fp.fromBytes: expected ${l}, got ${e.length}`);
                        return n ? (0, r.bytesToNumberLE)(e) : (0, r.bytesToNumberBE)(e)
                    }
                });
                return Object.freeze(u)
            }, t.FpSqrtOdd = function (e, t) {
                if (!e.isOdd) throw new Error("Field doesn't have isOdd");
                const n = e.sqrt(t);
                return e.isOdd(n) ? n : e.neg(n)
            }, t.FpSqrtEven = function (e, t) {
                if (!e.isOdd) throw new Error("Field doesn't have isOdd");
                const n = e.sqrt(t);
                return e.isOdd(n) ? e.neg(n) : n
            }, t.hashToPrivateScalar = function (e, t, n = !1) {
                const i = (e = (0, r.ensureBytes)("privateHash", e)).length, a = b(t).nByteLength + 8;
                if (a < 24 || i < a || i > 1024) throw new Error(`hashToPrivateScalar: expected ${a}-1024 bytes of input, got ${i}`);
                return d(n ? (0, r.bytesToNumberLE)(e) : (0, r.bytesToNumberBE)(e), t - s) + s
            }
        }, 3595: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.validateObject = t.createHmacDrbg = t.bitMask = t.bitSet = t.bitGet = t.bitLen = t.utf8ToBytes = t.equalBytes = t.concatBytes = t.ensureBytes = t.numberToVarBytesBE = t.numberToBytesLE = t.numberToBytesBE = t.bytesToNumberLE = t.bytesToNumberBE = t.hexToBytes = t.hexToNumber = t.numberToHexUnpadded = t.bytesToHex = void 0;
            const n = BigInt(0), r = BigInt(1), i = BigInt(2), s = e => e instanceof Uint8Array,
                a = Array.from({length: 256}, ((e, t) => t.toString(16).padStart(2, "0")));

            function o(e) {
                if (!s(e)) throw new Error("Uint8Array expected");
                let t = "";
                for (let n = 0; n < e.length; n++) t += a[e[n]];
                return t
            }

            function l(e) {
                const t = e.toString(16);
                return 1 & t.length ? `0${t}` : t
            }

            function c(e) {
                if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
                return BigInt("" === e ? "0" : `0x${e}`)
            }

            function u(e) {
                if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
                const t = e.length;
                if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
                const n = new Uint8Array(t / 2);
                for (let t = 0; t < n.length; t++) {
                    const r = 2 * t, i = e.slice(r, r + 2), s = Number.parseInt(i, 16);
                    if (Number.isNaN(s) || s < 0) throw new Error("Invalid byte sequence");
                    n[t] = s
                }
                return n
            }

            function d(e, t) {
                return u(e.toString(16).padStart(2 * t, "0"))
            }

            function h(...e) {
                const t = new Uint8Array(e.reduce(((e, t) => e + t.length), 0));
                let n = 0;
                return e.forEach((e => {
                    if (!s(e)) throw new Error("Uint8Array expected");
                    t.set(e, n), n += e.length
                })), t
            }

            t.bytesToHex = o, t.numberToHexUnpadded = l, t.hexToNumber = c, t.hexToBytes = u, t.bytesToNumberBE = function (e) {
                return c(o(e))
            }, t.bytesToNumberLE = function (e) {
                if (!s(e)) throw new Error("Uint8Array expected");
                return c(o(Uint8Array.from(e).reverse()))
            }, t.numberToBytesBE = d, t.numberToBytesLE = function (e, t) {
                return d(e, t).reverse()
            }, t.numberToVarBytesBE = function (e) {
                return u(l(e))
            }, t.ensureBytes = function (e, t, n) {
                let r;
                if ("string" == typeof t) try {
                    r = u(t)
                } catch (n) {
                    throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`)
                } else {
                    if (!s(t)) throw new Error(`${e} must be hex string or Uint8Array`);
                    r = Uint8Array.from(t)
                }
                const i = r.length;
                if ("number" == typeof n && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`);
                return r
            }, t.concatBytes = h, t.equalBytes = function (e, t) {
                if (e.length !== t.length) return !1;
                for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
                return !0
            }, t.utf8ToBytes = function (e) {
                if ("string" != typeof e) throw new Error("utf8ToBytes expected string, got " + typeof e);
                return new Uint8Array((new TextEncoder).encode(e))
            }, t.bitLen = function (e) {
                let t;
                for (t = 0; e > n; e >>= r, t += 1) ;
                return t
            }, t.bitGet = function (e, t) {
                return e >> BigInt(t) & r
            }, t.bitSet = (e, t, i) => e | (i ? r : n) << BigInt(t), t.bitMask = e => (i << BigInt(e - 1)) - r;
            const f = e => new Uint8Array(e), p = e => Uint8Array.from(e);
            t.createHmacDrbg = function (e, t, n) {
                if ("number" != typeof e || e < 2) throw new Error("hashLen must be a number");
                if ("number" != typeof t || t < 2) throw new Error("qByteLen must be a number");
                if ("function" != typeof n) throw new Error("hmacFn must be a function");
                let r = f(e), i = f(e), s = 0;
                const a = () => {
                    r.fill(1), i.fill(0), s = 0
                }, o = (...e) => n(i, r, ...e), l = (e = f()) => {
                    i = o(p([0]), e), r = o(), 0 !== e.length && (i = o(p([1]), e), r = o())
                }, c = () => {
                    if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
                    let e = 0;
                    const n = [];
                    for (; e < t;) {
                        r = o();
                        const t = r.slice();
                        n.push(t), e += r.length
                    }
                    return h(...n)
                };
                return (e, t) => {
                    let n;
                    for (a(), l(e); !(n = t(c()));) l();
                    return a(), n
                }
            };
            const m = {
                bigint: e => "bigint" == typeof e,
                function: e => "function" == typeof e,
                boolean: e => "boolean" == typeof e,
                string: e => "string" == typeof e,
                isSafeInteger: e => Number.isSafeInteger(e),
                array: e => Array.isArray(e),
                field: (e, t) => t.Fp.isValid(e),
                hash: e => "function" == typeof e && Number.isSafeInteger(e.outputLen)
            };
            t.validateObject = function (e, t, n = {}) {
                const r = (t, n, r) => {
                    const i = m[n];
                    if ("function" != typeof i) throw new Error(`Invalid validator "${n}", expected function`);
                    const s = e[t];
                    if (!(r && void 0 === s || i(s, e))) throw new Error(`Invalid param ${String(t)}=${s} (${typeof s}), expected ${n}`)
                };
                for (const [e, n] of Object.entries(t)) r(e, n, !1);
                for (const [e, t] of Object.entries(n)) r(e, t, !0);
                return e
            }
        }, 4151: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.mapToCurveSimpleSWU = t.SWUFpSqrtRatio = t.weierstrass = t.weierstrassPoints = t.DER = void 0;
            const r = n(4346), i = n(3595), s = n(3595), a = n(4667), {bytesToNumberBE: o, hexToBytes: l} = i;
            t.DER = {
                Err: class extends Error {
                    constructor(e = "") {
                        super(e)
                    }
                }, _parseInt(e) {
                    const {Err: n} = t.DER;
                    if (e.length < 2 || 2 !== e[0]) throw new n("Invalid signature integer tag");
                    const r = e[1], i = e.subarray(2, r + 2);
                    if (!r || i.length !== r) throw new n("Invalid signature integer: wrong length");
                    if (128 & i[0]) throw new n("Invalid signature integer: negative");
                    if (0 === i[0] && !(128 & i[1])) throw new n("Invalid signature integer: unnecessary leading zero");
                    return {d: o(i), l: e.subarray(r + 2)}
                }, toSig(e) {
                    const {Err: n} = t.DER, r = "string" == typeof e ? l(e) : e;
                    if (!(r instanceof Uint8Array)) throw new Error("ui8a expected");
                    let i = r.length;
                    if (i < 2 || 48 != r[0]) throw new n("Invalid signature tag");
                    if (r[1] !== i - 2) throw new n("Invalid signature: incorrect length");
                    const {d: s, l: a} = t.DER._parseInt(r.subarray(2)), {d: o, l: c} = t.DER._parseInt(a);
                    if (c.length) throw new n("Invalid signature: left bytes after parsing");
                    return {r: s, s: o}
                }, hexFromSig(e) {
                    const t = e => 8 & Number.parseInt(e[0], 16) ? "00" + e : e, n = e => {
                        const t = e.toString(16);
                        return 1 & t.length ? `0${t}` : t
                    }, r = t(n(e.s)), i = t(n(e.r)), s = r.length / 2, a = i.length / 2, o = n(s), l = n(a);
                    return `30${n(a + s + 4)}02${l}${i}02${o}${r}`
                }
            };
            const c = BigInt(0), u = BigInt(1), d = BigInt(2), h = BigInt(3), f = BigInt(4);

            function p(e) {
                const t = function (e) {
                    const t = (0, a.validateBasic)(e);
                    i.validateObject(t, {a: "field", b: "field"}, {
                        allowedPrivateKeyLengths: "array",
                        wrapPrivateKey: "boolean",
                        isTorsionFree: "function",
                        clearCofactor: "function",
                        allowInfinityPoint: "boolean",
                        fromBytes: "function",
                        toBytes: "function"
                    });
                    const {endo: n, Fp: r, a: s} = t;
                    if (n) {
                        if (!r.eql(s, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                        if ("object" != typeof n || "bigint" != typeof n.beta || "function" != typeof n.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
                    }
                    return Object.freeze({...t})
                }(e), {Fp: n} = t, o = t.toBytes || ((e, t, r) => {
                    const s = t.toAffine();
                    return i.concatBytes(Uint8Array.from([4]), n.toBytes(s.x), n.toBytes(s.y))
                }), l = t.fromBytes || (e => {
                    const t = e.subarray(1);
                    return {x: n.fromBytes(t.subarray(0, n.BYTES)), y: n.fromBytes(t.subarray(n.BYTES, 2 * n.BYTES))}
                });

                function d(e) {
                    const {a: r, b: i} = t, s = n.sqr(e), a = n.mul(s, e);
                    return n.add(n.add(a, n.mul(e, r)), i)
                }

                if (!n.eql(n.sqr(t.Gy), d(t.Gx))) throw new Error("bad generator point: equation left != right");

                function f(e) {
                    return "bigint" == typeof e && c < e && e < t.n
                }

                function p(e) {
                    if (!f(e)) throw new Error("Expected valid bigint: 0 < bigint < curve.n")
                }

                function m(e) {
                    const {allowedPrivateKeyLengths: n, nByteLength: a, wrapPrivateKey: o, n: l} = t;
                    if (n && "bigint" != typeof e) {
                        if (e instanceof Uint8Array && (e = i.bytesToHex(e)), "string" != typeof e || !n.includes(e.length)) throw new Error("Invalid key");
                        e = e.padStart(2 * a, "0")
                    }
                    let c;
                    try {
                        c = "bigint" == typeof e ? e : i.bytesToNumberBE((0, s.ensureBytes)("private key", e, a))
                    } catch (t) {
                        throw new Error(`private key must be ${a} bytes, hex or bigint, not ${typeof e}`)
                    }
                    return o && (c = r.mod(c, l)), p(c), c
                }

                const g = new Map;

                function y(e) {
                    if (!(e instanceof v)) throw new Error("ProjectivePoint expected")
                }

                class v {
                    constructor(e, t, r) {
                        if (this.px = e, this.py = t, this.pz = r, null == e || !n.isValid(e)) throw new Error("x required");
                        if (null == t || !n.isValid(t)) throw new Error("y required");
                        if (null == r || !n.isValid(r)) throw new Error("z required")
                    }

                    static fromAffine(e) {
                        const {x: t, y: r} = e || {};
                        if (!e || !n.isValid(t) || !n.isValid(r)) throw new Error("invalid affine point");
                        if (e instanceof v) throw new Error("projective point not allowed");
                        const i = e => n.eql(e, n.ZERO);
                        return i(t) && i(r) ? v.ZERO : new v(t, r, n.ONE)
                    }

                    get x() {
                        return this.toAffine().x
                    }

                    get y() {
                        return this.toAffine().y
                    }

                    static normalizeZ(e) {
                        const t = n.invertBatch(e.map((e => e.pz)));
                        return e.map(((e, n) => e.toAffine(t[n]))).map(v.fromAffine)
                    }

                    static fromHex(e) {
                        const t = v.fromAffine(l((0, s.ensureBytes)("pointHex", e)));
                        return t.assertValidity(), t
                    }

                    static fromPrivateKey(e) {
                        return v.BASE.multiply(m(e))
                    }

                    _setWindowSize(e) {
                        this._WINDOW_SIZE = e, g.delete(this)
                    }

                    assertValidity() {
                        if (this.is0()) {
                            if (t.allowInfinityPoint) return;
                            throw new Error("bad point: ZERO")
                        }
                        const {x: e, y: r} = this.toAffine();
                        if (!n.isValid(e) || !n.isValid(r)) throw new Error("bad point: x or y not FE");
                        const i = n.sqr(r), s = d(e);
                        if (!n.eql(i, s)) throw new Error("bad point: equation left != right");
                        if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup")
                    }

                    hasEvenY() {
                        const {y: e} = this.toAffine();
                        if (n.isOdd) return !n.isOdd(e);
                        throw new Error("Field doesn't support isOdd")
                    }

                    equals(e) {
                        y(e);
                        const {px: t, py: r, pz: i} = this, {px: s, py: a, pz: o} = e,
                            l = n.eql(n.mul(t, o), n.mul(s, i)), c = n.eql(n.mul(r, o), n.mul(a, i));
                        return l && c
                    }

                    negate() {
                        return new v(this.px, n.neg(this.py), this.pz)
                    }

                    double() {
                        const {a: e, b: r} = t, i = n.mul(r, h), {px: s, py: a, pz: o} = this;
                        let l = n.ZERO, c = n.ZERO, u = n.ZERO, d = n.mul(s, s), f = n.mul(a, a), p = n.mul(o, o),
                            m = n.mul(s, a);
                        return m = n.add(m, m), u = n.mul(s, o), u = n.add(u, u), l = n.mul(e, u), c = n.mul(i, p), c = n.add(l, c), l = n.sub(f, c), c = n.add(f, c), c = n.mul(l, c), l = n.mul(m, l), u = n.mul(i, u), p = n.mul(e, p), m = n.sub(d, p), m = n.mul(e, m), m = n.add(m, u), u = n.add(d, d), d = n.add(u, d), d = n.add(d, p), d = n.mul(d, m), c = n.add(c, d), p = n.mul(a, o), p = n.add(p, p), d = n.mul(p, m), l = n.sub(l, d), u = n.mul(p, f), u = n.add(u, u), u = n.add(u, u), new v(l, c, u)
                    }

                    add(e) {
                        y(e);
                        const {px: r, py: i, pz: s} = this, {px: a, py: o, pz: l} = e;
                        let c = n.ZERO, u = n.ZERO, d = n.ZERO;
                        const f = t.a, p = n.mul(t.b, h);
                        let m = n.mul(r, a), g = n.mul(i, o), b = n.mul(s, l), w = n.add(r, i), x = n.add(a, o);
                        w = n.mul(w, x), x = n.add(m, g), w = n.sub(w, x), x = n.add(r, s);
                        let E = n.add(a, l);
                        return x = n.mul(x, E), E = n.add(m, b), x = n.sub(x, E), E = n.add(i, s), c = n.add(o, l), E = n.mul(E, c), c = n.add(g, b), E = n.sub(E, c), d = n.mul(f, x), c = n.mul(p, b), d = n.add(c, d), c = n.sub(g, d), d = n.add(g, d), u = n.mul(c, d), g = n.add(m, m), g = n.add(g, m), b = n.mul(f, b), x = n.mul(p, x), g = n.add(g, b), b = n.sub(m, b), b = n.mul(f, b), x = n.add(x, b), m = n.mul(g, x), u = n.add(u, m), m = n.mul(E, x), c = n.mul(w, c), c = n.sub(c, m), m = n.mul(w, g), d = n.mul(E, d), d = n.add(d, m), new v(c, u, d)
                    }

                    subtract(e) {
                        return this.add(e.negate())
                    }

                    is0() {
                        return this.equals(v.ZERO)
                    }

                    wNAF(e) {
                        return w.wNAFCached(this, g, e, (e => {
                            const t = n.invertBatch(e.map((e => e.pz)));
                            return e.map(((e, n) => e.toAffine(t[n]))).map(v.fromAffine)
                        }))
                    }

                    multiplyUnsafe(e) {
                        const r = v.ZERO;
                        if (e === c) return r;
                        if (p(e), e === u) return this;
                        const {endo: i} = t;
                        if (!i) return w.unsafeLadder(this, e);
                        let {k1neg: s, k1: a, k2neg: o, k2: l} = i.splitScalar(e), d = r, h = r, f = this;
                        for (; a > c || l > c;) a & u && (d = d.add(f)), l & u && (h = h.add(f)), f = f.double(), a >>= u, l >>= u;
                        return s && (d = d.negate()), o && (h = h.negate()), h = new v(n.mul(h.px, i.beta), h.py, h.pz), d.add(h)
                    }

                    multiply(e) {
                        p(e);
                        let r, i, s = e;
                        const {endo: a} = t;
                        if (a) {
                            const {k1neg: e, k1: t, k2neg: o, k2: l} = a.splitScalar(s);
                            let {p: c, f: u} = this.wNAF(t), {p: d, f: h} = this.wNAF(l);
                            c = w.constTimeNegate(e, c), d = w.constTimeNegate(o, d), d = new v(n.mul(d.px, a.beta), d.py, d.pz), r = c.add(d), i = u.add(h)
                        } else {
                            const {p: e, f: t} = this.wNAF(s);
                            r = e, i = t
                        }
                        return v.normalizeZ([r, i])[0]
                    }

                    multiplyAndAddUnsafe(e, t, n) {
                        const r = v.BASE,
                            i = (e, t) => t !== c && t !== u && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t),
                            s = i(this, t).add(i(e, n));
                        return s.is0() ? void 0 : s
                    }

                    toAffine(e) {
                        const {px: t, py: r, pz: i} = this, s = this.is0();
                        null == e && (e = s ? n.ONE : n.inv(i));
                        const a = n.mul(t, e), o = n.mul(r, e), l = n.mul(i, e);
                        if (s) return {x: n.ZERO, y: n.ZERO};
                        if (!n.eql(l, n.ONE)) throw new Error("invZ was invalid");
                        return {x: a, y: o}
                    }

                    isTorsionFree() {
                        const {h: e, isTorsionFree: n} = t;
                        if (e === u) return !0;
                        if (n) return n(v, this);
                        throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                    }

                    clearCofactor() {
                        const {h: e, clearCofactor: n} = t;
                        return e === u ? this : n ? n(v, this) : this.multiplyUnsafe(t.h)
                    }

                    toRawBytes(e = !0) {
                        return this.assertValidity(), o(v, this, e)
                    }

                    toHex(e = !0) {
                        return i.bytesToHex(this.toRawBytes(e))
                    }
                }

                v.BASE = new v(t.Gx, t.Gy, n.ONE), v.ZERO = new v(n.ZERO, n.ONE, n.ZERO);
                const b = t.nBitLength, w = (0, a.wNAF)(v, t.endo ? Math.ceil(b / 2) : b);
                return {
                    CURVE: t,
                    ProjectivePoint: v,
                    normPrivateKeyToScalar: m,
                    weierstrassEquation: d,
                    isWithinCurveOrder: f
                }
            }

            function m(e, t) {
                const n = e.ORDER;
                let r = c;
                for (let e = n - u; e % d === c; e /= d) r += u;
                const i = r, s = d << i - u - u, a = s * d, o = (n - u) / a, l = (o - u) / d, p = a - u, m = s,
                    g = e.pow(t, o), y = e.pow(t, (o + u) / d);
                let v = (t, n) => {
                    let r = g, s = e.pow(n, p), a = e.sqr(s);
                    a = e.mul(a, n);
                    let o = e.mul(t, a);
                    o = e.pow(o, l), o = e.mul(o, s), s = e.mul(o, n), a = e.mul(o, t);
                    let c = e.mul(a, s);
                    o = e.pow(c, m);
                    let h = e.eql(o, e.ONE);
                    s = e.mul(a, y), o = e.mul(c, r), a = e.cmov(s, a, h), c = e.cmov(o, c, h);
                    for (let t = i; t > u; t--) {
                        let n = t - d;
                        n = d << n - u;
                        let i = e.pow(c, n);
                        const o = e.eql(i, e.ONE);
                        s = e.mul(a, r), r = e.mul(r, r), i = e.mul(c, r), a = e.cmov(s, a, o), c = e.cmov(i, c, o)
                    }
                    return {isValid: h, value: a}
                };
                if (e.ORDER % f === h) {
                    const n = (e.ORDER - h) / f, r = e.sqrt(e.neg(t));
                    v = (t, i) => {
                        let s = e.sqr(i);
                        const a = e.mul(t, i);
                        s = e.mul(s, a);
                        let o = e.pow(s, n);
                        o = e.mul(o, a);
                        const l = e.mul(o, r), c = e.mul(e.sqr(o), i), u = e.eql(c, t);
                        return {isValid: u, value: e.cmov(l, o, u)}
                    }
                }
                return v
            }

            t.weierstrassPoints = p, t.weierstrass = function (e) {
                const n = function (e) {
                    const t = (0, a.validateBasic)(e);
                    return i.validateObject(t, {
                        hash: "hash",
                        hmac: "function",
                        randomBytes: "function"
                    }, {
                        bits2int: "function",
                        bits2int_modN: "function",
                        lowS: "boolean"
                    }), Object.freeze({lowS: !0, ...t})
                }(e), {Fp: o, n: l} = n, d = o.BYTES + 1, h = 2 * o.BYTES + 1;

                function f(e) {
                    return r.mod(e, l)
                }

                function m(e) {
                    return r.invert(e, l)
                }

                const {
                    ProjectivePoint: g,
                    normPrivateKeyToScalar: y,
                    weierstrassEquation: v,
                    isWithinCurveOrder: b
                } = p({
                    ...n, toBytes(e, t, n) {
                        const r = t.toAffine(), s = o.toBytes(r.x), a = i.concatBytes;
                        return n ? a(Uint8Array.from([t.hasEvenY() ? 2 : 3]), s) : a(Uint8Array.from([4]), s, o.toBytes(r.y))
                    }, fromBytes(e) {
                        const t = e.length, n = e[0], r = e.subarray(1);
                        if (t !== d || 2 !== n && 3 !== n) {
                            if (t === h && 4 === n) return {
                                x: o.fromBytes(r.subarray(0, o.BYTES)),
                                y: o.fromBytes(r.subarray(o.BYTES, 2 * o.BYTES))
                            };
                            throw new Error(`Point of length ${t} was invalid. Expected ${d} compressed bytes or ${h} uncompressed bytes`)
                        }
                        {
                            const e = i.bytesToNumberBE(r);
                            if (!(c < (s = e) && s < o.ORDER)) throw new Error("Point is not on curve");
                            const t = v(e);
                            let a = o.sqrt(t);
                            return 1 == (1 & n) != ((a & u) === u) && (a = o.neg(a)), {x: e, y: a}
                        }
                        var s
                    }
                }), w = e => i.bytesToHex(i.numberToBytesBE(e, n.nByteLength));

                function x(e) {
                    return e > l >> u
                }

                const E = (e, t, n) => i.bytesToNumberBE(e.slice(t, n));

                class S {
                    constructor(e, t, n) {
                        this.r = e, this.s = t, this.recovery = n, this.assertValidity()
                    }

                    static fromCompact(e) {
                        const t = n.nByteLength;
                        return e = (0, s.ensureBytes)("compactSignature", e, 2 * t), new S(E(e, 0, t), E(e, t, 2 * t))
                    }

                    static fromDER(e) {
                        const {r: n, s: r} = t.DER.toSig((0, s.ensureBytes)("DER", e));
                        return new S(n, r)
                    }

                    assertValidity() {
                        if (!b(this.r)) throw new Error("r must be 0 < r < CURVE.n");
                        if (!b(this.s)) throw new Error("s must be 0 < s < CURVE.n")
                    }

                    addRecoveryBit(e) {
                        return new S(this.r, this.s, e)
                    }

                    recoverPublicKey(e) {
                        const {r: t, s: r, recovery: i} = this, a = C((0, s.ensureBytes)("msgHash", e));
                        if (null == i || ![0, 1, 2, 3].includes(i)) throw new Error("recovery id invalid");
                        const l = 2 === i || 3 === i ? t + n.n : t;
                        if (l >= o.ORDER) throw new Error("recovery id 2 or 3 invalid");
                        const c = 0 == (1 & i) ? "02" : "03", u = g.fromHex(c + w(l)), d = m(l), h = f(-a * d),
                            p = f(r * d), y = g.BASE.multiplyAndAddUnsafe(u, h, p);
                        if (!y) throw new Error("point at infinify");
                        return y.assertValidity(), y
                    }

                    hasHighS() {
                        return x(this.s)
                    }

                    normalizeS() {
                        return this.hasHighS() ? new S(this.r, f(-this.s), this.recovery) : this
                    }

                    toDERRawBytes() {
                        return i.hexToBytes(this.toDERHex())
                    }

                    toDERHex() {
                        return t.DER.hexFromSig({r: this.r, s: this.s})
                    }

                    toCompactRawBytes() {
                        return i.hexToBytes(this.toCompactHex())
                    }

                    toCompactHex() {
                        return w(this.r) + w(this.s)
                    }
                }

                const k = {
                    isValidPrivateKey(e) {
                        try {
                            return y(e), !0
                        } catch (e) {
                            return !1
                        }
                    }, normPrivateKeyToScalar: y, randomPrivateKey: () => {
                        const e = n.randomBytes(o.BYTES + 8), t = r.hashToPrivateScalar(e, l);
                        return i.numberToBytesBE(t, n.nByteLength)
                    }, precompute: (e = 8, t = g.BASE) => (t._setWindowSize(e), t.multiply(BigInt(3)), t)
                };

                function A(e) {
                    const t = e instanceof Uint8Array, n = "string" == typeof e, r = (t || n) && e.length;
                    return t ? r === d || r === h : n ? r === 2 * d || r === 2 * h : e instanceof g
                }

                const T = n.bits2int || function (e) {
                    const t = i.bytesToNumberBE(e), r = 8 * e.length - n.nBitLength;
                    return r > 0 ? t >> BigInt(r) : t
                }, C = n.bits2int_modN || function (e) {
                    return f(T(e))
                }, R = i.bitMask(n.nBitLength);

                function L(e) {
                    if ("bigint" != typeof e) throw new Error("bigint expected");
                    if (!(c <= e && e < R)) throw new Error(`bigint expected < 2^${n.nBitLength}`);
                    return i.numberToBytesBE(e, n.nByteLength)
                }

                const _ = {lowS: n.lowS, prehash: !1}, P = {lowS: n.lowS, prehash: !1};
                return g.BASE._setWindowSize(8), {
                    CURVE: n, getPublicKey: function (e, t = !0) {
                        return g.fromPrivateKey(e).toRawBytes(t)
                    }, getSharedSecret: function (e, t, n = !0) {
                        if (A(e)) throw new Error("first arg must be private key");
                        if (!A(t)) throw new Error("second arg must be public key");
                        return g.fromHex(t).multiply(y(e)).toRawBytes(n)
                    }, sign: function (e, t, r = _) {
                        const {seed: a, k2sig: l} = function (e, t, r = _) {
                            if (["recovered", "canonical"].some((e => e in r))) throw new Error("sign() legacy options not supported");
                            const {hash: a, randomBytes: l} = n;
                            let {lowS: d, prehash: h, extraEntropy: p} = r;
                            null == d && (d = !0), e = (0, s.ensureBytes)("msgHash", e), h && (e = (0, s.ensureBytes)("prehashed msgHash", a(e)));
                            const v = C(e), w = y(t), E = [L(w), L(v)];
                            if (null != p) {
                                const e = !0 === p ? l(o.BYTES) : p;
                                E.push((0, s.ensureBytes)("extraEntropy", e, o.BYTES))
                            }
                            const k = i.concatBytes(...E), A = v;
                            return {
                                seed: k, k2sig: function (e) {
                                    const t = T(e);
                                    if (!b(t)) return;
                                    const n = m(t), r = g.BASE.multiply(t).toAffine(), i = f(r.x);
                                    if (i === c) return;
                                    const s = f(n * f(A + i * w));
                                    if (s === c) return;
                                    let a = (r.x === i ? 0 : 2) | Number(r.y & u), o = s;
                                    return d && x(s) && (o = function (e) {
                                        return x(e) ? f(-e) : e
                                    }(s), a ^= 1), new S(i, o, a)
                                }
                            }
                        }(e, t, r), d = n;
                        return i.createHmacDrbg(d.hash.outputLen, d.nByteLength, d.hmac)(a, l)
                    }, verify: function (e, r, i, a = P) {
                        const o = e;
                        if (r = (0, s.ensureBytes)("msgHash", r), i = (0, s.ensureBytes)("publicKey", i), "strict" in a) throw new Error("options.strict was renamed to lowS");
                        const {lowS: l, prehash: c} = a;
                        let u, d;
                        try {
                            if ("string" == typeof o || o instanceof Uint8Array) try {
                                u = S.fromDER(o)
                            } catch (e) {
                                if (!(e instanceof t.DER.Err)) throw e;
                                u = S.fromCompact(o)
                            } else {
                                if ("object" != typeof o || "bigint" != typeof o.r || "bigint" != typeof o.s) throw new Error("PARSE");
                                {
                                    const {r: e, s: t} = o;
                                    u = new S(e, t)
                                }
                            }
                            d = g.fromHex(i)
                        } catch (e) {
                            if ("PARSE" === e.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
                            return !1
                        }
                        if (l && u.hasHighS()) return !1;
                        c && (r = n.hash(r));
                        const {r: h, s: p} = u, y = C(r), v = m(p), b = f(y * v), w = f(h * v),
                            x = g.BASE.multiplyAndAddUnsafe(d, b, w)?.toAffine();
                        return !!x && f(x.x) === h
                    }, ProjectivePoint: g, Signature: S, utils: k
                }
            }, t.SWUFpSqrtRatio = m, t.mapToCurveSimpleSWU = function (e, t) {
                if (r.validateField(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
                const n = m(e, t.Z);
                if (!e.isOdd) throw new Error("Fp.isOdd is not implemented!");
                return r => {
                    let i, s, a, o, l, c, u, d;
                    i = e.sqr(r), i = e.mul(i, t.Z), s = e.sqr(i), s = e.add(s, i), a = e.add(s, e.ONE), a = e.mul(a, t.B), o = e.cmov(t.Z, e.neg(s), !e.eql(s, e.ZERO)), o = e.mul(o, t.A), s = e.sqr(a), c = e.sqr(o), l = e.mul(c, t.A), s = e.add(s, l), s = e.mul(s, a), c = e.mul(c, o), l = e.mul(c, t.B), s = e.add(s, l), u = e.mul(i, a);
                    const {isValid: h, value: f} = n(s, c);
                    d = e.mul(i, r), d = e.mul(d, f), u = e.cmov(u, a, h), d = e.cmov(d, f, h);
                    const p = e.isOdd(r) === e.isOdd(d);
                    return d = e.cmov(e.neg(d), d, p), u = e.div(u, o), {x: u, y: d}
                }
            }
        }, 3491: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.encodeToCurve = t.hashToCurve = t.schnorr = t.secp256k1 = void 0;
            const r = n(1206), i = n(2331), s = n(4346), a = n(4151), o = n(3595), l = n(4713), c = n(1374),
                u = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
                d = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), h = BigInt(1),
                f = BigInt(2), p = (e, t) => (e + t / f) / t;

            function m(e) {
                const t = u, n = BigInt(3), r = BigInt(6), i = BigInt(11), a = BigInt(22), o = BigInt(23),
                    l = BigInt(44), c = BigInt(88), d = e * e * e % t, h = d * d * e % t,
                    p = (0, s.pow2)(h, n, t) * h % t, m = (0, s.pow2)(p, n, t) * h % t,
                    y = (0, s.pow2)(m, f, t) * d % t, v = (0, s.pow2)(y, i, t) * y % t,
                    b = (0, s.pow2)(v, a, t) * v % t, w = (0, s.pow2)(b, l, t) * b % t,
                    x = (0, s.pow2)(w, c, t) * w % t, E = (0, s.pow2)(x, l, t) * b % t,
                    S = (0, s.pow2)(E, n, t) * h % t, k = (0, s.pow2)(S, o, t) * v % t,
                    A = (0, s.pow2)(k, r, t) * d % t, T = (0, s.pow2)(A, f, t);
                if (!g.eql(g.sqr(T), e)) throw new Error("Cannot find square root");
                return T
            }

            const g = (0, s.Field)(u, void 0, void 0, {sqrt: m});
            t.secp256k1 = (0, c.createCurve)({
                a: BigInt(0),
                b: BigInt(7),
                Fp: g,
                n: d,
                Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                h: BigInt(1),
                lowS: !0,
                endo: {
                    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                    splitScalar: e => {
                        const t = d, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                            r = -h * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                            i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = n,
                            o = BigInt("0x100000000000000000000000000000000"), l = p(a * e, t), c = p(-r * e, t);
                        let u = (0, s.mod)(e - l * n - c * i, t), f = (0, s.mod)(-l * r - c * a, t);
                        const m = u > o, g = f > o;
                        if (m && (u = t - u), g && (f = t - f), u > o || f > o) throw new Error("splitScalar: Endomorphism failed, k=" + e);
                        return {k1neg: m, k1: u, k2neg: g, k2: f}
                    }
                }
            }, r.sha256);
            const y = BigInt(0), v = e => "bigint" == typeof e && y < e && e < u,
                b = e => "bigint" == typeof e && y < e && e < d, w = {};

            function x(e, ...t) {
                let n = w[e];
                if (void 0 === n) {
                    const t = (0, r.sha256)(Uint8Array.from(e, (e => e.charCodeAt(0))));
                    n = (0, o.concatBytes)(t, t), w[e] = n
                }
                return (0, r.sha256)((0, o.concatBytes)(n, ...t))
            }

            const E = e => e.toRawBytes(!0).slice(1), S = e => (0, o.numberToBytesBE)(e, 32), k = e => (0, s.mod)(e, u),
                A = e => (0, s.mod)(e, d), T = t.secp256k1.ProjectivePoint,
                C = (e, t, n) => T.BASE.multiplyAndAddUnsafe(e, t, n);

            function R(e) {
                let n = t.secp256k1.utils.normPrivateKeyToScalar(e), r = T.fromPrivateKey(n);
                return {scalar: r.hasEvenY() ? n : A(-n), bytes: E(r)}
            }

            function L(e) {
                if (!v(e)) throw new Error("bad x: need 0 < x < p");
                const t = k(e * e);
                let n = m(k(t * e + BigInt(7)));
                n % f !== y && (n = k(-n));
                const r = new T(e, n, h);
                return r.assertValidity(), r
            }

            function _(...e) {
                return A((0, o.bytesToNumberBE)(x("BIP0340/challenge", ...e)))
            }

            function P(e, t, n) {
                const r = (0, o.ensureBytes)("signature", e, 64), i = (0, o.ensureBytes)("message", t),
                    s = (0, o.ensureBytes)("publicKey", n, 32);
                try {
                    const e = L((0, o.bytesToNumberBE)(s)), t = (0, o.bytesToNumberBE)(r.subarray(0, 32));
                    if (!v(t)) return !1;
                    const n = (0, o.bytesToNumberBE)(r.subarray(32, 64));
                    if (!b(n)) return !1;
                    const a = _(S(t), E(e), i), l = C(e, n, A(-a));
                    return !(!l || !l.hasEvenY() || l.toAffine().x !== t)
                } catch (e) {
                    return !1
                }
            }

            t.schnorr = {
                getPublicKey: function (e) {
                    return R(e).bytes
                },
                sign: function (e, t, n = (0, i.randomBytes)(32)) {
                    const r = (0, o.ensureBytes)("message", e), {bytes: s, scalar: a} = R(t),
                        l = (0, o.ensureBytes)("auxRand", n, 32),
                        c = S(a ^ (0, o.bytesToNumberBE)(x("BIP0340/aux", l))), u = x("BIP0340/nonce", c, s, r),
                        d = A((0, o.bytesToNumberBE)(u));
                    if (d === y) throw new Error("sign failed: k is zero");
                    const {bytes: h, scalar: f} = R(d), p = _(h, s, r), m = new Uint8Array(64);
                    if (m.set(h, 0), m.set(S(A(f + p * a)), 32), !P(m, r, s)) throw new Error("sign: Invalid signature produced");
                    return m
                },
                verify: P,
                utils: {
                    randomPrivateKey: t.secp256k1.utils.randomPrivateKey,
                    lift_x: L,
                    pointToBytes: E,
                    numberToBytesBE: o.numberToBytesBE,
                    bytesToNumberBE: o.bytesToNumberBE,
                    taggedHash: x,
                    mod: s.mod
                }
            };
            const N = (() => (0, l.isogenyMap)(g, [["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"], ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"], ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"], ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]].map((e => e.map((e => BigInt(e)))))))(),
                j = (() => (0, a.mapToCurveSimpleSWU)(g, {
                    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
                    B: BigInt("1771"),
                    Z: g.create(BigInt("-11"))
                }))(), I = (() => (0, l.createHasher)(t.secp256k1.ProjectivePoint, (e => {
                    const {x: t, y: n} = j(g.create(e[0]));
                    return N(t, n)
                }), {
                    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
                    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
                    p: g.ORDER,
                    m: 1,
                    k: 128,
                    expand: "xmd",
                    hash: r.sha256
                }))();
            t.hashToCurve = I.hashToCurve, t.encodeToCurve = I.encodeToCurve
        }, 5085: (e, t) => {
            "use strict";

            function n(e) {
                if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`)
            }

            function r(e) {
                if ("boolean" != typeof e) throw new Error(`Expected boolean, not ${e}`)
            }

            function i(e, ...t) {
                if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
                if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)
            }

            function s(e) {
                if ("function" != typeof e || "function" != typeof e.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
                n(e.outputLen), n(e.blockLen)
            }

            function a(e, t = !0) {
                if (e.destroyed) throw new Error("Hash instance has been destroyed");
                if (t && e.finished) throw new Error("Hash#digest() has already been called")
            }

            function o(e, t) {
                i(e);
                const n = t.outputLen;
                if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`)
            }

            Object.defineProperty(t, "__esModule", {value: !0}), t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0, t.number = n, t.bool = r, t.bytes = i, t.hash = s, t.exists = a, t.output = o;
            const l = {number: n, bool: r, bytes: i, hash: s, exists: a, output: o};
            t.default = l
        }, 6878: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.SHA2 = void 0;
            const r = n(5085), i = n(2331);

            class s extends i.Hash {
                constructor(e, t, n, r) {
                    super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, i.createView)(this.buffer)
                }

                update(e) {
                    r.default.exists(this);
                    const {view: t, buffer: n, blockLen: s} = this, a = (e = (0, i.toBytes)(e)).length;
                    for (let r = 0; r < a;) {
                        const o = Math.min(s - this.pos, a - r);
                        if (o !== s) n.set(e.subarray(r, r + o), this.pos), this.pos += o, r += o, this.pos === s && (this.process(t, 0), this.pos = 0); else {
                            const t = (0, i.createView)(e);
                            for (; s <= a - r; r += s) this.process(t, r)
                        }
                    }
                    return this.length += e.length, this.roundClean(), this
                }

                digestInto(e) {
                    r.default.exists(this), r.default.output(e, this), this.finished = !0;
                    const {buffer: t, view: n, blockLen: s, isLE: a} = this;
                    let {pos: o} = this;
                    t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(n, 0), o = 0);
                    for (let e = o; e < s; e++) t[e] = 0;
                    !function (e, t, n, r) {
                        if ("function" == typeof e.setBigUint64) return e.setBigUint64(t, n, r);
                        const i = BigInt(32), s = BigInt(4294967295), a = Number(n >> i & s), o = Number(n & s),
                            l = r ? 4 : 0, c = r ? 0 : 4;
                        e.setUint32(t + l, a, r), e.setUint32(t + c, o, r)
                    }(n, s - 8, BigInt(8 * this.length), a), this.process(n, 0);
                    const l = (0, i.createView)(e), c = this.outputLen;
                    if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
                    const u = c / 4, d = this.get();
                    if (u > d.length) throw new Error("_sha2: outputLen bigger than state");
                    for (let e = 0; e < u; e++) l.setUint32(4 * e, d[e], a)
                }

                digest() {
                    const {buffer: e, outputLen: t} = this;
                    this.digestInto(e);
                    const n = e.slice(0, t);
                    return this.destroy(), n
                }

                _cloneInto(e) {
                    e || (e = new this.constructor), e.set(...this.get());
                    const {blockLen: t, buffer: n, length: r, finished: i, destroyed: s, pos: a} = this;
                    return e.length = r, e.pos = a, e.finished = i, e.destroyed = s, r % t && e.buffer.set(n), e
                }
            }

            t.SHA2 = s
        }, 5344: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.crypto = void 0, t.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0
        }, 7606: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.hmac = t.HMAC = void 0;
            const r = n(5085), i = n(2331);

            class s extends i.Hash {
                constructor(e, t) {
                    super(), this.finished = !1, this.destroyed = !1, r.default.hash(e);
                    const n = (0, i.toBytes)(t);
                    if (this.iHash = e.create(), "function" != typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
                    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
                    const s = this.blockLen, a = new Uint8Array(s);
                    a.set(n.length > s ? e.create().update(n).digest() : n);
                    for (let e = 0; e < a.length; e++) a[e] ^= 54;
                    this.iHash.update(a), this.oHash = e.create();
                    for (let e = 0; e < a.length; e++) a[e] ^= 106;
                    this.oHash.update(a), a.fill(0)
                }

                update(e) {
                    return r.default.exists(this), this.iHash.update(e), this
                }

                digestInto(e) {
                    r.default.exists(this), r.default.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy()
                }

                digest() {
                    const e = new Uint8Array(this.oHash.outputLen);
                    return this.digestInto(e), e
                }

                _cloneInto(e) {
                    e || (e = Object.create(Object.getPrototypeOf(this), {}));
                    const {oHash: t, iHash: n, finished: r, destroyed: i, blockLen: s, outputLen: a} = this;
                    return e.finished = r, e.destroyed = i, e.blockLen = s, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e
                }

                destroy() {
                    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
                }
            }

            t.HMAC = s, t.hmac = (e, t, n) => new s(e, t).update(n).digest(), t.hmac.create = (e, t) => new s(e, t)
        }, 1206: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.sha224 = t.sha256 = void 0;
            const r = n(6878), i = n(2331), s = (e, t, n) => e & t ^ e & n ^ t & n,
                a = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
                o = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
                l = new Uint32Array(64);

            class c extends r.SHA2 {
                constructor() {
                    super(64, 32, 8, !1), this.A = 0 | o[0], this.B = 0 | o[1], this.C = 0 | o[2], this.D = 0 | o[3], this.E = 0 | o[4], this.F = 0 | o[5], this.G = 0 | o[6], this.H = 0 | o[7]
                }

                get() {
                    const {A: e, B: t, C: n, D: r, E: i, F: s, G: a, H: o} = this;
                    return [e, t, n, r, i, s, a, o]
                }

                set(e, t, n, r, i, s, a, o) {
                    this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | s, this.G = 0 | a, this.H = 0 | o
                }

                process(e, t) {
                    for (let n = 0; n < 16; n++, t += 4) l[n] = e.getUint32(t, !1);
                    for (let e = 16; e < 64; e++) {
                        const t = l[e - 15], n = l[e - 2], r = (0, i.rotr)(t, 7) ^ (0, i.rotr)(t, 18) ^ t >>> 3,
                            s = (0, i.rotr)(n, 17) ^ (0, i.rotr)(n, 19) ^ n >>> 10;
                        l[e] = s + l[e - 7] + r + l[e - 16] | 0
                    }
                    let {A: n, B: r, C: o, D: c, E: u, F: d, G: h, H: f} = this;
                    for (let e = 0; e < 64; e++) {
                        const t = f + ((0, i.rotr)(u, 6) ^ (0, i.rotr)(u, 11) ^ (0, i.rotr)(u, 25)) + ((p = u) & d ^ ~p & h) + a[e] + l[e] | 0,
                            m = ((0, i.rotr)(n, 2) ^ (0, i.rotr)(n, 13) ^ (0, i.rotr)(n, 22)) + s(n, r, o) | 0;
                        f = h, h = d, d = u, u = c + t | 0, c = o, o = r, r = n, n = t + m | 0
                    }
                    var p;
                    n = n + this.A | 0, r = r + this.B | 0, o = o + this.C | 0, c = c + this.D | 0, u = u + this.E | 0, d = d + this.F | 0, h = h + this.G | 0, f = f + this.H | 0, this.set(n, r, o, c, u, d, h, f)
                }

                roundClean() {
                    l.fill(0)
                }

                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
                }
            }

            class u extends c {
                constructor() {
                    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28
                }
            }

            t.sha256 = (0, i.wrapConstructor)((() => new c)), t.sha224 = (0, i.wrapConstructor)((() => new u))
        }, 2331: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.randomBytes = t.wrapXOFConstructorWithOpts = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0;
            const r = n(5344), i = e => e instanceof Uint8Array;
            if (t.u8 = e => new Uint8Array(e.buffer, e.byteOffset, e.byteLength), t.u32 = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), t.createView = e => new DataView(e.buffer, e.byteOffset, e.byteLength), t.rotr = (e, t) => e << 32 - t | e >>> t, t.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !t.isLE) throw new Error("Non little-endian hardware is not supported");
            const s = Array.from({length: 256}, ((e, t) => t.toString(16).padStart(2, "0")));

            function a(e) {
                if ("string" != typeof e) throw new Error("utf8ToBytes expected string, got " + typeof e);
                return new Uint8Array((new TextEncoder).encode(e))
            }

            function o(e) {
                if ("string" == typeof e && (e = a(e)), !i(e)) throw new Error("expected Uint8Array, got " + typeof e);
                return e
            }

            t.bytesToHex = function (e) {
                if (!i(e)) throw new Error("Uint8Array expected");
                let t = "";
                for (let n = 0; n < e.length; n++) t += s[e[n]];
                return t
            }, t.hexToBytes = function (e) {
                if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
                const t = e.length;
                if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
                const n = new Uint8Array(t / 2);
                for (let t = 0; t < n.length; t++) {
                    const r = 2 * t, i = e.slice(r, r + 2), s = Number.parseInt(i, 16);
                    if (Number.isNaN(s) || s < 0) throw new Error("Invalid byte sequence");
                    n[t] = s
                }
                return n
            }, t.nextTick = async () => {
            }, t.asyncLoop = async function (e, n, r) {
                let i = Date.now();
                for (let s = 0; s < e; s++) {
                    r(s);
                    const e = Date.now() - i;
                    e >= 0 && e < n || (await (0, t.nextTick)(), i += e)
                }
            }, t.utf8ToBytes = a, t.toBytes = o, t.concatBytes = function (...e) {
                const t = new Uint8Array(e.reduce(((e, t) => e + t.length), 0));
                let n = 0;
                return e.forEach((e => {
                    if (!i(e)) throw new Error("Uint8Array expected");
                    t.set(e, n), n += e.length
                })), t
            }, t.Hash = class {
                clone() {
                    return this._cloneInto()
                }
            }, t.checkOpts = function (e, t) {
                if (void 0 !== t && ("object" != typeof t || (n = t, "[object Object]" !== Object.prototype.toString.call(n) || n.constructor !== Object))) throw new Error("Options should be object or undefined");
                var n;
                return Object.assign(e, t)
            }, t.wrapConstructor = function (e) {
                const t = t => e().update(o(t)).digest(), n = e();
                return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t
            }, t.wrapConstructorWithOpts = function (e) {
                const t = (t, n) => e(n).update(o(t)).digest(), n = e({});
                return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = t => e(t), t
            }, t.wrapXOFConstructorWithOpts = function (e) {
                const t = (t, n) => e(n).update(o(t)).digest(), n = e({});
                return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = t => e(t), t
            }, t.randomBytes = function (e = 32) {
                if (r.crypto && "function" == typeof r.crypto.getRandomValues) return r.crypto.getRandomValues(new Uint8Array(e));
                throw new Error("crypto.getRandomValues must be defined")
            }
        }, 9512: (e, t, n) => {
            const {bech32: r, hex: i, utf8: s} = n(6237),
                a = {bech32: "bc", pubKeyHash: 0, scriptHash: 5, validWitnessVersions: [0]},
                o = {bech32: "tb", pubKeyHash: 111, scriptHash: 196, validWitnessVersions: [0]},
                l = {bech32: "bcrt", pubKeyHash: 111, scriptHash: 196, validWitnessVersions: [0]},
                c = {bech32: "sb", pubKeyHash: 63, scriptHash: 123, validWitnessVersions: [0]},
                u = ["option_data_loss_protect", "initial_routing_sync", "option_upfront_shutdown_script", "gossip_queries", "var_onion_optin", "gossip_queries_ex", "option_static_remotekey", "payment_secret", "basic_mpp", "option_support_large_channel"],
                d = {m: BigInt(1e3), u: BigInt(1e6), n: BigInt(1e9), p: BigInt(1e12)},
                h = BigInt("2100000000000000000"), f = BigInt(1e11), p = {
                    payment_hash: 1,
                    payment_secret: 16,
                    description: 13,
                    payee: 19,
                    description_hash: 23,
                    expiry: 6,
                    min_final_cltv_expiry: 24,
                    fallback_address: 9,
                    route_hint: 3,
                    feature_bits: 5,
                    metadata: 27
                }, m = {};
            for (let e = 0, t = Object.keys(p); e < t.length; e++) {
                const n = t[e], r = p[t[e]].toString();
                m[r] = n
            }
            const g = {
                1: e => i.encode(r.fromWordsUnsafe(e)),
                16: e => i.encode(r.fromWordsUnsafe(e)),
                13: e => s.encode(r.fromWordsUnsafe(e)),
                19: e => i.encode(r.fromWordsUnsafe(e)),
                23: e => i.encode(r.fromWordsUnsafe(e)),
                27: e => i.encode(r.fromWordsUnsafe(e)),
                6: v,
                24: v,
                3: function (e) {
                    const t = [];
                    let n, s, a, o, l, c = r.fromWordsUnsafe(e);
                    for (; c.length > 0;) n = i.encode(c.slice(0, 33)), s = i.encode(c.slice(33, 41)), a = parseInt(i.encode(c.slice(41, 45)), 16), o = parseInt(i.encode(c.slice(45, 49)), 16), l = parseInt(i.encode(c.slice(49, 51)), 16), c = c.slice(51), t.push({
                        pubkey: n,
                        short_channel_id: s,
                        fee_base_msat: a,
                        fee_proportional_millionths: o,
                        cltv_expiry_delta: l
                    });
                    return t
                },
                5: function (e) {
                    const t = e.slice().reverse().map((e => [!!(1 & e), !!(2 & e), !!(4 & e), !!(8 & e), !!(16 & e)])).reduce(((e, t) => e.concat(t)), []);
                    for (; t.length < 2 * u.length;) t.push(!1);
                    const n = {};
                    u.forEach(((e, r) => {
                        let i;
                        i = t[2 * r] ? "required" : t[2 * r + 1] ? "supported" : "unsupported", n[e] = i
                    }));
                    const r = t.slice(2 * u.length);
                    return n.extra_bits = {
                        start_bit: 2 * u.length,
                        bits: r,
                        has_required: r.reduce(((e, t, n) => n % 2 != 0 ? e || !1 : e || t), !1)
                    }, n
                }
            };

            function y(e) {
                return t => ({tagCode: parseInt(e), words: r.encode("unknown", t, Number.MAX_SAFE_INTEGER)})
            }

            function v(e) {
                return e.reverse().reduce(((e, t, n) => e + t * Math.pow(32, n)), 0)
            }

            function b(e, t) {
                let n, r;
                if (e.slice(-1).match(/^[munp]$/)) n = e.slice(-1), r = e.slice(0, -1); else {
                    if (e.slice(-1).match(/^[^munp0-9]$/)) throw new Error("Not a valid multiplier for the amount");
                    r = e
                }
                if (!r.match(/^\d+$/)) throw new Error("Not a valid human readable amount");
                const i = BigInt(r), s = n ? i * f / d[n] : i * f;
                if ("p" === n && i % BigInt(10) !== BigInt(0) || s > h) throw new Error("Amount is outside of valid range");
                return t ? s.toString() : s
            }

            e.exports = {
                decode: function (e, t) {
                    if ("string" != typeof e) throw new Error("Lightning Payment Request must be string");
                    if ("ln" !== e.slice(0, 2).toLowerCase()) throw new Error("Not a proper lightning payment request");
                    const n = [], s = r.decode(e, Number.MAX_SAFE_INTEGER);
                    e = e.toLowerCase();
                    const u = s.prefix;
                    let d = s.words, h = e.slice(u.length + 1), f = d.slice(-104);
                    d = d.slice(0, -104);
                    let w = u.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);
                    if (w && !w[2] && (w = u.match(/^ln(\S+)$/)), !w) throw new Error("Not a proper lightning payment request");
                    n.push({name: "lightning_network", letters: "ln"});
                    const x = w[1];
                    let E;
                    if (t) {
                        if (void 0 === t.bech32 || void 0 === t.pubKeyHash || void 0 === t.scriptHash || !Array.isArray(t.validWitnessVersions)) throw new Error("Invalid network");
                        E = t
                    } else switch (x) {
                        case a.bech32:
                            E = a;
                            break;
                        case o.bech32:
                            E = o;
                            break;
                        case l.bech32:
                            E = l;
                            break;
                        case c.bech32:
                            E = c
                    }
                    if (!E || E.bech32 !== x) throw new Error("Unknown coin bech32 prefix");
                    n.push({name: "coin_network", letters: x, value: E});
                    const S = w[2];
                    let k;
                    S ? (k = b(S + w[3], !0), n.push({
                        name: "amount",
                        letters: w[2] + w[3],
                        value: k
                    })) : k = null, n.push({name: "separator", letters: "1"});
                    const A = v(d.slice(0, 7));
                    let T, C, R, L;
                    for (d = d.slice(7), n.push({
                        name: "timestamp",
                        letters: h.slice(0, 7),
                        value: A
                    }), h = h.slice(7); d.length > 0;) {
                        const e = d[0].toString();
                        T = m[e] || "unknown_tag", C = g[e] || y(e), d = d.slice(1), R = v(d.slice(0, 2)), d = d.slice(2), L = d.slice(0, R), d = d.slice(R), n.push({
                            name: T,
                            tag: h[0],
                            letters: h.slice(0, 3 + R),
                            value: C(L)
                        }), h = h.slice(3 + R)
                    }
                    n.push({
                        name: "signature",
                        letters: h.slice(0, 104),
                        value: i.encode(r.fromWordsUnsafe(f))
                    }), h = h.slice(104), n.push({name: "checksum", letters: h});
                    let _ = {
                        paymentRequest: e, sections: n, get expiry() {
                            let e = n.find((e => "expiry" === e.name));
                            if (e) return P("timestamp") + e.value
                        }, get route_hints() {
                            return n.filter((e => "route_hint" === e.name)).map((e => e.value))
                        }
                    };
                    for (let e in p) "route_hint" !== e && Object.defineProperty(_, e, {get: () => P(e)});
                    return _;

                    function P(e) {
                        let t = n.find((t => t.name === e));
                        return t ? t.value : void 0
                    }
                }, hrpToMillisat: b
            }
        }, 1222: function (e, t, n) {
            "use strict";
            var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                i && !("get" in i ? !t.__esModule : i.writable || i.configurable) || (i = {
                    enumerable: !0,
                    get: function () {
                        return t[n]
                    }
                }), Object.defineProperty(e, r, i)
            } : function (e, t, n, r) {
                void 0 === r && (r = n), e[r] = t[n]
            }), i = this && this.__exportStar || function (e, t) {
                for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n)
            };
            Object.defineProperty(t, "__esModule", {value: !0}), i(n(4907), t), i(n(8129), t), i(n(9447), t)
        }, 4907: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.useRequestBuilder = void 0;
            const r = n(2784), i = n(124), s = n(2036);
            t.useRequestBuilder = (e, t, n) => (0, r.useSyncExternalStore)((r => (r => {
                if (n) {
                    const i = e.Query(t, n), s = i.feed.hook(r);
                    return i.uncancel(), () => {
                        i.cancel(), s()
                    }
                }
                return () => {
                }
            })(r)), (() => (() => {
                const t = e.GetQuery(n?.id ?? "");
                return t ? (0, s.unwrap)(t).feed?.snapshot : i.EmptySnapshot
            })()))
        }, 8129: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.useSystemState = void 0;
            const r = n(2784);
            t.useSystemState = function (e) {
                return (0, r.useSyncExternalStore)((t => e.hook(t)), (() => e.snapshot()))
            }
        }, 9447: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.useUserProfile = void 0;
            const r = n(2784);
            t.useUserProfile = function (e, t) {
                return (0, r.useSyncExternalStore)((n => {
                    t && e.ProfileLoader.TrackMetadata(t);
                    const r = e.ProfileLoader.Cache.hook(n, t);
                    return () => {
                        r(), t && e.ProfileLoader.UntrackMetadata(t)
                    }
                }), (() => e.ProfileLoader.Cache.getFromCache(t)))
            }
        }, 4968: function (e, t, n) {
            "use strict";
            var r = this && this.__importDefault || function (e) {
                return e && e.__esModule ? e : {default: e}
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.SnortSystemDb = void 0;
            const i = r(n(9085)), s = {
                users: "++pubkey, name, display_name, picture, nip05, npub",
                relayMetrics: "++addr",
                userRelays: "++pubkey",
                events: "++id, pubkey, created_at"
            };

            class a extends i.default {
                constructor() {
                    super("snort-system"), this.ready = !1, this.version(2).stores(s)
                }

                isAvailable() {
                    return "indexedDB" in window ? new Promise((e => {
                        const t = window.indexedDB.open("dummy", 1);
                        t.onsuccess = () => {
                            e(!0)
                        }, t.onerror = () => {
                            e(!1)
                        }
                    })) : Promise.resolve(!1)
                }
            }

            t.SnortSystemDb = a
        }, 8848: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.mapEventToProfile = t.db = void 0;
            const r = n(2036), i = n(4968);
            t.db = new i.SnortSystemDb, t.mapEventToProfile = function (e) {
                try {
                    let t = {
                        ...JSON.parse(e.content),
                        pubkey: e.pubkey,
                        npub: (0, r.hexToBech32)("npub", e.pubkey),
                        created: e.created_at,
                        loaded: (0, r.unixNowMs)()
                    };
                    for (const [e, n] of Object.entries(t)) "number" != typeof n && "string" != typeof n && (t[e] = void 0);
                    return t
                } catch (t) {
                    console.error("Failed to parse JSON", e, t)
                }
            }
        }, 5517: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.RelayMetricCache = void 0;
            const r = n(8848), i = n(2036);

            class s extends i.FeedCache {
                constructor() {
                    super("RelayMetrics", r.db.relayMetrics)
                }

                key(e) {
                    return e.addr
                }

                async preload() {
                    await super.preload(), await this.buffer([...this.onTable])
                }

                takeSnapshot() {
                    return [...this.cache.values()]
                }
            }

            t.RelayMetricCache = s
        }, 6395: function (e, t, n) {
            "use strict";
            var r, i, s, a, o, l, c = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.UserProfileCache = void 0;
            const u = n(8848), d = n(2036);

            class h extends d.FeedCache {
                constructor() {
                    super("UserCache", u.db.users), r.add(this), i.set(this, []), s.set(this, []), c(this, r, "m", a).call(this), c(this, r, "m", o).call(this)
                }

                key(e) {
                    return e.pubkey
                }

                async preload(e) {
                    await super.preload(), e && await this.buffer(e)
                }

                async search(e) {
                    return u.db.ready ? (await u.db.users.where("npub").startsWithIgnoreCase(e).or("name").startsWithIgnoreCase(e).or("display_name").startsWithIgnoreCase(e).or("nip05").startsWithIgnoreCase(e).toArray()).slice(0, 5) : [...this.cache.values()].filter((t => {
                        const n = t;
                        return n.name?.includes(e) || n.npub?.includes(e) || n.display_name?.includes(e) || n.nip05?.includes(e)
                    })).slice(0, 5)
                }

                async update(e) {
                    const t = await super.update(e);
                    if ("refresh" !== t) {
                        const t = e.lud16 ?? e.lud06;
                        t && c(this, i, "f").push({
                            pubkey: e.pubkey,
                            lnurl: t
                        }), e.nip05 && c(this, s, "f").push({pubkey: e.pubkey, nip05: e.nip05})
                    }
                    return t
                }

                takeSnapshot() {
                    return []
                }
            }

            t.UserProfileCache = h, i = new WeakMap, s = new WeakMap, r = new WeakSet, a = async function e() {
                await c(this, r, "m", l).call(this, c(this, i, "f"), (async e => {
                    const t = new d.LNURL(e.lnurl);
                    await t.load();
                    const n = this.getFromCache(e.pubkey);
                    n && await this.set({...n, zapService: t.zapperPubkey})
                }), 5), setTimeout((() => c(this, r, "m", e).call(this)), 1e3)
            }, o = async function e() {
                await c(this, r, "m", l).call(this, c(this, s, "f"), (async e => {
                    const [t, n] = e.nip05.split("@"), r = await (0, d.fetchNip05Pubkey)(t, n),
                        i = this.getFromCache(e.pubkey);
                    i && await this.set({...i, isNostrAddressValid: e.pubkey === r})
                }), 5), setTimeout((() => c(this, r, "m", e).call(this)), 1e3)
            }, l = async function (e, t, n = 3) {
                const r = [];
                for (; e.length > 0;) {
                    const i = e.shift();
                    i ? (r.push((async () => {
                        try {
                            await t(i)
                        } catch {
                            console.warn("Failed to process item", i)
                        }
                        r.pop()
                    })()), r.length === n && await Promise.all(r)) : await Promise.all(r)
                }
            }
        }, 2141: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.UserRelaysCache = void 0;
            const r = n(8848), i = n(2036);

            class s extends i.FeedCache {
                constructor() {
                    super("UserRelays", r.db.userRelays)
                }

                key(e) {
                    return e.pubkey
                }

                async preload(e) {
                    await super.preload(), e && await this.buffer(e)
                }

                newest() {
                    let e = 0;
                    return this.cache.forEach((t => e = t.created_at > e ? t.created_at : e)), e
                }

                takeSnapshot() {
                    return [...this.cache.values()]
                }
            }

            t.UserRelaysCache = s
        }, 3735: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.ConnectionStats = void 0, t.ConnectionStats = class {
                constructor() {
                    this.Latency = [], this.Subs = 0, this.SubsTimeout = 0, this.EventsReceived = 0, this.EventsSent = 0, this.Disconnects = 0
                }
            }
        }, 2398: function (e, t, n) {
            "use strict";
            var r, i, s, a, o, l, c, u, d, h, f, p, m = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            }, g = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            }, y = this && this.__importDefault || function (e) {
                return e && e.__esModule ? e : {default: e}
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.Connection = void 0;
            const v = n(130), b = y(n(5130)), w = n(2036), x = n(3466), E = n(3735);

            class S extends w.ExternalStore {
                constructor(e, t, n, o = !1) {
                    super(), r.add(this), i.set(this, (0, b.default)("Connection")), s.set(this, void 0), a.set(this, (0, w.unixNowMs)()), this.Socket = null, this.PendingRaw = [], this.PendingRequests = [], this.ActiveRequests = new Set, this.ConnectTimeout = x.DefaultConnectTimeout, this.Stats = new E.ConnectionStats, this.HasStateChange = !0, this.Authed = !1, this.Down = !0, this.Id = (0, v.v4)(), this.Address = e, this.Settings = t, this.IsClosed = !1, this.EventsCallback = new Map, this.AwaitingAuth = new Map, this.Auth = n, this.Ephemeral = o
                }

                async Connect() {
                    try {
                        if (void 0 === this.Info) {
                            const e = new URL(this.Address),
                                t = await fetch(`${"wss:" === e.protocol ? "https:" : "http:"}//${e.host}`, {headers: {accept: "application/nostr+json"}});
                            if (t.ok) {
                                const e = await t.json();
                                for (const [t, n] of Object.entries(e)) "unset" !== n && "" !== n && "~" !== n || (e[t] = void 0);
                                this.Info = e
                            }
                        }
                    } catch {
                    }
                    const e = null !== this.Socket && !this.IsClosed;
                    this.Socket && (this.Id = (0, v.v4)(), this.Socket.onopen = null, this.Socket.onmessage = null, this.Socket.onerror = null, this.Socket.onclose = null, this.Socket = null), this.IsClosed = !1, this.Socket = new WebSocket(this.Address), this.Socket.onopen = () => this.OnOpen(e), this.Socket.onmessage = e => this.OnMessage(e), this.Socket.onerror = e => this.OnError(e), this.Socket.onclose = e => this.OnClose(e)
                }

                Close() {
                    this.IsClosed = !0, this.Socket?.close(), this.notifyChange()
                }

                OnOpen(e) {
                    this.ConnectTimeout = x.DefaultConnectTimeout, m(this, i, "f").call(this, `[${this.Address}] Open!`), this.Down = !1, m(this, r, "m", p).call(this), this.OnConnected?.(e), m(this, r, "m", u).call(this)
                }

                OnClose(e) {
                    this.ReconnectTimer && (clearTimeout(this.ReconnectTimer), this.ReconnectTimer = void 0), 4e3 === e.code ? (this.IsClosed = !0, m(this, i, "f").call(this, `[${this.Address}] Closed! (Remote)`)) : this.IsClosed ? (m(this, i, "f").call(this, `[${this.Address}] Closed!`), this.ReconnectTimer = void 0) : (this.ConnectTimeout = 2 * this.ConnectTimeout, m(this, i, "f").call(this, `[${this.Address}] Closed (code=${e.code}), trying again in ${(this.ConnectTimeout / 1e3).toFixed(0).toLocaleString()} sec`), this.ReconnectTimer = setTimeout((() => {
                        this.Connect()
                    }), this.ConnectTimeout), this.Stats.Disconnects++), this.OnDisconnect?.(e.code), m(this, r, "m", l).call(this), this.Id = (0, v.v4)(), this.notifyChange()
                }

                OnMessage(e) {
                    if (g(this, a, (0, w.unixNowMs)(), "f"), e.data.length > 0) {
                        const t = JSON.parse(e.data), n = t[0];
                        switch (n) {
                            case"AUTH":
                                m(this, r, "m", h).call(this, t[1]).then((() => m(this, r, "m", u).call(this))).catch(m(this, i, "f")), this.Stats.EventsReceived++, this.notifyChange();
                                break;
                            case"EVENT":
                                this.OnEvent?.(t[1], {
                                    ...t[2],
                                    relays: [this.Address]
                                }), this.Stats.EventsReceived++, this.notifyChange();
                                break;
                            case"EOSE":
                                this.OnEose?.(t[1]);
                                break;
                            case"OK": {
                                m(this, i, "f").call(this, `${this.Address} OK: %O`, t);
                                const e = t[1];
                                if (this.EventsCallback.has(e)) {
                                    const n = (0, w.unwrap)(this.EventsCallback.get(e));
                                    this.EventsCallback.delete(e), n(t)
                                }
                                break
                            }
                            case"NOTICE":
                                m(this, i, "f").call(this, `[${this.Address}] NOTICE: ${t[1]}`);
                                break;
                            default:
                                m(this, i, "f").call(this, `Unknown tag: ${n}`)
                        }
                    }
                }

                OnError(e) {
                    m(this, i, "f").call(this, "Error: %O", e), this.notifyChange()
                }

                SendEvent(e) {
                    if (!this.Settings.write) return;
                    const t = ["EVENT", e];
                    m(this, r, "m", c).call(this, t), this.Stats.EventsSent++, this.notifyChange()
                }

                async SendAsync(e, t = 5e3) {
                    return new Promise((n => {
                        if (!this.Settings.write) return void n();
                        const i = setTimeout((() => {
                            n()
                        }), t);
                        this.EventsCallback.set(e.id, (() => {
                            clearTimeout(i), n()
                        }));
                        const s = ["EVENT", e];
                        m(this, r, "m", c).call(this, s), this.Stats.EventsSent++, this.notifyChange()
                    }))
                }

                SupportsNip(e) {
                    return this.Info?.supported_nips?.some((t => t === e)) ?? !1
                }

                QueueReq(e, t) {
                    this.ActiveRequests.size >= m(this, r, "a", f) ? (this.PendingRequests.push({
                        cmd: e,
                        cb: t
                    }), m(this, i, "f").call(this, "Queuing: %s %O", this.Address, e)) : (this.ActiveRequests.add(e[1]), m(this, r, "m", c).call(this, e), t()), this.notifyChange()
                }

                CloseReq(e) {
                    this.ActiveRequests.delete(e) && (m(this, r, "m", c).call(this, ["CLOSE", e]), this.OnEose?.(e), m(this, r, "m", o).call(this)), this.notifyChange()
                }

                takeSnapshot() {
                    return {
                        connected: this.Socket?.readyState === WebSocket.OPEN,
                        events: {received: this.Stats.EventsReceived, send: this.Stats.EventsSent},
                        avgLatency: this.Stats.Latency.length > 0 ? this.Stats.Latency.reduce(((e, t) => e + t), 0) / this.Stats.Latency.length : 0,
                        disconnects: this.Stats.Disconnects,
                        info: this.Info,
                        id: this.Id,
                        pendingRequests: [...this.PendingRequests.map((e => e.cmd[1]))],
                        activeRequests: [...this.ActiveRequests],
                        ephemeral: this.Ephemeral,
                        address: this.Address
                    }
                }
            }

            t.Connection = S, i = new WeakMap, s = new WeakMap, a = new WeakMap, r = new WeakSet, o = function () {
                const e = m(this, r, "a", f) - this.ActiveRequests.size;
                if (e > 0) for (let t = 0; t < e; t++) {
                    const e = this.PendingRequests.shift();
                    e && (this.ActiveRequests.add(e.cmd[1]), m(this, r, "m", c).call(this, e.cmd), e.cb(), m(this, i, "f").call(this, "Sent pending REQ %s %O", this.Address, e.cmd))
                }
            }, l = function () {
                this.ActiveRequests.clear(), this.PendingRequests = [], this.PendingRaw = [], this.notifyChange()
            }, c = function (e) {
                const t = !this.Authed && (this.AwaitingAuth.size > 0 || !0 === this.Info?.limitation?.auth_required);
                if (this.Socket?.readyState !== WebSocket.OPEN || t) return this.PendingRaw.push(e), this.Socket?.readyState === WebSocket.CLOSED && this.Ephemeral && this.IsClosed && this.Connect(), !1;
                m(this, r, "m", u).call(this), m(this, r, "m", d).call(this, e)
            }, u = function () {
                for (; this.PendingRaw.length > 0;) {
                    const e = this.PendingRaw.shift();
                    e && m(this, r, "m", d).call(this, e)
                }
            }, d = function (e) {
                if (this.Socket?.readyState !== WebSocket.OPEN) throw new Error(`Socket is not open, state is ${this.Socket?.readyState}`);
                const t = JSON.stringify(e);
                return g(this, a, (0, w.unixNowMs)(), "f"), this.Socket.send(t), !0
            }, h = async function (e) {
                const t = () => {
                    this.AwaitingAuth.delete(e)
                };
                if (!this.Auth) throw new Error("Auth hook not registered");
                this.AwaitingAuth.set(e, !0);
                const n = await this.Auth(e, this.Address);
                return new Promise((e => {
                    if (!n) return t(), Promise.reject("no event");
                    const i = setTimeout((() => {
                        t(), e()
                    }), 1e4);
                    this.EventsCallback.set(n.id, (n => {
                        clearTimeout(i), t(), n.length > 3 && !0 === n[2] && (this.Authed = !0), e()
                    })), m(this, r, "m", d).call(this, ["AUTH", n])
                }))
            }, f = function () {
                return this.Info?.limitation?.max_subscriptions ?? 25
            }, p = function () {
                this.Ephemeral && (m(this, s, "f") && (clearInterval(m(this, s, "f")), g(this, s, void 0, "f")), g(this, s, setInterval((() => {
                    (0, w.unixNowMs)() - m(this, a, "f") > 3e4 && !this.IsClosed && (this.ActiveRequests.size > 0 ? m(this, i, "f").call(this, "%s Inactive connection has %d active requests! %O", this.Address, this.ActiveRequests.size, this.ActiveRequests) : this.Close())
                }), 5e3), "f"))
            }
        }, 3466: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.ProfileCacheExpire = t.HashtagRegex = t.DefaultConnectTimeout = void 0, t.DefaultConnectTimeout = 2e3, t.HashtagRegex = /(#[^\s!@#$%^&*()=+.\/,\[{\]};:'"?><]+)/g, t.ProfileCacheExpire = 216e5
        }, 5377: function (e, t, n) {
            "use strict";
            var r, i, s, a, o, l, c, u, d, h = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            }, f = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.EventBuilder = void 0;
            const p = n(124), m = n(3466), g = n(2036), y = n(5913), v = n(5283);
            t.EventBuilder = class {
                constructor() {
                    r.add(this), i.set(this, void 0), s.set(this, void 0), a.set(this, void 0), o.set(this, void 0), l.set(this, [])
                }

                kind(e) {
                    return h(this, i, e, "f"), this
                }

                content(e) {
                    return h(this, s, e, "f"), this
                }

                createdAt(e) {
                    return h(this, a, e, "f"), this
                }

                pubKey(e) {
                    return h(this, o, e, "f"), this
                }

                tag(e) {
                    return f(this, l, "f").some((t => t.length === e.length && t.every(((e, n) => e !== t[n])))) || f(this, l, "f").push(e), this
                }

                processContent() {
                    return f(this, s, "f") && (h(this, s, f(this, s, "f").replace(/@n(pub|profile|event|ote|addr|)1[acdefghjklmnpqrstuvwxyz023456789]+/g, (e => f(this, r, "m", u).call(this, e))), "f"), [...f(this, s, "f").matchAll(m.HashtagRegex)].map((e => {
                        f(this, r, "m", d).call(this, e[0])
                    }))), this
                }

                build() {
                    f(this, r, "m", c).call(this);
                    const e = {
                        id: "",
                        pubkey: f(this, o, "f") ?? "",
                        content: f(this, s, "f") ?? "",
                        kind: f(this, i, "f"),
                        created_at: f(this, a, "f") ?? (0, g.unixNow)(),
                        tags: f(this, l, "f")
                    };
                    return e.id = y.EventExt.createId(e), e
                }

                async buildAndSign(e) {
                    const t = this.pubKey((0, g.getPublicKey)(e)).build();
                    return await y.EventExt.sign(t, e), t
                }
            }, i = new WeakMap, s = new WeakMap, a = new WeakMap, o = new WeakMap, l = new WeakMap, r = new WeakSet, c = function () {
                if (void 0 === f(this, i, "f")) throw new Error("Kind must be set");
                if (void 0 === f(this, o, "f")) throw new Error("Pubkey must be set")
            }, u = function (e) {
                const t = e.slice(1), n = (0, v.tryParseNostrLink)(t);
                return n ? (n.type !== p.NostrPrefix.Profile && n.type !== p.NostrPrefix.PublicKey || this.tag(["p", n.id]), `nostr:${n.encode()}`) : e
            }, d = function (e) {
                const t = e.slice(1);
                this.tag(["t", t.toLowerCase()])
            }
        }, 5913: function (e, t, n) {
            "use strict";
            var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                i && !("get" in i ? !t.__esModule : i.writable || i.configurable) || (i = {
                    enumerable: !0,
                    get: function () {
                        return t[n]
                    }
                }), Object.defineProperty(e, r, i)
            } : function (e, t, n, r) {
                void 0 === r && (r = n), e[r] = t[n]
            }), i = this && this.__setModuleDefault || (Object.create ? function (e, t) {
                Object.defineProperty(e, "default", {enumerable: !0, value: t})
            } : function (e, t) {
                e.default = t
            }), s = this && this.__importStar || function (e) {
                if (e && e.__esModule) return e;
                var t = {};
                if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
                return i(t, e), t
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.EventExt = void 0;
            const a = s(n(8358)), o = s(n(4323)), l = n(2036), c = n(124), u = n(1071);

            class d {
                static getRootPubKey(e) {
                    const t = e.tags.find((e => "delegation" === e[0]));
                    return t?.[1] ? t[1] : e.pubkey
                }

                static sign(e, t) {
                    e.id = this.createId(e);
                    const n = a.schnorr.sign(e.id, t);
                    if (e.sig = o.bytesToHex(n), !a.schnorr.verify(e.sig, e.id, e.pubkey)) throw new Error("Signing failed")
                }

                static verify(e) {
                    const t = this.createId(e);
                    return a.schnorr.verify(e.sig, t, e.pubkey)
                }

                static createId(e) {
                    const t = [0, e.pubkey, e.created_at, e.kind, e.tags, e.content],
                        n = (0, l.sha256)(JSON.stringify(t));
                    if ("" !== e.id && n !== e.id) throw console.debug(t), new Error("ID doesnt match!");
                    return n
                }

                static forPubKey(e, t) {
                    return {pubkey: e, kind: t, created_at: (0, l.unixNow)(), content: "", tags: [], id: "", sig: ""}
                }

                static parseTag(e) {
                    if (e.length < 1) throw new Error("Invalid tag, must have more than 2 items");
                    const t = {key: e[0], value: e[1]};
                    return "e" === t.key && (t.relay = e.length > 2 ? e[2] : void 0, t.marker = e.length > 3 ? e[3] : void 0), t
                }

                static extractThread(e) {
                    if (!e.tags.some((e => "e" === e[0] && "mention" !== e[3] || "a" == e[0]))) return;
                    const t = e.kind === c.EventKind.TextNote, n = {mentions: [], pubKeys: []},
                        r = e.tags.filter((e => "e" === e[0] || "a" === e[0])).map((e => d.parseTag(e)));
                    if (r.some((e => e.marker))) {
                        const e = r.find((e => "root" === e.marker)), t = r.find((e => "reply" === e.marker));
                        n.root = e, n.replyTo = t, n.mentions = r.filter((e => "mention" === e.marker))
                    } else n.root = r[0], n.root.marker = t ? "root" : void 0, r.length > 1 && (n.replyTo = r[r.length - 1], n.replyTo.marker = t ? "reply" : void 0), r.length > 2 && (n.mentions = r.slice(1, -1), t && n.mentions.forEach((e => e.marker = "mention")));
                    return n.pubKeys = Array.from(new Set(e.tags.filter((e => "p" === e[0])).map((e => e[1])))), n
                }

                static async decryptDm(e, t, n) {
                    const r = new u.Nip4WebCryptoEncryptor, i = r.getSharedSecret(t, n);
                    return await r.decryptData(e, i)
                }

                static async encryptDm(e, t, n) {
                    const r = new u.Nip4WebCryptoEncryptor, i = r.getSharedSecret(t, n);
                    return await r.encryptData(e, i)
                }
            }

            t.EventExt = d
        }, 8323: (e, t) => {
            "use strict";
            var n;
            Object.defineProperty(t, "__esModule", {value: !0}), function (e) {
                e[e.Unknown = -1] = "Unknown", e[e.SetMetadata = 0] = "SetMetadata", e[e.TextNote = 1] = "TextNote", e[e.RecommendServer = 2] = "RecommendServer", e[e.ContactList = 3] = "ContactList", e[e.DirectMessage = 4] = "DirectMessage", e[e.Deletion = 5] = "Deletion", e[e.Repost = 6] = "Repost", e[e.Reaction = 7] = "Reaction", e[e.BadgeAward = 8] = "BadgeAward", e[e.SimpleChatMessage = 9] = "SimpleChatMessage", e[e.SnortSubscriptions = 1e3] = "SnortSubscriptions", e[e.Polls = 6969] = "Polls", e[e.GiftWrap = 1059] = "GiftWrap", e[e.FileHeader = 1063] = "FileHeader", e[e.Relays = 10002] = "Relays", e[e.Ephemeral = 2e4] = "Ephemeral", e[e.Auth = 22242] = "Auth", e[e.PubkeyLists = 3e4] = "PubkeyLists", e[e.NoteLists = 30001] = "NoteLists", e[e.TagLists = 30002] = "TagLists", e[e.Badge = 30009] = "Badge", e[e.ProfileBadges = 30008] = "ProfileBadges", e[e.LiveEvent = 30311] = "LiveEvent", e[e.ZapstrTrack = 31337] = "ZapstrTrack", e[e.SimpleChatMetadata = 39e3] = "SimpleChatMetadata", e[e.ZapRequest = 9734] = "ZapRequest", e[e.ZapReceipt = 9735] = "ZapReceipt", e[e.HttpAuthentication = 27235] = "HttpAuthentication"
            }(n || (n = {})), t.default = n
        }, 4578: function (e, t, n) {
            "use strict";
            var r, i, s, a, o, l, c = this && this.__createBinding || (Object.create ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                i && !("get" in i ? !t.__esModule : i.writable || i.configurable) || (i = {
                    enumerable: !0,
                    get: function () {
                        return t[n]
                    }
                }), Object.defineProperty(e, r, i)
            } : function (e, t, n, r) {
                void 0 === r && (r = n), e[r] = t[n]
            }), u = this && this.__setModuleDefault || (Object.create ? function (e, t) {
                Object.defineProperty(e, "default", {enumerable: !0, value: t})
            } : function (e, t) {
                e.default = t
            }), d = this && this.__importStar || function (e) {
                if (e && e.__esModule) return e;
                var t = {};
                if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && c(t, e, n);
                return u(t, e), t
            }, h = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            }, f = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.EventPublisher = void 0;
            const p = d(n(8358)), m = d(n(4323)), g = n(2036), y = n(124), v = n(5377), b = n(5913), w = n(2150),
                x = [];
            (0, g.processWorkQueue)(x);

            class E {
                constructor(e, t) {
                    r.add(this), i.set(this, void 0), s.set(this, void 0), t ? (h(this, s, t, "f"), h(this, i, m.bytesToHex(p.schnorr.getPublicKey(t)), "f")) : h(this, i, e, "f")
                }

                get pubKey() {
                    return f(this, i, "f")
                }

                static async nip7() {
                    if ("nostr" in window) {
                        const e = await (window.nostr?.getPublicKey());
                        if (e) return new E(e)
                    }
                }

                async nip4Encrypt(e, t) {
                    if (f(this, r, "a", a) && !f(this, s, "f")) {
                        if (await (0, g.barrierQueue)(x, (() => (0, g.unwrap)(window.nostr).getPublicKey())) !== f(this, i, "f")) throw new Error("Can't encrypt content, NIP-07 pubkey does not match");
                        return await (0, g.barrierQueue)(x, (() => (0, g.unwrap)(window.nostr?.nip04?.encrypt).call(window.nostr?.nip04, t, e)))
                    }
                    if (f(this, s, "f")) return await b.EventExt.encryptDm(e, f(this, s, "f"), t);
                    throw new Error("Can't encrypt content, no private keys available")
                }

                async nip4Decrypt(e, t) {
                    if (f(this, r, "a", a) && !f(this, s, "f") && window.nostr?.nip04?.decrypt) return await (0, g.barrierQueue)(x, (() => (0, g.unwrap)(window.nostr?.nip04?.decrypt).call(window.nostr?.nip04, t, e)));
                    if (f(this, s, "f")) return await b.EventExt.decryptDm(e, f(this, s, "f"), t);
                    throw new Error("Can't decrypt content, no private keys available")
                }

                async nip42Auth(e, t) {
                    const n = f(this, r, "m", o).call(this, y.EventKind.Auth);
                    return n.tag(["relay", t]), n.tag(["challenge", e]), await f(this, r, "m", l).call(this, n)
                }

                async muted(e, t) {
                    const n = f(this, r, "m", o).call(this, y.EventKind.PubkeyLists);
                    if (n.tag(["d", y.Lists.Muted]), e.forEach((e => {
                        n.tag(["p", e])
                    })), t.length > 0) {
                        const e = t.map((e => ["p", e])), r = JSON.stringify(e);
                        n.content(await this.nip4Encrypt(r, f(this, i, "f")))
                    }
                    return await f(this, r, "m", l).call(this, n)
                }

                async noteList(e, t) {
                    const n = f(this, r, "m", o).call(this, y.EventKind.NoteLists);
                    return n.tag(["d", t]), e.forEach((e => {
                        n.tag(["e", e])
                    })), await f(this, r, "m", l).call(this, n)
                }

                async tags(e) {
                    const t = f(this, r, "m", o).call(this, y.EventKind.TagLists);
                    return t.tag(["d", y.Lists.Followed]), e.forEach((e => {
                        t.tag(["t", e])
                    })), await f(this, r, "m", l).call(this, t)
                }

                async metadata(e) {
                    const t = f(this, r, "m", o).call(this, y.EventKind.SetMetadata);
                    return t.content(JSON.stringify(e)), await f(this, r, "m", l).call(this, t)
                }

                async note(e, t) {
                    const n = f(this, r, "m", o).call(this, y.EventKind.TextNote);
                    return n.content(e), n.processContent(), t?.(n), await f(this, r, "m", l).call(this, n)
                }

                async zap(e, t, n, i, s, a) {
                    const c = f(this, r, "m", o).call(this, y.EventKind.ZapRequest);
                    return c.content(s ?? ""), i && c.tag(["e", i]), c.tag(["p", t]), c.tag(["relays", ...n.map((e => e.trim()))]), c.tag(["amount", e.toString()]), c.processContent(), a?.(c), await f(this, r, "m", l).call(this, c)
                }

                async reply(e, t, n) {
                    const s = f(this, r, "m", o).call(this, y.EventKind.TextNote);
                    s.content(t);
                    const a = b.EventExt.extractThread(e);
                    if (a) {
                        (a.root || a.replyTo) && s.tag(["e", a.root?.value ?? a.replyTo?.value ?? "", "", "root"]), s.tag(["e", e.id, e.relays?.[0] ?? "", "reply"]), s.tag(["p", e.pubkey]);
                        for (const e of a.pubKeys) e !== f(this, i, "f") && s.tag(["p", e])
                    } else s.tag(["e", e.id, "", "reply"]), e.pubkey !== f(this, i, "f") && s.tag(["p", e.pubkey]);
                    return s.processContent(), n?.(s), await f(this, r, "m", l).call(this, s)
                }

                async react(e, t = "+") {
                    const n = f(this, r, "m", o).call(this, y.EventKind.Reaction);
                    return n.content(t), n.tag(["e", e.id]), n.tag(["p", e.pubkey]), await f(this, r, "m", l).call(this, n)
                }

                async relayList(e) {
                    Array.isArray(e) || (e = Object.entries(e).map((([e, t]) => ({url: e, settings: t}))));
                    const t = f(this, r, "m", o).call(this, y.EventKind.Relays);
                    for (const n of e) {
                        const e = ["r", n.url];
                        n.settings.read && !n.settings.write && e.push("read"), n.settings.write && !n.settings.read && e.push("write"), (n.settings.read || n.settings.write) && t.tag(e)
                    }
                    return await f(this, r, "m", l).call(this, t)
                }

                async contactList(e, t) {
                    const n = f(this, r, "m", o).call(this, y.EventKind.ContactList);
                    return n.content(JSON.stringify(t)), new Set(e.filter((e => 64 === e.length)).map((e => e.toLowerCase()))).forEach((e => n.tag(["p", e]))), await f(this, r, "m", l).call(this, n)
                }

                async delete(e) {
                    const t = f(this, r, "m", o).call(this, y.EventKind.Deletion);
                    return t.tag(["e", e]), await f(this, r, "m", l).call(this, t)
                }

                async repost(e) {
                    const t = f(this, r, "m", o).call(this, y.EventKind.Repost);
                    return t.tag(["e", e.id, ""]), t.tag(["p", e.pubkey]), await f(this, r, "m", l).call(this, t)
                }

                async decryptDm(e) {
                    if (e.pubkey !== f(this, i, "f") && !e.tags.some((e => e[1] === f(this, i, "f")))) throw new Error("Can't decrypt, DM does not belong to this user");
                    const t = e.pubkey === f(this, i, "f") ? (0, g.unwrap)(e.tags.find((e => "p" === e[0]))?.[1]) : e.pubkey;
                    return await this.nip4Decrypt(e.content, t)
                }

                async sendDm(e, t) {
                    const n = f(this, r, "m", o).call(this, y.EventKind.DirectMessage);
                    return n.content(await this.nip4Encrypt(e, t)), n.tag(["p", t]), await f(this, r, "m", l).call(this, n)
                }

                async generic(e) {
                    const t = new v.EventBuilder;
                    return t.pubKey(f(this, i, "f")), e(t), await f(this, r, "m", l).call(this, t)
                }

                async giftWrap(e) {
                    const t = m.bytesToHex(p.secp256k1.utils.randomPrivateKey()), n = (0, w.findTag)(e, "p");
                    if (!n) throw new Error("Inner event must have a p tag");
                    const r = new v.EventBuilder;
                    r.pubKey((0, g.getPublicKey)(t)), r.kind(y.EventKind.GiftWrap), r.tag(["p", n]);
                    const i = new y.Nip44Encryptor, s = i.getSharedSecret(t, n);
                    return r.content(i.encryptData(JSON.stringify(e), s)), await r.buildAndSign(t)
                }
            }

            t.EventPublisher = E, i = new WeakMap, s = new WeakMap, r = new WeakSet, a = function () {
                return "nostr" in window
            }, o = function (e) {
                return (new v.EventBuilder).pubKey(f(this, i, "f")).kind(e)
            }, l = async function (e) {
                if (f(this, r, "a", a) && !f(this, s, "f")) {
                    if (await (0, g.barrierQueue)(x, (() => (0, g.unwrap)(window.nostr).getPublicKey())) !== f(this, i, "f")) throw new Error("Can't sign event, NIP-07 pubkey does not match");
                    const t = e.build();
                    return await (0, g.barrierQueue)(x, (() => (0, g.unwrap)(window.nostr).signEvent(t)))
                }
                if (f(this, s, "f")) return await e.buildAndSign(f(this, s, "f"));
                throw new Error("Can't sign event, no private keys available")
            }
        }, 4040: function (e, t, n) {
            "use strict";
            var r = this && this.__importDefault || function (e) {
                return e && e.__esModule ? e : {default: e}
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.splitByWriteRelays = t.splitAllByWriteRelays = void 0;
            const i = n(2036), s = r(n(5130));

            function a(e, t) {
                if (0 === (t.authors?.length ?? 0)) return [{relay: "", filter: t}];
                const n = (0, i.unwrap)(t.authors).map((t => ({
                        key: t,
                        relays: e.getFromCache(t)?.relays?.filter((e => e.settings.write)).sort((() => Math.random() < .5 ? 1 : -1))
                    }))), r = n.filter((e => void 0 === e.relays || 0 === e.relays.length)),
                    a = [...n.filter((e => void 0 !== e.relays && e.relays.length > 0)).reduce(((e, t) => {
                        for (const n of (0, i.unwrap)(t.relays)) e.has(n.url) ? (0, i.unwrap)(e.get(n.url)).add(t.key) : e.set(n.url, new Set([t.key]));
                        return e
                    }), new Map).entries()].sort((([, e], [, t]) => t.size - e.size)),
                    o = (0, i.unwrap)(t.authors).map((e => {
                        const t = a.filter((([, t]) => t.has(e))).slice(0, 2).map((([e]) => e));
                        return {k: e, relaysForKey: t}
                    })), l = [...new Set(o.map((e => e.relaysForKey)).flat())].map((e => {
                        const n = new Set(o.filter((t => t.relaysForKey.includes(e))).map((e => e.k)));
                        return {relay: e, filter: {...t, authors: [...n]}}
                    }));
                return r.length > 0 && l.push({
                    relay: "",
                    filter: {...t, authors: r.map((e => e.key))}
                }), (0, s.default)("GOSSIP")("Picked %o", l), l
            }

            t.splitAllByWriteRelays = function (e, t) {
                return [...t.map((t => a(e, t))).reduce(((e, t) => {
                    for (const n of t) {
                        const t = e.get(n.relay);
                        t ? t.push(n.filter) : e.set(n.relay, [n.filter])
                    }
                    return e
                }), new Map).entries()].map((([e, t]) => ({relay: e, filters: t})))
            }, t.splitByWriteRelays = a
        }, 1071: function (e, t, n) {
            "use strict";
            var r, i, s = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.Nip4WebCryptoEncryptor = void 0;
            const a = n(6237), o = n(8358);
            t.Nip4WebCryptoEncryptor = class {
                constructor() {
                    r.add(this)
                }

                getSharedSecret(e, t) {
                    return o.secp256k1.getSharedSecret(e, "02" + t).slice(1, 33)
                }

                async encryptData(e, t) {
                    const n = await s(this, r, "m", i).call(this, t),
                        o = window.crypto.getRandomValues(new Uint8Array(16)), l = (new TextEncoder).encode(e),
                        c = await window.crypto.subtle.encrypt({name: "AES-CBC", iv: o}, n, l), u = new Uint8Array(c);
                    return `${a.base64.encode(u)}?iv=${a.base64.encode(o)}`
                }

                async decryptData(e, t) {
                    const n = await s(this, r, "m", i).call(this, t), o = e.split("?iv="), l = a.base64.decode(o[0]),
                        c = a.base64.decode(o[1]),
                        u = await window.crypto.subtle.decrypt({name: "AES-CBC", iv: c}, n, l);
                    return (new TextDecoder).decode(u)
                }
            }, r = new WeakSet, i = async function (e) {
                return await window.crypto.subtle.importKey("raw", e, {name: "AES-CBC"}, !1, ["encrypt", "decrypt"])
            }
        }, 481: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.Nip44Encryptor = t.Nip44Version = void 0;
            const r = n(6237), i = n(64), s = n(158), a = n(8358), o = n(6053);
            var l;
            !function (e) {
                e[e.Reserved = 0] = "Reserved", e[e.XChaCha20 = 1] = "XChaCha20"
            }(l = t.Nip44Version || (t.Nip44Version = {})), t.Nip44Encryptor = class {
                getSharedSecret(e, t) {
                    const n = a.secp256k1.getSharedSecret(e, "02" + t);
                    return (0, o.sha256)(n.slice(1, 33))
                }

                encryptData(e, t) {
                    const n = (0, i.randomBytes)(24), a = (new TextEncoder).encode(e), o = (0, s.streamXOR)(t, n, a, a),
                        c = r.base64.encode(Uint8Array.from(o)), u = r.base64.encode(n);
                    return JSON.stringify({ciphertext: c, nonce: u, v: l.XChaCha20})
                }

                decryptData(e, t) {
                    const n = JSON.parse(e);
                    if (1 !== n.v) throw new Error("NIP44: unknown encryption version");
                    const i = r.base64.decode(n.ciphertext), a = r.base64.decode(n.nonce),
                        o = (0, s.streamXOR)(t, a, i, i);
                    return (new TextDecoder).decode(o)
                }
            }
        }, 124: function (e, t, n) {
            "use strict";
            var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                i && !("get" in i ? !t.__esModule : i.writable || i.configurable) || (i = {
                    enumerable: !0,
                    get: function () {
                        return t[n]
                    }
                }), Object.defineProperty(e, r, i)
            } : function (e, t, n, r) {
                void 0 === r && (r = n), e[r] = t[n]
            }), i = this && this.__exportStar || function (e, t) {
                for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n)
            }, s = this && this.__importDefault || function (e) {
                return e && e.__esModule ? e : {default: e}
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.EventKind = void 0, i(n(5258), t);
            var a = n(8323);
            Object.defineProperty(t, "EventKind", {
                enumerable: !0, get: function () {
                    return s(a).default
                }
            }), i(n(332), t), i(n(2154), t), i(n(2366), t), i(n(3850), t), i(n(5913), t), i(n(2398), t), i(n(5529), t), i(n(7294), t), i(n(4578), t), i(n(5377), t), i(n(5283), t), i(n(8640), t), i(n(1948), t), i(n(1071), t), i(n(481), t), i(n(8848), t), i(n(2141), t), i(n(6395), t), i(n(5517), t)
        }, 2154: function (e, t, n) {
            "use strict";
            var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {
                void 0 === r && (r = n);
                var i = Object.getOwnPropertyDescriptor(t, n);
                i && !("get" in i ? !t.__esModule : i.writable || i.configurable) || (i = {
                    enumerable: !0,
                    get: function () {
                        return t[n]
                    }
                }), Object.defineProperty(e, r, i)
            } : function (e, t, n, r) {
                void 0 === r && (r = n), e[r] = t[n]
            }), i = this && this.__setModuleDefault || (Object.create ? function (e, t) {
                Object.defineProperty(e, "default", {enumerable: !0, value: t})
            } : function (e, t) {
                e.default = t
            }), s = this && this.__importStar || function (e) {
                if (e && e.__esModule) return e;
                var t = {};
                if (null != e) for (var n in e) "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
                return i(t, e), t
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.decodeTLV = t.encodeTLV = t.TLVEntryType = t.NostrPrefix = void 0;
            const a = s(n(4323)), o = n(6237);
            var l, c;

            function u(e, t, n) {
                switch (e) {
                    case c.Special:
                        return t === l.Address ? new TextDecoder("ASCII").decode(n) : a.bytesToHex(n);
                    case c.Author:
                        return a.bytesToHex(n);
                    case c.Kind:
                        return new Uint32Array(new Uint8Array(n.reverse()).buffer)[0];
                    case c.Relay:
                        return new TextDecoder("ASCII").decode(n)
                }
            }

            !function (e) {
                e.PublicKey = "npub", e.PrivateKey = "nsec", e.Note = "note", e.Profile = "nprofile", e.Event = "nevent", e.Relay = "nrelay", e.Address = "naddr"
            }(l = t.NostrPrefix || (t.NostrPrefix = {})), function (e) {
                e[e.Special = 0] = "Special", e[e.Relay = 1] = "Relay", e[e.Author = 2] = "Author", e[e.Kind = 3] = "Kind"
            }(c = t.TLVEntryType || (t.TLVEntryType = {})), t.encodeTLV = function (e, t, n, r, i) {
                const s = new TextEncoder, c = e === l.Address ? s.encode(t) : a.hexToBytes(t), u = [0, c.length, ...c],
                    d = n?.map((e => {
                        const t = s.encode(e);
                        return [1, t.length, ...t]
                    })).flat() ?? [], h = i ? [2, 32, ...a.hexToBytes(i)] : [],
                    f = r ? [3, 4, ...new Uint8Array(new Uint32Array([r]).buffer).reverse()] : [];
                return o.bech32.encode(e, o.bech32.toWords(new Uint8Array([...u, ...d, ...h, ...f])), 1e3)
            }, t.decodeTLV = function (e) {
                const t = o.bech32.decode(e, 1e3), n = o.bech32.fromWords(t.words), r = [];
                let i = 0;
                for (; i < n.length;) {
                    const e = n[i], s = n[i + 1], a = n.slice(i + 2, i + 2 + s);
                    r.push({type: e, length: s, value: u(e, t.prefix, new Uint8Array(a))}), i += 2 + s
                }
                return r
            }
        }, 2366: (e, t) => {
            "use strict";
            var n;
            Object.defineProperty(t, "__esModule", {value: !0}), t.Nips = void 0, (n = t.Nips || (t.Nips = {}))[n.Search = 50] = "Search"
        }, 5283: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.parseNostrLink = t.tryParseNostrLink = t.validateNostrLink = void 0;
            const r = n(2036), i = n(124);

            function s(e, t) {
                const n = e.startsWith("web+nostr:") || e.startsWith("nostr:") ? e.split(":")[1] : e,
                    s = e => n.startsWith(e);
                if (s(i.NostrPrefix.PublicKey)) {
                    const e = (0, r.bech32ToHex)(n);
                    if (64 !== e.length) throw new Error("Invalid nostr link, must contain 32 byte id");
                    return {
                        type: i.NostrPrefix.PublicKey,
                        id: e,
                        encode: () => (0, r.hexToBech32)(i.NostrPrefix.PublicKey, e)
                    }
                }
                if (s(i.NostrPrefix.Note)) {
                    const e = (0, r.bech32ToHex)(n);
                    if (64 !== e.length) throw new Error("Invalid nostr link, must contain 32 byte id");
                    return {type: i.NostrPrefix.Note, id: e, encode: () => (0, r.hexToBech32)(i.NostrPrefix.Note, e)}
                }
                if (s(i.NostrPrefix.Profile) || s(i.NostrPrefix.Event) || s(i.NostrPrefix.Address)) {
                    const e = (0, i.decodeTLV)(n), t = e.find((e => e.type === i.TLVEntryType.Special))?.value,
                        r = e.filter((e => e.type === i.TLVEntryType.Relay)).map((e => e.value)),
                        a = e.find((e => e.type === i.TLVEntryType.Author))?.value,
                        o = e.find((e => e.type === i.TLVEntryType.Kind))?.value, l = () => n;
                    if (s(i.NostrPrefix.Profile)) {
                        if (64 !== t.length) throw new Error("Invalid nostr link, must contain 32 byte id");
                        return {type: i.NostrPrefix.Profile, id: t, relays: r, kind: o, author: a, encode: l}
                    }
                    if (s(i.NostrPrefix.Event)) {
                        if (64 !== t.length) throw new Error("Invalid nostr link, must contain 32 byte id");
                        return {type: i.NostrPrefix.Event, id: t, relays: r, kind: o, author: a, encode: l}
                    }
                    if (s(i.NostrPrefix.Address)) return {
                        type: i.NostrPrefix.Address,
                        id: t,
                        relays: r,
                        kind: o,
                        author: a,
                        encode: l
                    }
                } else if (t) return {type: t, id: e, encode: () => (0, r.hexToBech32)(t, e)};
                throw new Error("Invalid nostr link")
            }

            t.validateNostrLink = function (e) {
                try {
                    const t = s(e);
                    return !!t && (t.type !== i.NostrPrefix.PublicKey && t.type !== i.NostrPrefix.Note || 64 === t.id.length)
                } catch {
                    return !1
                }
            }, t.tryParseNostrLink = function (e, t) {
                try {
                    return s(e, t)
                } catch {
                    return
                }
            }, t.parseNostrLink = s
        }, 5258: function (e, t, n) {
            "use strict";
            var r, i, s, a, o, l, c, u, d, h, f = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            }, p = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            }, m = this && this.__importDefault || function (e) {
                return e && e.__esModule ? e : {default: e}
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.NostrSystem = void 0;
            const g = m(n(5130)), y = n(2036), v = n(2398), b = n(1649), w = n(298), x = n(124);

            class E extends y.ExternalStore {
                constructor(e) {
                    super(), r.add(this), i.set(this, (0, g.default)("System")), s.set(this, new Map), this.Queries = new Map, a.set(this, void 0), o.set(this, void 0), l.set(this, void 0), c.set(this, void 0), u.set(this, void 0), d.set(this, void 0), f(this, a, e.authHandler, "f"), f(this, o, e.relayCache ?? new x.UserRelaysCache, "f"), f(this, l, e.profileCache ?? new x.UserProfileCache, "f"), f(this, c, e.relayMetrics ?? new x.RelayMetricCache, "f"), f(this, u, new x.ProfileLoaderService(this, p(this, l, "f")), "f"), f(this, d, new w.RelayMetricHandler(p(this, c, "f")), "f"), p(this, r, "m", h).call(this)
                }

                get ProfileLoader() {
                    return p(this, u, "f")
                }

                get Sockets() {
                    return [...p(this, s, "f").values()].map((e => e.snapshot()))
                }

                async ConnectToRelay(e, t) {
                    try {
                        const n = (0, y.unwrap)((0, y.sanitizeRelayUrl)(e));
                        if (p(this, s, "f").has(n)) (0, y.unwrap)(p(this, s, "f").get(n)).Settings = t; else {
                            const e = new v.Connection(n, t, p(this, a, "f")?.bind(this));
                            p(this, s, "f").set(n, e), e.OnEvent = (e, t) => this.OnEvent(e, t), e.OnEose = t => this.OnEndOfStoredEvents(e, t), e.OnDisconnect = t => this.OnRelayDisconnect(e, t), e.OnConnected = t => this.OnRelayConnected(e, t), await e.Connect()
                        }
                    } catch (e) {
                        console.error(e)
                    }
                }

                OnRelayConnected(e, t) {
                    if (t) for (const [, t] of this.Queries) t.connectionRestored(e)
                }

                OnRelayDisconnect(e, t) {
                    p(this, d, "f").onDisconnect(e, t);
                    for (const [, t] of this.Queries) t.connectionLost(e.Id)
                }

                OnEndOfStoredEvents(e, t) {
                    for (const [, n] of this.Queries) n.eose(t, e)
                }

                OnEvent(e, t) {
                    for (const [, n] of this.Queries) n.onEvent(e, t)
                }

                async ConnectEphemeralRelay(e) {
                    try {
                        const t = (0, y.unwrap)((0, y.sanitizeRelayUrl)(e));
                        if (!p(this, s, "f").has(t)) {
                            const e = new v.Connection(t, {read: !0, write: !0}, p(this, a, "f")?.bind(this), !0);
                            return p(this, s, "f").set(t, e), e.OnEvent = (e, t) => this.OnEvent(e, t), e.OnEose = t => this.OnEndOfStoredEvents(e, t), e.OnDisconnect = t => this.OnRelayDisconnect(e, t), e.OnConnected = t => this.OnRelayConnected(e, t), await e.Connect(), e
                        }
                    } catch (e) {
                        console.error(e)
                    }
                }

                DisconnectRelay(e) {
                    const t = p(this, s, "f").get(e);
                    t && (p(this, s, "f").delete(e), t.Close())
                }

                GetQuery(e) {
                    return this.Queries.get(e)
                }

                Query(e, t) {
                    const n = this.Queries.get(t.id);
                    if (n) {
                        if (n.fromInstance === t.instance) return n;
                        const e = t.options?.skipDiff ? t.build(p(this, o, "f")) : t.buildDiff(p(this, o, "f"), n.flatFilters);
                        if (0 === e.length && t.options?.skipDiff) return n;
                        for (const t of e) this.SendQuery(n, t);
                        return this.notifyChange(), n
                    }
                    {
                        const n = new e, r = t.build(p(this, o, "f")),
                            i = new b.Query(t.id, t.instance, n, t.options?.leaveOpen);
                        this.Queries.set(t.id, i);
                        for (const e of r) this.SendQuery(i, e);
                        return this.notifyChange(), i
                    }
                }

                async SendQuery(e, t) {
                    if (!t.relay) {
                        const n = [];
                        for (const [r, a] of p(this, s, "f")) if (!a.Ephemeral) {
                            p(this, i, "f").call(this, "Sending query to %s %O", r, t);
                            const s = e.sendToRelay(a, t);
                            s && n.push(s)
                        }
                        return n
                    }
                    {
                        p(this, i, "f").call(this, "Sending query to %s %O", t.relay, t);
                        const n = p(this, s, "f").get(t.relay);
                        if (n) {
                            const r = e.sendToRelay(n, t);
                            if (r) return [r]
                        } else {
                            const n = await this.ConnectEphemeralRelay(t.relay);
                            if (n) {
                                const r = e.sendToRelay(n, t);
                                if (r) return [r]
                            } else console.warn("Failed to connect to new relay for:", t.relay, e)
                        }
                    }
                    return []
                }

                BroadcastEvent(e) {
                    for (const [, t] of p(this, s, "f")) t.Ephemeral || t.SendEvent(e)
                }

                async WriteOnceToRelay(e, t) {
                    const n = (0, y.sanitizeRelayUrl)(e);
                    if (!n) throw new Error("Invalid relay address");
                    if (!p(this, s, "f").has(n)) return await new Promise(((n, r) => {
                        const i = new v.Connection(e, {write: !0, read: !0}, p(this, a, "f")?.bind(this), !0),
                            s = setTimeout(r, 5e3);
                        i.OnConnected = async () => {
                            clearTimeout(s), await i.SendAsync(t), i.Close(), n()
                        }, i.Connect()
                    }));
                    await (p(this, s, "f").get(n)?.SendAsync(t))
                }

                takeSnapshot() {
                    return {
                        queries: [...this.Queries.values()].map((e => ({
                            id: e.id,
                            filters: e.filters,
                            subFilters: []
                        })))
                    }
                }
            }

            t.NostrSystem = E, i = new WeakMap, s = new WeakMap, a = new WeakMap, o = new WeakMap, l = new WeakMap, c = new WeakMap, u = new WeakMap, d = new WeakMap, r = new WeakSet, h = function e() {
                let t = !1;
                for (const [e, n] of this.Queries) n.canRemove() && (n.sendClose(), this.Queries.delete(e), p(this, i, "f").call(this, "Deleted query %s", e), t = !0);
                t && this.notifyChange(), setTimeout((() => p(this, r, "m", e).call(this)), 1e3)
            }
        }, 332: (e, t) => {
            "use strict";
            var n;
            Object.defineProperty(t, "__esModule", {value: !0}), t.Lists = void 0, (n = t.Lists || (t.Lists = {})).Muted = "mute", n.Pinned = "pin", n.Bookmarked = "bookmark", n.Followed = "follow", n.Badges = "profile_badges"
        }, 5529: function (e, t, n) {
            "use strict";
            var r, i, s, a, o, l, c, u, d, h, f, p, m,
                g = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                    if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                    if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                    return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
                }, y = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                    if ("m" === r) throw new TypeError("Private method is not writable");
                    if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                    if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                    return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
                };
            Object.defineProperty(t, "__esModule", {value: !0}), t.ParameterizedReplaceableNoteStore = t.PubkeyReplaceableNoteStore = t.ReplaceableNoteStore = t.KeyedReplaceableNoteStore = t.FlatNoteStore = t.HookedNoteStore = t.NoteStore = t.EmptySnapshot = void 0;
            const v = n(2036), b = n(2150);
            t.EmptySnapshot = {
                data: void 0, clear: () => {
                }, loading: () => !0, add: () => {
                }
            }, t.NoteStore = class {
            };

            class w {
                constructor() {
                    r.add(this), i.set(this, []), s.set(this, []), a.set(this, !0), o.set(this, {
                        clear: () => this.clear(),
                        loading: () => this.loading,
                        add: e => this.add(e),
                        data: void 0
                    }), l.set(this, !0), c.set(this, void 0)
                }

                get snapshot() {
                    return g(this, r, "m", u).call(this), g(this, o, "f")
                }

                get loading() {
                    return g(this, a, "f")
                }

                set loading(e) {
                    y(this, a, e, "f"), this.onChange([])
                }

                hook(e) {
                    return g(this, i, "f").push(e), () => {
                        const t = g(this, i, "f").findIndex((t => t === e));
                        g(this, i, "f").splice(t, 1)
                    }
                }

                getSnapshotData() {
                    return g(this, r, "m", u).call(this), g(this, o, "f").data
                }

                onEvent(e) {
                    return g(this, s, "f").find((t => t === e)) ? () => {
                    } : (g(this, s, "f").push(e), () => {
                        const t = g(this, s, "f").findIndex((t => t === e));
                        g(this, s, "f").splice(t, 1)
                    })
                }

                onChange(e) {
                    if (y(this, l, !0, "f"), g(this, c, "f") || y(this, c, setTimeout((() => {
                        y(this, c, void 0, "f");
                        for (const e of g(this, i, "f")) e()
                    }), 500), "f"), e.length > 0) for (const t of g(this, s, "f")) t(e)
                }
            }

            t.HookedNoteStore = w, i = new WeakMap, s = new WeakMap, a = new WeakMap, o = new WeakMap, l = new WeakMap, c = new WeakMap, r = new WeakSet, u = function () {
                g(this, l, "f") && (y(this, o, {
                    ...g(this, o, "f"),
                    data: this.takeSnapshot()
                }, "f"), y(this, l, !1, "f"))
            }, t.FlatNoteStore = class extends w {
                constructor() {
                    super(...arguments), d.set(this, []), h.set(this, new Set)
                }

                add(e) {
                    e = Array.isArray(e) ? e : [e];
                    const t = [];
                    e.forEach((e => {
                        if (g(this, h, "f").has(e.id)) {
                            const t = g(this, d, "f").find((t => t.id === e.id));
                            t && (t.relays = (0, v.appendDedupe)(t.relays, e.relays))
                        } else g(this, d, "f").push(e), g(this, h, "f").add(e.id), t.push(e)
                    })), t.length > 0 && this.onChange(t)
                }

                clear() {
                    y(this, d, [], "f"), g(this, h, "f").clear(), this.onChange([])
                }

                takeSnapshot() {
                    return [...g(this, d, "f")]
                }
            }, d = new WeakMap, h = new WeakMap;

            class x extends w {
                constructor(e) {
                    super(), f.set(this, void 0), p.set(this, new Map), y(this, f, e, "f")
                }

                add(e) {
                    e = Array.isArray(e) ? e : [e];
                    const t = [];
                    e.forEach((e => {
                        const n = g(this, f, "f").call(this, e), r = g(this, p, "f").get(n)?.created_at ?? 0;
                        e.created_at > r && (g(this, p, "f").set(n, e), t.push(e))
                    })), t.length > 0 && this.onChange(t)
                }

                clear() {
                    g(this, p, "f").clear(), this.onChange([])
                }

                takeSnapshot() {
                    return [...g(this, p, "f").values()]
                }
            }

            t.KeyedReplaceableNoteStore = x, f = new WeakMap, p = new WeakMap, t.ReplaceableNoteStore = class extends w {
                constructor() {
                    super(...arguments), m.set(this, void 0)
                }

                add(e) {
                    e = Array.isArray(e) ? e : [e];
                    const t = [];
                    e.forEach((e => {
                        const n = g(this, m, "f")?.created_at ?? 0;
                        e.created_at > n && (y(this, m, e, "f"), t.push(e))
                    })), t.length > 0 && this.onChange(t)
                }

                clear() {
                    y(this, m, void 0, "f"), this.onChange([])
                }

                takeSnapshot() {
                    if (g(this, m, "f")) return Object.freeze({...g(this, m, "f")})
                }
            }, m = new WeakMap, t.PubkeyReplaceableNoteStore = class extends x {
                constructor() {
                    super((e => e.pubkey))
                }
            }, t.ParameterizedReplaceableNoteStore = class extends x {
                constructor() {
                    super((e => {
                        const t = (0, b.findTag)(e, "d");
                        return `${e.pubkey}-${t}`
                    }))
                }
            }
        }, 8640: function (e, t, n) {
            "use strict";
            var r, i, s, a, o, l, c, u = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            }, d = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            }, h = this && this.__importDefault || function (e) {
                return e && e.__esModule ? e : {default: e}
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.ProfileLoaderService = void 0;
            const f = h(n(5130)), p = n(2036), m = n(124), g = n(3466), y = n(8848), v = ["wss://purplepag.es"];
            t.ProfileLoaderService = class {
                constructor(e, t) {
                    r.add(this), i.set(this, void 0), s.set(this, void 0), a.set(this, new Set), o.set(this, new Set), l.set(this, (0, f.default)("ProfileCache")), u(this, i, e, "f"), u(this, s, t, "f"), d(this, r, "m", c).call(this)
                }

                get Cache() {
                    return d(this, s, "f")
                }

                TrackMetadata(e) {
                    const t = [];
                    for (const n of Array.isArray(e) ? e : [e]) 64 === n.length && d(this, o, "f").add(n) && t.push(n);
                    d(this, s, "f").buffer(t)
                }

                UntrackMetadata(e) {
                    for (const t of Array.isArray(e) ? e : [e]) t.length > 0 && d(this, o, "f").delete(t)
                }

                async onProfileEvent(e) {
                    const t = (0, y.mapEventToProfile)(e);
                    t && await d(this, s, "f").update(t)
                }
            }, i = new WeakMap, s = new WeakMap, a = new WeakMap, o = new WeakMap, l = new WeakMap, r = new WeakSet, c = async function e() {
                const t = await d(this, s, "f").buffer([...d(this, o, "f")]),
                    n = (0, p.unixNowMs)() - g.ProfileCacheExpire,
                    c = [...d(this, o, "f")].filter((e => !t.includes(e))).filter((e => (d(this, s, "f").getFromCache(e)?.loaded ?? 0) < n)),
                    h = new Set([...t, ...c]);
                if (h.size > 0) {
                    d(this, l, "f").call(this, "Wants profiles: %d missing, %d expired", t.length, c.length);
                    const e = new m.RequestBuilder("profiles");
                    if (e.withOptions({skipDiff: !0}).withFilter().kinds([m.EventKind.SetMetadata]).authors([...h]), d(this, a, "f").size > 0) {
                        const t = e.withFilter().kinds([m.EventKind.SetMetadata]).authors([...d(this, a, "f")]);
                        v.forEach((e => t.relay(e)))
                    }
                    const n = new Set, r = d(this, i, "f").Query(m.PubkeyReplaceableNoteStore, e),
                        o = r?.feed ?? new m.PubkeyReplaceableNoteStore, f = o.onEvent((async e => {
                            for (const t of e) n.add(t.id), await this.onProfileEvent(t)
                        })), y = await new Promise((t => {
                            let n;
                            const r = o.hook((() => {
                                o.loading || (clearTimeout(n), t(o.getSnapshotData() ?? []), d(this, l, "f").call(this, "Profiles finished: %s", e.id), r())
                            }));
                            n = setTimeout((() => {
                                r(), t(o.getSnapshotData() ?? []), d(this, l, "f").call(this, "Profiles timeout: %s", e.id)
                            }), 5e3)
                        }));
                    f();
                    const b = [...h].filter((e => !y.some((t => t.pubkey === e))));
                    if (u(this, a, new Set(b), "f"), b.length > 0) {
                        d(this, l, "f").call(this, "No profiles: %o", b);
                        const e = b.map((e => d(this, s, "f").update({
                            pubkey: e,
                            loaded: (0, p.unixNowMs)() - g.ProfileCacheExpire + 5e3,
                            created: 69
                        })));
                        await Promise.all(e)
                    }
                    const w = y.filter((e => !n.has(e.id) && c.includes(e.pubkey)));
                    await Promise.all(w.map((e => this.onProfileEvent(e))))
                }
                setTimeout((() => d(this, r, "m", e).call(this)), 500)
            }
        }, 1649: function (e, t, n) {
            "use strict";
            var r, i, s, a, o, l, c, u, d, h, f, p, m, g, y,
                v = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                    if ("m" === r) throw new TypeError("Private method is not writable");
                    if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                    if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                    return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
                }, b = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                    if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                    if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                    return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
                }, w = this && this.__importDefault || function (e) {
                    return e && e.__esModule ? e : {default: e}
                };
            Object.defineProperty(t, "__esModule", {value: !0}), t.Query = void 0;
            const x = n(130), E = w(n(5130)), S = n(2036), k = n(124), A = n(2150), T = n(2528), C = n(6966);

            class R {
                constructor(e, t, n, a, o) {
                    this.relay = e, this.filters = t, this.connId = n, r.set(this, !1), i.set(this, void 0), s.set(this, void 0), this.id = (0, x.v4)(), this.start = (0, S.unixNowMs)(), v(this, i, a, "f"), v(this, s, o, "f")
                }

                sentToRelay() {
                    this.sent = (0, S.unixNowMs)(), b(this, s, "f").call(this)
                }

                gotEose() {
                    this.eose = (0, S.unixNowMs)(), b(this, s, "f").call(this)
                }

                forceEose() {
                    this.eose = (0, S.unixNowMs)(), v(this, r, !0, "f"), this.sendClose()
                }

                sendClose() {
                    this.close = (0, S.unixNowMs)(), b(this, i, "f").call(this, this.id), b(this, s, "f").call(this)
                }

                get queued() {
                    return (void 0 === this.sent ? (0, S.unixNowMs)() : b(this, r, "f") ? (0, S.unwrap)(this.eose) : this.sent) - this.start
                }

                get runtime() {
                    return (void 0 === this.eose ? (0, S.unixNowMs)() : this.eose) - this.start
                }

                get responseTime() {
                    return this.finished ? (0, S.unwrap)(this.eose) - (0, S.unwrap)(this.sent) : 0
                }

                get finished() {
                    return void 0 !== this.eose
                }
            }

            r = new WeakMap, i = new WeakMap, s = new WeakMap, t.Query = class {
                constructor(e, t, n, r) {
                    a.add(this), o.set(this, []), l.set(this, !1), c.set(this, void 0), u.set(this, void 0), d.set(this, void 0), h.set(this, (0, E.default)("Query")), this.id = e, v(this, d, n, "f"), this.fromInstance = t, v(this, l, r ?? !1, "f"), b(this, a, "m", m).call(this)
                }

                isOpen() {
                    return void 0 === b(this, c, "f") && b(this, l, "f")
                }

                canRemove() {
                    return void 0 !== b(this, c, "f") && b(this, c, "f") < (0, S.unixNowMs)()
                }

                get filters() {
                    return (0, T.flatMerge)(this.flatFilters)
                }

                get flatFilters() {
                    const e = [];
                    for (const t of b(this, o, "f").flatMap((e => e.filters))) e.some((e => (0, A.reqFilterEq)(e, t))) || e.push(t);
                    return e.flatMap(C.expandFilter)
                }

                get feed() {
                    return b(this, d, "f")
                }

                onEvent(e, t) {
                    for (const n of b(this, o, "f")) if (n.id === e) {
                        this.feed.add(t);
                        break
                    }
                }

                cancel() {
                    v(this, c, (0, S.unixNowMs)() + 5e3, "f")
                }

                uncancel() {
                    v(this, c, void 0, "f")
                }

                cleanup() {
                    b(this, a, "m", p).call(this)
                }

                sendToRelay(e, t) {
                    if (b(this, a, "m", g).call(this, e, t)) return b(this, a, "m", y).call(this, e, t)
                }

                connectionLost(e) {
                    b(this, o, "f").filter((t => t.connId == e)).forEach((e => e.forceEose()))
                }

                connectionRestored(e) {
                    if (this.isOpen()) for (const t of b(this, o, "f")) t.relay === e.Address && e.QueueReq(["REQ", t.id, ...t.filters], (() => t.sentToRelay()))
                }

                sendClose() {
                    for (const e of b(this, o, "f")) e.sendClose();
                    this.cleanup()
                }

                eose(e, t) {
                    const n = b(this, o, "f").find((n => n.id === e && n.connId === t.Id));
                    n?.gotEose(), b(this, l, "f") || n?.sendClose()
                }

                get progress() {
                    const e = b(this, o, "f").reduce(((e, t) => e + (t.finished ? 1 : 0)), 0) / b(this, o, "f").length;
                    return isNaN(e) ? 0 : e
                }
            }, o = new WeakMap, l = new WeakMap, c = new WeakMap, u = new WeakMap, d = new WeakMap, h = new WeakMap, a = new WeakSet, f = function () {
                const e = 1 === this.progress;
                this.feed.loading !== e && (b(this, h, "f").call(this, "%s loading=%s, progress=%d", this.id, this.feed.loading, this.progress), this.feed.loading = e)
            }, p = function () {
                b(this, u, "f") && clearInterval(b(this, u, "f"))
            }, m = function () {
                b(this, a, "m", p).call(this), v(this, u, setInterval((() => {
                    for (const e of b(this, o, "f")) e.runtime > 5e3 && !e.finished && e.forceEose()
                }), 500), "f")
            }, g = function (e, t) {
                return !(t.relay && t.relay !== e.Address || (!t.relay && e.Ephemeral ? (b(this, h, "f").call(this, "Cant send non-specific REQ to ephemeral connection %O %O %O", t, t.relay, e), 1) : t.filters.some((e => e.search)) && !e.SupportsNip(k.Nips.Search) && (b(this, h, "f").call(this, "Cant send REQ to non-search relay", e.Address), 1)))
            }, y = function (e, t) {
                const n = new R(e.Address, t.filters, e.Id, (t => e.CloseReq(t)), (() => b(this, a, "m", f).call(this)));
                return b(this, o, "f").push(n), e.QueueReq(["REQ", n.id, ...n.filters], (() => n.sentToRelay())), n
            }
        }, 3850: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0})
        }, 298: function (e, t) {
            "use strict";
            var n, r = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.RelayMetricHandler = void 0, t.RelayMetricHandler = class {
                constructor(e) {
                    n.set(this, void 0), r(this, n, e, "f")
                }

                onDisconnect(e, t) {
                }
            }, n = new WeakMap
        }, 7294: function (e, t, n) {
            "use strict";
            var r, i, s, a, o, l, c, u = this && this.__classPrivateFieldSet || function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
            }, d = this && this.__classPrivateFieldGet || function (e, t, n, r) {
                if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
            }, h = this && this.__importDefault || function (e) {
                return e && e.__esModule ? e : {default: e}
            };
            Object.defineProperty(t, "__esModule", {value: !0}), t.RequestFilterBuilder = t.RequestBuilder = t.RequestStrategy = void 0;
            const f = h(n(5130)), p = n(130), m = n(2036), g = n(7597), y = n(4040), v = n(2528), b = n(6966);
            var w;
            !function (e) {
                e[e.DefaultRelays = 1] = "DefaultRelays", e[e.AuthorsRelays = 2] = "AuthorsRelays", e[e.ExplicitRelays = 3] = "ExplicitRelays"
            }(w = t.RequestStrategy || (t.RequestStrategy = {})), t.RequestBuilder = class {
                constructor(e) {
                    r.add(this), i.set(this, void 0), s.set(this, void 0), a.set(this, (0, f.default)("RequestBuilder")), this.instance = (0, p.v4)(), this.id = e, u(this, i, [], "f")
                }

                get numFilters() {
                    return d(this, i, "f").length
                }

                get options() {
                    return d(this, s, "f")
                }

                add(e) {
                    d(this, i, "f").push(...d(e, i, "f"))
                }

                withFilter() {
                    const e = new x;
                    return d(this, i, "f").push(e), e
                }

                withOptions(e) {
                    return u(this, s, {...d(this, s, "f"), ...e}, "f"), this
                }

                buildRaw() {
                    return d(this, i, "f").map((e => e.filter))
                }

                build(e) {
                    const t = d(this, i, "f").flatMap((t => t.build(e, this.id)));
                    return d(this, r, "m", o).call(this, t)
                }

                buildDiff(e, t) {
                    const n = (0, m.unixNowMs)(), r = d(this, i, "f").flatMap((e => (0, b.expandFilter)(e.filter))),
                        s = (0, g.diffFilters)(t, r), o = (0, m.unixNowMs)() - n;
                    return d(this, a, "f").call(this, "buildDiff %s %d ms", this.id, o), s.changed ? (d(this, a, "f").call(this, s), (0, y.splitAllByWriteRelays)(e, s.added).map((e => ({
                        strategy: w.AuthorsRelays,
                        filters: e.filters,
                        relay: e.relay
                    })))) : (d(this, a, "f").call(this, `Wasted ${o} ms detecting no changes!`), [])
                }
            }, i = new WeakMap, s = new WeakMap, a = new WeakMap, r = new WeakSet, o = function (e) {
                return [...e.reduce(((e, t) => {
                    const n = e.get(t.relay);
                    return n ? n.push(t) : e.set(t.relay, [t]), e
                }), new Map).values()].map((e => ({
                    filters: (0, v.mergeSimilar)(e.flatMap((e => e.filters))),
                    relay: e[0].relay,
                    strategy: e[0].strategy
                })))
            };

            class x {
                constructor() {
                    l.set(this, {}), c.set(this, new Set)
                }

                get filter() {
                    return {...d(this, l, "f")}
                }

                relay(e) {
                    const t = (0, m.sanitizeRelayUrl)(e);
                    return t && d(this, c, "f").add(t), this
                }

                ids(e) {
                    return d(this, l, "f").ids = (0, m.appendDedupe)(d(this, l, "f").ids, e), this
                }

                authors(e) {
                    return e ? (d(this, l, "f").authors = (0, m.appendDedupe)(d(this, l, "f").authors, e), this) : this
                }

                kinds(e) {
                    return e ? (d(this, l, "f").kinds = (0, m.appendDedupe)(d(this, l, "f").kinds, e), this) : this
                }

                since(e) {
                    return e ? (d(this, l, "f").since = e, this) : this
                }

                until(e) {
                    return e ? (d(this, l, "f").until = e, this) : this
                }

                limit(e) {
                    return e ? (d(this, l, "f").limit = e, this) : this
                }

                tag(e, t) {
                    return t ? (d(this, l, "f")[`#${e}`] = (0, m.appendDedupe)(d(this, l, "f")[`#${e}`], t), this) : this
                }

                search(e) {
                    return e ? (d(this, l, "f").search = e, this) : this
                }

                build(e, t) {
                    return d(this, c, "f").size > 0 ? [...d(this, c, "f")].map((e => ({
                        filters: [d(this, l, "f")],
                        relay: e,
                        strategy: w.ExplicitRelays
                    }))) : d(this, l, "f").authors ? (0, y.splitByWriteRelays)(e, d(this, l, "f")).map((e => ({
                        filters: [e.filter],
                        relay: e.relay,
                        strategy: w.AuthorsRelays
                    }))) : [{filters: [this.filter], relay: "", strategy: w.DefaultRelays}]
                }
            }

            t.RequestFilterBuilder = x, l = new WeakMap, c = new WeakMap
        }, 6966: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.expandFilter = void 0, t.expandFilter = function (e) {
                const t = [], n = Object.entries(e), r = n.filter((([, e]) => Array.isArray(e))).map((e => e[0])),
                    i = n.filter((([, e]) => !Array.isArray(e)));
                return function n(i, s) {
                    if (i === r.length) return void t.push(s);
                    const a = r[i], o = e[a];
                    for (let e = 0; e < o.length; e++) {
                        const t = o[e];
                        n(i + 1, {...s, [a]: t})
                    }
                }(0, {keys: r.length, ...Object.fromEntries(i)}), t
            }
        }, 2528: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.flatMerge = t.filterIncludes = t.simpleMerge = t.mergeSimilar = t.canMergeFilters = void 0;
            const r = n(2036), i = ["since", "until", "limit", "search"];

            function s(e, t) {
                const n = e, s = t;
                for (const e of i) if (n[e] !== s[e]) return !1;
                return (0, r.distance)(e, t) <= 1
            }

            function a(e) {
                const t = [], n = [...e];
                for (; n.length > 0;) {
                    const e = [n.shift()];
                    for (let t = 0; t < n.length; t++) {
                        const r = n[t];
                        e.some((e => !s(e, r))) || (e.push(n.splice(t, 1)[0]), t--)
                    }
                    t.push(o(e))
                }
                return t
            }

            function o(e) {
                const t = {};
                return e.forEach((e => {
                    Object.entries(e).forEach((([e, n]) => {
                        if (Array.isArray(n)) if (void 0 === t[e]) t[e] = [...n]; else {
                            const r = n.filter((n => !t[e].includes(n)));
                            t[e].push(...r)
                        } else t[e] = n
                    }))
                })), t
            }

            t.canMergeFilters = s, t.mergeSimilar = a, t.simpleMerge = o, t.filterIncludes = function (e, t) {
                const n = e;
                for (const [e, r] of Object.entries(t)) {
                    if (void 0 === n[e]) return !1;
                    if (Array.isArray(r) && r.some((t => !n[e].includes(t)))) return !1;
                    if ("number" == typeof r) {
                        if ("since" === e && n[e] > r) return !1;
                        if ("until" === e && n[e] < r) return !1
                    }
                }
                return !0
            }, t.flatMerge = function (e) {
                let t = [];
                for (; e.length > 0;) {
                    const n = [e.shift()];
                    for (let t = 0; t < e.length; t++) {
                        const r = e[t];
                        n.every((e => s(e, r))) && (n.push(e.splice(t, 1)[0]), t--)
                    }
                    t.push(n.reduce(((e, t) => (Object.entries(t).forEach((([t, n]) => {
                        "keys" !== t && (i.includes(t) ? e[t] = n : (e[t] ?? (e[t] = []), e[t].includes(n) || e[t].push(n)))
                    })), e)), {}))
                }
                for (; ;) {
                    const e = a([...t]);
                    if (e.length === t.length) break;
                    t = e
                }
                return t
            }
        }, 7597: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.diffFilters = void 0;
            const r = n(2150), i = n(2528);
            t.diffFilters = function (e, t, n) {
                const s = [], a = [];
                e = [...e], t = [...t];
                for (const n of t) {
                    const t = e.findIndex((e => (0, r.flatFilterEq)(e, n)));
                    -1 !== t ? e.splice(t, 1) : s.push(n)
                }
                if (n) for (const n of e) {
                    const e = t.findIndex((e => (0, r.flatFilterEq)(e, n)));
                    -1 !== e ? t.splice(e, 1) : a.push(n)
                }
                const o = s.length > 0 || a.length > 0;
                return {added: o ? (0, i.flatMerge)(s) : [], removed: o ? (0, i.flatMerge)(a) : [], changed: o}
            }
        }, 2150: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.flatFilterEq = t.reqFilterEq = t.findTag = void 0;
            const r = n(2036);
            t.findTag = function (e, t) {
                const n = e.tags.find((e => e[0] === t));
                return n && n[1]
            }, t.reqFilterEq = function (e, t) {
                return (0, r.equalProp)(e.ids, t.ids) && (0, r.equalProp)(e.kinds, t.kinds) && (0, r.equalProp)(e.authors, t.authors) && (0, r.equalProp)(e.limit, t.limit) && (0, r.equalProp)(e.since, t.since) && (0, r.equalProp)(e.until, t.until) && (0, r.equalProp)(e.search, t.search) && (0, r.equalProp)(e["#e"], t["#e"]) && (0, r.equalProp)(e["#p"], t["#p"]) && (0, r.equalProp)(e["#t"], t["#t"]) && (0, r.equalProp)(e["#d"], t["#d"]) && (0, r.equalProp)(e["#r"], t["#r"])
            }, t.flatFilterEq = function (e, t) {
                return e.keys === t.keys && e.since === t.since && e.until === t.until && e.limit === t.limit && e.search === t.search && e.ids === t.ids && e.kinds === t.kinds && e.authors === t.authors && e["#e"] === t["#e"] && e["#p"] === t["#p"] && e["#t"] === t["#t"] && e["#d"] === t["#d"] && e["#r"] === t["#r"]
            }
        }, 1948: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {value: !0}), t.parseZap = void 0;
            const r = n(2036), i = n(2150);
            t.parseZap = function (e, t, n) {
                let s = (0, i.findTag)(e, "description");
                if (s) try {
                    const a = function (e) {
                        const t = (0, i.findTag)(e, "bolt11");
                        if (!t) throw new Error("Invalid zap, missing bolt11 tag");
                        return (0, r.decodeInvoice)(t)
                    }(e);
                    s.startsWith("%") && (s = decodeURIComponent(s));
                    const o = JSON.parse(s);
                    if (Array.isArray(o)) throw new Error("deprecated zap format");
                    const l = n?.tags.some((e => "zap" === e[0])) ?? !1, c = o.tags.find((e => "anon" === e[0])),
                        u = (0, r.sha256)(s), d = o.tags.find((e => "poll_option" === e[0]))?.[1], h = {
                            id: e.id,
                            zapService: e.pubkey,
                            amount: (a?.amount ?? 0) / 1e3,
                            event: (0, i.findTag)(o, "e"),
                            sender: o.pubkey,
                            receiver: (0, i.findTag)(o, "p"),
                            valid: !0,
                            anonZap: void 0 !== c,
                            content: o.content,
                            errors: [],
                            pollOption: d ? Number(d) : void 0
                        };
                    return a?.descriptionHash !== u && (h.valid = !1, h.errors.push("description_hash does not match zap request")), (0, i.findTag)(o, "p") !== (0, i.findTag)(e, "p") && (h.valid = !1, h.errors.push("p tags dont match")), h.event && h.event !== (0, i.findTag)(e, "e") && (h.valid = !1, h.errors.push("e tags dont match")), (0, i.findTag)(o, "amount") === a?.amount && (h.valid = !1, h.errors.push("amount tag does not match invoice amount")), t.getFromCache(h.receiver)?.zapService === h.zapService || l || (h.valid = !1, h.errors.push("zap service pubkey doesn't match")), h
                } catch (e) {
                }
                return {
                    id: e.id,
                    zapService: e.pubkey,
                    amount: 0,
                    valid: !1,
                    anonZap: !1,
                    errors: ["invalid zap, parsing failed"]
                }
            }
        }, 7896: (e, t, n) => {
            "use strict";

            function r() {
                return r = Object.assign ? Object.assign.bind() : function (e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }, r.apply(this, arguments)
            }

            n.d(t, {Z: () => r})
        }, 5814: (e, t, n) => {
            "use strict";
            n.d(t, {OP: () => g, Pu: () => b, U_: () => p, gN: () => v, kK: () => y, oA: () => f, wQ: () => d});
            var r = n(7271);
            const i = BigInt(0), s = BigInt(1), a = BigInt(2), o = BigInt(3), l = BigInt(4), c = BigInt(5),
                u = BigInt(8);

            function d(e, t) {
                const n = e % t;
                return n >= i ? n : t + n
            }

            function h(e, t, n) {
                if (n <= i || t < i) throw new Error("Expected power/modulo > 0");
                if (n === s) return i;
                let r = s;
                for (; t > i;) t & s && (r = r * e % n), e = e * e % n, t >>= s;
                return r
            }

            function f(e, t, n) {
                let r = e;
                for (; t-- > i;) r *= r, r %= n;
                return r
            }

            function p(e, t) {
                if (e === i || t <= i) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
                let n = d(e, t), r = t, a = i, o = s, l = s, c = i;
                for (; n !== i;) {
                    const e = r / n, t = r % n, i = a - l * e, s = o - c * e;
                    r = n, n = t, a = l, o = c, l = i, c = s
                }
                if (r !== s) throw new Error("invert: does not exist");
                return d(a, t)
            }

            BigInt(9), BigInt(16);
            const m = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

            function g(e) {
                const t = m.reduce(((e, t) => (e[t] = "function", e)), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger"
                });
                return (0, r.FF)(e, t)
            }

            function y(e, t) {
                const n = void 0 !== t ? t : e.toString(2).length;
                return {nBitLength: n, nByteLength: Math.ceil(n / 8)}
            }

            function v(e, t, n = !1, f = {}) {
                if (e <= i) throw new Error(`Expected Fp ORDER > 0, got ${e}`);
                const {nBitLength: m, nByteLength: g} = y(e, t);
                if (g > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
                const v = function (e) {
                    if (e % l === o) {
                        const t = (e + s) / l;
                        return function (e, n) {
                            const r = e.pow(n, t);
                            if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
                            return r
                        }
                    }
                    if (e % u === c) {
                        const t = (e - c) / u;
                        return function (e, n) {
                            const r = e.mul(n, a), i = e.pow(r, t), s = e.mul(n, i), o = e.mul(e.mul(s, a), i),
                                l = e.mul(s, e.sub(o, e.ONE));
                            if (!e.eql(e.sqr(l), n)) throw new Error("Cannot find square root");
                            return l
                        }
                    }
                    return function (e) {
                        const t = (e - s) / a;
                        let n, r, o;
                        for (n = e - s, r = 0; n % a === i; n /= a, r++) ;
                        for (o = a; o < e && h(o, t, e) !== e - s; o++) ;
                        if (1 === r) {
                            const t = (e + s) / l;
                            return function (e, n) {
                                const r = e.pow(n, t);
                                if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
                                return r
                            }
                        }
                        const c = (n + s) / a;
                        return function (e, i) {
                            if (e.pow(i, t) === e.neg(e.ONE)) throw new Error("Cannot find square root");
                            let a = r, l = e.pow(e.mul(e.ONE, o), n), u = e.pow(i, c), d = e.pow(i, n);
                            for (; !e.eql(d, e.ONE);) {
                                if (e.eql(d, e.ZERO)) return e.ZERO;
                                let t = 1;
                                for (let n = e.sqr(d); t < a && !e.eql(n, e.ONE); t++) n = e.sqr(n);
                                const n = e.pow(l, s << BigInt(a - t - 1));
                                l = e.sqr(n), u = e.mul(u, n), d = e.mul(d, l), a = t
                            }
                            return u
                        }
                    }(e)
                }(e), b = Object.freeze({
                    ORDER: e,
                    BITS: m,
                    BYTES: g,
                    MASK: (0, r.dQ)(m),
                    ZERO: i,
                    ONE: s,
                    create: t => d(t, e),
                    isValid: t => {
                        if ("bigint" != typeof t) throw new Error("Invalid field element: expected bigint, got " + typeof t);
                        return i <= t && t < e
                    },
                    is0: e => e === i,
                    isOdd: e => (e & s) === s,
                    neg: t => d(-t, e),
                    eql: (e, t) => e === t,
                    sqr: t => d(t * t, e),
                    add: (t, n) => d(t + n, e),
                    sub: (t, n) => d(t - n, e),
                    mul: (t, n) => d(t * n, e),
                    pow: (e, t) => function (e, t, n) {
                        if (n < i) throw new Error("Expected power > 0");
                        if (n === i) return e.ONE;
                        if (n === s) return t;
                        let r = e.ONE, a = t;
                        for (; n > i;) n & s && (r = e.mul(r, a)), a = e.sqr(a), n >>= s;
                        return r
                    }(b, e, t),
                    div: (t, n) => d(t * p(n, e), e),
                    sqrN: e => e * e,
                    addN: (e, t) => e + t,
                    subN: (e, t) => e - t,
                    mulN: (e, t) => e * t,
                    inv: t => p(t, e),
                    sqrt: f.sqrt || (e => v(b, e)),
                    invertBatch: e => function (e, t) {
                        const n = new Array(t.length),
                            r = t.reduce(((t, r, i) => e.is0(r) ? t : (n[i] = t, e.mul(t, r))), e.ONE), i = e.inv(r);
                        return t.reduceRight(((t, r, i) => e.is0(r) ? t : (n[i] = e.mul(t, n[i]), e.mul(t, r))), i), n
                    }(b, e),
                    cmov: (e, t, n) => n ? t : e,
                    toBytes: e => n ? (0, r.S5)(e, g) : (0, r.tL)(e, g),
                    fromBytes: e => {
                        if (e.length !== g) throw new Error(`Fp.fromBytes: expected ${g}, got ${e.length}`);
                        return n ? (0, r.ty)(e) : (0, r.bytesToNumberBE)(e)
                    }
                });
                return Object.freeze(b)
            }

            function b(e, t, n = !1) {
                const i = (e = (0, r.ql)("privateHash", e)).length, a = y(t).nByteLength + 8;
                if (a < 24 || i < a || i > 1024) throw new Error(`hashToPrivateScalar: expected ${a}-1024 bytes of input, got ${i}`);
                return d(n ? (0, r.ty)(e) : (0, r.bytesToNumberBE)(e), t - s) + s
            }
        }, 7271: (e, t, n) => {
            "use strict";
            n.d(t, {
                FF: () => E,
                S5: () => f,
                bytesToNumberBE: () => u,
                ci: () => o,
                dQ: () => y,
                eV: () => m,
                hexToBytes: () => c,
                iY: () => g,
                n$: () => w,
                ql: () => p,
                tL: () => h,
                ty: () => d
            }), BigInt(0);
            const r = BigInt(1), i = BigInt(2), s = e => e instanceof Uint8Array,
                a = Array.from({length: 256}, ((e, t) => t.toString(16).padStart(2, "0")));

            function o(e) {
                if (!s(e)) throw new Error("Uint8Array expected");
                let t = "";
                for (let n = 0; n < e.length; n++) t += a[e[n]];
                return t
            }

            function l(e) {
                if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
                return BigInt("" === e ? "0" : `0x${e}`)
            }

            function c(e) {
                if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
                if (e.length % 2) throw new Error("hex string is invalid: unpadded " + e.length);
                const t = new Uint8Array(e.length / 2);
                for (let n = 0; n < t.length; n++) {
                    const r = 2 * n, i = e.slice(r, r + 2), s = Number.parseInt(i, 16);
                    if (Number.isNaN(s) || s < 0) throw new Error("invalid byte sequence");
                    t[n] = s
                }
                return t
            }

            function u(e) {
                return l(o(e))
            }

            function d(e) {
                if (!s(e)) throw new Error("Uint8Array expected");
                return l(o(Uint8Array.from(e).reverse()))
            }

            const h = (e, t) => c(e.toString(16).padStart(2 * t, "0")), f = (e, t) => h(e, t).reverse();

            function p(e, t, n) {
                let r;
                if ("string" == typeof t) try {
                    r = c(t)
                } catch (n) {
                    throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`)
                } else {
                    if (!s(t)) throw new Error(`${e} must be hex string or Uint8Array`);
                    r = Uint8Array.from(t)
                }
                const i = r.length;
                if ("number" == typeof n && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`);
                return r
            }

            function m(...e) {
                const t = new Uint8Array(e.reduce(((e, t) => e + t.length), 0));
                let n = 0;
                return e.forEach((e => {
                    if (!s(e)) throw new Error("Uint8Array expected");
                    t.set(e, n), n += e.length
                })), t
            }

            function g(e) {
                if ("string" != typeof e) throw new Error("utf8ToBytes expected string, got " + typeof e);
                return (new TextEncoder).encode(e)
            }

            const y = e => (i << BigInt(e - 1)) - r, v = e => new Uint8Array(e), b = e => Uint8Array.from(e);

            function w(e, t, n) {
                if ("number" != typeof e || e < 2) throw new Error("hashLen must be a number");
                if ("number" != typeof t || t < 2) throw new Error("qByteLen must be a number");
                if ("function" != typeof n) throw new Error("hmacFn must be a function");
                let r = v(e), i = v(e), s = 0;
                const a = () => {
                    r.fill(1), i.fill(0), s = 0
                }, o = (...e) => n(i, r, ...e), l = (e = v()) => {
                    i = o(b([0]), e), r = o(), 0 !== e.length && (i = o(b([1]), e), r = o())
                }, c = () => {
                    if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
                    let e = 0;
                    const n = [];
                    for (; e < t;) {
                        r = o();
                        const t = r.slice();
                        n.push(t), e += r.length
                    }
                    return m(...n)
                };
                return (e, t) => {
                    let n;
                    for (a(), l(e); !(n = t(c()));) l();
                    return a(), n
                }
            }

            const x = {
                bigint: e => "bigint" == typeof e,
                function: e => "function" == typeof e,
                boolean: e => "boolean" == typeof e,
                string: e => "string" == typeof e,
                isSafeInteger: e => Number.isSafeInteger(e),
                array: e => Array.isArray(e),
                field: (e, t) => t.Fp.isValid(e),
                hash: e => "function" == typeof e && Number.isSafeInteger(e.outputLen)
            };

            function E(e, t, n = {}) {
                const r = (t, n, r) => {
                    const i = x[n];
                    if ("function" != typeof i) throw new Error(`Invalid validator "${n}", expected function`);
                    const s = e[t];
                    if (!(r && void 0 === s || i(s, e))) throw new Error(`Invalid param ${String(t)}=${s} (${typeof s}), expected ${n}`)
                };
                for (const [e, n] of Object.entries(t)) r(e, n, !1);
                for (const [e, t] of Object.entries(n)) r(e, t, !0);
                return e
            }
        }, 8995: (e, t, n) => {
            "use strict";
            n.d(t, {xW: () => V, kA: () => I});
            var r = n(3929), i = n(4658), s = n(5814), a = n(7271);
            const o = BigInt(0), l = BigInt(1);

            function c(e) {
                return (0, s.OP)(e.Fp), (0, a.FF)(e, {
                    n: "bigint",
                    h: "bigint",
                    Gx: "field",
                    Gy: "field"
                }, {
                    nBitLength: "isSafeInteger",
                    nByteLength: "isSafeInteger"
                }), Object.freeze({...(0, s.kK)(e.n, e.nBitLength), ...e, p: e.Fp.ORDER})
            }

            const {bytesToNumberBE: u, hexToBytes: d} = a, h = {
                Err: class extends Error {
                    constructor(e = "") {
                        super(e)
                    }
                }, _parseInt(e) {
                    const {Err: t} = h;
                    if (e.length < 2 || 2 !== e[0]) throw new t("Invalid signature integer tag");
                    const n = e[1], r = e.subarray(2, n + 2);
                    if (!n || r.length !== n) throw new t("Invalid signature integer: wrong length");
                    if (128 & r[0]) throw new t("Invalid signature integer: negative");
                    if (0 === r[0] && !(128 & r[1])) throw new t("Invalid signature integer: unnecessary leading zero");
                    return {d: u(r), l: e.subarray(n + 2)}
                }, toSig(e) {
                    const {Err: t} = h, n = "string" == typeof e ? d(e) : e;
                    if (!(n instanceof Uint8Array)) throw new Error("ui8a expected");
                    let r = n.length;
                    if (r < 2 || 48 != n[0]) throw new t("Invalid signature tag");
                    if (n[1] !== r - 2) throw new t("Invalid signature: incorrect length");
                    const {d: i, l: s} = h._parseInt(n.subarray(2)), {d: a, l: o} = h._parseInt(s);
                    if (o.length) throw new t("Invalid signature: left bytes after parsing");
                    return {r: i, s: a}
                }, hexFromSig(e) {
                    const t = e => 8 & Number.parseInt(e[0], 16) ? "00" + e : e, n = e => {
                        const t = e.toString(16);
                        return 1 & t.length ? `0${t}` : t
                    }, r = t(n(e.s)), i = t(n(e.r)), s = r.length / 2, a = i.length / 2, o = n(s), l = n(a);
                    return `30${n(a + s + 4)}02${l}${i}02${o}${r}`
                }
            }, f = BigInt(0), p = BigInt(1), m = BigInt(2), g = BigInt(3), y = BigInt(4);

            function v(e) {
                const t = function (e) {
                    const t = c(e);
                    return a.FF(t, {hash: "hash", hmac: "function", randomBytes: "function"}, {
                        bits2int: "function",
                        bits2int_modN: "function",
                        lowS: "boolean"
                    }), Object.freeze({lowS: !0, ...t})
                }(e), {Fp: n, n: r} = t, i = n.BYTES + 1, u = 2 * n.BYTES + 1;

                function d(e) {
                    return s.wQ(e, r)
                }

                function m(e) {
                    return s.U_(e, r)
                }

                const {
                    ProjectivePoint: y,
                    normPrivateKeyToScalar: v,
                    weierstrassEquation: b,
                    isWithinCurveOrder: w
                } = function (e) {
                    const t = function (e) {
                        const t = c(e);
                        a.FF(t, {a: "field", b: "field"}, {
                            allowedPrivateKeyLengths: "array",
                            wrapPrivateKey: "boolean",
                            isTorsionFree: "function",
                            clearCofactor: "function",
                            allowInfinityPoint: "boolean",
                            fromBytes: "function",
                            toBytes: "function"
                        });
                        const {endo: n, Fp: r, a: i} = t;
                        if (n) {
                            if (!r.eql(i, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                            if ("object" != typeof n || "bigint" != typeof n.beta || "function" != typeof n.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
                        }
                        return Object.freeze({...t})
                    }(e), {Fp: n} = t, r = t.toBytes || ((e, t, r) => {
                        const i = t.toAffine();
                        return a.eV(Uint8Array.from([4]), n.toBytes(i.x), n.toBytes(i.y))
                    }), i = t.fromBytes || (e => {
                        const t = e.subarray(1);
                        return {
                            x: n.fromBytes(t.subarray(0, n.BYTES)),
                            y: n.fromBytes(t.subarray(n.BYTES, 2 * n.BYTES))
                        }
                    });

                    function u(e) {
                        const {a: r, b: i} = t, s = n.sqr(e), a = n.mul(s, e);
                        return n.add(n.add(a, n.mul(e, r)), i)
                    }

                    if (!n.eql(n.sqr(t.Gy), u(t.Gx))) throw new Error("bad generator point: equation left != right");

                    function d(e) {
                        return "bigint" == typeof e && f < e && e < t.n
                    }

                    function h(e) {
                        if (!d(e)) throw new Error("Expected valid bigint: 0 < bigint < curve.n")
                    }

                    function m(e) {
                        const {allowedPrivateKeyLengths: n, nByteLength: r, wrapPrivateKey: i, n: o} = t;
                        if (n && "bigint" != typeof e) {
                            if (e instanceof Uint8Array && (e = a.ci(e)), "string" != typeof e || !n.includes(e.length)) throw new Error("Invalid key");
                            e = e.padStart(2 * r, "0")
                        }
                        let l;
                        try {
                            l = "bigint" == typeof e ? e : a.bytesToNumberBE((0, a.ql)("private key", e, r))
                        } catch (t) {
                            throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof e}`)
                        }
                        return i && (l = s.wQ(l, o)), h(l), l
                    }

                    const y = new Map;

                    function v(e) {
                        if (!(e instanceof b)) throw new Error("ProjectivePoint expected")
                    }

                    class b {
                        constructor(e, t, r) {
                            if (this.px = e, this.py = t, this.pz = r, null == e || !n.isValid(e)) throw new Error("x required");
                            if (null == t || !n.isValid(t)) throw new Error("y required");
                            if (null == r || !n.isValid(r)) throw new Error("z required")
                        }

                        static fromAffine(e) {
                            const {x: t, y: r} = e || {};
                            if (!e || !n.isValid(t) || !n.isValid(r)) throw new Error("invalid affine point");
                            if (e instanceof b) throw new Error("projective point not allowed");
                            const i = e => n.eql(e, n.ZERO);
                            return i(t) && i(r) ? b.ZERO : new b(t, r, n.ONE)
                        }

                        get x() {
                            return this.toAffine().x
                        }

                        get y() {
                            return this.toAffine().y
                        }

                        static normalizeZ(e) {
                            const t = n.invertBatch(e.map((e => e.pz)));
                            return e.map(((e, n) => e.toAffine(t[n]))).map(b.fromAffine)
                        }

                        static fromHex(e) {
                            const t = b.fromAffine(i((0, a.ql)("pointHex", e)));
                            return t.assertValidity(), t
                        }

                        static fromPrivateKey(e) {
                            return b.BASE.multiply(m(e))
                        }

                        _setWindowSize(e) {
                            this._WINDOW_SIZE = e, y.delete(this)
                        }

                        assertValidity() {
                            if (this.is0()) {
                                if (t.allowInfinityPoint) return;
                                throw new Error("bad point: ZERO")
                            }
                            const {x: e, y: r} = this.toAffine();
                            if (!n.isValid(e) || !n.isValid(r)) throw new Error("bad point: x or y not FE");
                            const i = n.sqr(r), s = u(e);
                            if (!n.eql(i, s)) throw new Error("bad point: equation left != right");
                            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup")
                        }

                        hasEvenY() {
                            const {y: e} = this.toAffine();
                            if (n.isOdd) return !n.isOdd(e);
                            throw new Error("Field doesn't support isOdd")
                        }

                        equals(e) {
                            v(e);
                            const {px: t, py: r, pz: i} = this, {px: s, py: a, pz: o} = e,
                                l = n.eql(n.mul(t, o), n.mul(s, i)), c = n.eql(n.mul(r, o), n.mul(a, i));
                            return l && c
                        }

                        negate() {
                            return new b(this.px, n.neg(this.py), this.pz)
                        }

                        double() {
                            const {a: e, b: r} = t, i = n.mul(r, g), {px: s, py: a, pz: o} = this;
                            let l = n.ZERO, c = n.ZERO, u = n.ZERO, d = n.mul(s, s), h = n.mul(a, a), f = n.mul(o, o),
                                p = n.mul(s, a);
                            return p = n.add(p, p), u = n.mul(s, o), u = n.add(u, u), l = n.mul(e, u), c = n.mul(i, f), c = n.add(l, c), l = n.sub(h, c), c = n.add(h, c), c = n.mul(l, c), l = n.mul(p, l), u = n.mul(i, u), f = n.mul(e, f), p = n.sub(d, f), p = n.mul(e, p), p = n.add(p, u), u = n.add(d, d), d = n.add(u, d), d = n.add(d, f), d = n.mul(d, p), c = n.add(c, d), f = n.mul(a, o), f = n.add(f, f), d = n.mul(f, p), l = n.sub(l, d), u = n.mul(f, h), u = n.add(u, u), u = n.add(u, u), new b(l, c, u)
                        }

                        add(e) {
                            v(e);
                            const {px: r, py: i, pz: s} = this, {px: a, py: o, pz: l} = e;
                            let c = n.ZERO, u = n.ZERO, d = n.ZERO;
                            const h = t.a, f = n.mul(t.b, g);
                            let p = n.mul(r, a), m = n.mul(i, o), y = n.mul(s, l), w = n.add(r, i), x = n.add(a, o);
                            w = n.mul(w, x), x = n.add(p, m), w = n.sub(w, x), x = n.add(r, s);
                            let E = n.add(a, l);
                            return x = n.mul(x, E), E = n.add(p, y), x = n.sub(x, E), E = n.add(i, s), c = n.add(o, l), E = n.mul(E, c), c = n.add(m, y), E = n.sub(E, c), d = n.mul(h, x), c = n.mul(f, y), d = n.add(c, d), c = n.sub(m, d), d = n.add(m, d), u = n.mul(c, d), m = n.add(p, p), m = n.add(m, p), y = n.mul(h, y), x = n.mul(f, x), m = n.add(m, y), y = n.sub(p, y), y = n.mul(h, y), x = n.add(x, y), p = n.mul(m, x), u = n.add(u, p), p = n.mul(E, x), c = n.mul(w, c), c = n.sub(c, p), p = n.mul(w, m), d = n.mul(E, d), d = n.add(d, p), new b(c, u, d)
                        }

                        subtract(e) {
                            return this.add(e.negate())
                        }

                        is0() {
                            return this.equals(b.ZERO)
                        }

                        wNAF(e) {
                            return x.wNAFCached(this, y, e, (e => {
                                const t = n.invertBatch(e.map((e => e.pz)));
                                return e.map(((e, n) => e.toAffine(t[n]))).map(b.fromAffine)
                            }))
                        }

                        multiplyUnsafe(e) {
                            const r = b.ZERO;
                            if (e === f) return r;
                            if (h(e), e === p) return this;
                            const {endo: i} = t;
                            if (!i) return x.unsafeLadder(this, e);
                            let {k1neg: s, k1: a, k2neg: o, k2: l} = i.splitScalar(e), c = r, u = r, d = this;
                            for (; a > f || l > f;) a & p && (c = c.add(d)), l & p && (u = u.add(d)), d = d.double(), a >>= p, l >>= p;
                            return s && (c = c.negate()), o && (u = u.negate()), u = new b(n.mul(u.px, i.beta), u.py, u.pz), c.add(u)
                        }

                        multiply(e) {
                            h(e);
                            let r, i, s = e;
                            const {endo: a} = t;
                            if (a) {
                                const {k1neg: e, k1: t, k2neg: o, k2: l} = a.splitScalar(s);
                                let {p: c, f: u} = this.wNAF(t), {p: d, f: h} = this.wNAF(l);
                                c = x.constTimeNegate(e, c), d = x.constTimeNegate(o, d), d = new b(n.mul(d.px, a.beta), d.py, d.pz), r = c.add(d), i = u.add(h)
                            } else {
                                const {p: e, f: t} = this.wNAF(s);
                                r = e, i = t
                            }
                            return b.normalizeZ([r, i])[0]
                        }

                        multiplyAndAddUnsafe(e, t, n) {
                            const r = b.BASE,
                                i = (e, t) => t !== f && t !== p && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t),
                                s = i(this, t).add(i(e, n));
                            return s.is0() ? void 0 : s
                        }

                        toAffine(e) {
                            const {px: t, py: r, pz: i} = this, s = this.is0();
                            null == e && (e = s ? n.ONE : n.inv(i));
                            const a = n.mul(t, e), o = n.mul(r, e), l = n.mul(i, e);
                            if (s) return {x: n.ZERO, y: n.ZERO};
                            if (!n.eql(l, n.ONE)) throw new Error("invZ was invalid");
                            return {x: a, y: o}
                        }

                        isTorsionFree() {
                            const {h: e, isTorsionFree: n} = t;
                            if (e === p) return !0;
                            if (n) return n(b, this);
                            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                        }

                        clearCofactor() {
                            const {h: e, clearCofactor: n} = t;
                            return e === p ? this : n ? n(b, this) : this.multiplyUnsafe(t.h)
                        }

                        toRawBytes(e = !0) {
                            return this.assertValidity(), r(b, this, e)
                        }

                        toHex(e = !0) {
                            return a.ci(this.toRawBytes(e))
                        }
                    }

                    b.BASE = new b(t.Gx, t.Gy, n.ONE), b.ZERO = new b(n.ZERO, n.ONE, n.ZERO);
                    const w = t.nBitLength, x = function (e, t) {
                        const n = (e, t) => {
                            const n = t.negate();
                            return e ? n : t
                        }, r = e => ({windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1)});
                        return {
                            constTimeNegate: n, unsafeLadder(t, n) {
                                let r = e.ZERO, i = t;
                                for (; n > o;) n & l && (r = r.add(i)), i = i.double(), n >>= l;
                                return r
                            }, precomputeWindow(e, t) {
                                const {windows: n, windowSize: i} = r(t), s = [];
                                let a = e, o = a;
                                for (let e = 0; e < n; e++) {
                                    o = a, s.push(o);
                                    for (let e = 1; e < i; e++) o = o.add(a), s.push(o);
                                    a = o.double()
                                }
                                return s
                            }, wNAF(t, i, s) {
                                const {windows: a, windowSize: o} = r(t);
                                let c = e.ZERO, u = e.BASE;
                                const d = BigInt(2 ** t - 1), h = 2 ** t, f = BigInt(t);
                                for (let e = 0; e < a; e++) {
                                    const t = e * o;
                                    let r = Number(s & d);
                                    s >>= f, r > o && (r -= h, s += l);
                                    const a = t, p = t + Math.abs(r) - 1, m = e % 2 != 0, g = r < 0;
                                    0 === r ? u = u.add(n(m, i[a])) : c = c.add(n(g, i[p]))
                                }
                                return {p: c, f: u}
                            }, wNAFCached(e, t, n, r) {
                                const i = e._WINDOW_SIZE || 1;
                                let s = t.get(e);
                                return s || (s = this.precomputeWindow(e, i), 1 !== i && t.set(e, r(s))), this.wNAF(i, s, n)
                            }
                        }
                    }(b, t.endo ? Math.ceil(w / 2) : w);
                    return {
                        CURVE: t,
                        ProjectivePoint: b,
                        normPrivateKeyToScalar: m,
                        weierstrassEquation: u,
                        isWithinCurveOrder: d
                    }
                }({
                    ...t, toBytes(e, t, r) {
                        const i = t.toAffine(), s = n.toBytes(i.x), o = a.eV;
                        return r ? o(Uint8Array.from([t.hasEvenY() ? 2 : 3]), s) : o(Uint8Array.from([4]), s, n.toBytes(i.y))
                    }, fromBytes(e) {
                        const t = e.length, r = e[0], s = e.subarray(1);
                        if (t !== i || 2 !== r && 3 !== r) {
                            if (t === u && 4 === r) return {
                                x: n.fromBytes(s.subarray(0, n.BYTES)),
                                y: n.fromBytes(s.subarray(n.BYTES, 2 * n.BYTES))
                            };
                            throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${u} uncompressed bytes`)
                        }
                        {
                            const e = a.bytesToNumberBE(s);
                            if (!(f < (o = e) && o < n.ORDER)) throw new Error("Point is not on curve");
                            const t = b(e);
                            let i = n.sqrt(t);
                            return 1 == (1 & r) != ((i & p) === p) && (i = n.neg(i)), {x: e, y: i}
                        }
                        var o
                    }
                }), x = e => a.ci(a.tL(e, t.nByteLength));

                function E(e) {
                    return e > r >> p
                }

                const S = (e, t, n) => a.bytesToNumberBE(e.slice(t, n));

                class k {
                    constructor(e, t, n) {
                        this.r = e, this.s = t, this.recovery = n, this.assertValidity()
                    }

                    static fromCompact(e) {
                        const n = t.nByteLength;
                        return e = (0, a.ql)("compactSignature", e, 2 * n), new k(S(e, 0, n), S(e, n, 2 * n))
                    }

                    static fromDER(e) {
                        const {r: t, s: n} = h.toSig((0, a.ql)("DER", e));
                        return new k(t, n)
                    }

                    assertValidity() {
                        if (!w(this.r)) throw new Error("r must be 0 < r < CURVE.n");
                        if (!w(this.s)) throw new Error("s must be 0 < s < CURVE.n")
                    }

                    addRecoveryBit(e) {
                        return new k(this.r, this.s, e)
                    }

                    recoverPublicKey(e) {
                        const {r, s: i, recovery: s} = this, o = R((0, a.ql)("msgHash", e));
                        if (null == s || ![0, 1, 2, 3].includes(s)) throw new Error("recovery id invalid");
                        const l = 2 === s || 3 === s ? r + t.n : r;
                        if (l >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
                        const c = 0 == (1 & s) ? "02" : "03", u = y.fromHex(c + x(l)), h = m(l), f = d(-o * h),
                            p = d(i * h), g = y.BASE.multiplyAndAddUnsafe(u, f, p);
                        if (!g) throw new Error("point at infinify");
                        return g.assertValidity(), g
                    }

                    hasHighS() {
                        return E(this.s)
                    }

                    normalizeS() {
                        return this.hasHighS() ? new k(this.r, d(-this.s), this.recovery) : this
                    }

                    toDERRawBytes() {
                        return a.hexToBytes(this.toDERHex())
                    }

                    toDERHex() {
                        return h.hexFromSig({r: this.r, s: this.s})
                    }

                    toCompactRawBytes() {
                        return a.hexToBytes(this.toCompactHex())
                    }

                    toCompactHex() {
                        return x(this.r) + x(this.s)
                    }
                }

                const A = {
                    isValidPrivateKey(e) {
                        try {
                            return v(e), !0
                        } catch (e) {
                            return !1
                        }
                    }, normPrivateKeyToScalar: v, randomPrivateKey: () => {
                        const e = t.randomBytes(n.BYTES + 8), i = s.Pu(e, r);
                        return a.tL(i, t.nByteLength)
                    }, precompute: (e = 8, t = y.BASE) => (t._setWindowSize(e), t.multiply(BigInt(3)), t)
                };

                function T(e) {
                    const t = e instanceof Uint8Array, n = "string" == typeof e, r = (t || n) && e.length;
                    return t ? r === i || r === u : n ? r === 2 * i || r === 2 * u : e instanceof y
                }

                const C = t.bits2int || function (e) {
                    const n = a.bytesToNumberBE(e), r = 8 * e.length - t.nBitLength;
                    return r > 0 ? n >> BigInt(r) : n
                }, R = t.bits2int_modN || function (e) {
                    return d(C(e))
                }, L = a.dQ(t.nBitLength);

                function _(e) {
                    if ("bigint" != typeof e) throw new Error("bigint expected");
                    if (!(f <= e && e < L)) throw new Error(`bigint expected < 2^${t.nBitLength}`);
                    return a.tL(e, t.nByteLength)
                }

                const P = {lowS: t.lowS, prehash: !1}, N = {lowS: t.lowS, prehash: !1};
                return y.BASE._setWindowSize(8), {
                    CURVE: t, getPublicKey: function (e, t = !0) {
                        return y.fromPrivateKey(e).toRawBytes(t)
                    }, getSharedSecret: function (e, t, n = !0) {
                        if (T(e)) throw new Error("first arg must be private key");
                        if (!T(t)) throw new Error("second arg must be public key");
                        return y.fromHex(t).multiply(v(e)).toRawBytes(n)
                    }, sign: function (e, r, i = P) {
                        const {seed: s, k2sig: o} = function (e, r, i = P) {
                            if (["recovered", "canonical"].some((e => e in i))) throw new Error("sign() legacy options not supported");
                            const {hash: s, randomBytes: o} = t;
                            let {lowS: l, prehash: c, extraEntropy: u} = i;
                            null == l && (l = !0), e = (0, a.ql)("msgHash", e), c && (e = (0, a.ql)("prehashed msgHash", s(e)));
                            const h = R(e), g = v(r), b = [_(g), _(h)];
                            if (null != u) {
                                const e = !0 === u ? o(n.BYTES) : u;
                                b.push((0, a.ql)("extraEntropy", e, n.BYTES))
                            }
                            const x = a.eV(...b), S = h;
                            return {
                                seed: x, k2sig: function (e) {
                                    const t = C(e);
                                    if (!w(t)) return;
                                    const n = m(t), r = y.BASE.multiply(t).toAffine(), i = d(r.x);
                                    if (i === f) return;
                                    const s = d(n * d(S + i * g));
                                    if (s === f) return;
                                    let a = (r.x === i ? 0 : 2) | Number(r.y & p), o = s;
                                    return l && E(s) && (o = function (e) {
                                        return E(e) ? d(-e) : e
                                    }(s), a ^= 1), new k(i, o, a)
                                }
                            }
                        }(e, r, i);
                        return a.n$(t.hash.outputLen, t.nByteLength, t.hmac)(s, o)
                    }, verify: function (e, n, r, i = N) {
                        const s = e;
                        if (n = (0, a.ql)("msgHash", n), r = (0, a.ql)("publicKey", r), "strict" in i) throw new Error("options.strict was renamed to lowS");
                        const {lowS: o, prehash: l} = i;
                        let c, u;
                        try {
                            if ("string" == typeof s || s instanceof Uint8Array) try {
                                c = k.fromDER(s)
                            } catch (e) {
                                if (!(e instanceof h.Err)) throw e;
                                c = k.fromCompact(s)
                            } else {
                                if ("object" != typeof s || "bigint" != typeof s.r || "bigint" != typeof s.s) throw new Error("PARSE");
                                {
                                    const {r: e, s: t} = s;
                                    c = new k(e, t)
                                }
                            }
                            u = y.fromHex(r)
                        } catch (e) {
                            if ("PARSE" === e.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
                            return !1
                        }
                        if (o && c.hasHighS()) return !1;
                        l && (n = t.hash(n));
                        const {r: f, s: p} = c, g = R(n), v = m(p), b = d(g * v), w = d(f * v),
                            x = y.BASE.multiplyAndAddUnsafe(u, b, w)?.toAffine();
                        return !!x && d(x.x) === f
                    }, ProjectivePoint: y, Signature: k, utils: A
                }
            }

            const b = a.bytesToNumberBE;

            function w(e, t) {
                if (e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`);
                const n = Array.from({length: t}).fill(0);
                for (let r = t - 1; r >= 0; r--) n[r] = 255 & e, e >>>= 8;
                return new Uint8Array(n)
            }

            function x(e, t) {
                const n = new Uint8Array(e.length);
                for (let r = 0; r < e.length; r++) n[r] = e[r] ^ t[r];
                return n
            }

            function E(e) {
                if (!(e instanceof Uint8Array)) throw new Error("Uint8Array expected")
            }

            function S(e) {
                if (!Number.isSafeInteger(e)) throw new Error("number expected")
            }

            function k(e, t, n) {
                (0, a.FF)(n, {DST: "string", p: "bigint", m: "isSafeInteger", k: "isSafeInteger", hash: "hash"});
                const {p: r, k: i, m: o, hash: l, expand: c, DST: u} = n;
                E(e), S(t);
                const d = function (e) {
                    if (e instanceof Uint8Array) return e;
                    if ("string" == typeof e) return (0, a.iY)(e);
                    throw new Error("DST must be Uint8Array or string")
                }(u), h = r.toString(2).length, f = Math.ceil((h + i) / 8), p = t * o * f;
                let m;
                if ("xmd" === c) m = function (e, t, n, r) {
                    E(e), E(t), S(n), t.length > 255 && (t = r((0, a.eV)((0, a.iY)("H2C-OVERSIZE-DST-"), t)));
                    const {outputLen: i, blockLen: s} = r, o = Math.ceil(n / i);
                    if (o > 255) throw new Error("Invalid xmd length");
                    const l = (0, a.eV)(t, w(t.length, 1)), c = w(0, s), u = w(n, 2), d = new Array(o),
                        h = r((0, a.eV)(c, e, u, w(0, 1), l));
                    d[0] = r((0, a.eV)(h, w(1, 1), l));
                    for (let e = 1; e <= o; e++) {
                        const t = [x(h, d[e - 1]), w(e + 1, 1), l];
                        d[e] = r((0, a.eV)(...t))
                    }
                    return (0, a.eV)(...d).slice(0, n)
                }(e, d, p, l); else if ("xof" === c) m = function (e, t, n, r, i) {
                    if (E(e), E(t), S(n), t.length > 255) {
                        const e = Math.ceil(2 * r / 8);
                        t = i.create({dkLen: e}).update((0, a.iY)("H2C-OVERSIZE-DST-")).update(t).digest()
                    }
                    if (n > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
                    return i.create({dkLen: n}).update(e).update(w(n, 2)).update(t).update(w(t.length, 1)).digest()
                }(e, d, p, i, l); else {
                    if ("_internal_pass" !== c) throw new Error('expand must be "xmd" or "xof"');
                    m = e
                }
                const g = new Array(t);
                for (let e = 0; e < t; e++) {
                    const t = new Array(o);
                    for (let n = 0; n < o; n++) {
                        const i = f * (n + e * o), a = m.subarray(i, i + f);
                        t[n] = (0, s.wQ)(b(a), r)
                    }
                    g[e] = t
                }
                return g
            }

            var A = n(846);

            function T(e) {
                return {hash: e, hmac: (t, ...n) => (0, A.b)(e, t, (0, i.eV)(...n)), randomBytes: i.O6}
            }

            const C = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
                R = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), L = BigInt(1),
                _ = BigInt(2), P = (e, t) => (e + t / _) / t;

            function N(e) {
                const t = C, n = BigInt(3), r = BigInt(6), i = BigInt(11), a = BigInt(22), o = BigInt(23),
                    l = BigInt(44), c = BigInt(88), u = e * e * e % t, d = u * u * e % t,
                    h = (0, s.oA)(d, n, t) * d % t, f = (0, s.oA)(h, n, t) * d % t, p = (0, s.oA)(f, _, t) * u % t,
                    m = (0, s.oA)(p, i, t) * p % t, g = (0, s.oA)(m, a, t) * m % t, y = (0, s.oA)(g, l, t) * g % t,
                    v = (0, s.oA)(y, c, t) * y % t, b = (0, s.oA)(v, l, t) * g % t, w = (0, s.oA)(b, n, t) * d % t,
                    x = (0, s.oA)(w, o, t) * m % t, E = (0, s.oA)(x, r, t) * u % t, S = (0, s.oA)(E, _, t);
                if (!j.eql(j.sqr(S), e)) throw new Error("Cannot find square root");
                return S
            }

            const j = (0, s.gN)(C, void 0, void 0, {sqrt: N}), I = function (e, t) {
                const n = t => v({...e, ...T(t)});
                return Object.freeze({...n(t), create: n})
            }({
                a: BigInt(0),
                b: BigInt(7),
                Fp: j,
                n: R,
                Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                h: BigInt(1),
                lowS: !0,
                endo: {
                    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                    splitScalar: e => {
                        const t = R, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                            r = -L * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                            i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = n,
                            o = BigInt("0x100000000000000000000000000000000"), l = P(a * e, t), c = P(-r * e, t);
                        let u = (0, s.wQ)(e - l * n - c * i, t), d = (0, s.wQ)(-l * r - c * a, t);
                        const h = u > o, f = d > o;
                        if (h && (u = t - u), f && (d = t - d), u > o || d > o) throw new Error("splitScalar: Endomorphism failed, k=" + e);
                        return {k1neg: h, k1: u, k2neg: f, k2: d}
                    }
                }
            }, r.J), M = BigInt(0), D = e => "bigint" == typeof e && M < e && e < C, O = {};

            function B(e, ...t) {
                let n = O[e];
                if (void 0 === n) {
                    const t = (0, r.J)(Uint8Array.from(e, (e => e.charCodeAt(0))));
                    n = (0, a.eV)(t, t), O[e] = n
                }
                return (0, r.J)((0, a.eV)(n, ...t))
            }

            const F = e => e.toRawBytes(!0).slice(1), U = e => (0, a.tL)(e, 32), H = e => (0, s.wQ)(e, C),
                $ = e => (0, s.wQ)(e, R), K = I.ProjectivePoint;

            function z(e) {
                let t = I.utils.normPrivateKeyToScalar(e), n = K.fromPrivateKey(t);
                return {scalar: n.hasEvenY() ? t : $(-t), bytes: F(n)}
            }

            function G(e) {
                if (!D(e)) throw new Error("bad x: need 0 < x < p");
                const t = H(e * e);
                let n = N(H(t * e + BigInt(7)));
                n % _ !== M && (n = H(-n));
                const r = new K(e, n, L);
                return r.assertValidity(), r
            }

            function q(...e) {
                return $((0, a.bytesToNumberBE)(B("BIP0340/challenge", ...e)))
            }

            function W(e, t, n) {
                const r = (0, a.ql)("signature", e, 64), i = (0, a.ql)("message", t), s = (0, a.ql)("publicKey", n, 32);
                try {
                    const e = G((0, a.bytesToNumberBE)(s)), t = (0, a.bytesToNumberBE)(r.subarray(0, 32));
                    if (!D(t)) return !1;
                    const n = (0, a.bytesToNumberBE)(r.subarray(32, 64));
                    if (!("bigint" == typeof (u = n) && M < u && u < R)) return !1;
                    const d = q(U(t), F(e), i), h = (o = e, l = n, c = $(-d), K.BASE.multiplyAndAddUnsafe(o, l, c));
                    return !(!h || !h.hasEvenY() || h.toAffine().x !== t)
                } catch (e) {
                    return !1
                }
                var o, l, c, u
            }

            const V = {
                    getPublicKey: function (e) {
                        return z(e).bytes
                    },
                    sign: function (e, t, n = (0, i.O6)(32)) {
                        const r = (0, a.ql)("message", e), {bytes: s, scalar: o} = z(t), l = (0, a.ql)("auxRand", n, 32),
                            c = U(o ^ (0, a.bytesToNumberBE)(B("BIP0340/aux", l))), u = B("BIP0340/nonce", c, s, r),
                            d = $((0, a.bytesToNumberBE)(u));
                        if (d === M) throw new Error("sign failed: k is zero");
                        const {bytes: h, scalar: f} = z(d), p = q(h, s, r), m = new Uint8Array(64);
                        if (m.set(h, 0), m.set(U($(f + p * o)), 32), !W(m, r, s)) throw new Error("sign: Invalid signature produced");
                        return m
                    },
                    verify: W,
                    utils: {
                        randomPrivateKey: I.utils.randomPrivateKey,
                        lift_x: G,
                        pointToBytes: F,
                        numberToBytesBE: a.tL,
                        bytesToNumberBE: a.bytesToNumberBE,
                        taggedHash: B,
                        mod: s.wQ
                    }
                }, Y = function (e, t) {
                    const n = t.map((e => Array.from(e).reverse()));
                    return (t, r) => {
                        const [i, s, a, o] = n.map((n => n.reduce(((n, r) => e.add(e.mul(n, t), r)))));
                        return t = e.div(i, s), r = e.mul(r, e.div(a, o)), {x: t, y: r}
                    }
                }(j, [["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"], ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"], ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"], ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]].map((e => e.map((e => BigInt(e)))))),
                Z = function (e, t) {
                    if (s.OP(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
                    const n = function (e, t) {
                        const n = e.ORDER;
                        let r = f;
                        for (let e = n - p; e % m === f; e /= m) r += p;
                        const i = r, s = (n - p) / m ** i, a = (s - p) / m, o = m ** i - p, l = m ** (i - p),
                            c = e.pow(t, s), u = e.pow(t, (s + p) / m);
                        let d = (t, n) => {
                            let r = c, s = e.pow(n, o), d = e.sqr(s);
                            d = e.mul(d, n);
                            let h = e.mul(t, d);
                            h = e.pow(h, a), h = e.mul(h, s), s = e.mul(h, n), d = e.mul(h, t);
                            let f = e.mul(d, s);
                            h = e.pow(f, l);
                            let g = e.eql(h, e.ONE);
                            s = e.mul(d, u), h = e.mul(f, r), d = e.cmov(s, d, g), f = e.cmov(h, f, g);
                            for (let t = i; t > p; t--) {
                                let n = m ** (t - m), i = e.pow(f, n);
                                const a = e.eql(i, e.ONE);
                                s = e.mul(d, r), r = e.mul(r, r), i = e.mul(f, r), d = e.cmov(s, d, a), f = e.cmov(i, f, a)
                            }
                            return {isValid: g, value: d}
                        };
                        if (e.ORDER % y === g) {
                            const n = (e.ORDER - g) / y, r = e.sqrt(e.neg(t));
                            d = (t, i) => {
                                let s = e.sqr(i);
                                const a = e.mul(t, i);
                                s = e.mul(s, a);
                                let o = e.pow(s, n);
                                o = e.mul(o, a);
                                const l = e.mul(o, r), c = e.mul(e.sqr(o), i), u = e.eql(c, t);
                                return {isValid: u, value: e.cmov(l, o, u)}
                            }
                        }
                        return d
                    }(e, t.Z);
                    if (!e.isOdd) throw new Error("Fp.isOdd is not implemented!");
                    return r => {
                        let i, s, a, o, l, c, u, d;
                        i = e.sqr(r), i = e.mul(i, t.Z), s = e.sqr(i), s = e.add(s, i), a = e.add(s, e.ONE), a = e.mul(a, t.B), o = e.cmov(t.Z, e.neg(s), !e.eql(s, e.ZERO)), o = e.mul(o, t.A), s = e.sqr(a), c = e.sqr(o), l = e.mul(c, t.A), s = e.add(s, l), s = e.mul(s, a), c = e.mul(c, o), l = e.mul(c, t.B), s = e.add(s, l), u = e.mul(i, a);
                        const {isValid: h, value: f} = n(s, c);
                        d = e.mul(i, r), d = e.mul(d, f), u = e.cmov(u, a, h), d = e.cmov(d, f, h);
                        const p = e.isOdd(r) === e.isOdd(d);
                        return d = e.cmov(e.neg(d), d, p), u = e.div(u, o), {x: u, y: d}
                    }
                }(j, {
                    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
                    B: BigInt("1771"),
                    Z: j.create(BigInt("-11"))
                }), {hashToCurve: X, encodeToCurve: Q} = function (e, t, n) {
                    return {
                        hashToCurve(r, i) {
                            const s = k(r, 2, {...n, DST: n.DST, ...i}), a = e.fromAffine(t(s[0])),
                                o = e.fromAffine(t(s[1])), l = a.add(o).clearCofactor();
                            return l.assertValidity(), l
                        }, encodeToCurve(r, i) {
                            const s = k(r, 1, {...n, DST: n.encodeDST, ...i}), a = e.fromAffine(t(s[0])).clearCofactor();
                            return a.assertValidity(), a
                        }
                    }
                }(I.ProjectivePoint, (e => {
                    const {x: t, y: n} = Z(j.create(e[0]));
                    return Y(t, n)
                }), {
                    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
                    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
                    p: j.ORDER,
                    m: 1,
                    k: 128,
                    expand: "xmd",
                    hash: r.J
                })
        }, 9629: (e, t, n) => {
            "use strict";

            function r(e) {
                if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`)
            }

            function i(e, ...t) {
                if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
                if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`)
            }

            n.d(t, {ZP: () => s, aI: () => i});
            const s = {
                number: r, bool: function (e) {
                    if ("boolean" != typeof e) throw new Error(`Expected boolean, not ${e}`)
                }, bytes: i, hash: function (e) {
                    if ("function" != typeof e || "function" != typeof e.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
                    r(e.outputLen), r(e.blockLen)
                }, exists: function (e, t = !0) {
                    if (e.destroyed) throw new Error("Hash instance has been destroyed");
                    if (t && e.finished) throw new Error("Hash#digest() has already been called")
                }, output: function (e, t) {
                    i(e);
                    const n = t.outputLen;
                    if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`)
                }
            }
        }, 5088: (e, t, n) => {
            "use strict";
            n.d(t, {N: () => s});
            var r = n(9629), i = n(4658);

            class s extends i.kb {
                constructor(e, t, n, r) {
                    super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, i.GL)(this.buffer)
                }

                update(e) {
                    r.ZP.exists(this);
                    const {view: t, buffer: n, blockLen: s} = this, a = (e = (0, i.O0)(e)).length;
                    for (let r = 0; r < a;) {
                        const o = Math.min(s - this.pos, a - r);
                        if (o !== s) n.set(e.subarray(r, r + o), this.pos), this.pos += o, r += o, this.pos === s && (this.process(t, 0), this.pos = 0); else {
                            const t = (0, i.GL)(e);
                            for (; s <= a - r; r += s) this.process(t, r)
                        }
                    }
                    return this.length += e.length, this.roundClean(), this
                }

                digestInto(e) {
                    r.ZP.exists(this), r.ZP.output(e, this), this.finished = !0;
                    const {buffer: t, view: n, blockLen: s, isLE: a} = this;
                    let {pos: o} = this;
                    t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(n, 0), o = 0);
                    for (let e = o; e < s; e++) t[e] = 0;
                    !function (e, t, n, r) {
                        if ("function" == typeof e.setBigUint64) return e.setBigUint64(t, n, r);
                        const i = BigInt(32), s = BigInt(4294967295), a = Number(n >> i & s), o = Number(n & s),
                            l = r ? 4 : 0, c = r ? 0 : 4;
                        e.setUint32(t + l, a, r), e.setUint32(t + c, o, r)
                    }(n, s - 8, BigInt(8 * this.length), a), this.process(n, 0);
                    const l = (0, i.GL)(e), c = this.outputLen;
                    if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
                    const u = c / 4, d = this.get();
                    if (u > d.length) throw new Error("_sha2: outputLen bigger than state");
                    for (let e = 0; e < u; e++) l.setUint32(4 * e, d[e], a)
                }

                digest() {
                    const {buffer: e, outputLen: t} = this;
                    this.digestInto(e);
                    const n = e.slice(0, t);
                    return this.destroy(), n
                }

                _cloneInto(e) {
                    e || (e = new this.constructor), e.set(...this.get());
                    const {blockLen: t, buffer: n, length: r, finished: i, destroyed: s, pos: a} = this;
                    return e.length = r, e.pos = a, e.finished = i, e.destroyed = s, r % t && e.buffer.set(n), e
                }
            }
        }, 846: (e, t, n) => {
            "use strict";
            n.d(t, {b: () => a});
            var r = n(9629), i = n(4658);

            class s extends i.kb {
                constructor(e, t) {
                    super(), this.finished = !1, this.destroyed = !1, r.ZP.hash(e);
                    const n = (0, i.O0)(t);
                    if (this.iHash = e.create(), "function" != typeof this.iHash.update) throw new TypeError("Expected instance of class which extends utils.Hash");
                    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
                    const s = this.blockLen, a = new Uint8Array(s);
                    a.set(n.length > s ? e.create().update(n).digest() : n);
                    for (let e = 0; e < a.length; e++) a[e] ^= 54;
                    this.iHash.update(a), this.oHash = e.create();
                    for (let e = 0; e < a.length; e++) a[e] ^= 106;
                    this.oHash.update(a), a.fill(0)
                }

                update(e) {
                    return r.ZP.exists(this), this.iHash.update(e), this
                }

                digestInto(e) {
                    r.ZP.exists(this), r.ZP.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy()
                }

                digest() {
                    const e = new Uint8Array(this.oHash.outputLen);
                    return this.digestInto(e), e
                }

                _cloneInto(e) {
                    e || (e = Object.create(Object.getPrototypeOf(this), {}));
                    const {oHash: t, iHash: n, finished: r, destroyed: i, blockLen: s, outputLen: a} = this;
                    return e.finished = r, e.destroyed = i, e.blockLen = s, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e
                }

                destroy() {
                    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
                }
            }

            const a = (e, t, n) => new s(e, t).update(n).digest();
            a.create = (e, t) => new s(e, t)
        }, 3929: (e, t, n) => {
            "use strict";
            n.d(t, {J: () => d});
            var r = n(5088), i = n(4658);
            const s = (e, t, n) => e & t ^ e & n ^ t & n,
                a = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
                o = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
                l = new Uint32Array(64);

            class c extends r.N {
                constructor() {
                    super(64, 32, 8, !1), this.A = 0 | o[0], this.B = 0 | o[1], this.C = 0 | o[2], this.D = 0 | o[3], this.E = 0 | o[4], this.F = 0 | o[5], this.G = 0 | o[6], this.H = 0 | o[7]
                }

                get() {
                    const {A: e, B: t, C: n, D: r, E: i, F: s, G: a, H: o} = this;
                    return [e, t, n, r, i, s, a, o]
                }

                set(e, t, n, r, i, s, a, o) {
                    this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | s, this.G = 0 | a, this.H = 0 | o
                }

                process(e, t) {
                    for (let n = 0; n < 16; n++, t += 4) l[n] = e.getUint32(t, !1);
                    for (let e = 16; e < 64; e++) {
                        const t = l[e - 15], n = l[e - 2], r = (0, i.np)(t, 7) ^ (0, i.np)(t, 18) ^ t >>> 3,
                            s = (0, i.np)(n, 17) ^ (0, i.np)(n, 19) ^ n >>> 10;
                        l[e] = s + l[e - 7] + r + l[e - 16] | 0
                    }
                    let {A: n, B: r, C: o, D: c, E: u, F: d, G: h, H: f} = this;
                    for (let e = 0; e < 64; e++) {
                        const t = f + ((0, i.np)(u, 6) ^ (0, i.np)(u, 11) ^ (0, i.np)(u, 25)) + ((p = u) & d ^ ~p & h) + a[e] + l[e] | 0,
                            m = ((0, i.np)(n, 2) ^ (0, i.np)(n, 13) ^ (0, i.np)(n, 22)) + s(n, r, o) | 0;
                        f = h, h = d, d = u, u = c + t | 0, c = o, o = r, r = n, n = t + m | 0
                    }
                    var p;
                    n = n + this.A | 0, r = r + this.B | 0, o = o + this.C | 0, c = c + this.D | 0, u = u + this.E | 0, d = d + this.F | 0, h = h + this.G | 0, f = f + this.H | 0, this.set(n, r, o, c, u, d, h, f)
                }

                roundClean() {
                    l.fill(0)
                }

                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
                }
            }

            class u extends c {
                constructor() {
                    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28
                }
            }

            const d = (0, i.hE)((() => new c));
            (0, i.hE)((() => new u))
        }, 4658: (e, t, n) => {
            "use strict";
            n.d(t, {
                kb: () => h,
                ci: () => o,
                eV: () => d,
                GL: () => i,
                nr: () => l,
                O6: () => p,
                np: () => s,
                O0: () => u,
                iY: () => c,
                hE: () => f
            });
            const r = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0,
                i = e => new DataView(e.buffer, e.byteOffset, e.byteLength), s = (e, t) => e << 32 - t | e >>> t;
            if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0]) throw new Error("Non little-endian hardware is not supported");
            const a = Array.from({length: 256}, ((e, t) => t.toString(16).padStart(2, "0")));

            function o(e) {
                if (!(e instanceof Uint8Array)) throw new Error("Uint8Array expected");
                let t = "";
                for (let n = 0; n < e.length; n++) t += a[e[n]];
                return t
            }

            function l(e) {
                if ("string" != typeof e) throw new TypeError("hexToBytes: expected string, got " + typeof e);
                if (e.length % 2) throw new Error("hexToBytes: received invalid unpadded hex");
                const t = new Uint8Array(e.length / 2);
                for (let n = 0; n < t.length; n++) {
                    const r = 2 * n, i = e.slice(r, r + 2), s = Number.parseInt(i, 16);
                    if (Number.isNaN(s) || s < 0) throw new Error("Invalid byte sequence");
                    t[n] = s
                }
                return t
            }

            function c(e) {
                if ("string" != typeof e) throw new TypeError("utf8ToBytes expected string, got " + typeof e);
                return (new TextEncoder).encode(e)
            }

            function u(e) {
                if ("string" == typeof e && (e = c(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
                return e
            }

            function d(...e) {
                if (!e.every((e => e instanceof Uint8Array))) throw new Error("Uint8Array list expected");
                if (1 === e.length) return e[0];
                const t = e.reduce(((e, t) => e + t.length), 0), n = new Uint8Array(t);
                for (let t = 0, r = 0; t < e.length; t++) {
                    const i = e[t];
                    n.set(i, r), r += i.length
                }
                return n
            }

            class h {
                clone() {
                    return this._cloneInto()
                }
            }

            function f(e) {
                const t = t => e().update(u(t)).digest(), n = e();
                return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t
            }

            function p(e = 32) {
                if (r && "function" == typeof r.getRandomValues) return r.getRandomValues(new Uint8Array(e));
                throw new Error("crypto.getRandomValues must be defined")
            }
        }, 5253: (e, t, n) => {
            "use strict";

            function r(e) {
                if (!Number.isSafeInteger(e)) throw new Error(`Wrong integer: ${e}`)
            }

            function i(...e) {
                const t = (e, t) => n => e(t(n));
                return {
                    encode: Array.from(e).reverse().reduce(((e, n) => e ? t(e, n.encode) : n.encode), void 0),
                    decode: e.reduce(((e, n) => e ? t(e, n.decode) : n.decode), void 0)
                }
            }

            function s(e) {
                return {
                    encode: t => {
                        if (!Array.isArray(t) || t.length && "number" != typeof t[0]) throw new Error("alphabet.encode input should be an array of numbers");
                        return t.map((t => {
                            if (r(t), t < 0 || t >= e.length) throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${e.length})`);
                            return e[t]
                        }))
                    }, decode: t => {
                        if (!Array.isArray(t) || t.length && "string" != typeof t[0]) throw new Error("alphabet.decode input should be array of strings");
                        return t.map((t => {
                            if ("string" != typeof t) throw new Error(`alphabet.decode: not string element=${t}`);
                            const n = e.indexOf(t);
                            if (-1 === n) throw new Error(`Unknown letter: "${t}". Allowed: ${e}`);
                            return n
                        }))
                    }
                }
            }

            function a(e = "") {
                if ("string" != typeof e) throw new Error("join separator should be string");
                return {
                    encode: t => {
                        if (!Array.isArray(t) || t.length && "string" != typeof t[0]) throw new Error("join.encode input should be array of strings");
                        for (let e of t) if ("string" != typeof e) throw new Error(`join.encode: non-string input=${e}`);
                        return t.join(e)
                    }, decode: t => {
                        if ("string" != typeof t) throw new Error("join.decode input should be string");
                        return t.split(e)
                    }
                }
            }

            function o(e, t = "=") {
                if (r(e), "string" != typeof t) throw new Error("padding chr should be string");
                return {
                    encode(n) {
                        if (!Array.isArray(n) || n.length && "string" != typeof n[0]) throw new Error("padding.encode input should be array of strings");
                        for (let e of n) if ("string" != typeof e) throw new Error(`padding.encode: non-string input=${e}`);
                        for (; n.length * e % 8;) n.push(t);
                        return n
                    }, decode(n) {
                        if (!Array.isArray(n) || n.length && "string" != typeof n[0]) throw new Error("padding.encode input should be array of strings");
                        for (let e of n) if ("string" != typeof e) throw new Error(`padding.decode: non-string input=${e}`);
                        let r = n.length;
                        if (r * e % 8) throw new Error("Invalid padding: string should have whole number of bytes");
                        for (; r > 0 && n[r - 1] === t; r--) if (!((r - 1) * e % 8)) throw new Error("Invalid padding: string has too much padding");
                        return n.slice(0, r)
                    }
                }
            }

            function l(e) {
                if ("function" != typeof e) throw new Error("normalize fn should be function");
                return {encode: e => e, decode: t => e(t)}
            }

            function c(e, t, n) {
                if (t < 2) throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
                if (n < 2) throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);
                if (!Array.isArray(e)) throw new Error("convertRadix: data should be array");
                if (!e.length) return [];
                let i = 0;
                const s = [], a = Array.from(e);
                for (a.forEach((e => {
                    if (r(e), e < 0 || e >= t) throw new Error(`Wrong integer: ${e}`)
                })); ;) {
                    let e = 0, r = !0;
                    for (let s = i; s < a.length; s++) {
                        const o = a[s], l = t * e + o;
                        if (!Number.isSafeInteger(l) || t * e / t !== e || l - o != t * e) throw new Error("convertRadix: carry overflow");
                        if (e = l % n, a[s] = Math.floor(l / n), !Number.isSafeInteger(a[s]) || a[s] * n + e !== l) throw new Error("convertRadix: carry overflow");
                        r && (a[s] ? r = !1 : i = s)
                    }
                    if (s.push(e), r) break
                }
                for (let t = 0; t < e.length - 1 && 0 === e[t]; t++) s.push(0);
                return s.reverse()
            }

            n.d(t, {Av: () => k, US: () => v, eV: () => y, gW: () => _});
            const u = (e, t) => t ? u(t, e % t) : e, d = (e, t) => e + (t - u(e, t));

            function h(e, t, n, i) {
                if (!Array.isArray(e)) throw new Error("convertRadix2: data should be array");
                if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong from=${t}`);
                if (n <= 0 || n > 32) throw new Error(`convertRadix2: wrong to=${n}`);
                if (d(t, n) > 32) throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${d(t, n)}`);
                let s = 0, a = 0;
                const o = 2 ** n - 1, l = [];
                for (const i of e) {
                    if (r(i), i >= 2 ** t) throw new Error(`convertRadix2: invalid data word=${i} from=${t}`);
                    if (s = s << t | i, a + t > 32) throw new Error(`convertRadix2: carry overflow pos=${a} from=${t}`);
                    for (a += t; a >= n; a -= n) l.push((s >> a - n & o) >>> 0);
                    s &= 2 ** a - 1
                }
                if (s = s << n - a & o, !i && a >= t) throw new Error("Excess padding");
                if (!i && s) throw new Error(`Non-zero padding: ${s}`);
                return i && a > 0 && l.push(s >>> 0), l
            }

            function f(e, t = !1) {
                if (r(e), e <= 0 || e > 32) throw new Error("radix2: bits should be in (0..32]");
                if (d(8, e) > 32 || d(e, 8) > 32) throw new Error("radix2: carry overflow");
                return {
                    encode: n => {
                        if (!(n instanceof Uint8Array)) throw new Error("radix2.encode input should be Uint8Array");
                        return h(Array.from(n), 8, e, !t)
                    }, decode: n => {
                        if (!Array.isArray(n) || n.length && "number" != typeof n[0]) throw new Error("radix2.decode input should be array of strings");
                        return Uint8Array.from(h(n, e, 8, t))
                    }
                }
            }

            function p(e) {
                if ("function" != typeof e) throw new Error("unsafeWrapper fn should be function");
                return function (...t) {
                    try {
                        return e.apply(null, t)
                    } catch (e) {
                    }
                }
            }

            const m = i(f(4), s("0123456789ABCDEF"), a("")),
                g = i(f(5), s("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), o(5), a("")),
                y = i(f(5), s("0123456789ABCDEFGHIJKLMNOPQRSTUV"), o(5), a("")),
                v = (i(f(5), s("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), a(""), l((e => e.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")))), i(f(6), s("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), o(6), a(""))),
                b = i(f(6), s("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), o(6), a("")),
                w = e => {
                    return i((r(t = 58), {
                        encode: e => {
                            if (!(e instanceof Uint8Array)) throw new Error("radix.encode input should be Uint8Array");
                            return c(Array.from(e), 256, t)
                        }, decode: e => {
                            if (!Array.isArray(e) || e.length && "number" != typeof e[0]) throw new Error("radix.decode input should be array of strings");
                            return Uint8Array.from(c(e, t, 256))
                        }
                    }), s(e), a(""));
                    var t
                }, x = w("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
                E = (w("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), w("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"), [0, 2, 3, 5, 6, 7, 9, 10, 11]),
                S = {
                    encode(e) {
                        let t = "";
                        for (let n = 0; n < e.length; n += 8) {
                            const r = e.subarray(n, n + 8);
                            t += x.encode(r).padStart(E[r.length], "1")
                        }
                        return t
                    }, decode(e) {
                        let t = [];
                        for (let n = 0; n < e.length; n += 11) {
                            const r = e.slice(n, n + 11), i = E.indexOf(r.length), s = x.decode(r);
                            for (let e = 0; e < s.length - i; e++) if (0 !== s[e]) throw new Error("base58xmr: wrong padding");
                            t = t.concat(Array.from(s.slice(s.length - i)))
                        }
                        return Uint8Array.from(t)
                    }
                }, k = e => i(function (e, t) {
                    if (r(e), "function" != typeof t) throw new Error("checksum fn should be function");
                    return {
                        encode(n) {
                            if (!(n instanceof Uint8Array)) throw new Error("checksum.encode: input should be Uint8Array");
                            const r = t(n).slice(0, e), i = new Uint8Array(n.length + e);
                            return i.set(n), i.set(r, n.length), i
                        }, decode(n) {
                            if (!(n instanceof Uint8Array)) throw new Error("checksum.decode: input should be Uint8Array");
                            const r = n.slice(0, -e), i = t(r).slice(0, e), s = n.slice(-e);
                            for (let t = 0; t < e; t++) if (i[t] !== s[t]) throw new Error("Invalid checksum");
                            return r
                        }
                    }
                }(4, (t => e(e(t)))), x), A = i(s("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), a("")),
                T = [996825010, 642813549, 513874426, 1027748829, 705979059];

            function C(e) {
                const t = e >> 25;
                let n = (33554431 & e) << 5;
                for (let e = 0; e < T.length; e++) 1 == (t >> e & 1) && (n ^= T[e]);
                return n
            }

            function R(e, t, n = 1) {
                const r = e.length;
                let i = 1;
                for (let t = 0; t < r; t++) {
                    const n = e.charCodeAt(t);
                    if (n < 33 || n > 126) throw new Error(`Invalid prefix (${e})`);
                    i = C(i) ^ n >> 5
                }
                i = C(i);
                for (let t = 0; t < r; t++) i = C(i) ^ 31 & e.charCodeAt(t);
                for (let e of t) i = C(i) ^ e;
                for (let e = 0; e < 6; e++) i = C(i);
                return i ^= n, A.encode(h([i % 2 ** 30], 30, 5, !1))
            }

            function L(e) {
                const t = "bech32" === e ? 1 : 734539939, n = f(5), r = n.decode, i = n.encode, s = p(r);

                function a(e, n = 90) {
                    if ("string" != typeof e) throw new Error("bech32.decode input should be string, not " + typeof e);
                    if (e.length < 8 || !1 !== n && e.length > n) throw new TypeError(`Wrong string length: ${e.length} (${e}). Expected (8..${n})`);
                    const r = e.toLowerCase();
                    if (e !== r && e !== e.toUpperCase()) throw new Error("String must be lowercase or uppercase");
                    const i = (e = r).lastIndexOf("1");
                    if (0 === i || -1 === i) throw new Error('Letter "1" must be present between prefix and data only');
                    const s = e.slice(0, i), a = e.slice(i + 1);
                    if (a.length < 6) throw new Error("Data must be at least 6 characters long");
                    const o = A.decode(a).slice(0, -6), l = R(s, o, t);
                    if (!a.endsWith(l)) throw new Error(`Invalid checksum in ${e}: expected "${l}"`);
                    return {prefix: s, words: o}
                }

                return {
                    encode: function (e, n, r = 90) {
                        if ("string" != typeof e) throw new Error("bech32.encode prefix should be string, not " + typeof e);
                        if (!Array.isArray(n) || n.length && "number" != typeof n[0]) throw new Error("bech32.encode words should be array of numbers, not " + typeof n);
                        const i = e.length + 7 + n.length;
                        if (!1 !== r && i > r) throw new TypeError(`Length ${i} exceeds limit ${r}`);
                        return `${e = e.toLowerCase()}1${A.encode(n)}${R(e, n, t)}`
                    }, decode: a, decodeToBytes: function (e) {
                        const {prefix: t, words: n} = a(e, !1);
                        return {prefix: t, words: n, bytes: r(n)}
                    }, decodeUnsafe: p(a), fromWords: r, fromWordsUnsafe: s, toWords: i
                }
            }

            const _ = L("bech32"), P = {
                utf8: (L("bech32m"), {
                    encode: e => (new TextDecoder).decode(e),
                    decode: e => (new TextEncoder).encode(e)
                }), hex: i(f(4), s("0123456789abcdef"), a(""), l((e => {
                    if ("string" != typeof e || e.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);
                    return e.toLowerCase()
                }))), base16: m, base32: g, base64: v, base64url: b, base58: x, base58xmr: S
            };
            Object.keys(P).join(", ")
        }, 9085: (e, t, n) => {
            "use strict";
            n.r(t), n.d(t, {
                Dexie: () => Jn,
                RangeSet: () => Gn,
                default: () => Jn,
                liveQuery: () => rr,
                mergeRanges: () => Wn,
                rangesOverlap: () => Vn
            });
            const r = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global,
                i = Object.keys, s = Array.isArray;

            function a(e, t) {
                return "object" != typeof t || i(t).forEach((function (n) {
                    e[n] = t[n]
                })), e
            }

            "undefined" == typeof Promise || r.Promise || (r.Promise = Promise);
            const o = Object.getPrototypeOf, l = {}.hasOwnProperty;

            function c(e, t) {
                return l.call(e, t)
            }

            function u(e, t) {
                "function" == typeof t && (t = t(o(e))), ("undefined" == typeof Reflect ? i : Reflect.ownKeys)(t).forEach((n => {
                    h(e, n, t[n])
                }))
            }

            const d = Object.defineProperty;

            function h(e, t, n, r) {
                d(e, t, a(n && c(n, "get") && "function" == typeof n.get ? {
                    get: n.get,
                    set: n.set,
                    configurable: !0
                } : {value: n, configurable: !0, writable: !0}, r))
            }

            function f(e) {
                return {
                    from: function (t) {
                        return e.prototype = Object.create(t.prototype), h(e.prototype, "constructor", e), {extend: u.bind(null, e.prototype)}
                    }
                }
            }

            const p = Object.getOwnPropertyDescriptor;

            function m(e, t) {
                let n;
                return p(e, t) || (n = o(e)) && m(n, t)
            }

            const g = [].slice;

            function y(e, t, n) {
                return g.call(e, t, n)
            }

            function v(e, t) {
                return t(e)
            }

            function b(e) {
                if (!e) throw new Error("Assertion Failed")
            }

            function w(e) {
                r.setImmediate ? setImmediate(e) : setTimeout(e, 0)
            }

            function x(e, t) {
                return e.reduce(((e, n, r) => {
                    var i = t(n, r);
                    return i && (e[i[0]] = i[1]), e
                }), {})
            }

            function E(e, t) {
                if (c(e, t)) return e[t];
                if (!t) return e;
                if ("string" != typeof t) {
                    for (var n = [], r = 0, i = t.length; r < i; ++r) {
                        var s = E(e, t[r]);
                        n.push(s)
                    }
                    return n
                }
                var a = t.indexOf(".");
                if (-1 !== a) {
                    var o = e[t.substr(0, a)];
                    return void 0 === o ? void 0 : E(o, t.substr(a + 1))
                }
            }

            function S(e, t, n) {
                if (e && void 0 !== t && (!("isFrozen" in Object) || !Object.isFrozen(e))) if ("string" != typeof t && "length" in t) {
                    b("string" != typeof n && "length" in n);
                    for (var r = 0, i = t.length; r < i; ++r) S(e, t[r], n[r])
                } else {
                    var a = t.indexOf(".");
                    if (-1 !== a) {
                        var o = t.substr(0, a), l = t.substr(a + 1);
                        if ("" === l) void 0 === n ? s(e) && !isNaN(parseInt(o)) ? e.splice(o, 1) : delete e[o] : e[o] = n; else {
                            var u = e[o];
                            u && c(e, o) || (u = e[o] = {}), S(u, l, n)
                        }
                    } else void 0 === n ? s(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = n
                }
            }

            function k(e) {
                var t = {};
                for (var n in e) c(e, n) && (t[n] = e[n]);
                return t
            }

            const A = [].concat;

            function T(e) {
                return A.apply([], e)
            }

            const C = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(T([8, 16, 32, 64].map((e => ["Int", "Uint", "Float"].map((t => t + e + "Array")))))).filter((e => r[e])),
                R = C.map((e => r[e]));
            x(C, (e => [e, !0]));
            let L = null;

            function _(e) {
                L = "undefined" != typeof WeakMap && new WeakMap;
                const t = P(e);
                return L = null, t
            }

            function P(e) {
                if (!e || "object" != typeof e) return e;
                let t = L && L.get(e);
                if (t) return t;
                if (s(e)) {
                    t = [], L && L.set(e, t);
                    for (var n = 0, r = e.length; n < r; ++n) t.push(P(e[n]))
                } else if (R.indexOf(e.constructor) >= 0) t = e; else {
                    const n = o(e);
                    for (var i in t = n === Object.prototype ? {} : Object.create(n), L && L.set(e, t), e) c(e, i) && (t[i] = P(e[i]))
                }
                return t
            }

            const {toString: N} = {};

            function j(e) {
                return N.call(e).slice(8, -1)
            }

            const I = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator",
                M = "symbol" == typeof I ? function (e) {
                    var t;
                    return null != e && (t = e[I]) && t.apply(e)
                } : function () {
                    return null
                }, D = {};

            function O(e) {
                var t, n, r, i;
                if (1 === arguments.length) {
                    if (s(e)) return e.slice();
                    if (this === D && "string" == typeof e) return [e];
                    if (i = M(e)) {
                        for (n = []; !(r = i.next()).done;) n.push(r.value);
                        return n
                    }
                    if (null == e) return [e];
                    if ("number" == typeof (t = e.length)) {
                        for (n = new Array(t); t--;) n[t] = e[t];
                        return n
                    }
                    return [e]
                }
                for (t = arguments.length, n = new Array(t); t--;) n[t] = arguments[t];
                return n
            }

            const B = "undefined" != typeof Symbol ? e => "AsyncFunction" === e[Symbol.toStringTag] : () => !1;
            var F = "undefined" != typeof location && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);

            function U(e, t) {
                F = e, H = t
            }

            var H = () => !0;
            const $ = !new Error("").stack;

            function K() {
                if ($) try {
                    throw K.arguments, new Error
                } catch (e) {
                    return e
                }
                return new Error
            }

            function z(e, t) {
                var n = e.stack;
                return n ? (t = t || 0, 0 === n.indexOf(e.name) && (t += (e.name + e.message).split("\n").length), n.split("\n").slice(t).filter(H).map((e => "\n" + e)).join("")) : ""
            }

            var G = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"],
                q = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(G),
                W = {
                    VersionChanged: "Database version changed by other database connection",
                    DatabaseClosed: "Database has been closed",
                    Abort: "Transaction aborted",
                    TransactionInactive: "Transaction has already completed or failed",
                    MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
                };

            function V(e, t) {
                this._e = K(), this.name = e, this.message = t
            }

            function Y(e, t) {
                return e + ". Errors: " + Object.keys(t).map((e => t[e].toString())).filter(((e, t, n) => n.indexOf(e) === t)).join("\n")
            }

            function Z(e, t, n, r) {
                this._e = K(), this.failures = t, this.failedKeys = r, this.successCount = n, this.message = Y(e, t)
            }

            function X(e, t) {
                this._e = K(), this.name = "BulkError", this.failures = Object.keys(t).map((e => t[e])), this.failuresByPos = t, this.message = Y(e, t)
            }

            f(V).from(Error).extend({
                stack: {
                    get: function () {
                        return this._stack || (this._stack = this.name + ": " + this.message + z(this._e, 2))
                    }
                }, toString: function () {
                    return this.name + ": " + this.message
                }
            }), f(Z).from(V), f(X).from(V);
            var Q = q.reduce(((e, t) => (e[t] = t + "Error", e)), {});
            const J = V;
            var ee = q.reduce(((e, t) => {
                var n = t + "Error";

                function r(e, r) {
                    this._e = K(), this.name = n, e ? "string" == typeof e ? (this.message = `${e}${r ? "\n " + r : ""}`, this.inner = r || null) : "object" == typeof e && (this.message = `${e.name} ${e.message}`, this.inner = e) : (this.message = W[t] || n, this.inner = null)
                }

                return f(r).from(J), e[t] = r, e
            }), {});
            ee.Syntax = SyntaxError, ee.Type = TypeError, ee.Range = RangeError;
            var te = G.reduce(((e, t) => (e[t + "Error"] = ee[t], e)), {}),
                ne = q.reduce(((e, t) => (-1 === ["Syntax", "Type", "Range"].indexOf(t) && (e[t + "Error"] = ee[t]), e)), {});

            function re() {
            }

            function ie(e) {
                return e
            }

            function se(e, t) {
                return null == e || e === ie ? t : function (n) {
                    return t(e(n))
                }
            }

            function ae(e, t) {
                return function () {
                    e.apply(this, arguments), t.apply(this, arguments)
                }
            }

            function oe(e, t) {
                return e === re ? t : function () {
                    var n = e.apply(this, arguments);
                    void 0 !== n && (arguments[0] = n);
                    var r = this.onsuccess, i = this.onerror;
                    this.onsuccess = null, this.onerror = null;
                    var s = t.apply(this, arguments);
                    return r && (this.onsuccess = this.onsuccess ? ae(r, this.onsuccess) : r), i && (this.onerror = this.onerror ? ae(i, this.onerror) : i), void 0 !== s ? s : n
                }
            }

            function le(e, t) {
                return e === re ? t : function () {
                    e.apply(this, arguments);
                    var n = this.onsuccess, r = this.onerror;
                    this.onsuccess = this.onerror = null, t.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? ae(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? ae(r, this.onerror) : r)
                }
            }

            function ce(e, t) {
                return e === re ? t : function (n) {
                    var r = e.apply(this, arguments);
                    a(n, r);
                    var i = this.onsuccess, s = this.onerror;
                    this.onsuccess = null, this.onerror = null;
                    var o = t.apply(this, arguments);
                    return i && (this.onsuccess = this.onsuccess ? ae(i, this.onsuccess) : i), s && (this.onerror = this.onerror ? ae(s, this.onerror) : s), void 0 === r ? void 0 === o ? void 0 : o : a(r, o)
                }
            }

            function ue(e, t) {
                return e === re ? t : function () {
                    return !1 !== t.apply(this, arguments) && e.apply(this, arguments)
                }
            }

            function de(e, t) {
                return e === re ? t : function () {
                    var n = e.apply(this, arguments);
                    if (n && "function" == typeof n.then) {
                        for (var r = this, i = arguments.length, s = new Array(i); i--;) s[i] = arguments[i];
                        return n.then((function () {
                            return t.apply(r, s)
                        }))
                    }
                    return t.apply(this, arguments)
                }
            }

            ne.ModifyError = Z, ne.DexieError = V, ne.BulkError = X;
            var he = {};
            const fe = 100, [pe, me, ge] = "undefined" == typeof Promise ? [] : (() => {
                let e = Promise.resolve();
                if ("undefined" == typeof crypto || !crypto.subtle) return [e, o(e), e];
                const t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
                return [t, o(t), e]
            })(), ye = me && me.then, ve = pe && pe.constructor, be = !!ge;
            var we = !1, xe = ge ? () => {
                ge.then(ze)
            } : r.setImmediate ? setImmediate.bind(null, ze) : r.MutationObserver ? () => {
                var e = document.createElement("div");
                new MutationObserver((() => {
                    ze(), e = null
                })).observe(e, {attributes: !0}), e.setAttribute("i", "1")
            } : () => {
                setTimeout(ze, 0)
            }, Ee = function (e, t) {
                Pe.push([e, t]), ke && (xe(), ke = !1)
            }, Se = !0, ke = !0, Ae = [], Te = [], Ce = null, Re = ie, Le = {
                id: "global",
                global: !0,
                ref: 0,
                unhandleds: [],
                onunhandled: mt,
                pgp: !1,
                env: {},
                finalize: function () {
                    this.unhandleds.forEach((e => {
                        try {
                            mt(e[0], e[1])
                        } catch (e) {
                        }
                    }))
                }
            }, _e = Le, Pe = [], Ne = 0, je = [];

            function Ie(e) {
                if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
                this._listeners = [], this.onuncatched = re, this._lib = !1;
                var t = this._PSD = _e;
                if (F && (this._stackHolder = K(), this._prev = null, this._numPrev = 0), "function" != typeof e) {
                    if (e !== he) throw new TypeError("Not a function");
                    return this._state = arguments[1], this._value = arguments[2], void (!1 === this._state && Be(this, this._value))
                }
                this._state = null, this._value = null, ++t.ref, Oe(this, e)
            }

            const Me = {
                get: function () {
                    var e = _e, t = et;

                    function n(n, r) {
                        var i = !e.global && (e !== _e || t !== et);
                        const s = i && !it();
                        var a = new Ie(((t, a) => {
                            Ue(this, new De(ht(n, e, i, s), ht(r, e, i, s), t, a, e))
                        }));
                        return F && Ke(a, this), a
                    }

                    return n.prototype = he, n
                }, set: function (e) {
                    h(this, "then", e && e.prototype === he ? Me : {
                        get: function () {
                            return e
                        }, set: Me.set
                    })
                }
            };

            function De(e, t, n, r, i) {
                this.onFulfilled = "function" == typeof e ? e : null, this.onRejected = "function" == typeof t ? t : null, this.resolve = n, this.reject = r, this.psd = i
            }

            function Oe(e, t) {
                try {
                    t((t => {
                        if (null === e._state) {
                            if (t === e) throw new TypeError("A promise cannot be resolved with itself.");
                            var n = e._lib && Ge();
                            t && "function" == typeof t.then ? Oe(e, ((e, n) => {
                                t instanceof Ie ? t._then(e, n) : t.then(e, n)
                            })) : (e._state = !0, e._value = t, Fe(e)), n && qe()
                        }
                    }), Be.bind(null, e))
                } catch (t) {
                    Be(e, t)
                }
            }

            function Be(e, t) {
                if (Te.push(t), null === e._state) {
                    var n = e._lib && Ge();
                    t = Re(t), e._state = !1, e._value = t, F && null !== t && "object" == typeof t && !t._promise && function (e, t, n) {
                        try {
                            e.apply(null, void 0)
                        } catch (e) {
                        }
                    }((() => {
                        var n = m(t, "stack");
                        t._promise = e, h(t, "stack", {get: () => we ? n && (n.get ? n.get.apply(t) : n.value) : e.stack})
                    })), function (e) {
                        Ae.some((t => t._value === e._value)) || Ae.push(e)
                    }(e), Fe(e), n && qe()
                }
            }

            function Fe(e) {
                var t = e._listeners;
                e._listeners = [];
                for (var n = 0, r = t.length; n < r; ++n) Ue(e, t[n]);
                var i = e._PSD;
                --i.ref || i.finalize(), 0 === Ne && (++Ne, Ee((() => {
                    0 == --Ne && We()
                }), []))
            }

            function Ue(e, t) {
                if (null !== e._state) {
                    var n = e._state ? t.onFulfilled : t.onRejected;
                    if (null === n) return (e._state ? t.resolve : t.reject)(e._value);
                    ++t.psd.ref, ++Ne, Ee(He, [n, e, t])
                } else e._listeners.push(t)
            }

            function He(e, t, n) {
                try {
                    Ce = t;
                    var r, i = t._value;
                    t._state ? r = e(i) : (Te.length && (Te = []), r = e(i), -1 === Te.indexOf(i) && function (e) {
                        for (var t = Ae.length; t;) if (Ae[--t]._value === e._value) return void Ae.splice(t, 1)
                    }(t)), n.resolve(r)
                } catch (e) {
                    n.reject(e)
                } finally {
                    Ce = null, 0 == --Ne && We(), --n.psd.ref || n.psd.finalize()
                }
            }

            function $e(e, t, n) {
                if (t.length === n) return t;
                var r = "";
                if (!1 === e._state) {
                    var i, s, a = e._value;
                    null != a ? (i = a.name || "Error", s = a.message || a, r = z(a, 0)) : (i = a, s = ""), t.push(i + (s ? ": " + s : "") + r)
                }
                return F && ((r = z(e._stackHolder, 2)) && -1 === t.indexOf(r) && t.push(r), e._prev && $e(e._prev, t, n)), t
            }

            function Ke(e, t) {
                var n = t ? t._numPrev + 1 : 0;
                n < 100 && (e._prev = t, e._numPrev = n)
            }

            function ze() {
                Ge() && qe()
            }

            function Ge() {
                var e = Se;
                return Se = !1, ke = !1, e
            }

            function qe() {
                var e, t, n;
                do {
                    for (; Pe.length > 0;) for (e = Pe, Pe = [], n = e.length, t = 0; t < n; ++t) {
                        var r = e[t];
                        r[0].apply(null, r[1])
                    }
                } while (Pe.length > 0);
                Se = !0, ke = !0
            }

            function We() {
                var e = Ae;
                Ae = [], e.forEach((e => {
                    e._PSD.onunhandled.call(null, e._value, e)
                }));
                for (var t = je.slice(0), n = t.length; n;) t[--n]()
            }

            function Ve(e) {
                return new Ie(he, !1, e)
            }

            function Ye(e, t) {
                var n = _e;
                return function () {
                    var r = Ge(), i = _e;
                    try {
                        return lt(n, !0), e.apply(this, arguments)
                    } catch (e) {
                        t && t(e)
                    } finally {
                        lt(i, !1), r && qe()
                    }
                }
            }

            u(Ie.prototype, {
                then: Me, _then: function (e, t) {
                    Ue(this, new De(null, null, e, t, _e))
                }, catch: function (e) {
                    if (1 === arguments.length) return this.then(null, e);
                    var t = arguments[0], n = arguments[1];
                    return "function" == typeof t ? this.then(null, (e => e instanceof t ? n(e) : Ve(e))) : this.then(null, (e => e && e.name === t ? n(e) : Ve(e)))
                }, finally: function (e) {
                    return this.then((t => (e(), t)), (t => (e(), Ve(t))))
                }, stack: {
                    get: function () {
                        if (this._stack) return this._stack;
                        try {
                            we = !0;
                            var e = $e(this, [], 20).join("\nFrom previous: ");
                            return null !== this._state && (this._stack = e), e
                        } finally {
                            we = !1
                        }
                    }
                }, timeout: function (e, t) {
                    return e < 1 / 0 ? new Ie(((n, r) => {
                        var i = setTimeout((() => r(new ee.Timeout(t))), e);
                        this.then(n, r).finally(clearTimeout.bind(null, i))
                    })) : this
                }
            }), "undefined" != typeof Symbol && Symbol.toStringTag && h(Ie.prototype, Symbol.toStringTag, "Dexie.Promise"), Le.env = ct(), u(Ie, {
                all: function () {
                    var e = O.apply(null, arguments).map(st);
                    return new Ie((function (t, n) {
                        0 === e.length && t([]);
                        var r = e.length;
                        e.forEach(((i, s) => Ie.resolve(i).then((n => {
                            e[s] = n, --r || t(e)
                        }), n)))
                    }))
                },
                resolve: e => {
                    if (e instanceof Ie) return e;
                    if (e && "function" == typeof e.then) return new Ie(((t, n) => {
                        e.then(t, n)
                    }));
                    var t = new Ie(he, !0, e);
                    return Ke(t, Ce), t
                },
                reject: Ve,
                race: function () {
                    var e = O.apply(null, arguments).map(st);
                    return new Ie(((t, n) => {
                        e.map((e => Ie.resolve(e).then(t, n)))
                    }))
                },
                PSD: {get: () => _e, set: e => _e = e},
                totalEchoes: {get: () => et},
                newPSD: nt,
                usePSD: ut,
                scheduler: {
                    get: () => Ee, set: e => {
                        Ee = e
                    }
                },
                rejectionMapper: {
                    get: () => Re, set: e => {
                        Re = e
                    }
                },
                follow: (e, t) => new Ie(((n, r) => nt(((t, n) => {
                    var r = _e;
                    r.unhandleds = [], r.onunhandled = n, r.finalize = ae((function () {
                        !function (e) {
                            je.push((function t() {
                                e(), je.splice(je.indexOf(t), 1)
                            })), ++Ne, Ee((() => {
                                0 == --Ne && We()
                            }), [])
                        }((() => {
                            0 === this.unhandleds.length ? t() : n(this.unhandleds[0])
                        }))
                    }), r.finalize), e()
                }), t, n, r)))
            }), ve && (ve.allSettled && h(Ie, "allSettled", (function () {
                const e = O.apply(null, arguments).map(st);
                return new Ie((t => {
                    0 === e.length && t([]);
                    let n = e.length;
                    const r = new Array(n);
                    e.forEach(((e, i) => Ie.resolve(e).then((e => r[i] = {
                        status: "fulfilled",
                        value: e
                    }), (e => r[i] = {status: "rejected", reason: e})).then((() => --n || t(r)))))
                }))
            })), ve.any && "undefined" != typeof AggregateError && h(Ie, "any", (function () {
                const e = O.apply(null, arguments).map(st);
                return new Ie(((t, n) => {
                    0 === e.length && n(new AggregateError([]));
                    let r = e.length;
                    const i = new Array(r);
                    e.forEach(((e, s) => Ie.resolve(e).then((e => t(e)), (e => {
                        i[s] = e, --r || n(new AggregateError(i))
                    }))))
                }))
            })));
            const Ze = {awaits: 0, echoes: 0, id: 0};
            var Xe = 0, Qe = [], Je = 0, et = 0, tt = 0;

            function nt(e, t, n, r) {
                var i = _e, s = Object.create(i);
                s.parent = i, s.ref = 0, s.global = !1, s.id = ++tt;
                var o = Le.env;
                s.env = be ? {
                    Promise: Ie,
                    PromiseProp: {value: Ie, configurable: !0, writable: !0},
                    all: Ie.all,
                    race: Ie.race,
                    allSettled: Ie.allSettled,
                    any: Ie.any,
                    resolve: Ie.resolve,
                    reject: Ie.reject,
                    nthen: ft(o.nthen, s),
                    gthen: ft(o.gthen, s)
                } : {}, t && a(s, t), ++i.ref, s.finalize = function () {
                    --this.parent.ref || this.parent.finalize()
                };
                var l = ut(s, e, n, r);
                return 0 === s.ref && s.finalize(), l
            }

            function rt() {
                return Ze.id || (Ze.id = ++Xe), ++Ze.awaits, Ze.echoes += fe, Ze.id
            }

            function it() {
                return !!Ze.awaits && (0 == --Ze.awaits && (Ze.id = 0), Ze.echoes = Ze.awaits * fe, !0)
            }

            function st(e) {
                return Ze.echoes && e && e.constructor === ve ? (rt(), e.then((e => (it(), e)), (e => (it(), gt(e))))) : e
            }

            function at(e) {
                ++et, Ze.echoes && 0 != --Ze.echoes || (Ze.echoes = Ze.id = 0), Qe.push(_e), lt(e, !0)
            }

            function ot() {
                var e = Qe[Qe.length - 1];
                Qe.pop(), lt(e, !1)
            }

            function lt(e, t) {
                var n = _e;
                if ((t ? !Ze.echoes || Je++ && e === _e : !Je || --Je && e === _e) || dt(t ? at.bind(null, e) : ot), e !== _e && (_e = e, n === Le && (Le.env = ct()), be)) {
                    var i = Le.env.Promise, s = e.env;
                    me.then = s.nthen, i.prototype.then = s.gthen, (n.global || e.global) && (Object.defineProperty(r, "Promise", s.PromiseProp), i.all = s.all, i.race = s.race, i.resolve = s.resolve, i.reject = s.reject, s.allSettled && (i.allSettled = s.allSettled), s.any && (i.any = s.any))
                }
            }

            function ct() {
                var e = r.Promise;
                return be ? {
                    Promise: e,
                    PromiseProp: Object.getOwnPropertyDescriptor(r, "Promise"),
                    all: e.all,
                    race: e.race,
                    allSettled: e.allSettled,
                    any: e.any,
                    resolve: e.resolve,
                    reject: e.reject,
                    nthen: me.then,
                    gthen: e.prototype.then
                } : {}
            }

            function ut(e, t, n, r, i) {
                var s = _e;
                try {
                    return lt(e, !0), t(n, r, i)
                } finally {
                    lt(s, !1)
                }
            }

            function dt(e) {
                ye.call(pe, e)
            }

            function ht(e, t, n, r) {
                return "function" != typeof e ? e : function () {
                    var i = _e;
                    n && rt(), lt(t, !0);
                    try {
                        return e.apply(this, arguments)
                    } finally {
                        lt(i, !1), r && dt(it)
                    }
                }
            }

            function ft(e, t) {
                return function (n, r) {
                    return e.call(this, ht(n, t), ht(r, t))
                }
            }

            -1 === ("" + ye).indexOf("[native code]") && (rt = it = re);
            const pt = "unhandledrejection";

            function mt(e, t) {
                var n;
                try {
                    n = t.onuncatched(e)
                } catch (e) {
                }
                if (!1 !== n) try {
                    var i, s = {promise: t, reason: e};
                    if (r.document && document.createEvent ? ((i = document.createEvent("Event")).initEvent(pt, !0, !0), a(i, s)) : r.CustomEvent && a(i = new CustomEvent(pt, {detail: s}), s), i && r.dispatchEvent && (dispatchEvent(i), !r.PromiseRejectionEvent && r.onunhandledrejection)) try {
                        r.onunhandledrejection(i)
                    } catch (e) {
                    }
                    F && i && !i.defaultPrevented && console.warn(`Unhandled rejection: ${e.stack || e}`)
                } catch (e) {
                }
            }

            var gt = Ie.reject;

            function yt(e, t, n, r) {
                if (e.idbdb && (e._state.openComplete || _e.letThrough || e._vip)) {
                    var i = e._createTransaction(t, n, e._dbSchema);
                    try {
                        i.create(), e._state.PR1398_maxLoop = 3
                    } catch (i) {
                        return i.name === Q.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then((() => yt(e, t, n, r)))) : gt(i)
                    }
                    return i._promise(t, ((e, t) => nt((() => (_e.trans = i, r(e, t, i)))))).then((e => i._completion.then((() => e))))
                }
                if (e._state.openComplete) return gt(new ee.DatabaseClosed(e._state.dbOpenError));
                if (!e._state.isBeingOpened) {
                    if (!e._options.autoOpen) return gt(new ee.DatabaseClosed);
                    e.open().catch(re)
                }
                return e._state.dbReadyPromise.then((() => yt(e, t, n, r)))
            }

            const vt = "3.2.4", bt = String.fromCharCode(65535), wt = -1 / 0,
                xt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.",
                Et = "String expected.", St = [],
                kt = "undefined" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent), At = kt,
                Tt = kt, Ct = e => !/(dexie\.js|dexie\.min\.js)/.test(e), Rt = "__dbnames", Lt = "readonly",
                _t = "readwrite";

            function Pt(e, t) {
                return e ? t ? function () {
                    return e.apply(this, arguments) && t.apply(this, arguments)
                } : e : t
            }

            const Nt = {type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1};

            function jt(e) {
                return "string" != typeof e || /\./.test(e) ? e => e : t => (void 0 === t[e] && e in t && delete (t = _(t))[e], t)
            }

            class It {
                _trans(e, t, n) {
                    const r = this._tx || _e.trans, i = this.name;

                    function s(e, n, r) {
                        if (!r.schema[i]) throw new ee.NotFound("Table " + i + " not part of transaction");
                        return t(r.idbtrans, r)
                    }

                    const a = Ge();
                    try {
                        return r && r.db === this.db ? r === _e.trans ? r._promise(e, s, n) : nt((() => r._promise(e, s, n)), {
                            trans: r,
                            transless: _e.transless || _e
                        }) : yt(this.db, e, [this.name], s)
                    } finally {
                        a && qe()
                    }
                }

                get(e, t) {
                    return e && e.constructor === Object ? this.where(e).first(t) : this._trans("readonly", (t => this.core.get({
                        trans: t,
                        key: e
                    }).then((e => this.hook.reading.fire(e))))).then(t)
                }

                where(e) {
                    if ("string" == typeof e) return new this.db.WhereClause(this, e);
                    if (s(e)) return new this.db.WhereClause(this, `[${e.join("+")}]`);
                    const t = i(e);
                    if (1 === t.length) return this.where(t[0]).equals(e[t[0]]);
                    const n = this.schema.indexes.concat(this.schema.primKey).filter((e => e.compound && t.every((t => e.keyPath.indexOf(t) >= 0)) && e.keyPath.every((e => t.indexOf(e) >= 0))))[0];
                    if (n && this.db._maxKey !== bt) return this.where(n.name).equals(n.keyPath.map((t => e[t])));
                    !n && F && console.warn(`The query ${JSON.stringify(e)} on ${this.name} would benefit of a compound index [${t.join("+")}]`);
                    const {idxByName: r} = this.schema, a = this.db._deps.indexedDB;

                    function o(e, t) {
                        try {
                            return 0 === a.cmp(e, t)
                        } catch (e) {
                            return !1
                        }
                    }

                    const [l, c] = t.reduce((([t, n], i) => {
                        const a = r[i], l = e[i];
                        return [t || a, t || !a ? Pt(n, a && a.multi ? e => {
                            const t = E(e, i);
                            return s(t) && t.some((e => o(l, e)))
                        } : e => o(l, E(e, i))) : n]
                    }), [null, null]);
                    return l ? this.where(l.name).equals(e[l.keyPath]).filter(c) : n ? this.filter(c) : this.where(t).equals("")
                }

                filter(e) {
                    return this.toCollection().and(e)
                }

                count(e) {
                    return this.toCollection().count(e)
                }

                offset(e) {
                    return this.toCollection().offset(e)
                }

                limit(e) {
                    return this.toCollection().limit(e)
                }

                each(e) {
                    return this.toCollection().each(e)
                }

                toArray(e) {
                    return this.toCollection().toArray(e)
                }

                toCollection() {
                    return new this.db.Collection(new this.db.WhereClause(this))
                }

                orderBy(e) {
                    return new this.db.Collection(new this.db.WhereClause(this, s(e) ? `[${e.join("+")}]` : e))
                }

                reverse() {
                    return this.toCollection().reverse()
                }

                mapToClass(e) {
                    this.schema.mappedClass = e;
                    const t = t => {
                        if (!t) return t;
                        const n = Object.create(e.prototype);
                        for (var r in t) if (c(t, r)) try {
                            n[r] = t[r]
                        } catch (e) {
                        }
                        return n
                    };
                    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = t, this.hook("reading", t), e
                }

                defineClass() {
                    return this.mapToClass((function (e) {
                        a(this, e)
                    }))
                }

                add(e, t) {
                    const {auto: n, keyPath: r} = this.schema.primKey;
                    let i = e;
                    return r && n && (i = jt(r)(e)), this._trans("readwrite", (e => this.core.mutate({
                        trans: e,
                        type: "add",
                        keys: null != t ? [t] : null,
                        values: [i]
                    }))).then((e => e.numFailures ? Ie.reject(e.failures[0]) : e.lastResult)).then((t => {
                        if (r) try {
                            S(e, r, t)
                        } catch (e) {
                        }
                        return t
                    }))
                }

                update(e, t) {
                    if ("object" != typeof e || s(e)) return this.where(":id").equals(e).modify(t);
                    {
                        const n = E(e, this.schema.primKey.keyPath);
                        if (void 0 === n) return gt(new ee.InvalidArgument("Given object does not contain its primary key"));
                        try {
                            "function" != typeof t ? i(t).forEach((n => {
                                S(e, n, t[n])
                            })) : t(e, {value: e, primKey: n})
                        } catch (e) {
                        }
                        return this.where(":id").equals(n).modify(t)
                    }
                }

                put(e, t) {
                    const {auto: n, keyPath: r} = this.schema.primKey;
                    let i = e;
                    return r && n && (i = jt(r)(e)), this._trans("readwrite", (e => this.core.mutate({
                        trans: e,
                        type: "put",
                        values: [i],
                        keys: null != t ? [t] : null
                    }))).then((e => e.numFailures ? Ie.reject(e.failures[0]) : e.lastResult)).then((t => {
                        if (r) try {
                            S(e, r, t)
                        } catch (e) {
                        }
                        return t
                    }))
                }

                delete(e) {
                    return this._trans("readwrite", (t => this.core.mutate({
                        trans: t,
                        type: "delete",
                        keys: [e]
                    }))).then((e => e.numFailures ? Ie.reject(e.failures[0]) : void 0))
                }

                clear() {
                    return this._trans("readwrite", (e => this.core.mutate({
                        trans: e,
                        type: "deleteRange",
                        range: Nt
                    }))).then((e => e.numFailures ? Ie.reject(e.failures[0]) : void 0))
                }

                bulkGet(e) {
                    return this._trans("readonly", (t => this.core.getMany({
                        keys: e,
                        trans: t
                    }).then((e => e.map((e => this.hook.reading.fire(e)))))))
                }

                bulkAdd(e, t, n) {
                    const r = Array.isArray(t) ? t : void 0, i = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0;
                    return this._trans("readwrite", (t => {
                        const {auto: n, keyPath: s} = this.schema.primKey;
                        if (s && r) throw new ee.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                        if (r && r.length !== e.length) throw new ee.InvalidArgument("Arguments objects and keys must have the same length");
                        const a = e.length;
                        let o = s && n ? e.map(jt(s)) : e;
                        return this.core.mutate({
                            trans: t,
                            type: "add",
                            keys: r,
                            values: o,
                            wantResults: i
                        }).then((({numFailures: e, results: t, lastResult: n, failures: r}) => {
                            if (0 === e) return i ? t : n;
                            throw new X(`${this.name}.bulkAdd(): ${e} of ${a} operations failed`, r)
                        }))
                    }))
                }

                bulkPut(e, t, n) {
                    const r = Array.isArray(t) ? t : void 0, i = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0;
                    return this._trans("readwrite", (t => {
                        const {auto: n, keyPath: s} = this.schema.primKey;
                        if (s && r) throw new ee.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                        if (r && r.length !== e.length) throw new ee.InvalidArgument("Arguments objects and keys must have the same length");
                        const a = e.length;
                        let o = s && n ? e.map(jt(s)) : e;
                        return this.core.mutate({
                            trans: t,
                            type: "put",
                            keys: r,
                            values: o,
                            wantResults: i
                        }).then((({numFailures: e, results: t, lastResult: n, failures: r}) => {
                            if (0 === e) return i ? t : n;
                            throw new X(`${this.name}.bulkPut(): ${e} of ${a} operations failed`, r)
                        }))
                    }))
                }

                bulkDelete(e) {
                    const t = e.length;
                    return this._trans("readwrite", (t => this.core.mutate({
                        trans: t,
                        type: "delete",
                        keys: e
                    }))).then((({numFailures: e, lastResult: n, failures: r}) => {
                        if (0 === e) return n;
                        throw new X(`${this.name}.bulkDelete(): ${e} of ${t} operations failed`, r)
                    }))
                }
            }

            function Mt(e) {
                var t = {}, n = function (n, r) {
                    if (r) {
                        for (var i = arguments.length, s = new Array(i - 1); --i;) s[i - 1] = arguments[i];
                        return t[n].subscribe.apply(null, s), e
                    }
                    if ("string" == typeof n) return t[n]
                };
                n.addEventType = o;
                for (var r = 1, a = arguments.length; r < a; ++r) o(arguments[r]);
                return n;

                function o(e, r, a) {
                    if ("object" != typeof e) {
                        var l;
                        r || (r = ue), a || (a = re);
                        var c = {
                            subscribers: [], fire: a, subscribe: function (e) {
                                -1 === c.subscribers.indexOf(e) && (c.subscribers.push(e), c.fire = r(c.fire, e))
                            }, unsubscribe: function (e) {
                                c.subscribers = c.subscribers.filter((function (t) {
                                    return t !== e
                                })), c.fire = c.subscribers.reduce(r, a)
                            }
                        };
                        return t[e] = n[e] = c, c
                    }
                    i(l = e).forEach((function (e) {
                        var t = l[e];
                        if (s(t)) o(e, l[e][0], l[e][1]); else {
                            if ("asap" !== t) throw new ee.InvalidArgument("Invalid event config");
                            var n = o(e, ie, (function () {
                                for (var e = arguments.length, t = new Array(e); e--;) t[e] = arguments[e];
                                n.subscribers.forEach((function (e) {
                                    w((function () {
                                        e.apply(null, t)
                                    }))
                                }))
                            }))
                        }
                    }))
                }
            }

            function Dt(e, t) {
                return f(t).from({prototype: e}), t
            }

            function Ot(e, t) {
                return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter)
            }

            function Bt(e, t) {
                e.filter = Pt(e.filter, t)
            }

            function Ft(e, t, n) {
                var r = e.replayFilter;
                e.replayFilter = r ? () => Pt(r(), t()) : t, e.justLimit = n && !r
            }

            function Ut(e, t) {
                if (e.isPrimKey) return t.primaryKey;
                const n = t.getIndexByKeyPath(e.index);
                if (!n) throw new ee.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed");
                return n
            }

            function Ht(e, t, n) {
                const r = Ut(e, t.schema);
                return t.openCursor({
                    trans: n,
                    values: !e.keysOnly,
                    reverse: "prev" === e.dir,
                    unique: !!e.unique,
                    query: {index: r, range: e.range}
                })
            }

            function $t(e, t, n, r) {
                const i = e.replayFilter ? Pt(e.filter, e.replayFilter()) : e.filter;
                if (e.or) {
                    const s = {}, a = (e, n, r) => {
                        if (!i || i(n, r, (e => n.stop(e)), (e => n.fail(e)))) {
                            var a = n.primaryKey, o = "" + a;
                            "[object ArrayBuffer]" === o && (o = "" + new Uint8Array(a)), c(s, o) || (s[o] = !0, t(e, n, r))
                        }
                    };
                    return Promise.all([e.or._iterate(a, n), Kt(Ht(e, r, n), e.algorithm, a, !e.keysOnly && e.valueMapper)])
                }
                return Kt(Ht(e, r, n), Pt(e.algorithm, i), t, !e.keysOnly && e.valueMapper)
            }

            function Kt(e, t, n, r) {
                var i = Ye(r ? (e, t, i) => n(r(e), t, i) : n);
                return e.then((e => {
                    if (e) return e.start((() => {
                        var n = () => e.continue();
                        t && !t(e, (e => n = e), (t => {
                            e.stop(t), n = re
                        }), (t => {
                            e.fail(t), n = re
                        })) || i(e.value, e, (e => n = e)), n()
                    }))
                }))
            }

            function zt(e, t) {
                try {
                    const n = Gt(e), r = Gt(t);
                    if (n !== r) return "Array" === n ? 1 : "Array" === r ? -1 : "binary" === n ? 1 : "binary" === r ? -1 : "string" === n ? 1 : "string" === r ? -1 : "Date" === n ? 1 : "Date" !== r ? NaN : -1;
                    switch (n) {
                        case"number":
                        case"Date":
                        case"string":
                            return e > t ? 1 : e < t ? -1 : 0;
                        case"binary":
                            return function (e, t) {
                                const n = e.length, r = t.length, i = n < r ? n : r;
                                for (let n = 0; n < i; ++n) if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1;
                                return n === r ? 0 : n < r ? -1 : 1
                            }(qt(e), qt(t));
                        case"Array":
                            return function (e, t) {
                                const n = e.length, r = t.length, i = n < r ? n : r;
                                for (let n = 0; n < i; ++n) {
                                    const r = zt(e[n], t[n]);
                                    if (0 !== r) return r
                                }
                                return n === r ? 0 : n < r ? -1 : 1
                            }(e, t)
                    }
                } catch (e) {
                }
                return NaN
            }

            function Gt(e) {
                const t = typeof e;
                if ("object" !== t) return t;
                if (ArrayBuffer.isView(e)) return "binary";
                const n = j(e);
                return "ArrayBuffer" === n ? "binary" : n
            }

            function qt(e) {
                return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e)
            }

            class Wt {
                _read(e, t) {
                    var n = this._ctx;
                    return n.error ? n.table._trans(null, gt.bind(null, n.error)) : n.table._trans("readonly", e).then(t)
                }

                _write(e) {
                    var t = this._ctx;
                    return t.error ? t.table._trans(null, gt.bind(null, t.error)) : t.table._trans("readwrite", e, "locked")
                }

                _addAlgorithm(e) {
                    var t = this._ctx;
                    t.algorithm = Pt(t.algorithm, e)
                }

                _iterate(e, t) {
                    return $t(this._ctx, e, t, this._ctx.table.core)
                }

                clone(e) {
                    var t = Object.create(this.constructor.prototype), n = Object.create(this._ctx);
                    return e && a(n, e), t._ctx = n, t
                }

                raw() {
                    return this._ctx.valueMapper = null, this
                }

                each(e) {
                    var t = this._ctx;
                    return this._read((n => $t(t, e, n, t.table.core)))
                }

                count(e) {
                    return this._read((e => {
                        const t = this._ctx, n = t.table.core;
                        if (Ot(t, !0)) return n.count({
                            trans: e,
                            query: {index: Ut(t, n.schema), range: t.range}
                        }).then((e => Math.min(e, t.limit)));
                        var r = 0;
                        return $t(t, (() => (++r, !1)), e, n).then((() => r))
                    })).then(e)
                }

                sortBy(e, t) {
                    const n = e.split(".").reverse(), r = n[0], i = n.length - 1;

                    function s(e, t) {
                        return t ? s(e[n[t]], t - 1) : e[r]
                    }

                    var a = "next" === this._ctx.dir ? 1 : -1;

                    function o(e, t) {
                        var n = s(e, i), r = s(t, i);
                        return n < r ? -a : n > r ? a : 0
                    }

                    return this.toArray((function (e) {
                        return e.sort(o)
                    })).then(t)
                }

                toArray(e) {
                    return this._read((e => {
                        var t = this._ctx;
                        if ("next" === t.dir && Ot(t, !0) && t.limit > 0) {
                            const {valueMapper: n} = t, r = Ut(t, t.table.core.schema);
                            return t.table.core.query({
                                trans: e,
                                limit: t.limit,
                                values: !0,
                                query: {index: r, range: t.range}
                            }).then((({result: e}) => n ? e.map(n) : e))
                        }
                        {
                            const n = [];
                            return $t(t, (e => n.push(e)), e, t.table.core).then((() => n))
                        }
                    }), e)
                }

                offset(e) {
                    var t = this._ctx;
                    return e <= 0 || (t.offset += e, Ot(t) ? Ft(t, (() => {
                        var t = e;
                        return (e, n) => 0 === t || (1 === t ? (--t, !1) : (n((() => {
                            e.advance(t), t = 0
                        })), !1))
                    })) : Ft(t, (() => {
                        var t = e;
                        return () => --t < 0
                    }))), this
                }

                limit(e) {
                    return this._ctx.limit = Math.min(this._ctx.limit, e), Ft(this._ctx, (() => {
                        var t = e;
                        return function (e, n, r) {
                            return --t <= 0 && n(r), t >= 0
                        }
                    }), !0), this
                }

                until(e, t) {
                    return Bt(this._ctx, (function (n, r, i) {
                        return !e(n.value) || (r(i), t)
                    })), this
                }

                first(e) {
                    return this.limit(1).toArray((function (e) {
                        return e[0]
                    })).then(e)
                }

                last(e) {
                    return this.reverse().first(e)
                }

                filter(e) {
                    var t, n;
                    return Bt(this._ctx, (function (t) {
                        return e(t.value)
                    })), t = this._ctx, n = e, t.isMatch = Pt(t.isMatch, n), this
                }

                and(e) {
                    return this.filter(e)
                }

                or(e) {
                    return new this.db.WhereClause(this._ctx.table, e, this)
                }

                reverse() {
                    return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this
                }

                desc() {
                    return this.reverse()
                }

                eachKey(e) {
                    var t = this._ctx;
                    return t.keysOnly = !t.isMatch, this.each((function (t, n) {
                        e(n.key, n)
                    }))
                }

                eachUniqueKey(e) {
                    return this._ctx.unique = "unique", this.eachKey(e)
                }

                eachPrimaryKey(e) {
                    var t = this._ctx;
                    return t.keysOnly = !t.isMatch, this.each((function (t, n) {
                        e(n.primaryKey, n)
                    }))
                }

                keys(e) {
                    var t = this._ctx;
                    t.keysOnly = !t.isMatch;
                    var n = [];
                    return this.each((function (e, t) {
                        n.push(t.key)
                    })).then((function () {
                        return n
                    })).then(e)
                }

                primaryKeys(e) {
                    var t = this._ctx;
                    if ("next" === t.dir && Ot(t, !0) && t.limit > 0) return this._read((e => {
                        var n = Ut(t, t.table.core.schema);
                        return t.table.core.query({
                            trans: e,
                            values: !1,
                            limit: t.limit,
                            query: {index: n, range: t.range}
                        })
                    })).then((({result: e}) => e)).then(e);
                    t.keysOnly = !t.isMatch;
                    var n = [];
                    return this.each((function (e, t) {
                        n.push(t.primaryKey)
                    })).then((function () {
                        return n
                    })).then(e)
                }

                uniqueKeys(e) {
                    return this._ctx.unique = "unique", this.keys(e)
                }

                firstKey(e) {
                    return this.limit(1).keys((function (e) {
                        return e[0]
                    })).then(e)
                }

                lastKey(e) {
                    return this.reverse().firstKey(e)
                }

                distinct() {
                    var e = this._ctx, t = e.index && e.table.schema.idxByName[e.index];
                    if (!t || !t.multi) return this;
                    var n = {};
                    return Bt(this._ctx, (function (e) {
                        var t = e.primaryKey.toString(), r = c(n, t);
                        return n[t] = !0, !r
                    })), this
                }

                modify(e) {
                    var t = this._ctx;
                    return this._write((n => {
                        var r;
                        if ("function" == typeof e) r = e; else {
                            var s = i(e), a = s.length;
                            r = function (t) {
                                for (var n = !1, r = 0; r < a; ++r) {
                                    var i = s[r], o = e[i];
                                    E(t, i) !== o && (S(t, i, o), n = !0)
                                }
                                return n
                            }
                        }
                        const o = t.table.core, {outbound: l, extractKey: c} = o.schema.primaryKey,
                            u = this.db._options.modifyChunkSize || 200, d = [];
                        let h = 0;
                        const f = [], p = (e, t) => {
                            const {failures: n, numFailures: r} = t;
                            h += e - r;
                            for (let e of i(n)) d.push(n[e])
                        };
                        return this.clone().primaryKeys().then((i => {
                            const s = a => {
                                const d = Math.min(u, i.length - a);
                                return o.getMany({trans: n, keys: i.slice(a, a + d), cache: "immutable"}).then((h => {
                                    const f = [], m = [], g = l ? [] : null, y = [];
                                    for (let e = 0; e < d; ++e) {
                                        const t = h[e], n = {value: _(t), primKey: i[a + e]};
                                        !1 !== r.call(n, n.value, n) && (null == n.value ? y.push(i[a + e]) : l || 0 === zt(c(t), c(n.value)) ? (m.push(n.value), l && g.push(i[a + e])) : (y.push(i[a + e]), f.push(n.value)))
                                    }
                                    const v = Ot(t) && t.limit === 1 / 0 && ("function" != typeof e || e === Vt) && {
                                        index: t.index,
                                        range: t.range
                                    };
                                    return Promise.resolve(f.length > 0 && o.mutate({
                                        trans: n,
                                        type: "add",
                                        values: f
                                    }).then((e => {
                                        for (let t in e.failures) y.splice(parseInt(t), 1);
                                        p(f.length, e)
                                    }))).then((() => (m.length > 0 || v && "object" == typeof e) && o.mutate({
                                        trans: n,
                                        type: "put",
                                        keys: g,
                                        values: m,
                                        criteria: v,
                                        changeSpec: "function" != typeof e && e
                                    }).then((e => p(m.length, e))))).then((() => (y.length > 0 || v && e === Vt) && o.mutate({
                                        trans: n,
                                        type: "delete",
                                        keys: y,
                                        criteria: v
                                    }).then((e => p(y.length, e))))).then((() => i.length > a + d && s(a + u)))
                                }))
                            };
                            return s(0).then((() => {
                                if (d.length > 0) throw new Z("Error modifying one or more objects", d, h, f);
                                return i.length
                            }))
                        }))
                    }))
                }

                delete() {
                    var e = this._ctx, t = e.range;
                    return Ot(e) && (e.isPrimKey && !Tt || 3 === t.type) ? this._write((n => {
                        const {primaryKey: r} = e.table.core.schema, i = t;
                        return e.table.core.count({
                            trans: n,
                            query: {index: r, range: i}
                        }).then((t => e.table.core.mutate({
                            trans: n,
                            type: "deleteRange",
                            range: i
                        }).then((({failures: e, lastResult: n, results: r, numFailures: i}) => {
                            if (i) throw new Z("Could not delete some values", Object.keys(e).map((t => e[t])), t - i);
                            return t - i
                        }))))
                    })) : this.modify(Vt)
                }
            }

            const Vt = (e, t) => t.value = null;

            function Yt(e, t) {
                return e < t ? -1 : e === t ? 0 : 1
            }

            function Zt(e, t) {
                return e > t ? -1 : e === t ? 0 : 1
            }

            function Xt(e, t, n) {
                var r = e instanceof rn ? new e.Collection(e) : e;
                return r._ctx.error = n ? new n(t) : new TypeError(t), r
            }

            function Qt(e) {
                return new e.Collection(e, (() => nn(""))).limit(0)
            }

            function Jt(e, t, n, r, i, s) {
                for (var a = Math.min(e.length, r.length), o = -1, l = 0; l < a; ++l) {
                    var c = t[l];
                    if (c !== r[l]) return i(e[l], n[l]) < 0 ? e.substr(0, l) + n[l] + n.substr(l + 1) : i(e[l], r[l]) < 0 ? e.substr(0, l) + r[l] + n.substr(l + 1) : o >= 0 ? e.substr(0, o) + t[o] + n.substr(o + 1) : null;
                    i(e[l], c) < 0 && (o = l)
                }
                return a < r.length && "next" === s ? e + n.substr(e.length) : a < e.length && "prev" === s ? e.substr(0, n.length) : o < 0 ? null : e.substr(0, o) + r[o] + n.substr(o + 1)
            }

            function en(e, t, n, r) {
                var i, s, a, o, l, c, u, d = n.length;
                if (!n.every((e => "string" == typeof e))) return Xt(e, Et);

                function h(e) {
                    i = function (e) {
                        return "next" === e ? e => e.toUpperCase() : e => e.toLowerCase()
                    }(e), s = function (e) {
                        return "next" === e ? e => e.toLowerCase() : e => e.toUpperCase()
                    }(e), a = "next" === e ? Yt : Zt;
                    var t = n.map((function (e) {
                        return {lower: s(e), upper: i(e)}
                    })).sort((function (e, t) {
                        return a(e.lower, t.lower)
                    }));
                    o = t.map((function (e) {
                        return e.upper
                    })), l = t.map((function (e) {
                        return e.lower
                    })), c = e, u = "next" === e ? "" : r
                }

                h("next");
                var f = new e.Collection(e, (() => tn(o[0], l[d - 1] + r)));
                f._ondirectionchange = function (e) {
                    h(e)
                };
                var p = 0;
                return f._addAlgorithm((function (e, n, r) {
                    var i = e.key;
                    if ("string" != typeof i) return !1;
                    var h = s(i);
                    if (t(h, l, p)) return !0;
                    for (var f = null, m = p; m < d; ++m) {
                        var g = Jt(i, h, o[m], l[m], a, c);
                        null === g && null === f ? p = m + 1 : (null === f || a(f, g) > 0) && (f = g)
                    }
                    return n(null !== f ? function () {
                        e.continue(f + u)
                    } : r), !1
                })), f
            }

            function tn(e, t, n, r) {
                return {type: 2, lower: e, upper: t, lowerOpen: n, upperOpen: r}
            }

            function nn(e) {
                return {type: 1, lower: e, upper: e}
            }

            class rn {
                get Collection() {
                    return this._ctx.table.db.Collection
                }

                between(e, t, n, r) {
                    n = !1 !== n, r = !0 === r;
                    try {
                        return this._cmp(e, t) > 0 || 0 === this._cmp(e, t) && (n || r) && (!n || !r) ? Qt(this) : new this.Collection(this, (() => tn(e, t, !n, !r)))
                    } catch (e) {
                        return Xt(this, xt)
                    }
                }

                equals(e) {
                    return null == e ? Xt(this, xt) : new this.Collection(this, (() => nn(e)))
                }

                above(e) {
                    return null == e ? Xt(this, xt) : new this.Collection(this, (() => tn(e, void 0, !0)))
                }

                aboveOrEqual(e) {
                    return null == e ? Xt(this, xt) : new this.Collection(this, (() => tn(e, void 0, !1)))
                }

                below(e) {
                    return null == e ? Xt(this, xt) : new this.Collection(this, (() => tn(void 0, e, !1, !0)))
                }

                belowOrEqual(e) {
                    return null == e ? Xt(this, xt) : new this.Collection(this, (() => tn(void 0, e)))
                }

                startsWith(e) {
                    return "string" != typeof e ? Xt(this, Et) : this.between(e, e + bt, !0, !0)
                }

                startsWithIgnoreCase(e) {
                    return "" === e ? this.startsWith(e) : en(this, ((e, t) => 0 === e.indexOf(t[0])), [e], bt)
                }

                equalsIgnoreCase(e) {
                    return en(this, ((e, t) => e === t[0]), [e], "")
                }

                anyOfIgnoreCase() {
                    var e = O.apply(D, arguments);
                    return 0 === e.length ? Qt(this) : en(this, ((e, t) => -1 !== t.indexOf(e)), e, "")
                }

                startsWithAnyOfIgnoreCase() {
                    var e = O.apply(D, arguments);
                    return 0 === e.length ? Qt(this) : en(this, ((e, t) => t.some((t => 0 === e.indexOf(t)))), e, bt)
                }

                anyOf() {
                    const e = O.apply(D, arguments);
                    let t = this._cmp;
                    try {
                        e.sort(t)
                    } catch (e) {
                        return Xt(this, xt)
                    }
                    if (0 === e.length) return Qt(this);
                    const n = new this.Collection(this, (() => tn(e[0], e[e.length - 1])));
                    n._ondirectionchange = n => {
                        t = "next" === n ? this._ascending : this._descending, e.sort(t)
                    };
                    let r = 0;
                    return n._addAlgorithm(((n, i, s) => {
                        const a = n.key;
                        for (; t(a, e[r]) > 0;) if (++r, r === e.length) return i(s), !1;
                        return 0 === t(a, e[r]) || (i((() => {
                            n.continue(e[r])
                        })), !1)
                    })), n
                }

                notEqual(e) {
                    return this.inAnyRange([[wt, e], [e, this.db._maxKey]], {includeLowers: !1, includeUppers: !1})
                }

                noneOf() {
                    const e = O.apply(D, arguments);
                    if (0 === e.length) return new this.Collection(this);
                    try {
                        e.sort(this._ascending)
                    } catch (e) {
                        return Xt(this, xt)
                    }
                    const t = e.reduce(((e, t) => e ? e.concat([[e[e.length - 1][1], t]]) : [[wt, t]]), null);
                    return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, {
                        includeLowers: !1,
                        includeUppers: !1
                    })
                }

                inAnyRange(e, t) {
                    const n = this._cmp, r = this._ascending, i = this._descending, s = this._min, a = this._max;
                    if (0 === e.length) return Qt(this);
                    if (!e.every((e => void 0 !== e[0] && void 0 !== e[1] && r(e[0], e[1]) <= 0))) return Xt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", ee.InvalidArgument);
                    const o = !t || !1 !== t.includeLowers, l = t && !0 === t.includeUppers;
                    let c, u = r;

                    function d(e, t) {
                        return u(e[0], t[0])
                    }

                    try {
                        c = e.reduce((function (e, t) {
                            let r = 0, i = e.length;
                            for (; r < i; ++r) {
                                const i = e[r];
                                if (n(t[0], i[1]) < 0 && n(t[1], i[0]) > 0) {
                                    i[0] = s(i[0], t[0]), i[1] = a(i[1], t[1]);
                                    break
                                }
                            }
                            return r === i && e.push(t), e
                        }), []), c.sort(d)
                    } catch (e) {
                        return Xt(this, xt)
                    }
                    let h = 0;
                    const f = l ? e => r(e, c[h][1]) > 0 : e => r(e, c[h][1]) >= 0,
                        p = o ? e => i(e, c[h][0]) > 0 : e => i(e, c[h][0]) >= 0;
                    let m = f;
                    const g = new this.Collection(this, (() => tn(c[0][0], c[c.length - 1][1], !o, !l)));
                    return g._ondirectionchange = e => {
                        "next" === e ? (m = f, u = r) : (m = p, u = i), c.sort(d)
                    }, g._addAlgorithm(((e, t, n) => {
                        for (var i = e.key; m(i);) if (++h, h === c.length) return t(n), !1;
                        return !!function (e) {
                            return !f(e) && !p(e)
                        }(i) || (0 === this._cmp(i, c[h][1]) || 0 === this._cmp(i, c[h][0]) || t((() => {
                            u === r ? e.continue(c[h][0]) : e.continue(c[h][1])
                        })), !1)
                    })), g
                }

                startsWithAnyOf() {
                    const e = O.apply(D, arguments);
                    return e.every((e => "string" == typeof e)) ? 0 === e.length ? Qt(this) : this.inAnyRange(e.map((e => [e, e + bt]))) : Xt(this, "startsWithAnyOf() only works with strings")
                }
            }

            function sn(e) {
                return Ye((function (t) {
                    return an(t), e(t.target.error), !1
                }))
            }

            function an(e) {
                e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault()
            }

            const on = "storagemutated", ln = "x-storagemutated-1", cn = Mt(null, on);

            class un {
                _lock() {
                    return b(!_e.global), ++this._reculock, 1 !== this._reculock || _e.global || (_e.lockOwnerFor = this), this
                }

                _unlock() {
                    if (b(!_e.global), 0 == --this._reculock) for (_e.global || (_e.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) {
                        var e = this._blockedFuncs.shift();
                        try {
                            ut(e[1], e[0])
                        } catch (e) {
                        }
                    }
                    return this
                }

                _locked() {
                    return this._reculock && _e.lockOwnerFor !== this
                }

                create(e) {
                    if (!this.mode) return this;
                    const t = this.db.idbdb, n = this.db._state.dbOpenError;
                    if (b(!this.idbtrans), !e && !t) switch (n && n.name) {
                        case"DatabaseClosedError":
                            throw new ee.DatabaseClosed(n);
                        case"MissingAPIError":
                            throw new ee.MissingAPI(n.message, n);
                        default:
                            throw new ee.OpenFailed(n)
                    }
                    if (!this.active) throw new ee.TransactionInactive;
                    return b(null === this._completion._state), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {durability: this.chromeTransactionDurability}) : t.transaction(this.storeNames, this.mode, {durability: this.chromeTransactionDurability}))).onerror = Ye((t => {
                        an(t), this._reject(e.error)
                    })), e.onabort = Ye((t => {
                        an(t), this.active && this._reject(new ee.Abort(e.error)), this.active = !1, this.on("abort").fire(t)
                    })), e.oncomplete = Ye((() => {
                        this.active = !1, this._resolve(), "mutatedParts" in e && cn.storagemutated.fire(e.mutatedParts)
                    })), this
                }

                _promise(e, t, n) {
                    if ("readwrite" === e && "readwrite" !== this.mode) return gt(new ee.ReadOnly("Transaction is readonly"));
                    if (!this.active) return gt(new ee.TransactionInactive);
                    if (this._locked()) return new Ie(((r, i) => {
                        this._blockedFuncs.push([() => {
                            this._promise(e, t, n).then(r, i)
                        }, _e])
                    }));
                    if (n) return nt((() => {
                        var e = new Ie(((e, n) => {
                            this._lock();
                            const r = t(e, n, this);
                            r && r.then && r.then(e, n)
                        }));
                        return e.finally((() => this._unlock())), e._lib = !0, e
                    }));
                    var r = new Ie(((e, n) => {
                        var r = t(e, n, this);
                        r && r.then && r.then(e, n)
                    }));
                    return r._lib = !0, r
                }

                _root() {
                    return this.parent ? this.parent._root() : this
                }

                waitFor(e) {
                    var t = this._root();
                    const n = Ie.resolve(e);
                    if (t._waitingFor) t._waitingFor = t._waitingFor.then((() => n)); else {
                        t._waitingFor = n, t._waitingQueue = [];
                        var r = t.idbtrans.objectStore(t.storeNames[0]);
                        !function e() {
                            for (++t._spinCount; t._waitingQueue.length;) t._waitingQueue.shift()();
                            t._waitingFor && (r.get(-1 / 0).onsuccess = e)
                        }()
                    }
                    var i = t._waitingFor;
                    return new Ie(((e, r) => {
                        n.then((n => t._waitingQueue.push(Ye(e.bind(null, n)))), (e => t._waitingQueue.push(Ye(r.bind(null, e))))).finally((() => {
                            t._waitingFor === i && (t._waitingFor = null)
                        }))
                    }))
                }

                abort() {
                    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new ee.Abort))
                }

                table(e) {
                    const t = this._memoizedTables || (this._memoizedTables = {});
                    if (c(t, e)) return t[e];
                    const n = this.schema[e];
                    if (!n) throw new ee.NotFound("Table " + e + " not part of transaction");
                    const r = new this.db.Table(e, n, this);
                    return r.core = this.db.core.table(e), t[e] = r, r
                }
            }

            function dn(e, t, n, r, i, s, a) {
                return {
                    name: e,
                    keyPath: t,
                    unique: n,
                    multi: r,
                    auto: i,
                    compound: s,
                    src: (n && !a ? "&" : "") + (r ? "*" : "") + (i ? "++" : "") + hn(t)
                }
            }

            function hn(e) {
                return "string" == typeof e ? e : e ? "[" + [].join.call(e, "+") + "]" : ""
            }

            function fn(e, t, n) {
                return {name: e, primKey: t, indexes: n, mappedClass: null, idxByName: x(n, (e => [e.name, e]))}
            }

            let pn = e => {
                try {
                    return e.only([[]]), pn = () => [[]], [[]]
                } catch (e) {
                    return pn = () => bt, bt
                }
            };

            function mn(e) {
                return null == e ? () => {
                } : "string" == typeof e ? function (e) {
                    return 1 === e.split(".").length ? t => t[e] : t => E(t, e)
                }(e) : t => E(t, e)
            }

            function gn(e) {
                return [].slice.call(e)
            }

            let yn = 0;

            function vn(e) {
                return null == e ? ":id" : "string" == typeof e ? e : `[${e.join("+")}]`
            }

            function bn(e, t, n) {
                function r(e) {
                    if (3 === e.type) return null;
                    if (4 === e.type) throw new Error("Cannot convert never type to IDBKeyRange");
                    const {lower: n, upper: r, lowerOpen: i, upperOpen: s} = e;
                    return void 0 === n ? void 0 === r ? null : t.upperBound(r, !!s) : void 0 === r ? t.lowerBound(n, !!i) : t.bound(n, r, !!i, !!s)
                }

                const {schema: i, hasGetAll: a} = function (e, t) {
                    const n = gn(e.objectStoreNames);
                    return {
                        schema: {
                            name: e.name, tables: n.map((e => t.objectStore(e))).map((e => {
                                const {keyPath: t, autoIncrement: n} = e, r = s(t), i = null == t, a = {}, o = {
                                    name: e.name,
                                    primaryKey: {
                                        name: null,
                                        isPrimaryKey: !0,
                                        outbound: i,
                                        compound: r,
                                        keyPath: t,
                                        autoIncrement: n,
                                        unique: !0,
                                        extractKey: mn(t)
                                    },
                                    indexes: gn(e.indexNames).map((t => e.index(t))).map((e => {
                                        const {name: t, unique: n, multiEntry: r, keyPath: i} = e, o = {
                                            name: t,
                                            compound: s(i),
                                            keyPath: i,
                                            unique: n,
                                            multiEntry: r,
                                            extractKey: mn(i)
                                        };
                                        return a[vn(i)] = o, o
                                    })),
                                    getIndexByKeyPath: e => a[vn(e)]
                                };
                                return a[":id"] = o.primaryKey, null != t && (a[vn(t)] = o.primaryKey), o
                            }))
                        },
                        hasGetAll: n.length > 0 && "getAll" in t.objectStore(n[0]) && !("undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
                    }
                }(e, n), o = i.tables.map((e => function (e) {
                    const t = e.name;
                    return {
                        name: t, schema: e, mutate: function ({trans: e, type: n, keys: i, values: s, range: a}) {
                            return new Promise(((o, l) => {
                                o = Ye(o);
                                const c = e.objectStore(t), u = null == c.keyPath, d = "put" === n || "add" === n;
                                if (!d && "delete" !== n && "deleteRange" !== n) throw new Error("Invalid operation type: " + n);
                                const {length: h} = i || s || {length: 1};
                                if (i && s && i.length !== s.length) throw new Error("Given keys array must have same length as given values array.");
                                if (0 === h) return o({numFailures: 0, failures: {}, results: [], lastResult: void 0});
                                let f;
                                const p = [], m = [];
                                let g = 0;
                                const y = e => {
                                    ++g, an(e)
                                };
                                if ("deleteRange" === n) {
                                    if (4 === a.type) return o({
                                        numFailures: g,
                                        failures: m,
                                        results: [],
                                        lastResult: void 0
                                    });
                                    3 === a.type ? p.push(f = c.clear()) : p.push(f = c.delete(r(a)))
                                } else {
                                    const [e, t] = d ? u ? [s, i] : [s, null] : [i, null];
                                    if (d) for (let r = 0; r < h; ++r) p.push(f = t && void 0 !== t[r] ? c[n](e[r], t[r]) : c[n](e[r])), f.onerror = y; else for (let t = 0; t < h; ++t) p.push(f = c[n](e[t])), f.onerror = y
                                }
                                const v = e => {
                                    const t = e.target.result;
                                    p.forEach(((e, t) => null != e.error && (m[t] = e.error))), o({
                                        numFailures: g,
                                        failures: m,
                                        results: "delete" === n ? i : p.map((e => e.result)),
                                        lastResult: t
                                    })
                                };
                                f.onerror = e => {
                                    y(e), v(e)
                                }, f.onsuccess = v
                            }))
                        }, getMany: ({trans: e, keys: n}) => new Promise(((r, i) => {
                            r = Ye(r);
                            const s = e.objectStore(t), a = n.length, o = new Array(a);
                            let l, c = 0, u = 0;
                            const d = e => {
                                const t = e.target;
                                o[t._pos] = t.result, ++u === c && r(o)
                            }, h = sn(i);
                            for (let e = 0; e < a; ++e) null != n[e] && (l = s.get(n[e]), l._pos = e, l.onsuccess = d, l.onerror = h, ++c);
                            0 === c && r(o)
                        })), get: ({trans: e, key: n}) => new Promise(((r, i) => {
                            r = Ye(r);
                            const s = e.objectStore(t).get(n);
                            s.onsuccess = e => r(e.target.result), s.onerror = sn(i)
                        })), query: function (e) {
                            return n => new Promise(((i, s) => {
                                i = Ye(i);
                                const {trans: a, values: o, limit: l, query: c} = n,
                                    u = l === 1 / 0 ? void 0 : l, {index: d, range: h} = c, f = a.objectStore(t),
                                    p = d.isPrimaryKey ? f : f.index(d.name), m = r(h);
                                if (0 === l) return i({result: []});
                                if (e) {
                                    const e = o ? p.getAll(m, u) : p.getAllKeys(m, u);
                                    e.onsuccess = e => i({result: e.target.result}), e.onerror = sn(s)
                                } else {
                                    let e = 0;
                                    const t = o || !("openKeyCursor" in p) ? p.openCursor(m) : p.openKeyCursor(m),
                                        n = [];
                                    t.onsuccess = r => {
                                        const s = t.result;
                                        return s ? (n.push(o ? s.value : s.primaryKey), ++e === l ? i({result: n}) : void s.continue()) : i({result: n})
                                    }, t.onerror = sn(s)
                                }
                            }))
                        }(a), openCursor: function ({trans: e, values: n, query: i, reverse: s, unique: a}) {
                            return new Promise(((o, l) => {
                                o = Ye(o);
                                const {index: c, range: u} = i, d = e.objectStore(t),
                                    h = c.isPrimaryKey ? d : d.index(c.name),
                                    f = s ? a ? "prevunique" : "prev" : a ? "nextunique" : "next",
                                    p = n || !("openKeyCursor" in h) ? h.openCursor(r(u), f) : h.openKeyCursor(r(u), f);
                                p.onerror = sn(l), p.onsuccess = Ye((t => {
                                    const n = p.result;
                                    if (!n) return void o(null);
                                    n.___id = ++yn, n.done = !1;
                                    const r = n.continue.bind(n);
                                    let i = n.continuePrimaryKey;
                                    i && (i = i.bind(n));
                                    const s = n.advance.bind(n), a = () => {
                                        throw new Error("Cursor not stopped")
                                    };
                                    n.trans = e, n.stop = n.continue = n.continuePrimaryKey = n.advance = () => {
                                        throw new Error("Cursor not started")
                                    }, n.fail = Ye(l), n.next = function () {
                                        let e = 1;
                                        return this.start((() => e-- ? this.continue() : this.stop())).then((() => this))
                                    }, n.start = e => {
                                        const t = new Promise(((e, t) => {
                                            e = Ye(e), p.onerror = sn(t), n.fail = t, n.stop = t => {
                                                n.stop = n.continue = n.continuePrimaryKey = n.advance = a, e(t)
                                            }
                                        })), o = () => {
                                            if (p.result) try {
                                                e()
                                            } catch (e) {
                                                n.fail(e)
                                            } else n.done = !0, n.start = () => {
                                                throw new Error("Cursor behind last entry")
                                            }, n.stop()
                                        };
                                        return p.onsuccess = Ye((e => {
                                            p.onsuccess = o, o()
                                        })), n.continue = r, n.continuePrimaryKey = i, n.advance = s, o(), t
                                    }, o(n)
                                }), l)
                            }))
                        }, count({query: e, trans: n}) {
                            const {index: i, range: s} = e;
                            return new Promise(((e, a) => {
                                const o = n.objectStore(t), l = i.isPrimaryKey ? o : o.index(i.name), c = r(s),
                                    u = c ? l.count(c) : l.count();
                                u.onsuccess = Ye((t => e(t.target.result))), u.onerror = sn(a)
                            }))
                        }
                    }
                }(e))), l = {};
                return o.forEach((e => l[e.name] = e)), {
                    stack: "dbcore", transaction: e.transaction.bind(e), table(e) {
                        if (!l[e]) throw new Error(`Table '${e}' not found`);
                        return l[e]
                    }, MIN_KEY: -1 / 0, MAX_KEY: pn(t), schema: i
                }
            }

            function wn({_novip: e}, t) {
                const n = t.db, r = function (e, t, {IDBKeyRange: n, indexedDB: r}, i) {
                    const s = function (e, t) {
                        return t.reduce(((e, {create: t}) => ({...e, ...t(e)})), e)
                    }(bn(t, n, i), e.dbcore);
                    return {dbcore: s}
                }(e._middlewares, n, e._deps, t);
                e.core = r.dbcore, e.tables.forEach((t => {
                    const n = t.name;
                    e.core.schema.tables.some((e => e.name === n)) && (t.core = e.core.table(n), e[n] instanceof e.Table && (e[n].core = t.core))
                }))
            }

            function xn({_novip: e}, t, n, r) {
                n.forEach((n => {
                    const i = r[n];
                    t.forEach((t => {
                        const r = m(t, n);
                        (!r || "value" in r && void 0 === r.value) && (t === e.Transaction.prototype || t instanceof e.Transaction ? h(t, n, {
                            get() {
                                return this.table(n)
                            }, set(e) {
                                d(this, n, {value: e, writable: !0, configurable: !0, enumerable: !0})
                            }
                        }) : t[n] = new e.Table(n, i))
                    }))
                }))
            }

            function En({_novip: e}, t) {
                t.forEach((t => {
                    for (let n in t) t[n] instanceof e.Table && delete t[n]
                }))
            }

            function Sn(e, t) {
                return e._cfg.version - t._cfg.version
            }

            function kn(e, t, n, r) {
                const s = e._dbSchema, a = e._createTransaction("readwrite", e._storeNames, s);
                a.create(n), a._completion.catch(r);
                const o = a._reject.bind(a), l = _e.transless || _e;
                nt((() => {
                    _e.trans = a, _e.transless = l, 0 === t ? (i(s).forEach((e => {
                        Tn(n, e, s[e].primKey, s[e].indexes)
                    })), wn(e, n), Ie.follow((() => e.on.populate.fire(a))).catch(o)) : function ({_novip: e}, t, n, r) {
                        const s = [], a = e._versions;
                        let o = e._dbSchema = Rn(0, e.idbdb, r), l = !1;
                        const c = a.filter((e => e._cfg.version >= t));
                        return c.forEach((a => {
                            s.push((() => {
                                const s = o, c = a._cfg.dbschema;
                                Ln(e, s, r), Ln(e, c, r), o = e._dbSchema = c;
                                const u = An(s, c);
                                u.add.forEach((e => {
                                    Tn(r, e[0], e[1].primKey, e[1].indexes)
                                })), u.change.forEach((e => {
                                    if (e.recreate) throw new ee.Upgrade("Not yet support for changing primary key");
                                    {
                                        const t = r.objectStore(e.name);
                                        e.add.forEach((e => Cn(t, e))), e.change.forEach((e => {
                                            t.deleteIndex(e.name), Cn(t, e)
                                        })), e.del.forEach((e => t.deleteIndex(e)))
                                    }
                                }));
                                const d = a._cfg.contentUpgrade;
                                if (d && a._cfg.version > t) {
                                    wn(e, r), n._memoizedTables = {}, l = !0;
                                    let t = k(c);
                                    u.del.forEach((e => {
                                        t[e] = s[e]
                                    })), En(e, [e.Transaction.prototype]), xn(e, [e.Transaction.prototype], i(t), t), n.schema = t;
                                    const a = B(d);
                                    let o;
                                    a && rt();
                                    const h = Ie.follow((() => {
                                        if (o = d(n), o && a) {
                                            var e = it.bind(null, null);
                                            o.then(e, e)
                                        }
                                    }));
                                    return o && "function" == typeof o.then ? Ie.resolve(o) : h.then((() => o))
                                }
                            })), s.push((t => {
                                l && At || function (e, t) {
                                    [].slice.call(t.db.objectStoreNames).forEach((n => null == e[n] && t.db.deleteObjectStore(n)))
                                }(a._cfg.dbschema, t), En(e, [e.Transaction.prototype]), xn(e, [e.Transaction.prototype], e._storeNames, e._dbSchema), n.schema = e._dbSchema
                            }))
                        })), function e() {
                            return s.length ? Ie.resolve(s.shift()(n.idbtrans)).then(e) : Ie.resolve()
                        }().then((() => {
                            var e, t;
                            t = r, i(e = o).forEach((n => {
                                t.db.objectStoreNames.contains(n) || Tn(t, n, e[n].primKey, e[n].indexes)
                            }))
                        }))
                    }(e, t, a, n).catch(o)
                }))
            }

            function An(e, t) {
                const n = {del: [], add: [], change: []};
                let r;
                for (r in e) t[r] || n.del.push(r);
                for (r in t) {
                    const i = e[r], s = t[r];
                    if (i) {
                        const e = {name: r, def: s, recreate: !1, del: [], add: [], change: []};
                        if ("" + (i.primKey.keyPath || "") != "" + (s.primKey.keyPath || "") || i.primKey.auto !== s.primKey.auto && !kt) e.recreate = !0, n.change.push(e); else {
                            const t = i.idxByName, r = s.idxByName;
                            let a;
                            for (a in t) r[a] || e.del.push(a);
                            for (a in r) {
                                const n = t[a], i = r[a];
                                n ? n.src !== i.src && e.change.push(i) : e.add.push(i)
                            }
                            (e.del.length > 0 || e.add.length > 0 || e.change.length > 0) && n.change.push(e)
                        }
                    } else n.add.push([r, s])
                }
                return n
            }

            function Tn(e, t, n, r) {
                const i = e.db.createObjectStore(t, n.keyPath ? {
                    keyPath: n.keyPath,
                    autoIncrement: n.auto
                } : {autoIncrement: n.auto});
                return r.forEach((e => Cn(i, e))), i
            }

            function Cn(e, t) {
                e.createIndex(t.name, t.keyPath, {unique: t.unique, multiEntry: t.multi})
            }

            function Rn(e, t, n) {
                const r = {};
                return y(t.objectStoreNames, 0).forEach((e => {
                    const t = n.objectStore(e);
                    let i = t.keyPath;
                    const s = dn(hn(i), i || "", !1, !1, !!t.autoIncrement, i && "string" != typeof i, !0), a = [];
                    for (let e = 0; e < t.indexNames.length; ++e) {
                        const n = t.index(t.indexNames[e]);
                        i = n.keyPath;
                        var o = dn(n.name, i, !!n.unique, !!n.multiEntry, !1, i && "string" != typeof i, !1);
                        a.push(o)
                    }
                    r[e] = fn(e, s, a)
                })), r
            }

            function Ln({_novip: e}, t, n) {
                const i = n.db.objectStoreNames;
                for (let r = 0; r < i.length; ++r) {
                    const s = i[r], a = n.objectStore(s);
                    e._hasGetAll = "getAll" in a;
                    for (let e = 0; e < a.indexNames.length; ++e) {
                        const n = a.indexNames[e], r = a.index(n).keyPath,
                            i = "string" == typeof r ? r : "[" + y(r).join("+") + "]";
                        if (t[s]) {
                            const e = t[s].idxByName[i];
                            e && (e.name = n, delete t[s].idxByName[i], t[s].idxByName[n] = e)
                        }
                    }
                }
                "undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && r.WorkerGlobalScope && r instanceof r.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1)
            }

            class _n {
                _parseStoresSpec(e, t) {
                    i(e).forEach((n => {
                        if (null !== e[n]) {
                            var r = e[n].split(",").map(((e, t) => {
                                const n = (e = e.trim()).replace(/([&*]|\+\+)/g, ""),
                                    r = /^\[/.test(n) ? n.match(/^\[(.*)\]$/)[1].split("+") : n;
                                return dn(n, r || null, /\&/.test(e), /\*/.test(e), /\+\+/.test(e), s(r), 0 === t)
                            })), i = r.shift();
                            if (i.multi) throw new ee.Schema("Primary key cannot be multi-valued");
                            r.forEach((e => {
                                if (e.auto) throw new ee.Schema("Only primary key can be marked as autoIncrement (++)");
                                if (!e.keyPath) throw new ee.Schema("Index must have a name and cannot be an empty string")
                            })), t[n] = fn(n, i, r)
                        }
                    }))
                }

                stores(e) {
                    const t = this.db;
                    this._cfg.storesSource = this._cfg.storesSource ? a(this._cfg.storesSource, e) : e;
                    const n = t._versions, r = {};
                    let s = {};
                    return n.forEach((e => {
                        a(r, e._cfg.storesSource), s = e._cfg.dbschema = {}, e._parseStoresSpec(r, s)
                    })), t._dbSchema = s, En(t, [t._allTables, t, t.Transaction.prototype]), xn(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], i(s), s), t._storeNames = i(s), this
                }

                upgrade(e) {
                    return this._cfg.contentUpgrade = de(this._cfg.contentUpgrade || re, e), this
                }
            }

            function Pn(e, t) {
                let n = e._dbNamesDB;
                return n || (n = e._dbNamesDB = new Jn(Rt, {
                    addons: [],
                    indexedDB: e,
                    IDBKeyRange: t
                }), n.version(1).stores({dbnames: "name"})), n.table("dbnames")
            }

            function Nn(e) {
                return e && "function" == typeof e.databases
            }

            function jn(e) {
                return nt((function () {
                    return _e.letThrough = !0, e()
                }))
            }

            function In() {
                var e;
                return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise((function (t) {
                    var n = function () {
                        return indexedDB.databases().finally(t)
                    };
                    e = setInterval(n, 100), n()
                })).finally((function () {
                    return clearInterval(e)
                })) : Promise.resolve()
            }

            function Mn(e) {
                var t = t => e.next(t), n = i(t), r = i((t => e.throw(t)));

                function i(e) {
                    return t => {
                        var i = e(t), a = i.value;
                        return i.done ? a : a && "function" == typeof a.then ? a.then(n, r) : s(a) ? Promise.all(a).then(n, r) : n(a)
                    }
                }

                return i(t)()
            }

            function Dn(e, t, n) {
                var r = arguments.length;
                if (r < 2) throw new ee.InvalidArgument("Too few arguments");
                for (var i = new Array(r - 1); --r;) i[r - 1] = arguments[r];
                return n = i.pop(), [e, T(i), n]
            }

            function On(e, t, n, r, i) {
                return Ie.resolve().then((() => {
                    const s = _e.transless || _e, a = e._createTransaction(t, n, e._dbSchema, r),
                        o = {trans: a, transless: s};
                    if (r) a.idbtrans = r.idbtrans; else try {
                        a.create(), e._state.PR1398_maxLoop = 3
                    } catch (r) {
                        return r.name === Q.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then((() => On(e, t, n, null, i)))) : gt(r)
                    }
                    const l = B(i);
                    let c;
                    l && rt();
                    const u = Ie.follow((() => {
                        if (c = i.call(a, a), c) if (l) {
                            var e = it.bind(null, null);
                            c.then(e, e)
                        } else "function" == typeof c.next && "function" == typeof c.throw && (c = Mn(c))
                    }), o);
                    return (c && "function" == typeof c.then ? Ie.resolve(c).then((e => a.active ? e : gt(new ee.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")))) : u.then((() => c))).then((e => (r && a._resolve(), a._completion.then((() => e))))).catch((e => (a._reject(e), gt(e))))
                }))
            }

            function Bn(e, t, n) {
                const r = s(e) ? e.slice() : [e];
                for (let e = 0; e < n; ++e) r.push(t);
                return r
            }

            const Fn = {
                stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function (e) {
                    return {
                        ...e, table(t) {
                            const n = e.table(t), {schema: r} = n, i = {}, s = [];

                            function a(e, t, n) {
                                const r = vn(e), o = i[r] = i[r] || [],
                                    l = null == e ? 0 : "string" == typeof e ? 1 : e.length, c = t > 0, u = {
                                        ...n,
                                        isVirtual: c,
                                        keyTail: t,
                                        keyLength: l,
                                        extractKey: mn(e),
                                        unique: !c && n.unique
                                    };
                                return o.push(u), u.isPrimaryKey || s.push(u), l > 1 && a(2 === l ? e[0] : e.slice(0, l - 1), t + 1, n), o.sort(((e, t) => e.keyTail - t.keyTail)), u
                            }

                            const o = a(r.primaryKey.keyPath, 0, r.primaryKey);
                            i[":id"] = [o];
                            for (const e of r.indexes) a(e.keyPath, 0, e);

                            function l(t) {
                                const n = t.query.index;
                                return n.isVirtual ? {
                                    ...t,
                                    query: {
                                        index: n,
                                        range: (r = t.query.range, i = n.keyTail, {
                                            type: 1 === r.type ? 2 : r.type,
                                            lower: Bn(r.lower, r.lowerOpen ? e.MAX_KEY : e.MIN_KEY, i),
                                            lowerOpen: !0,
                                            upper: Bn(r.upper, r.upperOpen ? e.MIN_KEY : e.MAX_KEY, i),
                                            upperOpen: !0
                                        })
                                    }
                                } : t;
                                var r, i
                            }

                            const c = {
                                ...n, schema: {
                                    ...r, primaryKey: o, indexes: s, getIndexByKeyPath: function (e) {
                                        const t = i[vn(e)];
                                        return t && t[0]
                                    }
                                }, count: e => n.count(l(e)), query: e => n.query(l(e)), openCursor(t) {
                                    const {keyTail: r, isVirtual: i, keyLength: s} = t.query.index;
                                    return i ? n.openCursor(l(t)).then((n => n && function (n) {
                                        const i = Object.create(n, {
                                            continue: {
                                                value: function (i) {
                                                    null != i ? n.continue(Bn(i, t.reverse ? e.MAX_KEY : e.MIN_KEY, r)) : t.unique ? n.continue(n.key.slice(0, s).concat(t.reverse ? e.MIN_KEY : e.MAX_KEY, r)) : n.continue()
                                                }
                                            }, continuePrimaryKey: {
                                                value(t, i) {
                                                    n.continuePrimaryKey(Bn(t, e.MAX_KEY, r), i)
                                                }
                                            }, primaryKey: {get: () => n.primaryKey}, key: {
                                                get() {
                                                    const e = n.key;
                                                    return 1 === s ? e[0] : e.slice(0, s)
                                                }
                                            }, value: {get: () => n.value}
                                        });
                                        return i
                                    }(n))) : n.openCursor(t)
                                }
                            };
                            return c
                        }
                    }
                }
            };

            function Un(e, t, n, r) {
                return n = n || {}, r = r || "", i(e).forEach((i => {
                    if (c(t, i)) {
                        var s = e[i], a = t[i];
                        if ("object" == typeof s && "object" == typeof a && s && a) {
                            const e = j(s);
                            e !== j(a) ? n[r + i] = t[i] : "Object" === e ? Un(s, a, n, r + i + ".") : s !== a && (n[r + i] = t[i])
                        } else s !== a && (n[r + i] = t[i])
                    } else n[r + i] = void 0
                })), i(t).forEach((i => {
                    c(e, i) || (n[r + i] = t[i])
                })), n
            }

            const Hn = {
                stack: "dbcore", name: "HooksMiddleware", level: 2, create: e => ({
                    ...e, table(t) {
                        const n = e.table(t), {primaryKey: r} = n.schema, i = {
                            ...n, mutate(e) {
                                const i = _e.trans, {deleting: s, creating: a, updating: o} = i.table(t).hook;
                                switch (e.type) {
                                    case"add":
                                        if (a.fire === re) break;
                                        return i._promise("readwrite", (() => l(e)), !0);
                                    case"put":
                                        if (a.fire === re && o.fire === re) break;
                                        return i._promise("readwrite", (() => l(e)), !0);
                                    case"delete":
                                        if (s.fire === re) break;
                                        return i._promise("readwrite", (() => l(e)), !0);
                                    case"deleteRange":
                                        if (s.fire === re) break;
                                        return i._promise("readwrite", (() => function (e) {
                                            return u(e.trans, e.range, 1e4)
                                        }(e)), !0)
                                }
                                return n.mutate(e);

                                function l(e) {
                                    const t = _e.trans, i = e.keys || function (e, t) {
                                        return "delete" === t.type ? t.keys : t.keys || t.values.map(e.extractKey)
                                    }(r, e);
                                    if (!i) throw new Error("Keys missing");
                                    return "delete" !== (e = "add" === e.type || "put" === e.type ? {
                                        ...e,
                                        keys: i
                                    } : {...e}).type && (e.values = [...e.values]), e.keys && (e.keys = [...e.keys]), function (e, t, n) {
                                        return "add" === t.type ? Promise.resolve([]) : e.getMany({
                                            trans: t.trans,
                                            keys: n,
                                            cache: "immutable"
                                        })
                                    }(n, e, i).then((l => {
                                        const u = i.map(((n, i) => {
                                            const u = l[i], d = {onerror: null, onsuccess: null};
                                            if ("delete" === e.type) s.fire.call(d, n, u, t); else if ("add" === e.type || void 0 === u) {
                                                const s = a.fire.call(d, n, e.values[i], t);
                                                null == n && null != s && (n = s, e.keys[i] = n, r.outbound || S(e.values[i], r.keyPath, n))
                                            } else {
                                                const r = Un(u, e.values[i]), s = o.fire.call(d, r, n, u, t);
                                                if (s) {
                                                    const t = e.values[i];
                                                    Object.keys(s).forEach((e => {
                                                        c(t, e) ? t[e] = s[e] : S(t, e, s[e])
                                                    }))
                                                }
                                            }
                                            return d
                                        }));
                                        return n.mutate(e).then((({
                                                                      failures: t,
                                                                      results: n,
                                                                      numFailures: r,
                                                                      lastResult: s
                                                                  }) => {
                                            for (let r = 0; r < i.length; ++r) {
                                                const s = n ? n[r] : i[r], a = u[r];
                                                null == s ? a.onerror && a.onerror(t[r]) : a.onsuccess && a.onsuccess("put" === e.type && l[r] ? e.values[r] : s)
                                            }
                                            return {failures: t, results: n, numFailures: r, lastResult: s}
                                        })).catch((e => (u.forEach((t => t.onerror && t.onerror(e))), Promise.reject(e))))
                                    }))
                                }

                                function u(e, t, i) {
                                    return n.query({
                                        trans: e,
                                        values: !1,
                                        query: {index: r, range: t},
                                        limit: i
                                    }).then((({result: n}) => l({
                                        type: "delete",
                                        keys: n,
                                        trans: e
                                    }).then((r => r.numFailures > 0 ? Promise.reject(r.failures[0]) : n.length < i ? {
                                        failures: [],
                                        numFailures: 0,
                                        lastResult: void 0
                                    } : u(e, {...t, lower: n[n.length - 1], lowerOpen: !0}, i)))))
                                }
                            }
                        };
                        return i
                    }
                })
            };

            function $n(e, t, n) {
                try {
                    if (!t) return null;
                    if (t.keys.length < e.length) return null;
                    const r = [];
                    for (let i = 0, s = 0; i < t.keys.length && s < e.length; ++i) 0 === zt(t.keys[i], e[s]) && (r.push(n ? _(t.values[i]) : t.values[i]), ++s);
                    return r.length === e.length ? r : null
                } catch (e) {
                    return null
                }
            }

            const Kn = {
                stack: "dbcore", level: -1, create: e => ({
                    table: t => {
                        const n = e.table(t);
                        return {
                            ...n, getMany: e => {
                                if (!e.cache) return n.getMany(e);
                                const t = $n(e.keys, e.trans._cache, "clone" === e.cache);
                                return t ? Ie.resolve(t) : n.getMany(e).then((t => (e.trans._cache = {
                                    keys: e.keys,
                                    values: "clone" === e.cache ? _(t) : t
                                }, t)))
                            }, mutate: e => ("add" !== e.type && (e.trans._cache = null), n.mutate(e))
                        }
                    }
                })
            };

            function zn(e) {
                return !("from" in e)
            }

            const Gn = function (e, t) {
                if (!this) {
                    const t = new Gn;
                    return e && "d" in e && a(t, e), t
                }
                a(this, arguments.length ? {d: 1, from: e, to: arguments.length > 1 ? t : e} : {d: 0})
            };

            function qn(e, t, n) {
                const r = zt(t, n);
                if (isNaN(r)) return;
                if (r > 0) throw RangeError();
                if (zn(e)) return a(e, {from: t, to: n, d: 1});
                const i = e.l, s = e.r;
                if (zt(n, e.from) < 0) return i ? qn(i, t, n) : e.l = {from: t, to: n, d: 1, l: null, r: null}, Zn(e);
                if (zt(t, e.to) > 0) return s ? qn(s, t, n) : e.r = {from: t, to: n, d: 1, l: null, r: null}, Zn(e);
                zt(t, e.from) < 0 && (e.from = t, e.l = null, e.d = s ? s.d + 1 : 1), zt(n, e.to) > 0 && (e.to = n, e.r = null, e.d = e.l ? e.l.d + 1 : 1);
                const o = !e.r;
                i && !e.l && Wn(e, i), s && o && Wn(e, s)
            }

            function Wn(e, t) {
                zn(t) || function e(t, {from: n, to: r, l: i, r: s}) {
                    qn(t, n, r), i && e(t, i), s && e(t, s)
                }(e, t)
            }

            function Vn(e, t) {
                const n = Yn(t);
                let r = n.next();
                if (r.done) return !1;
                let i = r.value;
                const s = Yn(e);
                let a = s.next(i.from), o = a.value;
                for (; !r.done && !a.done;) {
                    if (zt(o.from, i.to) <= 0 && zt(o.to, i.from) >= 0) return !0;
                    zt(i.from, o.from) < 0 ? i = (r = n.next(o.from)).value : o = (a = s.next(i.from)).value
                }
                return !1
            }

            function Yn(e) {
                let t = zn(e) ? null : {s: 0, n: e};
                return {
                    next(e) {
                        const n = arguments.length > 0;
                        for (; t;) switch (t.s) {
                            case 0:
                                if (t.s = 1, n) for (; t.n.l && zt(e, t.n.from) < 0;) t = {
                                    up: t,
                                    n: t.n.l,
                                    s: 1
                                }; else for (; t.n.l;) t = {up: t, n: t.n.l, s: 1};
                            case 1:
                                if (t.s = 2, !n || zt(e, t.n.to) <= 0) return {value: t.n, done: !1};
                            case 2:
                                if (t.n.r) {
                                    t.s = 3, t = {up: t, n: t.n.r, s: 0};
                                    continue
                                }
                            case 3:
                                t = t.up
                        }
                        return {done: !0}
                    }
                }
            }

            function Zn(e) {
                var t, n;
                const r = ((null === (t = e.r) || void 0 === t ? void 0 : t.d) || 0) - ((null === (n = e.l) || void 0 === n ? void 0 : n.d) || 0),
                    i = r > 1 ? "r" : r < -1 ? "l" : "";
                if (i) {
                    const t = "r" === i ? "l" : "r", n = {...e}, r = e[i];
                    e.from = r.from, e.to = r.to, e[i] = r[i], n[i] = r[t], e[t] = n, n.d = Xn(n)
                }
                e.d = Xn(e)
            }

            function Xn({r: e, l: t}) {
                return (e ? t ? Math.max(e.d, t.d) : e.d : t ? t.d : 0) + 1
            }

            u(Gn.prototype, {
                add(e) {
                    return Wn(this, e), this
                }, addKey(e) {
                    return qn(this, e, e), this
                }, addKeys(e) {
                    return e.forEach((e => qn(this, e, e))), this
                }, [I]() {
                    return Yn(this)
                }
            });
            const Qn = {
                stack: "dbcore", level: 0, create: e => {
                    const t = e.schema.name, n = new Gn(e.MIN_KEY, e.MAX_KEY);
                    return {
                        ...e, table: r => {
                            const a = e.table(r), {schema: o} = a, {primaryKey: l} = o, {
                                extractKey: c,
                                outbound: u
                            } = l, d = {
                                ...a, mutate: e => {
                                    const i = e.trans, l = i.mutatedParts || (i.mutatedParts = {}), c = e => {
                                        const n = `idb://${t}/${r}/${e}`;
                                        return l[n] || (l[n] = new Gn)
                                    }, u = c(""), d = c(":dels"), {type: h} = e;
                                    let [f, p] = "deleteRange" === e.type ? [e.range] : "delete" === e.type ? [e.keys] : e.values.length < 50 ? [[], e.values] : [];
                                    const m = e.trans._cache;
                                    return a.mutate(e).then((e => {
                                        if (s(f)) {
                                            "delete" !== h && (f = e.results), u.addKeys(f);
                                            const t = $n(f, m);
                                            t || "add" === h || d.addKeys(f), (t || p) && function (e, t, n, r) {
                                                t.indexes.forEach((function (t) {
                                                    const i = e(t.name || "");

                                                    function a(e) {
                                                        return null != e ? t.extractKey(e) : null
                                                    }

                                                    const o = e => t.multiEntry && s(e) ? e.forEach((e => i.addKey(e))) : i.addKey(e);
                                                    (n || r).forEach(((e, t) => {
                                                        const i = n && a(n[t]), s = r && a(r[t]);
                                                        0 !== zt(i, s) && (null != i && o(i), null != s && o(s))
                                                    }))
                                                }))
                                            }(c, o, t, p)
                                        } else if (f) {
                                            const e = {from: f.lower, to: f.upper};
                                            d.add(e), u.add(e)
                                        } else u.add(n), d.add(n), o.indexes.forEach((e => c(e.name).add(n)));
                                        return e
                                    }))
                                }
                            }, h = ({query: {index: t, range: n}}) => {
                                var r, i;
                                return [t, new Gn(null !== (r = n.lower) && void 0 !== r ? r : e.MIN_KEY, null !== (i = n.upper) && void 0 !== i ? i : e.MAX_KEY)]
                            }, f = {
                                get: e => [l, new Gn(e.key)],
                                getMany: e => [l, (new Gn).addKeys(e.keys)],
                                count: h,
                                query: h,
                                openCursor: h
                            };
                            return i(f).forEach((e => {
                                d[e] = function (i) {
                                    const {subscr: s} = _e;
                                    if (s) {
                                        const o = e => {
                                            const n = `idb://${t}/${r}/${e}`;
                                            return s[n] || (s[n] = new Gn)
                                        }, l = o(""), d = o(":dels"), [h, p] = f[e](i);
                                        if (o(h.name || "").add(p), !h.isPrimaryKey) {
                                            if ("count" !== e) {
                                                const t = "query" === e && u && i.values && a.query({...i, values: !1});
                                                return a[e].apply(this, arguments).then((n => {
                                                    if ("query" === e) {
                                                        if (u && i.values) return t.then((({result: e}) => (l.addKeys(e), n)));
                                                        const e = i.values ? n.result.map(c) : n.result;
                                                        i.values ? l.addKeys(e) : d.addKeys(e)
                                                    } else if ("openCursor" === e) {
                                                        const e = n, t = i.values;
                                                        return e && Object.create(e, {
                                                            key: {get: () => (d.addKey(e.primaryKey), e.key)},
                                                            primaryKey: {
                                                                get() {
                                                                    const t = e.primaryKey;
                                                                    return d.addKey(t), t
                                                                }
                                                            },
                                                            value: {get: () => (t && l.addKey(e.primaryKey), e.value)}
                                                        })
                                                    }
                                                    return n
                                                }))
                                            }
                                            d.add(n)
                                        }
                                    }
                                    return a[e].apply(this, arguments)
                                }
                            })), d
                        }
                    }
                }
            };

            class Jn {
                constructor(e, t) {
                    this._middlewares = {}, this.verno = 0;
                    const n = Jn.dependencies;
                    this._options = t = {
                        addons: Jn.addons,
                        autoOpen: !0,
                        indexedDB: n.indexedDB,
                        IDBKeyRange: n.IDBKeyRange, ...t
                    }, this._deps = {indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange};
                    const {addons: r} = t;
                    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
                    const i = {
                        dbOpenError: null,
                        isBeingOpened: !1,
                        onReadyBeingFired: null,
                        openComplete: !1,
                        dbReadyResolve: re,
                        dbReadyPromise: null,
                        cancelOpen: re,
                        openCanceller: null,
                        autoSchema: !0,
                        PR1398_maxLoop: 3
                    };
                    var s;
                    i.dbReadyPromise = new Ie((e => {
                        i.dbReadyResolve = e
                    })), i.openCanceller = new Ie(((e, t) => {
                        i.cancelOpen = t
                    })), this._state = i, this.name = e, this.on = Mt(this, "populate", "blocked", "versionchange", "close", {ready: [de, re]}), this.on.ready.subscribe = v(this.on.ready.subscribe, (e => (t, n) => {
                        Jn.vip((() => {
                            const r = this._state;
                            if (r.openComplete) r.dbOpenError || Ie.resolve().then(t), n && e(t); else if (r.onReadyBeingFired) r.onReadyBeingFired.push(t), n && e(t); else {
                                e(t);
                                const r = this;
                                n || e((function e() {
                                    r.on.ready.unsubscribe(t), r.on.ready.unsubscribe(e)
                                }))
                            }
                        }))
                    })), this.Collection = (s = this, Dt(Wt.prototype, (function (e, t) {
                        this.db = s;
                        let n = Nt, r = null;
                        if (t) try {
                            n = t()
                        } catch (e) {
                            r = e
                        }
                        const i = e._ctx, a = i.table, o = a.hook.reading.fire;
                        this._ctx = {
                            table: a,
                            index: i.index,
                            isPrimKey: !i.index || a.schema.primKey.keyPath && i.index === a.schema.primKey.name,
                            range: n,
                            keysOnly: !1,
                            dir: "next",
                            unique: "",
                            algorithm: null,
                            filter: null,
                            replayFilter: null,
                            justLimit: !0,
                            isMatch: null,
                            offset: 0,
                            limit: 1 / 0,
                            error: r,
                            or: i.or,
                            valueMapper: o !== ie ? o : null
                        }
                    }))), this.Table = function (e) {
                        return Dt(It.prototype, (function (t, n, r) {
                            this.db = e, this._tx = r, this.name = t, this.schema = n, this.hook = e._allTables[t] ? e._allTables[t].hook : Mt(null, {
                                creating: [oe, re],
                                reading: [se, ie],
                                updating: [ce, re],
                                deleting: [le, re]
                            })
                        }))
                    }(this), this.Transaction = function (e) {
                        return Dt(un.prototype, (function (t, n, r, i, s) {
                            this.db = e, this.mode = t, this.storeNames = n, this.schema = r, this.chromeTransactionDurability = i, this.idbtrans = null, this.on = Mt(this, "complete", "error", "abort"), this.parent = s || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Ie(((e, t) => {
                                this._resolve = e, this._reject = t
                            })), this._completion.then((() => {
                                this.active = !1, this.on.complete.fire()
                            }), (e => {
                                var t = this.active;
                                return this.active = !1, this.on.error.fire(e), this.parent ? this.parent._reject(e) : t && this.idbtrans && this.idbtrans.abort(), gt(e)
                            }))
                        }))
                    }(this), this.Version = function (e) {
                        return Dt(_n.prototype, (function (t) {
                            this.db = e, this._cfg = {
                                version: t,
                                storesSource: null,
                                dbschema: {},
                                tables: {},
                                contentUpgrade: null
                            }
                        }))
                    }(this), this.WhereClause = function (e) {
                        return Dt(rn.prototype, (function (t, n, r) {
                            this.db = e, this._ctx = {table: t, index: ":id" === n ? null : n, or: r};
                            const i = e._deps.indexedDB;
                            if (!i) throw new ee.MissingAPI;
                            this._cmp = this._ascending = i.cmp.bind(i), this._descending = (e, t) => i.cmp(t, e), this._max = (e, t) => i.cmp(e, t) > 0 ? e : t, this._min = (e, t) => i.cmp(e, t) < 0 ? e : t, this._IDBKeyRange = e._deps.IDBKeyRange
                        }))
                    }(this), this.on("versionchange", (e => {
                        e.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close()
                    })), this.on("blocked", (e => {
                        !e.newVersion || e.newVersion < e.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${e.oldVersion / 10}`)
                    })), this._maxKey = pn(t.IDBKeyRange), this._createTransaction = (e, t, n, r) => new this.Transaction(e, t, n, this._options.chromeTransactionDurability, r), this._fireOnBlocked = e => {
                        this.on("blocked").fire(e), St.filter((e => e.name === this.name && e !== this && !e._state.vcFired)).map((t => t.on("versionchange").fire(e)))
                    }, this.use(Fn), this.use(Hn), this.use(Qn), this.use(Kn), this.vip = Object.create(this, {_vip: {value: !0}}), r.forEach((e => e(this)))
                }

                version(e) {
                    if (isNaN(e) || e < .1) throw new ee.Type("Given version is not a positive number");
                    if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new ee.Schema("Cannot add version when database is open");
                    this.verno = Math.max(this.verno, e);
                    const t = this._versions;
                    var n = t.filter((t => t._cfg.version === e))[0];
                    return n || (n = new this.Version(e), t.push(n), t.sort(Sn), n.stores({}), this._state.autoSchema = !1, n)
                }

                _whenReady(e) {
                    return this.idbdb && (this._state.openComplete || _e.letThrough || this._vip) ? e() : new Ie(((e, t) => {
                        if (this._state.openComplete) return t(new ee.DatabaseClosed(this._state.dbOpenError));
                        if (!this._state.isBeingOpened) {
                            if (!this._options.autoOpen) return void t(new ee.DatabaseClosed);
                            this.open().catch(re)
                        }
                        this._state.dbReadyPromise.then(e, t)
                    })).then(e)
                }

                use({stack: e, create: t, level: n, name: r}) {
                    r && this.unuse({stack: e, name: r});
                    const i = this._middlewares[e] || (this._middlewares[e] = []);
                    return i.push({
                        stack: e,
                        create: t,
                        level: null == n ? 10 : n,
                        name: r
                    }), i.sort(((e, t) => e.level - t.level)), this
                }

                unuse({stack: e, name: t, create: n}) {
                    return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter((e => n ? e.create !== n : !!t && e.name !== t))), this
                }

                open() {
                    return function (e) {
                        const t = e._state, {indexedDB: n} = e._deps;
                        if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then((() => t.dbOpenError ? gt(t.dbOpenError) : e));
                        F && (t.openCanceller._stackHolder = K()), t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
                        const r = t.openCanceller;

                        function s() {
                            if (t.openCanceller !== r) throw new ee.DatabaseClosed("db.open() was cancelled")
                        }

                        let a = t.dbReadyResolve, o = null, l = !1;
                        return Ie.race([r, ("undefined" == typeof navigator ? Ie.resolve() : In()).then((() => new Ie(((r, a) => {
                            if (s(), !n) throw new ee.MissingAPI;
                            const c = e.name, u = t.autoSchema ? n.open(c) : n.open(c, Math.round(10 * e.verno));
                            if (!u) throw new ee.MissingAPI;
                            u.onerror = sn(a), u.onblocked = Ye(e._fireOnBlocked), u.onupgradeneeded = Ye((r => {
                                if (o = u.transaction, t.autoSchema && !e._options.allowEmptyDB) {
                                    u.onerror = an, o.abort(), u.result.close();
                                    const e = n.deleteDatabase(c);
                                    e.onsuccess = e.onerror = Ye((() => {
                                        a(new ee.NoSuchDatabase(`Database ${c} doesnt exist`))
                                    }))
                                } else {
                                    o.onerror = sn(a);
                                    var i = r.oldVersion > Math.pow(2, 62) ? 0 : r.oldVersion;
                                    l = i < 1, e._novip.idbdb = u.result, kn(e, i / 10, o, a)
                                }
                            }), a), u.onsuccess = Ye((() => {
                                o = null;
                                const n = e._novip.idbdb = u.result, s = y(n.objectStoreNames);
                                if (s.length > 0) try {
                                    const r = n.transaction(1 === (a = s).length ? a[0] : a, "readonly");
                                    t.autoSchema ? function ({_novip: e}, t, n) {
                                        e.verno = t.version / 10;
                                        const r = e._dbSchema = Rn(0, t, n);
                                        e._storeNames = y(t.objectStoreNames, 0), xn(e, [e._allTables], i(r), r)
                                    }(e, n, r) : (Ln(e, e._dbSchema, r), function (e, t) {
                                        const n = An(Rn(0, e.idbdb, t), e._dbSchema);
                                        return !(n.add.length || n.change.some((e => e.add.length || e.change.length)))
                                    }(e, r) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), wn(e, r)
                                } catch (e) {
                                }
                                var a;
                                St.push(e), n.onversionchange = Ye((n => {
                                    t.vcFired = !0, e.on("versionchange").fire(n)
                                })), n.onclose = Ye((t => {
                                    e.on("close").fire(t)
                                })), l && function ({indexedDB: e, IDBKeyRange: t}, n) {
                                    !Nn(e) && n !== Rt && Pn(e, t).put({name: n}).catch(re)
                                }(e._deps, c), r()
                            }), a)
                        }))))]).then((() => (s(), t.onReadyBeingFired = [], Ie.resolve(jn((() => e.on.ready.fire(e.vip)))).then((function n() {
                            if (t.onReadyBeingFired.length > 0) {
                                let r = t.onReadyBeingFired.reduce(de, re);
                                return t.onReadyBeingFired = [], Ie.resolve(jn((() => r(e.vip)))).then(n)
                            }
                        }))))).finally((() => {
                            t.onReadyBeingFired = null, t.isBeingOpened = !1
                        })).then((() => e)).catch((n => {
                            t.dbOpenError = n;
                            try {
                                o && o.abort()
                            } catch (e) {
                            }
                            return r === t.openCanceller && e._close(), gt(n)
                        })).finally((() => {
                            t.openComplete = !0, a()
                        }))
                    }(this)
                }

                _close() {
                    const e = this._state, t = St.indexOf(this);
                    if (t >= 0 && St.splice(t, 1), this.idbdb) {
                        try {
                            this.idbdb.close()
                        } catch (e) {
                        }
                        this._novip.idbdb = null
                    }
                    e.dbReadyPromise = new Ie((t => {
                        e.dbReadyResolve = t
                    })), e.openCanceller = new Ie(((t, n) => {
                        e.cancelOpen = n
                    }))
                }

                close() {
                    this._close();
                    const e = this._state;
                    this._options.autoOpen = !1, e.dbOpenError = new ee.DatabaseClosed, e.isBeingOpened && e.cancelOpen(e.dbOpenError)
                }

                delete() {
                    const e = arguments.length > 0, t = this._state;
                    return new Ie(((n, r) => {
                        const i = () => {
                            this.close();
                            var e = this._deps.indexedDB.deleteDatabase(this.name);
                            e.onsuccess = Ye((() => {
                                !function ({indexedDB: e, IDBKeyRange: t}, n) {
                                    !Nn(e) && n !== Rt && Pn(e, t).delete(n).catch(re)
                                }(this._deps, this.name), n()
                            })), e.onerror = sn(r), e.onblocked = this._fireOnBlocked
                        };
                        if (e) throw new ee.InvalidArgument("Arguments not allowed in db.delete()");
                        t.isBeingOpened ? t.dbReadyPromise.then(i) : i()
                    }))
                }

                backendDB() {
                    return this.idbdb
                }

                isOpen() {
                    return null !== this.idbdb
                }

                hasBeenClosed() {
                    const e = this._state.dbOpenError;
                    return e && "DatabaseClosed" === e.name
                }

                hasFailed() {
                    return null !== this._state.dbOpenError
                }

                dynamicallyOpened() {
                    return this._state.autoSchema
                }

                get tables() {
                    return i(this._allTables).map((e => this._allTables[e]))
                }

                transaction() {
                    const e = Dn.apply(this, arguments);
                    return this._transaction.apply(this, e)
                }

                _transaction(e, t, n) {
                    let r = _e.trans;
                    r && r.db === this && -1 === e.indexOf("!") || (r = null);
                    const i = -1 !== e.indexOf("?");
                    let s, a;
                    e = e.replace("!", "").replace("?", "");
                    try {
                        if (a = t.map((e => {
                            var t = e instanceof this.Table ? e.name : e;
                            if ("string" != typeof t) throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                            return t
                        })), "r" == e || e === Lt) s = Lt; else {
                            if ("rw" != e && e != _t) throw new ee.InvalidArgument("Invalid transaction mode: " + e);
                            s = _t
                        }
                        if (r) {
                            if (r.mode === Lt && s === _t) {
                                if (!i) throw new ee.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                                r = null
                            }
                            r && a.forEach((e => {
                                if (r && -1 === r.storeNames.indexOf(e)) {
                                    if (!i) throw new ee.SubTransaction("Table " + e + " not included in parent transaction.");
                                    r = null
                                }
                            })), i && r && !r.active && (r = null)
                        }
                    } catch (e) {
                        return r ? r._promise(null, ((t, n) => {
                            n(e)
                        })) : gt(e)
                    }
                    const o = On.bind(null, this, s, a, r, n);
                    return r ? r._promise(s, o, "lock") : _e.trans ? ut(_e.transless, (() => this._whenReady(o))) : this._whenReady(o)
                }

                table(e) {
                    if (!c(this._allTables, e)) throw new ee.InvalidTable(`Table ${e} does not exist`);
                    return this._allTables[e]
                }
            }

            const er = "undefined" != typeof Symbol && "observable" in Symbol ? Symbol.observable : "@@observable";

            class tr {
                constructor(e) {
                    this._subscribe = e
                }

                subscribe(e, t, n) {
                    return this._subscribe(e && "function" != typeof e ? e : {next: e, error: t, complete: n})
                }

                [er]() {
                    return this
                }
            }

            function nr(e, t) {
                return i(t).forEach((n => {
                    Wn(e[n] || (e[n] = new Gn), t[n])
                })), e
            }

            function rr(e) {
                let t, n = !1;
                const r = new tr((r => {
                    const s = B(e);
                    let a = !1, o = {}, l = {};
                    const c = {
                        get closed() {
                            return a
                        }, unsubscribe: () => {
                            a = !0, cn.storagemutated.unsubscribe(f)
                        }
                    };
                    r.start && r.start(c);
                    let u = !1, d = !1;

                    function h() {
                        return i(l).some((e => o[e] && Vn(o[e], l[e])))
                    }

                    const f = e => {
                        nr(o, e), h() && p()
                    }, p = () => {
                        if (u || a) return;
                        o = {};
                        const i = {}, m = function (t) {
                            s && rt();
                            const n = () => nt(e, {subscr: t, trans: null}), r = _e.trans ? ut(_e.transless, n) : n();
                            return s && r.then(it, it), r
                        }(i);
                        d || (cn(on, f), d = !0), u = !0, Promise.resolve(m).then((e => {
                            n = !0, t = e, u = !1, a || (h() ? p() : (o = {}, l = i, r.next && r.next(e)))
                        }), (e => {
                            u = !1, n = !1, r.error && r.error(e), c.unsubscribe()
                        }))
                    };
                    return p(), c
                }));
                return r.hasValue = () => n, r.getValue = () => t, r
            }

            let ir;
            try {
                ir = {
                    indexedDB: r.indexedDB || r.mozIndexedDB || r.webkitIndexedDB || r.msIndexedDB,
                    IDBKeyRange: r.IDBKeyRange || r.webkitIDBKeyRange
                }
            } catch (r) {
                ir = {indexedDB: null, IDBKeyRange: null}
            }
            const sr = Jn;

            function ar(e) {
                let t = or;
                try {
                    or = !0, cn.storagemutated.fire(e)
                } finally {
                    or = t
                }
            }

            u(sr, {
                ...ne,
                delete: e => new sr(e, {addons: []}).delete(),
                exists: e => new sr(e, {addons: []}).open().then((e => (e.close(), !0))).catch("NoSuchDatabaseError", (() => !1)),
                getDatabaseNames(e) {
                    try {
                        return function ({indexedDB: e, IDBKeyRange: t}) {
                            return Nn(e) ? Promise.resolve(e.databases()).then((e => e.map((e => e.name)).filter((e => e !== Rt)))) : Pn(e, t).toCollection().primaryKeys()
                        }(sr.dependencies).then(e)
                    } catch (e) {
                        return gt(new ee.MissingAPI)
                    }
                },
                defineClass: () => function (e) {
                    a(this, e)
                },
                ignoreTransaction: e => _e.trans ? ut(_e.transless, e) : e(),
                vip: jn,
                async: function (e) {
                    return function () {
                        try {
                            var t = Mn(e.apply(this, arguments));
                            return t && "function" == typeof t.then ? t : Ie.resolve(t)
                        } catch (e) {
                            return gt(e)
                        }
                    }
                },
                spawn: function (e, t, n) {
                    try {
                        var r = Mn(e.apply(n, t || []));
                        return r && "function" == typeof r.then ? r : Ie.resolve(r)
                    } catch (e) {
                        return gt(e)
                    }
                },
                currentTransaction: {get: () => _e.trans || null},
                waitFor: function (e, t) {
                    const n = Ie.resolve("function" == typeof e ? sr.ignoreTransaction(e) : e).timeout(t || 6e4);
                    return _e.trans ? _e.trans.waitFor(n) : n
                },
                Promise: Ie,
                debug: {
                    get: () => F, set: e => {
                        U(e, "dexie" === e ? () => !0 : Ct)
                    }
                },
                derive: f,
                extend: a,
                props: u,
                override: v,
                Events: Mt,
                on: cn,
                liveQuery: rr,
                extendObservabilitySet: nr,
                getByKeyPath: E,
                setByKeyPath: S,
                delByKeyPath: function (e, t) {
                    "string" == typeof t ? S(e, t, void 0) : "length" in t && [].map.call(t, (function (t) {
                        S(e, t, void 0)
                    }))
                },
                shallowClone: k,
                deepClone: _,
                getObjectDiff: Un,
                cmp: zt,
                asap: w,
                minKey: wt,
                addons: [],
                connections: St,
                errnames: Q,
                dependencies: ir,
                semVer: vt,
                version: vt.split(".").map((e => parseInt(e))).reduce(((e, t, n) => e + t / Math.pow(10, 2 * n)))
            }), sr.maxKey = pn(sr.dependencies.IDBKeyRange), "undefined" != typeof dispatchEvent && "undefined" != typeof addEventListener && (cn(on, (e => {
                if (!or) {
                    let t;
                    kt ? (t = document.createEvent("CustomEvent"), t.initCustomEvent(ln, !0, !0, e)) : t = new CustomEvent(ln, {detail: e}), or = !0, dispatchEvent(t), or = !1
                }
            })), addEventListener(ln, (({detail: e}) => {
                or || ar(e)
            })));
            let or = !1;
            if ("undefined" != typeof BroadcastChannel) {
                const e = new BroadcastChannel(ln);
                "function" == typeof e.unref && e.unref(), cn(on, (t => {
                    or || e.postMessage(t)
                })), e.onmessage = e => {
                    e.data && ar(e.data)
                }
            } else if ("undefined" != typeof self && "undefined" != typeof navigator) {
                cn(on, (e => {
                    try {
                        or || ("undefined" != typeof localStorage && localStorage.setItem(ln, JSON.stringify({
                            trig: Math.random(),
                            changedParts: e
                        })), "object" == typeof self.clients && [...self.clients.matchAll({includeUncontrolled: !0})].forEach((t => t.postMessage({
                            type: ln,
                            changedParts: e
                        }))))
                    } catch (e) {
                    }
                })), "undefined" != typeof addEventListener && addEventListener("storage", (e => {
                    if (e.key === ln) {
                        const t = JSON.parse(e.newValue);
                        t && ar(t.changedParts)
                    }
                }));
                const e = self.document && navigator.serviceWorker;
                e && e.addEventListener("message", (function ({data: e}) {
                    e && e.type === ln && ar(e.changedParts)
                }))
            }
            Ie.rejectionMapper = function (e, t) {
                if (!e || e instanceof V || e instanceof TypeError || e instanceof SyntaxError || !e.name || !te[e.name]) return e;
                var n = new te[e.name](t || e.message, e);
                return "stack" in e && h(n, "stack", {
                    get: function () {
                        return this.inner.stack
                    }
                }), n
            }, U(F, Ct)
        }
    }, s = {};

    function a(e) {
        var t = s[e];
        if (void 0 !== t) return t.exports;
        var n = s[e] = {id: e, loaded: !1, exports: {}};
        return i[e].call(n.exports, n, n.exports, a), n.loaded = !0, n.exports
    }

    a.m = i, a.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return a.d(t, {a: t}), t
    }, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__, a.t = function (n, r) {
        if (1 & r && (n = this(n)), 8 & r) return n;
        if ("object" == typeof n && n) {
            if (4 & r && n.__esModule) return n;
            if (16 & r && "function" == typeof n.then) return n
        }
        var i = Object.create(null);
        a.r(i);
        var s = {};
        e = e || [null, t({}), t([]), t(t)];
        for (var o = 2 & r && n; "object" == typeof o && !~e.indexOf(o); o = t(o)) Object.getOwnPropertyNames(o).forEach((e => s[e] = () => n[e]));
        return s.default = () => n, a.d(i, s), i
    }, a.d = (e, t) => {
        for (var n in t) a.o(t, n) && !a.o(e, n) && Object.defineProperty(e, n, {enumerable: !0, get: t[n]})
    }, a.f = {}, a.e = e => Promise.all(Object.keys(a.f).reduce(((t, n) => (a.f[n](e, t), t)), [])), a.u = e => e + ".js", a.miniCssF = e => {
    }, a.g = function () {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window) return window
        }
    }(), a.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n = {}, r = "@snort/app:", a.l = (e, t, i, s) => {
        if (n[e]) n[e].push(t); else {
            var o, l;
            if (void 0 !== i) for (var c = document.getElementsByTagName("script"), u = 0; u < c.length; u++) {
                var d = c[u];
                if (d.getAttribute("src") == e || d.getAttribute("data-webpack") == r + i) {
                    o = d;
                    break
                }
            }
            o || (l = !0, (o = document.createElement("script")).charset = "utf-8", o.timeout = 120, a.nc && o.setAttribute("nonce", a.nc), o.setAttribute("data-webpack", r + i), o.src = e), n[e] = [t];
            var h = (t, r) => {
                o.onerror = o.onload = null, clearTimeout(f);
                var i = n[e];
                if (delete n[e], o.parentNode && o.parentNode.removeChild(o), i && i.forEach((e => e(r))), t) return t(r)
            }, f = setTimeout(h.bind(null, void 0, {type: "timeout", target: o}), 12e4);
            o.onerror = h.bind(null, o.onerror), o.onload = h.bind(null, o.onload), l && document.head.appendChild(o)
        }
    }, a.r = e => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e, "__esModule", {value: !0})
    }, a.nmd = e => (e.paths = [], e.children || (e.children = []), e), a.p = "/", (() => {
        var e = {179: 0};
        a.f.j = (t, n) => {
            var r = a.o(e, t) ? e[t] : void 0;
            if (0 !== r) if (r) n.push(r[2]); else {
                var i = new Promise(((n, i) => r = e[t] = [n, i]));
                n.push(r[2] = i);
                var s = a.p + a.u(t), o = new Error;
                a.l(s, (n => {
                    if (a.o(e, t) && (0 !== (r = e[t]) && (e[t] = void 0), r)) {
                        var i = n && ("load" === n.type ? "missing" : n.type), s = n && n.target && n.target.src;
                        o.message = "Loading chunk " + t + " failed.\n(" + i + ": " + s + ")", o.name = "ChunkLoadError", o.type = i, o.request = s, r[1](o)
                    }
                }), "chunk-" + t, t)
            }
        };
        var t = (t, n) => {
            var r, i, [s, o, l] = n, c = 0;
            if (s.some((t => 0 !== e[t]))) {
                for (r in o) a.o(o, r) && (a.m[r] = o[r]);
                l && l(a)
            }
            for (t && t(n); c < s.length; c++) i = s[c], a.o(e, i) && e[i] && e[i][0](), e[i] = 0
        }, n = self.webpackChunk_snort_app = self.webpackChunk_snort_app || [];
        n.forEach(t.bind(null, 0)), n.push = t.bind(null, n.push.bind(n))
    })();
    var o = {};
    (() => {
        "use strict";
        a.d(o, {xP: () => DS, Nd: () => OS});
        var e = a(2322), t = a(2784), n = a.t(t, 2), r = a(7029), i = a(3100), s = a(1110), l = a(8316);
        let c = function (e) {
            e()
        };
        const u = () => c, d = (0, t.createContext)(null);

        function h() {
            return (0, t.useContext)(d)
        }

        let f = () => {
            throw new Error("uSES not initialized!")
        };
        const p = (e, t) => e === t;

        function m(e = d) {
            const n = e === d ? h : () => (0, t.useContext)(e);
            return function (e, r = p) {
                const {store: i, subscription: s, getServerState: a} = n(),
                    o = f(s.addNestedSub, i.getState, a || i.getState, e, r);
                return (0, t.useDebugValue)(o), o
            }
        }

        const g = m();
        a(3463), a(3920);
        const y = {
            notify() {
            }, get: () => []
        };
        const v = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement ? t.useLayoutEffect : t.useEffect;
        let b = null;

        function w(e = d) {
            const n = e === d ? h : () => (0, t.useContext)(e);
            return function () {
                const {store: e} = n();
                return e
            }
        }

        const x = w();

        function E(e = d) {
            const t = e === d ? x : w(e);
            return function () {
                return t().dispatch
            }
        }

        const S = E();
        var k, A;

        function T() {
            return T = Object.assign ? Object.assign.bind() : function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }, T.apply(this, arguments)
        }

        (e => {
            f = e
        })(s.useSyncExternalStoreWithSelector), (e => {
            b = e
        })(i.useSyncExternalStore), k = l.unstable_batchedUpdates, c = k, function (e) {
            e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE"
        }(A || (A = {}));
        const C = "popstate";

        function R(e, t) {
            if (!1 === e || null == e) throw new Error(t)
        }

        function L(e, t) {
            if (!e) {
                "undefined" != typeof console && console.warn(t);
                try {
                    throw new Error(t)
                } catch (e) {
                }
            }
        }

        function _(e, t) {
            return {usr: e.state, key: e.key, idx: t}
        }

        function P(e, t, n, r) {
            return void 0 === n && (n = null), T({
                pathname: "string" == typeof e ? e : e.pathname,
                search: "",
                hash: ""
            }, "string" == typeof t ? j(t) : t, {
                state: n,
                key: t && t.key || r || Math.random().toString(36).substr(2, 8)
            })
        }

        function N(e) {
            let {pathname: t = "/", search: n = "", hash: r = ""} = e;
            return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t
        }

        function j(e) {
            let t = {};
            if (e) {
                let n = e.indexOf("#");
                n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n));
                let r = e.indexOf("?");
                r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e)
            }
            return t
        }

        var I;
        !function (e) {
            e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error"
        }(I || (I = {}));
        const M = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);

        function D(e, t, n, r) {
            return void 0 === n && (n = []), void 0 === r && (r = {}), e.map(((e, i) => {
                let s = [...n, i], a = "string" == typeof e.id ? e.id : s.join("-");
                if (R(!0 !== e.index || !e.children, "Cannot specify children on an index route"), R(!r[a], 'Found a route id collision on id "' + a + "\".  Route id's must be globally unique within Data Router usages"), function (e) {
                    return !0 === e.index
                }(e)) {
                    let n = T({}, e, {hasErrorBoundary: t(e), id: a});
                    return r[a] = n, n
                }
                {
                    let n = T({}, e, {id: a, hasErrorBoundary: t(e), children: void 0});
                    return r[a] = n, e.children && (n.children = D(e.children, t, s, r)), n
                }
            }))
        }

        function O(e, t, n) {
            void 0 === n && (n = "/");
            let r = X(("string" == typeof t ? j(t) : t).pathname || "/", n);
            if (null == r) return null;
            let i = B(e);
            !function (e) {
                e.sort(((e, t) => e.score !== t.score ? t.score - e.score : function (e, t) {
                    let n = e.length === t.length && e.slice(0, -1).every(((e, n) => e === t[n]));
                    return n ? e[e.length - 1] - t[t.length - 1] : 0
                }(e.routesMeta.map((e => e.childrenIndex)), t.routesMeta.map((e => e.childrenIndex)))))
            }(i);
            let s = null;
            for (let e = 0; null == s && e < i.length; ++e) s = V(i[e], Z(r));
            return s
        }

        function B(e, t, n, r) {
            void 0 === t && (t = []), void 0 === n && (n = []), void 0 === r && (r = "");
            let i = (e, i, s) => {
                let a = {
                    relativePath: void 0 === s ? e.path || "" : s,
                    caseSensitive: !0 === e.caseSensitive,
                    childrenIndex: i,
                    route: e
                };
                a.relativePath.startsWith("/") && (R(a.relativePath.startsWith(r), 'Absolute route path "' + a.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), a.relativePath = a.relativePath.slice(r.length));
                let o = te([r, a.relativePath]), l = n.concat(a);
                e.children && e.children.length > 0 && (R(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + o + '".'), B(e.children, t, l, o)), (null != e.path || e.index) && t.push({
                    path: o,
                    score: W(o, e.index),
                    routesMeta: l
                })
            };
            return e.forEach(((e, t) => {
                var n;
                if ("" !== e.path && null != (n = e.path) && n.includes("?")) for (let n of F(e.path)) i(e, t, n); else i(e, t)
            })), t
        }

        function F(e) {
            let t = e.split("/");
            if (0 === t.length) return [];
            let [n, ...r] = t, i = n.endsWith("?"), s = n.replace(/\?$/, "");
            if (0 === r.length) return i ? [s, ""] : [s];
            let a = F(r.join("/")), o = [];
            return o.push(...a.map((e => "" === e ? s : [s, e].join("/")))), i && o.push(...a), o.map((t => e.startsWith("/") && "" === t ? "/" : t))
        }

        const U = /^:\w+$/, H = 3, $ = 2, K = 1, z = 10, G = -2, q = e => "*" === e;

        function W(e, t) {
            let n = e.split("/"), r = n.length;
            return n.some(q) && (r += G), t && (r += $), n.filter((e => !q(e))).reduce(((e, t) => e + (U.test(t) ? H : "" === t ? K : z)), r)
        }

        function V(e, t) {
            let {routesMeta: n} = e, r = {}, i = "/", s = [];
            for (let e = 0; e < n.length; ++e) {
                let a = n[e], o = e === n.length - 1, l = "/" === i ? t : t.slice(i.length) || "/",
                    c = Y({path: a.relativePath, caseSensitive: a.caseSensitive, end: o}, l);
                if (!c) return null;
                Object.assign(r, c.params);
                let u = a.route;
                s.push({
                    params: r,
                    pathname: te([i, c.pathname]),
                    pathnameBase: ne(te([i, c.pathnameBase])),
                    route: u
                }), "/" !== c.pathnameBase && (i = te([i, c.pathnameBase]))
            }
            return s
        }

        function Y(e, t) {
            "string" == typeof e && (e = {path: e, caseSensitive: !1, end: !0});
            let [n, r] = function (e, t, n) {
                void 0 === t && (t = !1), void 0 === n && (n = !0), L("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".');
                let r = [],
                    i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, ((e, t) => (r.push(t), "/([^\\/]+)")));
                return e.endsWith("*") ? (r.push("*"), i += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : "" !== e && "/" !== e && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r]
            }(e.path, e.caseSensitive, e.end), i = t.match(n);
            if (!i) return null;
            let s = i[0], a = s.replace(/(.)\/+$/, "$1"), o = i.slice(1);
            return {
                params: r.reduce(((e, t, n) => {
                    if ("*" === t) {
                        let e = o[n] || "";
                        a = s.slice(0, s.length - e.length).replace(/(.)\/+$/, "$1")
                    }
                    return e[t] = function (e, t) {
                        try {
                            return decodeURIComponent(e)
                        } catch (n) {
                            return L(!1, 'The value for the URL param "' + t + '" will not be decoded because the string "' + e + '" is a malformed URL segment. This is probably due to a bad percent encoding (' + n + ")."), e
                        }
                    }(o[n] || "", t), e
                }), {}), pathname: s, pathnameBase: a, pattern: e
            }
        }

        function Z(e) {
            try {
                return decodeURI(e)
            } catch (t) {
                return L(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + ")."), e
            }
        }

        function X(e, t) {
            if ("/" === t) return e;
            if (!e.toLowerCase().startsWith(t.toLowerCase())) return null;
            let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n);
            return r && "/" !== r ? null : e.slice(n) || "/"
        }

        function Q(e, t, n, r) {
            return "Cannot include a '" + e + "' character in a manually specified `to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the `to." + n + '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'
        }

        function J(e) {
            return e.filter(((e, t) => 0 === t || e.route.path && e.route.path.length > 0))
        }

        function ee(e, t, n, r) {
            let i;
            void 0 === r && (r = !1), "string" == typeof e ? i = j(e) : (i = T({}, e), R(!i.pathname || !i.pathname.includes("?"), Q("?", "pathname", "search", i)), R(!i.pathname || !i.pathname.includes("#"), Q("#", "pathname", "hash", i)), R(!i.search || !i.search.includes("#"), Q("#", "search", "hash", i)));
            let s, a = "" === e || "" === i.pathname, o = a ? "/" : i.pathname;
            if (r || null == o) s = n; else {
                let e = t.length - 1;
                if (o.startsWith("..")) {
                    let t = o.split("/");
                    for (; ".." === t[0];) t.shift(), e -= 1;
                    i.pathname = t.join("/")
                }
                s = e >= 0 ? t[e] : "/"
            }
            let l = function (e, t) {
                void 0 === t && (t = "/");
                let {pathname: n, search: r = "", hash: i = ""} = "string" == typeof e ? j(e) : e,
                    s = n ? n.startsWith("/") ? n : function (e, t) {
                        let n = t.replace(/\/+$/, "").split("/");
                        return e.split("/").forEach((e => {
                            ".." === e ? n.length > 1 && n.pop() : "." !== e && n.push(e)
                        })), n.length > 1 ? n.join("/") : "/"
                    }(n, t) : t;
                return {pathname: s, search: re(r), hash: ie(i)}
            }(i, s), c = o && "/" !== o && o.endsWith("/"), u = (a || "." === o) && n.endsWith("/");
            return l.pathname.endsWith("/") || !c && !u || (l.pathname += "/"), l
        }

        const te = e => e.join("/").replace(/\/\/+/g, "/"), ne = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"),
            re = e => e && "?" !== e ? e.startsWith("?") ? e : "?" + e : "",
            ie = e => e && "#" !== e ? e.startsWith("#") ? e : "#" + e : "";

        class se extends Error {
        }

        class ae {
            constructor(e, t, n, r) {
                void 0 === r && (r = !1), this.status = e, this.statusText = t || "", this.internal = r, n instanceof Error ? (this.data = n.toString(), this.error = n) : this.data = n
            }
        }

        function oe(e) {
            return null != e && "number" == typeof e.status && "string" == typeof e.statusText && "boolean" == typeof e.internal && "data" in e
        }

        const le = ["post", "put", "patch", "delete"], ce = new Set(le), ue = ["get", ...le], de = new Set(ue),
            he = new Set([301, 302, 303, 307, 308]), fe = new Set([307, 308]), pe = {
                state: "idle",
                location: void 0,
                formMethod: void 0,
                formAction: void 0,
                formEncType: void 0,
                formData: void 0
            }, me = {
                state: "idle",
                data: void 0,
                formMethod: void 0,
                formAction: void 0,
                formEncType: void 0,
                formData: void 0
            }, ge = {state: "unblocked", proceed: void 0, reset: void 0, location: void 0},
            ye = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
            ve = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement,
            be = !ve, we = e => Boolean(e.hasErrorBoundary);

        function xe(e, t, n, r) {
            void 0 === r && (r = !1);
            let i, s = "string" == typeof e ? e : N(e);
            if (!n || !function (e) {
                return null != e && "formData" in e
            }(n)) return {path: s};
            if (n.formMethod && (a = n.formMethod, !de.has(a.toLowerCase()))) return {
                path: s,
                error: je(405, {method: n.formMethod})
            };
            var a;
            if (n.formData) {
                let e = n.formMethod || "get";
                if (i = {
                    formMethod: t.v7_normalizeFormMethod ? e.toUpperCase() : e.toLowerCase(),
                    formAction: Me(s),
                    formEncType: n && n.formEncType || "application/x-www-form-urlencoded",
                    formData: n.formData
                }, Fe(i.formMethod)) return {path: s, submission: i}
            }
            let o = j(s), l = Re(n.formData);
            return r && o.search && $e(o.search) && l.append("index", ""), o.search = "?" + l, {
                path: N(o),
                submission: i
            }
        }

        function Ee(e, t, n, r, i, s, a, o, l, c, u, d, h) {
            let f = h ? Object.values(h)[0] : d ? Object.values(d)[0] : void 0, p = e.createURL(t.location),
                m = e.createURL(i), g = s || p.toString() === m.toString() || p.search !== m.search,
                y = h ? Object.keys(h)[0] : void 0, v = function (e, t) {
                    let n = e;
                    if (t) {
                        let r = e.findIndex((e => e.route.id === t));
                        r >= 0 && (n = e.slice(0, r))
                    }
                    return n
                }(n, y).filter(((e, n) => {
                    if (e.route.lazy) return !0;
                    if (null == e.route.loader) return !1;
                    if (function (e, t, n) {
                        let r = !t || n.route.id !== t.route.id, i = void 0 === e[n.route.id];
                        return r || i
                    }(t.loaderData, t.matches[n], e) || a.some((t => t === e.route.id))) return !0;
                    let i = t.matches[n], s = e;
                    return ke(e, T({
                        currentUrl: p,
                        currentParams: i.params,
                        nextUrl: m,
                        nextParams: s.params
                    }, r, {actionResult: f, defaultShouldRevalidate: g || Se(i, s)}))
                })), b = [];
            return l.forEach(((e, i) => {
                if (!n.some((t => t.route.id === e.routeId))) return;
                let s = O(c, e.path, u);
                if (!s) return void b.push(T({key: i}, e, {matches: null, match: null}));
                let a = ze(s, e.path);
                (o.includes(i) || ke(a, T({
                    currentUrl: p,
                    currentParams: t.matches[t.matches.length - 1].params,
                    nextUrl: m,
                    nextParams: n[n.length - 1].params
                }, r, {actionResult: f, defaultShouldRevalidate: g}))) && b.push(T({key: i, matches: s, match: a}, e))
            })), [v, b]
        }

        function Se(e, t) {
            let n = e.route.path;
            return e.pathname !== t.pathname || null != n && n.endsWith("*") && e.params["*"] !== t.params["*"]
        }

        function ke(e, t) {
            if (e.route.shouldRevalidate) {
                let n = e.route.shouldRevalidate(t);
                if ("boolean" == typeof n) return n
            }
            return t.defaultShouldRevalidate
        }

        async function Ae(e, t, n) {
            if (!e.lazy) return;
            let r = await e.lazy();
            if (!e.lazy) return;
            let i = n[e.id];
            R(i, "No route found in manifest");
            let s = {};
            for (let e in r) {
                let t = void 0 !== i[e] && "hasErrorBoundary" !== e;
                L(!t, 'Route "' + i.id + '" has a static property "' + e + '" defined but its lazy function is also returning a value for this property. The lazy route property "' + e + '" will be ignored.'), t || M.has(e) || (s[e] = r[e])
            }
            Object.assign(i, s), Object.assign(i, {hasErrorBoundary: t(T({}, i)), lazy: void 0})
        }

        async function Te(e, t, n, r, i, s, a, o, l, c) {
            let u, d, h;
            void 0 === a && (a = "/"), void 0 === o && (o = !1), void 0 === l && (l = !1);
            let f = e => {
                let r, i = new Promise(((e, t) => r = t));
                return h = () => r(), t.signal.addEventListener("abort", h), Promise.race([e({
                    request: t,
                    params: n.params,
                    context: c
                }), i])
            };
            try {
                let r = n.route[e];
                if (n.route.lazy) if (r) d = (await Promise.all([f(r), Ae(n.route, s, i)]))[0]; else {
                    if (await Ae(n.route, s, i), r = n.route[e], !r) {
                        if ("action" === e) throw je(405, {
                            method: t.method,
                            pathname: new URL(t.url).pathname,
                            routeId: n.route.id
                        });
                        return {type: I.data, data: void 0}
                    }
                    d = await f(r)
                } else R(r, "Could not find the " + e + ' to run on the "' + n.route.id + '" route'), d = await f(r);
                R(void 0 !== d, "You defined " + ("action" === e ? "an action" : "a loader") + ' for route "' + n.route.id + "\" but didn't return anything from your `" + e + "` function. Please return a value or `null`.")
            } catch (e) {
                u = I.error, d = e
            } finally {
                h && t.signal.removeEventListener("abort", h)
            }
            if (null != (p = d) && "number" == typeof p.status && "string" == typeof p.statusText && "object" == typeof p.headers && void 0 !== p.body) {
                let e, i = d.status;
                if (he.has(i)) {
                    let e = d.headers.get("Location");
                    if (R(e, "Redirects returned/thrown from loaders/actions must have a Location header"), ye.test(e)) {
                        if (!o) {
                            let n = new URL(t.url), r = e.startsWith("//") ? new URL(n.protocol + e) : new URL(e),
                                i = null != X(r.pathname, a);
                            r.origin === n.origin && i && (e = r.pathname + r.search + r.hash)
                        }
                    } else {
                        let i = ee(e, J(r.slice(0, r.indexOf(n) + 1)).map((e => e.pathnameBase)), new URL(t.url).pathname);
                        if (R(N(i), "Unable to resolve redirect location: " + e), a) {
                            let e = i.pathname;
                            i.pathname = "/" === e ? a : te([a, e])
                        }
                        e = N(i)
                    }
                    if (o) throw d.headers.set("Location", e), d;
                    return {
                        type: I.redirect,
                        status: i,
                        location: e,
                        revalidate: null !== d.headers.get("X-Remix-Revalidate")
                    }
                }
                if (l) throw{type: u || I.data, response: d};
                let s = d.headers.get("Content-Type");
                return e = s && /\bapplication\/json\b/.test(s) ? await d.json() : await d.text(), u === I.error ? {
                    type: u,
                    error: new ae(i, d.statusText, e),
                    headers: d.headers
                } : {type: I.data, data: e, statusCode: d.status, headers: d.headers}
            }
            var p, m, g;
            return u === I.error ? {type: u, error: d} : function (e) {
                let t = e;
                return t && "object" == typeof t && "object" == typeof t.data && "function" == typeof t.subscribe && "function" == typeof t.cancel && "function" == typeof t.resolveData
            }(d) ? {
                type: I.deferred,
                deferredData: d,
                statusCode: null == (m = d.init) ? void 0 : m.status,
                headers: (null == (g = d.init) ? void 0 : g.headers) && new Headers(d.init.headers)
            } : {type: I.data, data: d}
        }

        function Ce(e, t, n, r) {
            let i = e.createURL(Me(t)).toString(), s = {signal: n};
            if (r && Fe(r.formMethod)) {
                let {formMethod: e, formEncType: t, formData: n} = r;
                s.method = e.toUpperCase(), s.body = "application/x-www-form-urlencoded" === t ? Re(n) : n
            }
            return new Request(i, s)
        }

        function Re(e) {
            let t = new URLSearchParams;
            for (let [n, r] of e.entries()) t.append(n, r instanceof File ? r.name : r);
            return t
        }

        function Le(e, t, n, r, i, s, a, o) {
            let {loaderData: l, errors: c} = function (e, t, n, r, i) {
                let s, a = {}, o = null, l = !1, c = {};
                return n.forEach(((n, u) => {
                    let d = t[u].route.id;
                    if (R(!Be(n), "Cannot handle redirect results in processLoaderData"), Oe(n)) {
                        let t = Pe(e, d), i = n.error;
                        r && (i = Object.values(r)[0], r = void 0), o = o || {}, null == o[t.route.id] && (o[t.route.id] = i), a[d] = void 0, l || (l = !0, s = oe(n.error) ? n.error.status : 500), n.headers && (c[d] = n.headers)
                    } else De(n) ? (i.set(d, n.deferredData), a[d] = n.deferredData.data) : a[d] = n.data, null == n.statusCode || 200 === n.statusCode || l || (s = n.statusCode), n.headers && (c[d] = n.headers)
                })), r && (o = r, a[Object.keys(r)[0]] = void 0), {
                    loaderData: a,
                    errors: o,
                    statusCode: s || 200,
                    loaderHeaders: c
                }
            }(t, n, r, i, o);
            for (let t = 0; t < s.length; t++) {
                let {key: n, match: r} = s[t];
                R(void 0 !== a && void 0 !== a[t], "Did not find corresponding fetcher result");
                let i = a[t];
                if (Oe(i)) {
                    let t = Pe(e.matches, null == r ? void 0 : r.route.id);
                    c && c[t.route.id] || (c = T({}, c, {[t.route.id]: i.error})), e.fetchers.delete(n)
                } else if (Be(i)) R(!1, "Unhandled fetcher revalidation redirect"); else if (De(i)) R(!1, "Unhandled fetcher deferred data"); else {
                    let t = {
                        state: "idle",
                        data: i.data,
                        formMethod: void 0,
                        formAction: void 0,
                        formEncType: void 0,
                        formData: void 0,
                        " _hasFetcherDoneAnything ": !0
                    };
                    e.fetchers.set(n, t)
                }
            }
            return {loaderData: l, errors: c}
        }

        function _e(e, t, n, r) {
            let i = T({}, t);
            for (let s of n) {
                let n = s.route.id;
                if (t.hasOwnProperty(n) ? void 0 !== t[n] && (i[n] = t[n]) : void 0 !== e[n] && s.route.loader && (i[n] = e[n]), r && r.hasOwnProperty(n)) break
            }
            return i
        }

        function Pe(e, t) {
            let n = t ? e.slice(0, e.findIndex((e => e.route.id === t)) + 1) : [...e];
            return n.reverse().find((e => !0 === e.route.hasErrorBoundary)) || e[0]
        }

        function Ne(e) {
            let t = e.find((e => e.index || !e.path || "/" === e.path)) || {id: "__shim-error-route__"};
            return {matches: [{params: {}, pathname: "", pathnameBase: "", route: t}], route: t}
        }

        function je(e, t) {
            let {pathname: n, routeId: r, method: i, type: s} = void 0 === t ? {} : t, a = "Unknown Server Error",
                o = "Unknown @remix-run/router error";
            return 400 === e ? (a = "Bad Request", i && n && r ? o = "You made a " + i + ' request to "' + n + '" but did not provide a `loader` for route "' + r + '", so there is no way to handle the request.' : "defer-action" === s && (o = "defer() is not supported in actions")) : 403 === e ? (a = "Forbidden", o = 'Route "' + r + '" does not match URL "' + n + '"') : 404 === e ? (a = "Not Found", o = 'No route matches URL "' + n + '"') : 405 === e && (a = "Method Not Allowed", i && n && r ? o = "You made a " + i.toUpperCase() + ' request to "' + n + '" but did not provide an `action` for route "' + r + '", so there is no way to handle the request.' : i && (o = 'Invalid request method "' + i.toUpperCase() + '"')), new ae(e || 500, a, new Error(o), !0)
        }

        function Ie(e) {
            for (let t = e.length - 1; t >= 0; t--) {
                let n = e[t];
                if (Be(n)) return n
            }
        }

        function Me(e) {
            return N(T({}, "string" == typeof e ? j(e) : e, {hash: ""}))
        }

        function De(e) {
            return e.type === I.deferred
        }

        function Oe(e) {
            return e.type === I.error
        }

        function Be(e) {
            return (e && e.type) === I.redirect
        }

        function Fe(e) {
            return ce.has(e.toLowerCase())
        }

        async function Ue(e, t, n, r, i, s) {
            for (let a = 0; a < n.length; a++) {
                let o = n[a], l = t[a];
                if (!l) continue;
                let c = e.find((e => e.route.id === l.route.id)),
                    u = null != c && !Se(c, l) && void 0 !== (s && s[l.route.id]);
                De(o) && (i || u) && await He(o, r, i).then((e => {
                    e && (n[a] = e || n[a])
                }))
            }
        }

        async function He(e, t, n) {
            if (void 0 === n && (n = !1), !await e.deferredData.resolveData(t)) {
                if (n) try {
                    return {type: I.data, data: e.deferredData.unwrappedData}
                } catch (e) {
                    return {type: I.error, error: e}
                }
                return {type: I.data, data: e.deferredData.data}
            }
        }

        function $e(e) {
            return new URLSearchParams(e).getAll("index").some((e => "" === e))
        }

        function Ke(e, t) {
            let {route: n, pathname: r, params: i} = e;
            return {id: n.id, pathname: r, params: i, data: t[n.id], handle: n.handle}
        }

        function ze(e, t) {
            let n = "string" == typeof t ? j(t).search : t.search;
            if (e[e.length - 1].route.index && $e(n || "")) return e[e.length - 1];
            let r = J(e);
            return r[r.length - 1]
        }

        Symbol("deferred");
        "function" == typeof Object.is && Object.is;
        const {useState: Ge, useEffect: qe, useLayoutEffect: We, useDebugValue: Ve} = n;
        "undefined" == typeof window || void 0 === window.document || window.document.createElement;
        const Ye = n.useSyncExternalStore, Ze = t.createContext(null), Xe = t.createContext(null),
            Qe = t.createContext(null), Je = t.createContext(null), et = t.createContext({outlet: null, matches: []}),
            tt = t.createContext(null);

        function nt() {
            return nt = Object.assign ? Object.assign.bind() : function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }, nt.apply(this, arguments)
        }

        function rt() {
            return null != t.useContext(Je)
        }

        function it() {
            return rt() || R(!1), t.useContext(Je).location
        }

        function st() {
            rt() || R(!1);
            let {basename: e, navigator: n} = t.useContext(Qe), {matches: r} = t.useContext(et), {pathname: i} = it(),
                s = JSON.stringify(J(r).map((e => e.pathnameBase))), a = t.useRef(!1);
            return t.useEffect((() => {
                a.current = !0
            })), t.useCallback((function (t, r) {
                if (void 0 === r && (r = {}), !a.current) return;
                if ("number" == typeof t) return void n.go(t);
                let o = ee(t, JSON.parse(s), i, "path" === r.relative);
                "/" !== e && (o.pathname = "/" === o.pathname ? e : te([e, o.pathname])), (r.replace ? n.replace : n.push)(o, r.state, r)
            }), [e, n, s, i])
        }

        const at = t.createContext(null);

        function ot() {
            let {matches: e} = t.useContext(et), n = e[e.length - 1];
            return n ? n.params : {}
        }

        function lt(e, n) {
            let {relative: r} = void 0 === n ? {} : n, {matches: i} = t.useContext(et), {pathname: s} = it(),
                a = JSON.stringify(J(i).map((e => e.pathnameBase)));
            return t.useMemo((() => ee(e, JSON.parse(a), s, "path" === r)), [e, a, s, r])
        }

        function ct() {
            let e = mt(),
                n = oe(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e),
                r = e instanceof Error ? e.stack : null,
                i = {padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)"};
            return t.createElement(t.Fragment, null, t.createElement("h2", null, "Unexpected Application Error!"), t.createElement("h3", {style: {fontStyle: "italic"}}, n), r ? t.createElement("pre", {style: i}, r) : null, null)
        }

        class ut extends t.Component {
            constructor(e) {
                super(e), this.state = {location: e.location, error: e.error}
            }

            static getDerivedStateFromError(e) {
                return {error: e}
            }

            static getDerivedStateFromProps(e, t) {
                return t.location !== e.location ? {error: e.error, location: e.location} : {
                    error: e.error || t.error,
                    location: t.location
                }
            }

            componentDidCatch(e, t) {
                console.error("React Router caught the following error during render", e, t)
            }

            render() {
                return this.state.error ? t.createElement(et.Provider, {value: this.props.routeContext}, t.createElement(tt.Provider, {
                    value: this.state.error,
                    children: this.props.component
                })) : this.props.children
            }
        }

        function dt(e) {
            let {routeContext: n, match: r, children: i} = e, s = t.useContext(Ze);
            return s && s.static && s.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = r.route.id), t.createElement(et.Provider, {value: n}, i)
        }

        var ht, ft, pt;

        function mt() {
            var e;
            let n = t.useContext(tt), r = function (e) {
                let n = t.useContext(Xe);
                return n || R(!1), n
            }(ft.UseRouteError), i = function (e) {
                let n = function (e) {
                    let n = t.useContext(et);
                    return n || R(!1), n
                }(), r = n.matches[n.matches.length - 1];
                return r.route.id || R(!1), r.route.id
            }(ft.UseRouteError);
            return n || (null == (e = r.errors) ? void 0 : e[i])
        }

        function gt(e) {
            let {to: n, replace: r, state: i, relative: s} = e;
            rt() || R(!1);
            let a = t.useContext(Xe), o = st();
            return t.useEffect((() => {
                a && "idle" !== a.navigation.state || o(n, {replace: r, state: i, relative: s})
            })), null
        }

        function yt(e) {
            return function (e) {
                let n = t.useContext(et).outlet;
                return n ? t.createElement(at.Provider, {value: e}, n) : n
            }(e.context)
        }

        function vt(e) {
            R(!1)
        }

        function bt(e) {
            let {
                basename: n = "/",
                children: r = null,
                location: i,
                navigationType: s = A.Pop,
                navigator: a,
                static: o = !1
            } = e;
            rt() && R(!1);
            let l = n.replace(/^\/*/, "/"), c = t.useMemo((() => ({basename: l, navigator: a, static: o})), [l, a, o]);
            "string" == typeof i && (i = j(i));
            let {pathname: u = "/", search: d = "", hash: h = "", state: f = null, key: p = "default"} = i,
                m = t.useMemo((() => {
                    let e = X(u, l);
                    return null == e ? null : {
                        location: {pathname: e, search: d, hash: h, state: f, key: p},
                        navigationType: s
                    }
                }), [l, u, d, h, f, p, s]);
            return null == m ? null : t.createElement(Qe.Provider, {value: c}, t.createElement(Je.Provider, {
                children: r,
                value: m
            }))
        }

        function wt(e) {
            let {children: n, location: r} = e, i = t.useContext(Ze);
            return function (e, n) {
                rt() || R(!1);
                let {navigator: r} = t.useContext(Qe), i = t.useContext(Xe), {matches: s} = t.useContext(et),
                    a = s[s.length - 1], o = a ? a.params : {}, l = (a && a.pathname, a ? a.pathnameBase : "/");
                a && a.route;
                let c, u = it();
                if (n) {
                    var d;
                    let e = "string" == typeof n ? j(n) : n;
                    "/" === l || (null == (d = e.pathname) ? void 0 : d.startsWith(l)) || R(!1), c = e
                } else c = u;
                let h = c.pathname || "/", f = O(e, {pathname: "/" === l ? h : h.slice(l.length) || "/"}),
                    p = function (e, n, r) {
                        if (void 0 === n && (n = []), null == e) {
                            if (null == r || !r.errors) return null;
                            e = r.matches
                        }
                        let i = e, s = null == r ? void 0 : r.errors;
                        if (null != s) {
                            let e = i.findIndex((e => e.route.id && (null == s ? void 0 : s[e.route.id])));
                            e >= 0 || R(!1), i = i.slice(0, Math.min(i.length, e + 1))
                        }
                        return i.reduceRight(((e, a, o) => {
                            let l = a.route.id ? null == s ? void 0 : s[a.route.id] : null, c = null;
                            r && (c = a.route.ErrorBoundary ? t.createElement(a.route.ErrorBoundary, null) : a.route.errorElement ? a.route.errorElement : t.createElement(ct, null));
                            let u = n.concat(i.slice(0, o + 1)), d = () => {
                                let n = e;
                                return l ? n = c : a.route.Component ? n = t.createElement(a.route.Component, null) : a.route.element && (n = a.route.element), t.createElement(dt, {
                                    match: a,
                                    routeContext: {outlet: e, matches: u},
                                    children: n
                                })
                            };
                            return r && (a.route.ErrorBoundary || a.route.errorElement || 0 === o) ? t.createElement(ut, {
                                location: r.location,
                                component: c,
                                error: l,
                                children: d(),
                                routeContext: {outlet: null, matches: u}
                            }) : d()
                        }), null)
                    }(f && f.map((e => Object.assign({}, e, {
                        params: Object.assign({}, o, e.params),
                        pathname: te([l, r.encodeLocation ? r.encodeLocation(e.pathname).pathname : e.pathname]),
                        pathnameBase: "/" === e.pathnameBase ? l : te([l, r.encodeLocation ? r.encodeLocation(e.pathnameBase).pathname : e.pathnameBase])
                    }))), s, i || void 0);
                return n && p ? t.createElement(Je.Provider, {
                    value: {
                        location: nt({
                            pathname: "/",
                            search: "",
                            hash: "",
                            state: null,
                            key: "default"
                        }, c), navigationType: A.Pop
                    }
                }, p) : p
            }(i && !n ? i.router.routes : Et(n), r)
        }

        !function (e) {
            e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator"
        }(ht || (ht = {})), function (e) {
            e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator"
        }(ft || (ft = {})), function (e) {
            e[e.pending = 0] = "pending", e[e.success = 1] = "success", e[e.error = 2] = "error"
        }(pt || (pt = {})), new Promise((() => {
        }));

        class xt extends t.Component {
            constructor(e) {
                super(e), this.state = {error: null}
            }

            static getDerivedStateFromError(e) {
                return {error: e}
            }

            componentDidCatch(e, t) {
                console.error("<Await> caught the following error during render", e, t)
            }

            render() {
                let {children: e, errorElement: t, resolve: n} = this.props, r = null, i = pt.pending;
                if (n instanceof Promise) if (this.state.error) {
                    pt.error;
                    let e = this.state.error;
                    Promise.reject().catch((() => {
                    })), Object.defineProperty(r, "_tracked", {get: () => !0}), Object.defineProperty(r, "_error", {get: () => e})
                } else n._tracked ? void 0 !== r._error ? pt.error : void 0 !== r._data ? pt.success : pt.pending : (pt.pending, Object.defineProperty(n, "_tracked", {get: () => !0}), n.then((e => Object.defineProperty(n, "_data", {get: () => e})), (e => Object.defineProperty(n, "_error", {get: () => e})))); else pt.success, Promise.resolve(), Object.defineProperty(r, "_tracked", {get: () => !0}), Object.defineProperty(r, "_data", {get: () => n});
                if (i === pt.error && r._error instanceof AbortedDeferredError) throw neverSettledPromise;
                if (i === pt.error && !t) throw r._error;
                if (i === pt.error) return React.createElement(AwaitContext.Provider, {value: r, children: t});
                if (i === pt.success) return React.createElement(AwaitContext.Provider, {value: r, children: e});
                throw r
            }
        }

        function Et(e, n) {
            void 0 === n && (n = []);
            let r = [];
            return t.Children.forEach(e, ((e, i) => {
                if (!t.isValidElement(e)) return;
                let s = [...n, i];
                if (e.type === t.Fragment) return void r.push.apply(r, Et(e.props.children, s));
                e.type !== vt && R(!1), e.props.index && e.props.children && R(!1);
                let a = {
                    id: e.props.id || s.join("-"),
                    caseSensitive: e.props.caseSensitive,
                    element: e.props.element,
                    Component: e.props.Component,
                    index: e.props.index,
                    path: e.props.path,
                    loader: e.props.loader,
                    action: e.props.action,
                    errorElement: e.props.errorElement,
                    ErrorBoundary: e.props.ErrorBoundary,
                    hasErrorBoundary: null != e.props.ErrorBoundary || null != e.props.errorElement,
                    shouldRevalidate: e.props.shouldRevalidate,
                    handle: e.props.handle,
                    lazy: e.props.lazy
                };
                e.props.children && (a.children = Et(e.props.children, s)), r.push(a)
            })), r
        }

        function St() {
            return St = Object.assign ? Object.assign.bind() : function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }, St.apply(this, arguments)
        }

        const kt = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];

        function At(e) {
            if (!e) return null;
            let t = Object.entries(e), n = {};
            for (let [e, r] of t) if (r && "RouteErrorResponse" === r.__type) n[e] = new ae(r.status, r.statusText, r.data, !0 === r.internal); else if (r && "Error" === r.__type) {
                let t = new Error(r.message);
                t.stack = "", n[e] = t
            } else n[e] = r;
            return n
        }

        const Tt = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement,
            Ct = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Rt = t.forwardRef((function (e, n) {
                let r, {
                    onClick: i,
                    relative: s,
                    reloadDocument: a,
                    replace: o,
                    state: l,
                    target: c,
                    to: u,
                    preventScrollReset: d
                } = e, h = function (e, t) {
                    if (null == e) return {};
                    var n, r, i = {}, s = Object.keys(e);
                    for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
                    return i
                }(e, kt), {basename: f} = t.useContext(Qe), p = !1;
                if ("string" == typeof u && Ct.test(u) && (r = u, Tt)) {
                    let e = new URL(window.location.href), t = u.startsWith("//") ? new URL(e.protocol + u) : new URL(u),
                        n = X(t.pathname, f);
                    t.origin === e.origin && null != n ? u = n + t.search + t.hash : p = !0
                }
                let m = function (e, n) {
                    let {relative: r} = void 0 === n ? {} : n;
                    rt() || R(!1);
                    let {basename: i, navigator: s} = t.useContext(Qe), {
                        hash: a,
                        pathname: o,
                        search: l
                    } = lt(e, {relative: r}), c = o;
                    return "/" !== i && (c = "/" === o ? i : te([i, o])), s.createHref({pathname: c, search: l, hash: a})
                }(u, {relative: s}), g = function (e, n) {
                    let {target: r, replace: i, state: s, preventScrollReset: a, relative: o} = void 0 === n ? {} : n,
                        l = st(), c = it(), u = lt(e, {relative: o});
                    return t.useCallback((t => {
                        if (function (e, t) {
                            return !(0 !== e.button || t && "_self" !== t || function (e) {
                                return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
                            }(e))
                        }(t, r)) {
                            t.preventDefault();
                            let n = void 0 !== i ? i : N(c) === N(u);
                            l(e, {replace: n, state: s, preventScrollReset: a, relative: o})
                        }
                    }), [c, l, u, i, s, r, e, a, o])
                }(u, {replace: o, state: l, target: c, preventScrollReset: d, relative: s});
                return t.createElement("a", St({}, h, {
                    href: r || m, onClick: p || a ? i : function (e) {
                        i && i(e), e.defaultPrevented || g(e)
                    }, ref: n, target: c
                }))
            }));
        var Lt, _t;
        (function (e) {
            e.UseScrollRestoration = "useScrollRestoration", e.UseSubmitImpl = "useSubmitImpl", e.UseFetcher = "useFetcher"
        })(Lt || (Lt = {})), function (e) {
            e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration"
        }(_t || (_t = {}));
        var Pt = a(124), Nt = function (e, t) {
            return Nt = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
                e.__proto__ = t
            } || function (e, t) {
                for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
            }, Nt(e, t)
        };

        function jt(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");

            function n() {
                this.constructor = e
            }

            Nt(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
        }

        var It = function () {
            return It = Object.assign || function (e) {
                for (var t, n = 1, r = arguments.length; n < r; n++) for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                return e
            }, It.apply(this, arguments)
        };

        function Mt(e, t) {
            var n = {};
            for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
            if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                var i = 0;
                for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]])
            }
            return n
        }

        function Dt(e, t, n) {
            if (n || 2 === arguments.length) for (var r, i = 0, s = t.length; i < s; i++) !r && i in t || (r || (r = Array.prototype.slice.call(t, 0, i)), r[i] = t[i]);
            return e.concat(r || Array.prototype.slice.call(t))
        }

        Object.create, Object.create;
        var Ot, Bt, Ft,
            Ut = "undefined" != typeof window ? window.__REACT_INTL_CONTEXT__ || (window.__REACT_INTL_CONTEXT__ = t.createContext(null)) : t.createContext(null),
            Ht = (Ut.Consumer, Ut.Provider), $t = Ut;

        function Kt(e, t, n) {
            if (void 0 === n && (n = Error), !e) throw new n(t)
        }

        function zt(e) {
            return e.type === Bt.literal
        }

        function Gt(e) {
            return e.type === Bt.argument
        }

        function qt(e) {
            return e.type === Bt.number
        }

        function Wt(e) {
            return e.type === Bt.date
        }

        function Vt(e) {
            return e.type === Bt.time
        }

        function Yt(e) {
            return e.type === Bt.select
        }

        function Zt(e) {
            return e.type === Bt.plural
        }

        function Xt(e) {
            return e.type === Bt.pound
        }

        function Qt(e) {
            return e.type === Bt.tag
        }

        function Jt(e) {
            return !(!e || "object" != typeof e || e.type !== Ft.number)
        }

        function en(e) {
            return !(!e || "object" != typeof e || e.type !== Ft.dateTime)
        }

        !function (e) {
            e[e.EXPECT_ARGUMENT_CLOSING_BRACE = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE", e[e.EMPTY_ARGUMENT = 2] = "EMPTY_ARGUMENT", e[e.MALFORMED_ARGUMENT = 3] = "MALFORMED_ARGUMENT", e[e.EXPECT_ARGUMENT_TYPE = 4] = "EXPECT_ARGUMENT_TYPE", e[e.INVALID_ARGUMENT_TYPE = 5] = "INVALID_ARGUMENT_TYPE", e[e.EXPECT_ARGUMENT_STYLE = 6] = "EXPECT_ARGUMENT_STYLE", e[e.INVALID_NUMBER_SKELETON = 7] = "INVALID_NUMBER_SKELETON", e[e.INVALID_DATE_TIME_SKELETON = 8] = "INVALID_DATE_TIME_SKELETON", e[e.EXPECT_NUMBER_SKELETON = 9] = "EXPECT_NUMBER_SKELETON", e[e.EXPECT_DATE_TIME_SKELETON = 10] = "EXPECT_DATE_TIME_SKELETON", e[e.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE", e[e.EXPECT_SELECT_ARGUMENT_OPTIONS = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS", e[e.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE", e[e.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE", e[e.EXPECT_SELECT_ARGUMENT_SELECTOR = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR", e[e.EXPECT_PLURAL_ARGUMENT_SELECTOR = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR", e[e.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT", e[e.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT", e[e.INVALID_PLURAL_ARGUMENT_SELECTOR = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR", e[e.DUPLICATE_PLURAL_ARGUMENT_SELECTOR = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR", e[e.DUPLICATE_SELECT_ARGUMENT_SELECTOR = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR", e[e.MISSING_OTHER_CLAUSE = 22] = "MISSING_OTHER_CLAUSE", e[e.INVALID_TAG = 23] = "INVALID_TAG", e[e.INVALID_TAG_NAME = 25] = "INVALID_TAG_NAME", e[e.UNMATCHED_CLOSING_TAG = 26] = "UNMATCHED_CLOSING_TAG", e[e.UNCLOSED_TAG = 27] = "UNCLOSED_TAG"
        }(Ot || (Ot = {})), function (e) {
            e[e.literal = 0] = "literal", e[e.argument = 1] = "argument", e[e.number = 2] = "number", e[e.date = 3] = "date", e[e.time = 4] = "time", e[e.select = 5] = "select", e[e.plural = 6] = "plural", e[e.pound = 7] = "pound", e[e.tag = 8] = "tag"
        }(Bt || (Bt = {})), function (e) {
            e[e.number = 0] = "number", e[e.dateTime = 1] = "dateTime"
        }(Ft || (Ft = {}));
        var tn = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,
            nn = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;

        function rn(e) {
            var t = {};
            return e.replace(nn, (function (e) {
                var n = e.length;
                switch (e[0]) {
                    case"G":
                        t.era = 4 === n ? "long" : 5 === n ? "narrow" : "short";
                        break;
                    case"y":
                        t.year = 2 === n ? "2-digit" : "numeric";
                        break;
                    case"Y":
                    case"u":
                    case"U":
                    case"r":
                        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
                    case"q":
                    case"Q":
                        throw new RangeError("`q/Q` (quarter) patterns are not supported");
                    case"M":
                    case"L":
                        t.month = ["numeric", "2-digit", "short", "long", "narrow"][n - 1];
                        break;
                    case"w":
                    case"W":
                        throw new RangeError("`w/W` (week) patterns are not supported");
                    case"d":
                        t.day = ["numeric", "2-digit"][n - 1];
                        break;
                    case"D":
                    case"F":
                    case"g":
                        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
                    case"E":
                        t.weekday = 4 === n ? "short" : 5 === n ? "narrow" : "short";
                        break;
                    case"e":
                        if (n < 4) throw new RangeError("`e..eee` (weekday) patterns are not supported");
                        t.weekday = ["short", "long", "narrow", "short"][n - 4];
                        break;
                    case"c":
                        if (n < 4) throw new RangeError("`c..ccc` (weekday) patterns are not supported");
                        t.weekday = ["short", "long", "narrow", "short"][n - 4];
                        break;
                    case"a":
                        t.hour12 = !0;
                        break;
                    case"b":
                    case"B":
                        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
                    case"h":
                        t.hourCycle = "h12", t.hour = ["numeric", "2-digit"][n - 1];
                        break;
                    case"H":
                        t.hourCycle = "h23", t.hour = ["numeric", "2-digit"][n - 1];
                        break;
                    case"K":
                        t.hourCycle = "h11", t.hour = ["numeric", "2-digit"][n - 1];
                        break;
                    case"k":
                        t.hourCycle = "h24", t.hour = ["numeric", "2-digit"][n - 1];
                        break;
                    case"j":
                    case"J":
                    case"C":
                        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
                    case"m":
                        t.minute = ["numeric", "2-digit"][n - 1];
                        break;
                    case"s":
                        t.second = ["numeric", "2-digit"][n - 1];
                        break;
                    case"S":
                    case"A":
                        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
                    case"z":
                        t.timeZoneName = n < 4 ? "short" : "long";
                        break;
                    case"Z":
                    case"O":
                    case"v":
                    case"V":
                    case"X":
                    case"x":
                        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead")
                }
                return ""
            })), t
        }

        var sn = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i, an = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g,
            on = /^(@+)?(\+|#+)?[rs]?$/g, ln = /(\*)(0+)|(#+)(0+)|(0+)/g, cn = /^(0+)$/;

        function un(e) {
            var t = {};
            return "r" === e[e.length - 1] ? t.roundingPriority = "morePrecision" : "s" === e[e.length - 1] && (t.roundingPriority = "lessPrecision"), e.replace(on, (function (e, n, r) {
                return "string" != typeof r ? (t.minimumSignificantDigits = n.length, t.maximumSignificantDigits = n.length) : "+" === r ? t.minimumSignificantDigits = n.length : "#" === n[0] ? t.maximumSignificantDigits = n.length : (t.minimumSignificantDigits = n.length, t.maximumSignificantDigits = n.length + ("string" == typeof r ? r.length : 0)), ""
            })), t
        }

        function dn(e) {
            switch (e) {
                case"sign-auto":
                    return {signDisplay: "auto"};
                case"sign-accounting":
                case"()":
                    return {currencySign: "accounting"};
                case"sign-always":
                case"+!":
                    return {signDisplay: "always"};
                case"sign-accounting-always":
                case"()!":
                    return {signDisplay: "always", currencySign: "accounting"};
                case"sign-except-zero":
                case"+?":
                    return {signDisplay: "exceptZero"};
                case"sign-accounting-except-zero":
                case"()?":
                    return {signDisplay: "exceptZero", currencySign: "accounting"};
                case"sign-never":
                case"+_":
                    return {signDisplay: "never"}
            }
        }

        function hn(e) {
            var t;
            if ("E" === e[0] && "E" === e[1] ? (t = {notation: "engineering"}, e = e.slice(2)) : "E" === e[0] && (t = {notation: "scientific"}, e = e.slice(1)), t) {
                var n = e.slice(0, 2);
                if ("+!" === n ? (t.signDisplay = "always", e = e.slice(2)) : "+?" === n && (t.signDisplay = "exceptZero", e = e.slice(2)), !cn.test(e)) throw new Error("Malformed concise eng/scientific notation");
                t.minimumIntegerDigits = e.length
            }
            return t
        }

        function fn(e) {
            return dn(e) || {}
        }

        function pn(e) {
            for (var t = {}, n = 0, r = e; n < r.length; n++) {
                var i = r[n];
                switch (i.stem) {
                    case"percent":
                    case"%":
                        t.style = "percent";
                        continue;
                    case"%x100":
                        t.style = "percent", t.scale = 100;
                        continue;
                    case"currency":
                        t.style = "currency", t.currency = i.options[0];
                        continue;
                    case"group-off":
                    case",_":
                        t.useGrouping = !1;
                        continue;
                    case"precision-integer":
                    case".":
                        t.maximumFractionDigits = 0;
                        continue;
                    case"measure-unit":
                    case"unit":
                        t.style = "unit", t.unit = i.options[0].replace(/^(.*?)-/, "");
                        continue;
                    case"compact-short":
                    case"K":
                        t.notation = "compact", t.compactDisplay = "short";
                        continue;
                    case"compact-long":
                    case"KK":
                        t.notation = "compact", t.compactDisplay = "long";
                        continue;
                    case"scientific":
                        t = It(It(It({}, t), {notation: "scientific"}), i.options.reduce((function (e, t) {
                            return It(It({}, e), fn(t))
                        }), {}));
                        continue;
                    case"engineering":
                        t = It(It(It({}, t), {notation: "engineering"}), i.options.reduce((function (e, t) {
                            return It(It({}, e), fn(t))
                        }), {}));
                        continue;
                    case"notation-simple":
                        t.notation = "standard";
                        continue;
                    case"unit-width-narrow":
                        t.currencyDisplay = "narrowSymbol", t.unitDisplay = "narrow";
                        continue;
                    case"unit-width-short":
                        t.currencyDisplay = "code", t.unitDisplay = "short";
                        continue;
                    case"unit-width-full-name":
                        t.currencyDisplay = "name", t.unitDisplay = "long";
                        continue;
                    case"unit-width-iso-code":
                        t.currencyDisplay = "symbol";
                        continue;
                    case"scale":
                        t.scale = parseFloat(i.options[0]);
                        continue;
                    case"integer-width":
                        if (i.options.length > 1) throw new RangeError("integer-width stems only accept a single optional option");
                        i.options[0].replace(ln, (function (e, n, r, i, s, a) {
                            if (n) t.minimumIntegerDigits = r.length; else {
                                if (i && s) throw new Error("We currently do not support maximum integer digits");
                                if (a) throw new Error("We currently do not support exact integer digits")
                            }
                            return ""
                        }));
                        continue
                }
                if (cn.test(i.stem)) t.minimumIntegerDigits = i.stem.length; else if (an.test(i.stem)) {
                    if (i.options.length > 1) throw new RangeError("Fraction-precision stems only accept a single optional option");
                    i.stem.replace(an, (function (e, n, r, i, s, a) {
                        return "*" === r ? t.minimumFractionDigits = n.length : i && "#" === i[0] ? t.maximumFractionDigits = i.length : s && a ? (t.minimumFractionDigits = s.length, t.maximumFractionDigits = s.length + a.length) : (t.minimumFractionDigits = n.length, t.maximumFractionDigits = n.length), ""
                    }));
                    var s = i.options[0];
                    "w" === s ? t = It(It({}, t), {trailingZeroDisplay: "stripIfInteger"}) : s && (t = It(It({}, t), un(s)))
                } else if (on.test(i.stem)) t = It(It({}, t), un(i.stem)); else {
                    var a = dn(i.stem);
                    a && (t = It(It({}, t), a));
                    var o = hn(i.stem);
                    o && (t = It(It({}, t), o))
                }
            }
            return t
        }

        var mn, gn = {
            AX: ["H"],
            BQ: ["H"],
            CP: ["H"],
            CZ: ["H"],
            DK: ["H"],
            FI: ["H"],
            ID: ["H"],
            IS: ["H"],
            ML: ["H"],
            NE: ["H"],
            RU: ["H"],
            SE: ["H"],
            SJ: ["H"],
            SK: ["H"],
            AS: ["h", "H"],
            BT: ["h", "H"],
            DJ: ["h", "H"],
            ER: ["h", "H"],
            GH: ["h", "H"],
            IN: ["h", "H"],
            LS: ["h", "H"],
            PG: ["h", "H"],
            PW: ["h", "H"],
            SO: ["h", "H"],
            TO: ["h", "H"],
            VU: ["h", "H"],
            WS: ["h", "H"],
            "001": ["H", "h"],
            AL: ["h", "H", "hB"],
            TD: ["h", "H", "hB"],
            "ca-ES": ["H", "h", "hB"],
            CF: ["H", "h", "hB"],
            CM: ["H", "h", "hB"],
            "fr-CA": ["H", "h", "hB"],
            "gl-ES": ["H", "h", "hB"],
            "it-CH": ["H", "h", "hB"],
            "it-IT": ["H", "h", "hB"],
            LU: ["H", "h", "hB"],
            NP: ["H", "h", "hB"],
            PF: ["H", "h", "hB"],
            SC: ["H", "h", "hB"],
            SM: ["H", "h", "hB"],
            SN: ["H", "h", "hB"],
            TF: ["H", "h", "hB"],
            VA: ["H", "h", "hB"],
            CY: ["h", "H", "hb", "hB"],
            GR: ["h", "H", "hb", "hB"],
            CO: ["h", "H", "hB", "hb"],
            DO: ["h", "H", "hB", "hb"],
            KP: ["h", "H", "hB", "hb"],
            KR: ["h", "H", "hB", "hb"],
            NA: ["h", "H", "hB", "hb"],
            PA: ["h", "H", "hB", "hb"],
            PR: ["h", "H", "hB", "hb"],
            VE: ["h", "H", "hB", "hb"],
            AC: ["H", "h", "hb", "hB"],
            AI: ["H", "h", "hb", "hB"],
            BW: ["H", "h", "hb", "hB"],
            BZ: ["H", "h", "hb", "hB"],
            CC: ["H", "h", "hb", "hB"],
            CK: ["H", "h", "hb", "hB"],
            CX: ["H", "h", "hb", "hB"],
            DG: ["H", "h", "hb", "hB"],
            FK: ["H", "h", "hb", "hB"],
            GB: ["H", "h", "hb", "hB"],
            GG: ["H", "h", "hb", "hB"],
            GI: ["H", "h", "hb", "hB"],
            IE: ["H", "h", "hb", "hB"],
            IM: ["H", "h", "hb", "hB"],
            IO: ["H", "h", "hb", "hB"],
            JE: ["H", "h", "hb", "hB"],
            LT: ["H", "h", "hb", "hB"],
            MK: ["H", "h", "hb", "hB"],
            MN: ["H", "h", "hb", "hB"],
            MS: ["H", "h", "hb", "hB"],
            NF: ["H", "h", "hb", "hB"],
            NG: ["H", "h", "hb", "hB"],
            NR: ["H", "h", "hb", "hB"],
            NU: ["H", "h", "hb", "hB"],
            PN: ["H", "h", "hb", "hB"],
            SH: ["H", "h", "hb", "hB"],
            SX: ["H", "h", "hb", "hB"],
            TA: ["H", "h", "hb", "hB"],
            ZA: ["H", "h", "hb", "hB"],
            "af-ZA": ["H", "h", "hB", "hb"],
            AR: ["H", "h", "hB", "hb"],
            CL: ["H", "h", "hB", "hb"],
            CR: ["H", "h", "hB", "hb"],
            CU: ["H", "h", "hB", "hb"],
            EA: ["H", "h", "hB", "hb"],
            "es-BO": ["H", "h", "hB", "hb"],
            "es-BR": ["H", "h", "hB", "hb"],
            "es-EC": ["H", "h", "hB", "hb"],
            "es-ES": ["H", "h", "hB", "hb"],
            "es-GQ": ["H", "h", "hB", "hb"],
            "es-PE": ["H", "h", "hB", "hb"],
            GT: ["H", "h", "hB", "hb"],
            HN: ["H", "h", "hB", "hb"],
            IC: ["H", "h", "hB", "hb"],
            KG: ["H", "h", "hB", "hb"],
            KM: ["H", "h", "hB", "hb"],
            LK: ["H", "h", "hB", "hb"],
            MA: ["H", "h", "hB", "hb"],
            MX: ["H", "h", "hB", "hb"],
            NI: ["H", "h", "hB", "hb"],
            PY: ["H", "h", "hB", "hb"],
            SV: ["H", "h", "hB", "hb"],
            UY: ["H", "h", "hB", "hb"],
            JP: ["H", "h", "K"],
            AD: ["H", "hB"],
            AM: ["H", "hB"],
            AO: ["H", "hB"],
            AT: ["H", "hB"],
            AW: ["H", "hB"],
            BE: ["H", "hB"],
            BF: ["H", "hB"],
            BJ: ["H", "hB"],
            BL: ["H", "hB"],
            BR: ["H", "hB"],
            CG: ["H", "hB"],
            CI: ["H", "hB"],
            CV: ["H", "hB"],
            DE: ["H", "hB"],
            EE: ["H", "hB"],
            FR: ["H", "hB"],
            GA: ["H", "hB"],
            GF: ["H", "hB"],
            GN: ["H", "hB"],
            GP: ["H", "hB"],
            GW: ["H", "hB"],
            HR: ["H", "hB"],
            IL: ["H", "hB"],
            IT: ["H", "hB"],
            KZ: ["H", "hB"],
            MC: ["H", "hB"],
            MD: ["H", "hB"],
            MF: ["H", "hB"],
            MQ: ["H", "hB"],
            MZ: ["H", "hB"],
            NC: ["H", "hB"],
            NL: ["H", "hB"],
            PM: ["H", "hB"],
            PT: ["H", "hB"],
            RE: ["H", "hB"],
            RO: ["H", "hB"],
            SI: ["H", "hB"],
            SR: ["H", "hB"],
            ST: ["H", "hB"],
            TG: ["H", "hB"],
            TR: ["H", "hB"],
            WF: ["H", "hB"],
            YT: ["H", "hB"],
            BD: ["h", "hB", "H"],
            PK: ["h", "hB", "H"],
            AZ: ["H", "hB", "h"],
            BA: ["H", "hB", "h"],
            BG: ["H", "hB", "h"],
            CH: ["H", "hB", "h"],
            GE: ["H", "hB", "h"],
            LI: ["H", "hB", "h"],
            ME: ["H", "hB", "h"],
            RS: ["H", "hB", "h"],
            UA: ["H", "hB", "h"],
            UZ: ["H", "hB", "h"],
            XK: ["H", "hB", "h"],
            AG: ["h", "hb", "H", "hB"],
            AU: ["h", "hb", "H", "hB"],
            BB: ["h", "hb", "H", "hB"],
            BM: ["h", "hb", "H", "hB"],
            BS: ["h", "hb", "H", "hB"],
            CA: ["h", "hb", "H", "hB"],
            DM: ["h", "hb", "H", "hB"],
            "en-001": ["h", "hb", "H", "hB"],
            FJ: ["h", "hb", "H", "hB"],
            FM: ["h", "hb", "H", "hB"],
            GD: ["h", "hb", "H", "hB"],
            GM: ["h", "hb", "H", "hB"],
            GU: ["h", "hb", "H", "hB"],
            GY: ["h", "hb", "H", "hB"],
            JM: ["h", "hb", "H", "hB"],
            KI: ["h", "hb", "H", "hB"],
            KN: ["h", "hb", "H", "hB"],
            KY: ["h", "hb", "H", "hB"],
            LC: ["h", "hb", "H", "hB"],
            LR: ["h", "hb", "H", "hB"],
            MH: ["h", "hb", "H", "hB"],
            MP: ["h", "hb", "H", "hB"],
            MW: ["h", "hb", "H", "hB"],
            NZ: ["h", "hb", "H", "hB"],
            SB: ["h", "hb", "H", "hB"],
            SG: ["h", "hb", "H", "hB"],
            SL: ["h", "hb", "H", "hB"],
            SS: ["h", "hb", "H", "hB"],
            SZ: ["h", "hb", "H", "hB"],
            TC: ["h", "hb", "H", "hB"],
            TT: ["h", "hb", "H", "hB"],
            UM: ["h", "hb", "H", "hB"],
            US: ["h", "hb", "H", "hB"],
            VC: ["h", "hb", "H", "hB"],
            VG: ["h", "hb", "H", "hB"],
            VI: ["h", "hb", "H", "hB"],
            ZM: ["h", "hb", "H", "hB"],
            BO: ["H", "hB", "h", "hb"],
            EC: ["H", "hB", "h", "hb"],
            ES: ["H", "hB", "h", "hb"],
            GQ: ["H", "hB", "h", "hb"],
            PE: ["H", "hB", "h", "hb"],
            AE: ["h", "hB", "hb", "H"],
            "ar-001": ["h", "hB", "hb", "H"],
            BH: ["h", "hB", "hb", "H"],
            DZ: ["h", "hB", "hb", "H"],
            EG: ["h", "hB", "hb", "H"],
            EH: ["h", "hB", "hb", "H"],
            HK: ["h", "hB", "hb", "H"],
            IQ: ["h", "hB", "hb", "H"],
            JO: ["h", "hB", "hb", "H"],
            KW: ["h", "hB", "hb", "H"],
            LB: ["h", "hB", "hb", "H"],
            LY: ["h", "hB", "hb", "H"],
            MO: ["h", "hB", "hb", "H"],
            MR: ["h", "hB", "hb", "H"],
            OM: ["h", "hB", "hb", "H"],
            PH: ["h", "hB", "hb", "H"],
            PS: ["h", "hB", "hb", "H"],
            QA: ["h", "hB", "hb", "H"],
            SA: ["h", "hB", "hb", "H"],
            SD: ["h", "hB", "hb", "H"],
            SY: ["h", "hB", "hb", "H"],
            TN: ["h", "hB", "hb", "H"],
            YE: ["h", "hB", "hb", "H"],
            AF: ["H", "hb", "hB", "h"],
            LA: ["H", "hb", "hB", "h"],
            CN: ["H", "hB", "hb", "h"],
            LV: ["H", "hB", "hb", "h"],
            TL: ["H", "hB", "hb", "h"],
            "zu-ZA": ["H", "hB", "hb", "h"],
            CD: ["hB", "H"],
            IR: ["hB", "H"],
            "hi-IN": ["hB", "h", "H"],
            "kn-IN": ["hB", "h", "H"],
            "ml-IN": ["hB", "h", "H"],
            "te-IN": ["hB", "h", "H"],
            KH: ["hB", "h", "H", "hb"],
            "ta-IN": ["hB", "h", "hb", "H"],
            BN: ["hb", "hB", "h", "H"],
            MY: ["hb", "hB", "h", "H"],
            ET: ["hB", "hb", "h", "H"],
            "gu-IN": ["hB", "hb", "h", "H"],
            "mr-IN": ["hB", "hb", "h", "H"],
            "pa-IN": ["hB", "hb", "h", "H"],
            TW: ["hB", "hb", "h", "H"],
            KE: ["hB", "hb", "H", "h"],
            MM: ["hB", "hb", "H", "h"],
            TZ: ["hB", "hb", "H", "h"],
            UG: ["hB", "hb", "H", "h"]
        };

        function yn(e) {
            var t = e.hourCycle;
            if (void 0 === t && e.hourCycles && e.hourCycles.length && (t = e.hourCycles[0]), t) switch (t) {
                case"h24":
                    return "k";
                case"h23":
                    return "H";
                case"h12":
                    return "h";
                case"h11":
                    return "K";
                default:
                    throw new Error("Invalid hourCycle")
            }
            var n, r = e.language;
            return "root" !== r && (n = e.maximize().region), (gn[n || ""] || gn[r || ""] || gn["".concat(r, "-001")] || gn["001"])[0]
        }

        var vn = new RegExp("^".concat(tn.source, "*")), bn = new RegExp("".concat(tn.source, "*$"));

        function wn(e, t) {
            return {start: e, end: t}
        }

        var xn = !!String.prototype.startsWith, En = !!String.fromCodePoint, Sn = !!Object.fromEntries,
            kn = !!String.prototype.codePointAt, An = !!String.prototype.trimStart, Tn = !!String.prototype.trimEnd,
            Cn = Number.isSafeInteger ? Number.isSafeInteger : function (e) {
                return "number" == typeof e && isFinite(e) && Math.floor(e) === e && Math.abs(e) <= 9007199254740991
            }, Rn = !0;
        try {
            Rn = "a" === (null === (mn = Dn("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu").exec("a")) || void 0 === mn ? void 0 : mn[0])
        } catch (ga) {
            Rn = !1
        }
        var Ln, _n = xn ? function (e, t, n) {
            return e.startsWith(t, n)
        } : function (e, t, n) {
            return e.slice(n, n + t.length) === t
        }, Pn = En ? String.fromCodePoint : function () {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            for (var n, r = "", i = e.length, s = 0; i > s;) {
                if ((n = e[s++]) > 1114111) throw RangeError(n + " is not a valid code point");
                r += n < 65536 ? String.fromCharCode(n) : String.fromCharCode(55296 + ((n -= 65536) >> 10), n % 1024 + 56320)
            }
            return r
        }, Nn = Sn ? Object.fromEntries : function (e) {
            for (var t = {}, n = 0, r = e; n < r.length; n++) {
                var i = r[n], s = i[0], a = i[1];
                t[s] = a
            }
            return t
        }, jn = kn ? function (e, t) {
            return e.codePointAt(t)
        } : function (e, t) {
            var n = e.length;
            if (!(t < 0 || t >= n)) {
                var r, i = e.charCodeAt(t);
                return i < 55296 || i > 56319 || t + 1 === n || (r = e.charCodeAt(t + 1)) < 56320 || r > 57343 ? i : r - 56320 + (i - 55296 << 10) + 65536
            }
        }, In = An ? function (e) {
            return e.trimStart()
        } : function (e) {
            return e.replace(vn, "")
        }, Mn = Tn ? function (e) {
            return e.trimEnd()
        } : function (e) {
            return e.replace(bn, "")
        };

        function Dn(e, t) {
            return new RegExp(e, t)
        }

        if (Rn) {
            var On = Dn("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
            Ln = function (e, t) {
                var n;
                return On.lastIndex = t, null !== (n = On.exec(e)[1]) && void 0 !== n ? n : ""
            }
        } else Ln = function (e, t) {
            for (var n = []; ;) {
                var r = jn(e, t);
                if (void 0 === r || Hn(r) || $n(r)) break;
                n.push(r), t += r >= 65536 ? 2 : 1
            }
            return Pn.apply(void 0, n)
        };
        var Bn = function () {
            function e(e, t) {
                void 0 === t && (t = {}), this.message = e, this.position = {
                    offset: 0,
                    line: 1,
                    column: 1
                }, this.ignoreTag = !!t.ignoreTag, this.locale = t.locale, this.requiresOtherClause = !!t.requiresOtherClause, this.shouldParseSkeletons = !!t.shouldParseSkeletons
            }

            return e.prototype.parse = function () {
                if (0 !== this.offset()) throw Error("parser can only be used once");
                return this.parseMessage(0, "", !1)
            }, e.prototype.parseMessage = function (e, t, n) {
                for (var r = []; !this.isEOF();) {
                    var i = this.char();
                    if (123 === i) {
                        if ((s = this.parseArgument(e, n)).err) return s;
                        r.push(s.val)
                    } else {
                        if (125 === i && e > 0) break;
                        if (35 !== i || "plural" !== t && "selectordinal" !== t) {
                            if (60 === i && !this.ignoreTag && 47 === this.peek()) {
                                if (n) break;
                                return this.error(Ot.UNMATCHED_CLOSING_TAG, wn(this.clonePosition(), this.clonePosition()))
                            }
                            if (60 === i && !this.ignoreTag && Fn(this.peek() || 0)) {
                                if ((s = this.parseTag(e, t)).err) return s;
                                r.push(s.val)
                            } else {
                                var s;
                                if ((s = this.parseLiteral(e, t)).err) return s;
                                r.push(s.val)
                            }
                        } else {
                            var a = this.clonePosition();
                            this.bump(), r.push({type: Bt.pound, location: wn(a, this.clonePosition())})
                        }
                    }
                }
                return {val: r, err: null}
            }, e.prototype.parseTag = function (e, t) {
                var n = this.clonePosition();
                this.bump();
                var r = this.parseTagName();
                if (this.bumpSpace(), this.bumpIf("/>")) return {
                    val: {
                        type: Bt.literal,
                        value: "<".concat(r, "/>"),
                        location: wn(n, this.clonePosition())
                    }, err: null
                };
                if (this.bumpIf(">")) {
                    var i = this.parseMessage(e + 1, t, !0);
                    if (i.err) return i;
                    var s = i.val, a = this.clonePosition();
                    if (this.bumpIf("</")) {
                        if (this.isEOF() || !Fn(this.char())) return this.error(Ot.INVALID_TAG, wn(a, this.clonePosition()));
                        var o = this.clonePosition();
                        return r !== this.parseTagName() ? this.error(Ot.UNMATCHED_CLOSING_TAG, wn(o, this.clonePosition())) : (this.bumpSpace(), this.bumpIf(">") ? {
                            val: {
                                type: Bt.tag,
                                value: r,
                                children: s,
                                location: wn(n, this.clonePosition())
                            }, err: null
                        } : this.error(Ot.INVALID_TAG, wn(a, this.clonePosition())))
                    }
                    return this.error(Ot.UNCLOSED_TAG, wn(n, this.clonePosition()))
                }
                return this.error(Ot.INVALID_TAG, wn(n, this.clonePosition()))
            }, e.prototype.parseTagName = function () {
                var e = this.offset();
                for (this.bump(); !this.isEOF() && Un(this.char());) this.bump();
                return this.message.slice(e, this.offset())
            }, e.prototype.parseLiteral = function (e, t) {
                for (var n = this.clonePosition(), r = ""; ;) {
                    var i = this.tryParseQuote(t);
                    if (i) r += i; else {
                        var s = this.tryParseUnquoted(e, t);
                        if (s) r += s; else {
                            var a = this.tryParseLeftAngleBracket();
                            if (!a) break;
                            r += a
                        }
                    }
                }
                var o = wn(n, this.clonePosition());
                return {val: {type: Bt.literal, value: r, location: o}, err: null}
            }, e.prototype.tryParseLeftAngleBracket = function () {
                return this.isEOF() || 60 !== this.char() || !this.ignoreTag && (Fn(e = this.peek() || 0) || 47 === e) ? null : (this.bump(), "<");
                var e
            }, e.prototype.tryParseQuote = function (e) {
                if (this.isEOF() || 39 !== this.char()) return null;
                switch (this.peek()) {
                    case 39:
                        return this.bump(), this.bump(), "'";
                    case 123:
                    case 60:
                    case 62:
                    case 125:
                        break;
                    case 35:
                        if ("plural" === e || "selectordinal" === e) break;
                        return null;
                    default:
                        return null
                }
                this.bump();
                var t = [this.char()];
                for (this.bump(); !this.isEOF();) {
                    var n = this.char();
                    if (39 === n) {
                        if (39 !== this.peek()) {
                            this.bump();
                            break
                        }
                        t.push(39), this.bump()
                    } else t.push(n);
                    this.bump()
                }
                return Pn.apply(void 0, t)
            }, e.prototype.tryParseUnquoted = function (e, t) {
                if (this.isEOF()) return null;
                var n = this.char();
                return 60 === n || 123 === n || 35 === n && ("plural" === t || "selectordinal" === t) || 125 === n && e > 0 ? null : (this.bump(), Pn(n))
            }, e.prototype.parseArgument = function (e, t) {
                var n = this.clonePosition();
                if (this.bump(), this.bumpSpace(), this.isEOF()) return this.error(Ot.EXPECT_ARGUMENT_CLOSING_BRACE, wn(n, this.clonePosition()));
                if (125 === this.char()) return this.bump(), this.error(Ot.EMPTY_ARGUMENT, wn(n, this.clonePosition()));
                var r = this.parseIdentifierIfPossible().value;
                if (!r) return this.error(Ot.MALFORMED_ARGUMENT, wn(n, this.clonePosition()));
                if (this.bumpSpace(), this.isEOF()) return this.error(Ot.EXPECT_ARGUMENT_CLOSING_BRACE, wn(n, this.clonePosition()));
                switch (this.char()) {
                    case 125:
                        return this.bump(), {
                            val: {type: Bt.argument, value: r, location: wn(n, this.clonePosition())},
                            err: null
                        };
                    case 44:
                        return this.bump(), this.bumpSpace(), this.isEOF() ? this.error(Ot.EXPECT_ARGUMENT_CLOSING_BRACE, wn(n, this.clonePosition())) : this.parseArgumentOptions(e, t, r, n);
                    default:
                        return this.error(Ot.MALFORMED_ARGUMENT, wn(n, this.clonePosition()))
                }
            }, e.prototype.parseIdentifierIfPossible = function () {
                var e = this.clonePosition(), t = this.offset(), n = Ln(this.message, t), r = t + n.length;
                return this.bumpTo(r), {value: n, location: wn(e, this.clonePosition())}
            }, e.prototype.parseArgumentOptions = function (e, t, n, r) {
                var i, s = this.clonePosition(), a = this.parseIdentifierIfPossible().value, o = this.clonePosition();
                switch (a) {
                    case"":
                        return this.error(Ot.EXPECT_ARGUMENT_TYPE, wn(s, o));
                    case"number":
                    case"date":
                    case"time":
                        this.bumpSpace();
                        var l = null;
                        if (this.bumpIf(",")) {
                            this.bumpSpace();
                            var c = this.clonePosition();
                            if ((y = this.parseSimpleArgStyleIfPossible()).err) return y;
                            if (0 === (f = Mn(y.val)).length) return this.error(Ot.EXPECT_ARGUMENT_STYLE, wn(this.clonePosition(), this.clonePosition()));
                            l = {style: f, styleLocation: wn(c, this.clonePosition())}
                        }
                        if ((v = this.tryParseArgumentClose(r)).err) return v;
                        var u = wn(r, this.clonePosition());
                        if (l && _n(null == l ? void 0 : l.style, "::", 0)) {
                            var d = In(l.style.slice(2));
                            if ("number" === a) return (y = this.parseNumberSkeletonFromString(d, l.styleLocation)).err ? y : {
                                val: {
                                    type: Bt.number,
                                    value: n,
                                    location: u,
                                    style: y.val
                                }, err: null
                            };
                            if (0 === d.length) return this.error(Ot.EXPECT_DATE_TIME_SKELETON, u);
                            var h = d;
                            this.locale && (h = function (e, t) {
                                for (var n = "", r = 0; r < e.length; r++) {
                                    var i = e.charAt(r);
                                    if ("j" === i) {
                                        for (var s = 0; r + 1 < e.length && e.charAt(r + 1) === i;) s++, r++;
                                        var a = 1 + (1 & s), o = s < 2 ? 1 : 3 + (s >> 1), l = yn(t);
                                        for ("H" != l && "k" != l || (o = 0); o-- > 0;) n += "a";
                                        for (; a-- > 0;) n = l + n
                                    } else n += "J" === i ? "H" : i
                                }
                                return n
                            }(d, this.locale));
                            var f = {
                                type: Ft.dateTime,
                                pattern: h,
                                location: l.styleLocation,
                                parsedOptions: this.shouldParseSkeletons ? rn(h) : {}
                            };
                            return {
                                val: {type: "date" === a ? Bt.date : Bt.time, value: n, location: u, style: f},
                                err: null
                            }
                        }
                        return {
                            val: {
                                type: "number" === a ? Bt.number : "date" === a ? Bt.date : Bt.time,
                                value: n,
                                location: u,
                                style: null !== (i = null == l ? void 0 : l.style) && void 0 !== i ? i : null
                            }, err: null
                        };
                    case"plural":
                    case"selectordinal":
                    case"select":
                        var p = this.clonePosition();
                        if (this.bumpSpace(), !this.bumpIf(",")) return this.error(Ot.EXPECT_SELECT_ARGUMENT_OPTIONS, wn(p, It({}, p)));
                        this.bumpSpace();
                        var m = this.parseIdentifierIfPossible(), g = 0;
                        if ("select" !== a && "offset" === m.value) {
                            if (!this.bumpIf(":")) return this.error(Ot.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, wn(this.clonePosition(), this.clonePosition()));
                            var y;
                            if (this.bumpSpace(), (y = this.tryParseDecimalInteger(Ot.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, Ot.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE)).err) return y;
                            this.bumpSpace(), m = this.parseIdentifierIfPossible(), g = y.val
                        }
                        var v, b = this.tryParsePluralOrSelectOptions(e, a, t, m);
                        if (b.err) return b;
                        if ((v = this.tryParseArgumentClose(r)).err) return v;
                        var w = wn(r, this.clonePosition());
                        return "select" === a ? {
                            val: {type: Bt.select, value: n, options: Nn(b.val), location: w},
                            err: null
                        } : {
                            val: {
                                type: Bt.plural,
                                value: n,
                                options: Nn(b.val),
                                offset: g,
                                pluralType: "plural" === a ? "cardinal" : "ordinal",
                                location: w
                            }, err: null
                        };
                    default:
                        return this.error(Ot.INVALID_ARGUMENT_TYPE, wn(s, o))
                }
            }, e.prototype.tryParseArgumentClose = function (e) {
                return this.isEOF() || 125 !== this.char() ? this.error(Ot.EXPECT_ARGUMENT_CLOSING_BRACE, wn(e, this.clonePosition())) : (this.bump(), {
                    val: !0,
                    err: null
                })
            }, e.prototype.parseSimpleArgStyleIfPossible = function () {
                for (var e = 0, t = this.clonePosition(); !this.isEOF();) switch (this.char()) {
                    case 39:
                        this.bump();
                        var n = this.clonePosition();
                        if (!this.bumpUntil("'")) return this.error(Ot.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, wn(n, this.clonePosition()));
                        this.bump();
                        break;
                    case 123:
                        e += 1, this.bump();
                        break;
                    case 125:
                        if (!(e > 0)) return {val: this.message.slice(t.offset, this.offset()), err: null};
                        e -= 1;
                        break;
                    default:
                        this.bump()
                }
                return {val: this.message.slice(t.offset, this.offset()), err: null}
            }, e.prototype.parseNumberSkeletonFromString = function (e, t) {
                var n = [];
                try {
                    n = function (e) {
                        if (0 === e.length) throw new Error("Number skeleton cannot be empty");
                        for (var t = e.split(sn).filter((function (e) {
                            return e.length > 0
                        })), n = [], r = 0, i = t; r < i.length; r++) {
                            var s = i[r].split("/");
                            if (0 === s.length) throw new Error("Invalid number skeleton");
                            for (var a = s[0], o = s.slice(1), l = 0, c = o; l < c.length; l++) if (0 === c[l].length) throw new Error("Invalid number skeleton");
                            n.push({stem: a, options: o})
                        }
                        return n
                    }(e)
                } catch (e) {
                    return this.error(Ot.INVALID_NUMBER_SKELETON, t)
                }
                return {
                    val: {
                        type: Ft.number,
                        tokens: n,
                        location: t,
                        parsedOptions: this.shouldParseSkeletons ? pn(n) : {}
                    }, err: null
                }
            }, e.prototype.tryParsePluralOrSelectOptions = function (e, t, n, r) {
                for (var i, s = !1, a = [], o = new Set, l = r.value, c = r.location; ;) {
                    if (0 === l.length) {
                        var u = this.clonePosition();
                        if ("select" === t || !this.bumpIf("=")) break;
                        var d = this.tryParseDecimalInteger(Ot.EXPECT_PLURAL_ARGUMENT_SELECTOR, Ot.INVALID_PLURAL_ARGUMENT_SELECTOR);
                        if (d.err) return d;
                        c = wn(u, this.clonePosition()), l = this.message.slice(u.offset, this.offset())
                    }
                    if (o.has(l)) return this.error("select" === t ? Ot.DUPLICATE_SELECT_ARGUMENT_SELECTOR : Ot.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, c);
                    "other" === l && (s = !0), this.bumpSpace();
                    var h = this.clonePosition();
                    if (!this.bumpIf("{")) return this.error("select" === t ? Ot.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : Ot.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, wn(this.clonePosition(), this.clonePosition()));
                    var f = this.parseMessage(e + 1, t, n);
                    if (f.err) return f;
                    var p = this.tryParseArgumentClose(h);
                    if (p.err) return p;
                    a.push([l, {
                        value: f.val,
                        location: wn(h, this.clonePosition())
                    }]), o.add(l), this.bumpSpace(), l = (i = this.parseIdentifierIfPossible()).value, c = i.location
                }
                return 0 === a.length ? this.error("select" === t ? Ot.EXPECT_SELECT_ARGUMENT_SELECTOR : Ot.EXPECT_PLURAL_ARGUMENT_SELECTOR, wn(this.clonePosition(), this.clonePosition())) : this.requiresOtherClause && !s ? this.error(Ot.MISSING_OTHER_CLAUSE, wn(this.clonePosition(), this.clonePosition())) : {
                    val: a,
                    err: null
                }
            }, e.prototype.tryParseDecimalInteger = function (e, t) {
                var n = 1, r = this.clonePosition();
                this.bumpIf("+") || this.bumpIf("-") && (n = -1);
                for (var i = !1, s = 0; !this.isEOF();) {
                    var a = this.char();
                    if (!(a >= 48 && a <= 57)) break;
                    i = !0, s = 10 * s + (a - 48), this.bump()
                }
                var o = wn(r, this.clonePosition());
                return i ? Cn(s *= n) ? {val: s, err: null} : this.error(t, o) : this.error(e, o)
            }, e.prototype.offset = function () {
                return this.position.offset
            }, e.prototype.isEOF = function () {
                return this.offset() === this.message.length
            }, e.prototype.clonePosition = function () {
                return {offset: this.position.offset, line: this.position.line, column: this.position.column}
            }, e.prototype.char = function () {
                var e = this.position.offset;
                if (e >= this.message.length) throw Error("out of bound");
                var t = jn(this.message, e);
                if (void 0 === t) throw Error("Offset ".concat(e, " is at invalid UTF-16 code unit boundary"));
                return t
            }, e.prototype.error = function (e, t) {
                return {val: null, err: {kind: e, message: this.message, location: t}}
            }, e.prototype.bump = function () {
                if (!this.isEOF()) {
                    var e = this.char();
                    10 === e ? (this.position.line += 1, this.position.column = 1, this.position.offset += 1) : (this.position.column += 1, this.position.offset += e < 65536 ? 1 : 2)
                }
            }, e.prototype.bumpIf = function (e) {
                if (_n(this.message, e, this.offset())) {
                    for (var t = 0; t < e.length; t++) this.bump();
                    return !0
                }
                return !1
            }, e.prototype.bumpUntil = function (e) {
                var t = this.offset(), n = this.message.indexOf(e, t);
                return n >= 0 ? (this.bumpTo(n), !0) : (this.bumpTo(this.message.length), !1)
            }, e.prototype.bumpTo = function (e) {
                if (this.offset() > e) throw Error("targetOffset ".concat(e, " must be greater than or equal to the current offset ").concat(this.offset()));
                for (e = Math.min(e, this.message.length); ;) {
                    var t = this.offset();
                    if (t === e) break;
                    if (t > e) throw Error("targetOffset ".concat(e, " is at invalid UTF-16 code unit boundary"));
                    if (this.bump(), this.isEOF()) break
                }
            }, e.prototype.bumpSpace = function () {
                for (; !this.isEOF() && Hn(this.char());) this.bump()
            }, e.prototype.peek = function () {
                if (this.isEOF()) return null;
                var e = this.char(), t = this.offset(), n = this.message.charCodeAt(t + (e >= 65536 ? 2 : 1));
                return null != n ? n : null
            }, e
        }();

        function Fn(e) {
            return e >= 97 && e <= 122 || e >= 65 && e <= 90
        }

        function Un(e) {
            return 45 === e || 46 === e || e >= 48 && e <= 57 || 95 === e || e >= 97 && e <= 122 || e >= 65 && e <= 90 || 183 == e || e >= 192 && e <= 214 || e >= 216 && e <= 246 || e >= 248 && e <= 893 || e >= 895 && e <= 8191 || e >= 8204 && e <= 8205 || e >= 8255 && e <= 8256 || e >= 8304 && e <= 8591 || e >= 11264 && e <= 12271 || e >= 12289 && e <= 55295 || e >= 63744 && e <= 64975 || e >= 65008 && e <= 65533 || e >= 65536 && e <= 983039
        }

        function Hn(e) {
            return e >= 9 && e <= 13 || 32 === e || 133 === e || e >= 8206 && e <= 8207 || 8232 === e || 8233 === e
        }

        function $n(e) {
            return e >= 33 && e <= 35 || 36 === e || e >= 37 && e <= 39 || 40 === e || 41 === e || 42 === e || 43 === e || 44 === e || 45 === e || e >= 46 && e <= 47 || e >= 58 && e <= 59 || e >= 60 && e <= 62 || e >= 63 && e <= 64 || 91 === e || 92 === e || 93 === e || 94 === e || 96 === e || 123 === e || 124 === e || 125 === e || 126 === e || 161 === e || e >= 162 && e <= 165 || 166 === e || 167 === e || 169 === e || 171 === e || 172 === e || 174 === e || 176 === e || 177 === e || 182 === e || 187 === e || 191 === e || 215 === e || 247 === e || e >= 8208 && e <= 8213 || e >= 8214 && e <= 8215 || 8216 === e || 8217 === e || 8218 === e || e >= 8219 && e <= 8220 || 8221 === e || 8222 === e || 8223 === e || e >= 8224 && e <= 8231 || e >= 8240 && e <= 8248 || 8249 === e || 8250 === e || e >= 8251 && e <= 8254 || e >= 8257 && e <= 8259 || 8260 === e || 8261 === e || 8262 === e || e >= 8263 && e <= 8273 || 8274 === e || 8275 === e || e >= 8277 && e <= 8286 || e >= 8592 && e <= 8596 || e >= 8597 && e <= 8601 || e >= 8602 && e <= 8603 || e >= 8604 && e <= 8607 || 8608 === e || e >= 8609 && e <= 8610 || 8611 === e || e >= 8612 && e <= 8613 || 8614 === e || e >= 8615 && e <= 8621 || 8622 === e || e >= 8623 && e <= 8653 || e >= 8654 && e <= 8655 || e >= 8656 && e <= 8657 || 8658 === e || 8659 === e || 8660 === e || e >= 8661 && e <= 8691 || e >= 8692 && e <= 8959 || e >= 8960 && e <= 8967 || 8968 === e || 8969 === e || 8970 === e || 8971 === e || e >= 8972 && e <= 8991 || e >= 8992 && e <= 8993 || e >= 8994 && e <= 9e3 || 9001 === e || 9002 === e || e >= 9003 && e <= 9083 || 9084 === e || e >= 9085 && e <= 9114 || e >= 9115 && e <= 9139 || e >= 9140 && e <= 9179 || e >= 9180 && e <= 9185 || e >= 9186 && e <= 9254 || e >= 9255 && e <= 9279 || e >= 9280 && e <= 9290 || e >= 9291 && e <= 9311 || e >= 9472 && e <= 9654 || 9655 === e || e >= 9656 && e <= 9664 || 9665 === e || e >= 9666 && e <= 9719 || e >= 9720 && e <= 9727 || e >= 9728 && e <= 9838 || 9839 === e || e >= 9840 && e <= 10087 || 10088 === e || 10089 === e || 10090 === e || 10091 === e || 10092 === e || 10093 === e || 10094 === e || 10095 === e || 10096 === e || 10097 === e || 10098 === e || 10099 === e || 10100 === e || 10101 === e || e >= 10132 && e <= 10175 || e >= 10176 && e <= 10180 || 10181 === e || 10182 === e || e >= 10183 && e <= 10213 || 10214 === e || 10215 === e || 10216 === e || 10217 === e || 10218 === e || 10219 === e || 10220 === e || 10221 === e || 10222 === e || 10223 === e || e >= 10224 && e <= 10239 || e >= 10240 && e <= 10495 || e >= 10496 && e <= 10626 || 10627 === e || 10628 === e || 10629 === e || 10630 === e || 10631 === e || 10632 === e || 10633 === e || 10634 === e || 10635 === e || 10636 === e || 10637 === e || 10638 === e || 10639 === e || 10640 === e || 10641 === e || 10642 === e || 10643 === e || 10644 === e || 10645 === e || 10646 === e || 10647 === e || 10648 === e || e >= 10649 && e <= 10711 || 10712 === e || 10713 === e || 10714 === e || 10715 === e || e >= 10716 && e <= 10747 || 10748 === e || 10749 === e || e >= 10750 && e <= 11007 || e >= 11008 && e <= 11055 || e >= 11056 && e <= 11076 || e >= 11077 && e <= 11078 || e >= 11079 && e <= 11084 || e >= 11085 && e <= 11123 || e >= 11124 && e <= 11125 || e >= 11126 && e <= 11157 || 11158 === e || e >= 11159 && e <= 11263 || e >= 11776 && e <= 11777 || 11778 === e || 11779 === e || 11780 === e || 11781 === e || e >= 11782 && e <= 11784 || 11785 === e || 11786 === e || 11787 === e || 11788 === e || 11789 === e || e >= 11790 && e <= 11798 || 11799 === e || e >= 11800 && e <= 11801 || 11802 === e || 11803 === e || 11804 === e || 11805 === e || e >= 11806 && e <= 11807 || 11808 === e || 11809 === e || 11810 === e || 11811 === e || 11812 === e || 11813 === e || 11814 === e || 11815 === e || 11816 === e || 11817 === e || e >= 11818 && e <= 11822 || 11823 === e || e >= 11824 && e <= 11833 || e >= 11834 && e <= 11835 || e >= 11836 && e <= 11839 || 11840 === e || 11841 === e || 11842 === e || e >= 11843 && e <= 11855 || e >= 11856 && e <= 11857 || 11858 === e || e >= 11859 && e <= 11903 || e >= 12289 && e <= 12291 || 12296 === e || 12297 === e || 12298 === e || 12299 === e || 12300 === e || 12301 === e || 12302 === e || 12303 === e || 12304 === e || 12305 === e || e >= 12306 && e <= 12307 || 12308 === e || 12309 === e || 12310 === e || 12311 === e || 12312 === e || 12313 === e || 12314 === e || 12315 === e || 12316 === e || 12317 === e || e >= 12318 && e <= 12319 || 12320 === e || 12336 === e || 64830 === e || 64831 === e || e >= 65093 && e <= 65094
        }

        function Kn(e) {
            e.forEach((function (e) {
                if (delete e.location, Yt(e) || Zt(e)) for (var t in e.options) delete e.options[t].location, Kn(e.options[t].value); else qt(e) && Jt(e.style) || (Wt(e) || Vt(e)) && en(e.style) ? delete e.style.location : Qt(e) && Kn(e.children)
            }))
        }

        function zn(e, t) {
            void 0 === t && (t = {}), t = It({shouldParseSkeletons: !0, requiresOtherClause: !0}, t);
            var n = new Bn(e, t).parse();
            if (n.err) {
                var r = SyntaxError(Ot[n.err.kind]);
                throw r.location = n.err.location, r.originalMessage = n.err.message, r
            }
            return (null == t ? void 0 : t.captureLocation) || Kn(n.val), n.val
        }

        function Gn(e, t) {
            var n = t && t.cache ? t.cache : Jn, r = t && t.serializer ? t.serializer : Zn;
            return (t && t.strategy ? t.strategy : Yn)(e, {cache: n, serializer: r})
        }

        function qn(e, t, n, r) {
            var i, s = null == (i = r) || "number" == typeof i || "boolean" == typeof i ? r : n(r), a = t.get(s);
            return void 0 === a && (a = e.call(this, r), t.set(s, a)), a
        }

        function Wn(e, t, n) {
            var r = Array.prototype.slice.call(arguments, 3), i = n(r), s = t.get(i);
            return void 0 === s && (s = e.apply(this, r), t.set(i, s)), s
        }

        function Vn(e, t, n, r, i) {
            return n.bind(t, e, r, i)
        }

        function Yn(e, t) {
            return Vn(e, this, 1 === e.length ? qn : Wn, t.cache.create(), t.serializer)
        }

        var Zn = function () {
            return JSON.stringify(arguments)
        };

        function Xn() {
            this.cache = Object.create(null)
        }

        Xn.prototype.get = function (e) {
            return this.cache[e]
        }, Xn.prototype.set = function (e, t) {
            this.cache[e] = t
        };
        var Qn, Jn = {
            create: function () {
                return new Xn
            }
        }, er = {
            variadic: function (e, t) {
                return Vn(e, this, Wn, t.cache.create(), t.serializer)
            }, monadic: function (e, t) {
                return Vn(e, this, qn, t.cache.create(), t.serializer)
            }
        };
        !function (e) {
            e.MISSING_VALUE = "MISSING_VALUE", e.INVALID_VALUE = "INVALID_VALUE", e.MISSING_INTL_API = "MISSING_INTL_API"
        }(Qn || (Qn = {}));
        var tr, nr = function (e) {
            function t(t, n, r) {
                var i = e.call(this, t) || this;
                return i.code = n, i.originalMessage = r, i
            }

            return jt(t, e), t.prototype.toString = function () {
                return "[formatjs Error: ".concat(this.code, "] ").concat(this.message)
            }, t
        }(Error), rr = function (e) {
            function t(t, n, r, i) {
                return e.call(this, 'Invalid values for "'.concat(t, '": "').concat(n, '". Options are "').concat(Object.keys(r).join('", "'), '"'), Qn.INVALID_VALUE, i) || this
            }

            return jt(t, e), t
        }(nr), ir = function (e) {
            function t(t, n, r) {
                return e.call(this, 'Value for "'.concat(t, '" must be of type ').concat(n), Qn.INVALID_VALUE, r) || this
            }

            return jt(t, e), t
        }(nr), sr = function (e) {
            function t(t, n) {
                return e.call(this, 'The intl string context variable "'.concat(t, '" was not provided to the string "').concat(n, '"'), Qn.MISSING_VALUE, n) || this
            }

            return jt(t, e), t
        }(nr);

        function ar(e) {
            return "function" == typeof e
        }

        function or(e, t, n, r, i, s, a) {
            if (1 === e.length && zt(e[0])) return [{type: tr.literal, value: e[0].value}];
            for (var o = [], l = 0, c = e; l < c.length; l++) {
                var u = c[l];
                if (zt(u)) o.push({
                    type: tr.literal,
                    value: u.value
                }); else if (Xt(u)) "number" == typeof s && o.push({
                    type: tr.literal,
                    value: n.getNumberFormat(t).format(s)
                }); else {
                    var d = u.value;
                    if (!i || !(d in i)) throw new sr(d, a);
                    var h = i[d];
                    if (Gt(u)) h && "string" != typeof h && "number" != typeof h || (h = "string" == typeof h || "number" == typeof h ? String(h) : ""), o.push({
                        type: "string" == typeof h ? tr.literal : tr.object,
                        value: h
                    }); else if (Wt(u)) {
                        var f = "string" == typeof u.style ? r.date[u.style] : en(u.style) ? u.style.parsedOptions : void 0;
                        o.push({type: tr.literal, value: n.getDateTimeFormat(t, f).format(h)})
                    } else if (Vt(u)) f = "string" == typeof u.style ? r.time[u.style] : en(u.style) ? u.style.parsedOptions : r.time.medium, o.push({
                        type: tr.literal,
                        value: n.getDateTimeFormat(t, f).format(h)
                    }); else if (qt(u)) (f = "string" == typeof u.style ? r.number[u.style] : Jt(u.style) ? u.style.parsedOptions : void 0) && f.scale && (h *= f.scale || 1), o.push({
                        type: tr.literal,
                        value: n.getNumberFormat(t, f).format(h)
                    }); else {
                        if (Qt(u)) {
                            var p = u.children, m = u.value, g = i[m];
                            if (!ar(g)) throw new ir(m, "function", a);
                            var y = g(or(p, t, n, r, i, s).map((function (e) {
                                return e.value
                            })));
                            Array.isArray(y) || (y = [y]), o.push.apply(o, y.map((function (e) {
                                return {type: "string" == typeof e ? tr.literal : tr.object, value: e}
                            })))
                        }
                        if (Yt(u)) {
                            if (!(v = u.options[h] || u.options.other)) throw new rr(u.value, h, Object.keys(u.options), a);
                            o.push.apply(o, or(v.value, t, n, r, i))
                        } else if (Zt(u)) {
                            var v;
                            if (!(v = u.options["=".concat(h)])) {
                                if (!Intl.PluralRules) throw new nr('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', Qn.MISSING_INTL_API, a);
                                var b = n.getPluralRules(t, {type: u.pluralType}).select(h - (u.offset || 0));
                                v = u.options[b] || u.options.other
                            }
                            if (!v) throw new rr(u.value, h, Object.keys(u.options), a);
                            o.push.apply(o, or(v.value, t, n, r, i, h - (u.offset || 0)))
                        }
                    }
                }
            }
            return (w = o).length < 2 ? w : w.reduce((function (e, t) {
                var n = e[e.length - 1];
                return n && n.type === tr.literal && t.type === tr.literal ? n.value += t.value : e.push(t), e
            }), []);
            var w
        }

        function lr(e) {
            return {
                create: function () {
                    return {
                        get: function (t) {
                            return e[t]
                        }, set: function (t, n) {
                            e[t] = n
                        }
                    }
                }
            }
        }

        !function (e) {
            e[e.literal = 0] = "literal", e[e.object = 1] = "object"
        }(tr || (tr = {}));
        var cr, ur = function () {
            function e(t, n, r, i) {
                void 0 === n && (n = e.defaultLocale);
                var s, a, o, l = this;
                if (this.formatterCache = {number: {}, dateTime: {}, pluralRules: {}}, this.format = function (e) {
                    var t = l.formatToParts(e);
                    if (1 === t.length) return t[0].value;
                    var n = t.reduce((function (e, t) {
                        return e.length && t.type === tr.literal && "string" == typeof e[e.length - 1] ? e[e.length - 1] += t.value : e.push(t.value), e
                    }), []);
                    return n.length <= 1 ? n[0] || "" : n
                }, this.formatToParts = function (e) {
                    return or(l.ast, l.locales, l.formatters, l.formats, e, void 0, l.message)
                }, this.resolvedOptions = function () {
                    var e;
                    return {locale: (null === (e = l.resolvedLocale) || void 0 === e ? void 0 : e.toString()) || Intl.NumberFormat.supportedLocalesOf(l.locales)[0]}
                }, this.getAst = function () {
                    return l.ast
                }, this.locales = n, this.resolvedLocale = e.resolveLocale(n), "string" == typeof t) {
                    if (this.message = t, !e.__parse) throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
                    var c = i || {}, u = (c.formatters, Mt(c, ["formatters"]));
                    this.ast = e.__parse(t, It(It({}, u), {locale: this.resolvedLocale}))
                } else this.ast = t;
                if (!Array.isArray(this.ast)) throw new TypeError("A message must be provided as a String or AST.");
                this.formats = (a = e.formats, (o = r) ? Object.keys(a).reduce((function (e, t) {
                    var n, r;
                    return e[t] = (n = a[t], (r = o[t]) ? It(It(It({}, n || {}), r || {}), Object.keys(n).reduce((function (e, t) {
                        return e[t] = It(It({}, n[t]), r[t] || {}), e
                    }), {})) : n), e
                }), It({}, a)) : a), this.formatters = i && i.formatters || (void 0 === (s = this.formatterCache) && (s = {
                    number: {},
                    dateTime: {},
                    pluralRules: {}
                }), {
                    getNumberFormat: Gn((function () {
                        for (var e, t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                        return new ((e = Intl.NumberFormat).bind.apply(e, Dt([void 0], t, !1)))
                    }), {cache: lr(s.number), strategy: er.variadic}), getDateTimeFormat: Gn((function () {
                        for (var e, t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                        return new ((e = Intl.DateTimeFormat).bind.apply(e, Dt([void 0], t, !1)))
                    }), {cache: lr(s.dateTime), strategy: er.variadic}), getPluralRules: Gn((function () {
                        for (var e, t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                        return new ((e = Intl.PluralRules).bind.apply(e, Dt([void 0], t, !1)))
                    }), {cache: lr(s.pluralRules), strategy: er.variadic})
                })
            }

            return Object.defineProperty(e, "defaultLocale", {
                get: function () {
                    return e.memoizedDefaultLocale || (e.memoizedDefaultLocale = (new Intl.NumberFormat).resolvedOptions().locale), e.memoizedDefaultLocale
                }, enumerable: !1, configurable: !0
            }), e.memoizedDefaultLocale = null, e.resolveLocale = function (e) {
                if (void 0 !== Intl.Locale) {
                    var t = Intl.NumberFormat.supportedLocalesOf(e);
                    return t.length > 0 ? new Intl.Locale(t[0]) : new Intl.Locale("string" == typeof e ? e : e[0])
                }
            }, e.__parse = zn, e.formats = {
                number: {
                    integer: {maximumFractionDigits: 0},
                    currency: {style: "currency"},
                    percent: {style: "percent"}
                },
                date: {
                    short: {month: "numeric", day: "numeric", year: "2-digit"},
                    medium: {month: "short", day: "numeric", year: "numeric"},
                    long: {month: "long", day: "numeric", year: "numeric"},
                    full: {weekday: "long", month: "long", day: "numeric", year: "numeric"}
                },
                time: {
                    short: {hour: "numeric", minute: "numeric"},
                    medium: {hour: "numeric", minute: "numeric", second: "numeric"},
                    long: {hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short"},
                    full: {hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short"}
                }
            }, e
        }();
        !function (e) {
            e.FORMAT_ERROR = "FORMAT_ERROR", e.UNSUPPORTED_FORMATTER = "UNSUPPORTED_FORMATTER", e.INVALID_CONFIG = "INVALID_CONFIG", e.MISSING_DATA = "MISSING_DATA", e.MISSING_TRANSLATION = "MISSING_TRANSLATION"
        }(cr || (cr = {}));
        var dr = function (e) {
            function t(n, r, i) {
                var s = this, a = i ? i instanceof Error ? i : new Error(String(i)) : void 0;
                return (s = e.call(this, "[@formatjs/intl Error ".concat(n, "] ").concat(r, "\n").concat(a ? "\n".concat(a.message, "\n").concat(a.stack) : "")) || this).code = n, "function" == typeof Error.captureStackTrace && Error.captureStackTrace(s, t), s
            }

            return jt(t, e), t
        }(Error), hr = function (e) {
            function t(t, n) {
                return e.call(this, cr.UNSUPPORTED_FORMATTER, t, n) || this
            }

            return jt(t, e), t
        }(dr), fr = function (e) {
            function t(t, n) {
                return e.call(this, cr.INVALID_CONFIG, t, n) || this
            }

            return jt(t, e), t
        }(dr), pr = function (e) {
            function t(t, n) {
                return e.call(this, cr.MISSING_DATA, t, n) || this
            }

            return jt(t, e), t
        }(dr), mr = function (e) {
            function t(t, n, r) {
                return e.call(this, cr.FORMAT_ERROR, "".concat(t, "\nLocale: ").concat(n, "\n"), r) || this
            }

            return jt(t, e), t
        }(dr), gr = function (e) {
            function t(t, n, r, i) {
                var s = e.call(this, "".concat(t, "\nMessageID: ").concat(null == r ? void 0 : r.id, "\nDefault Message: ").concat(null == r ? void 0 : r.defaultMessage, "\nDescription: ").concat(null == r ? void 0 : r.description, "\n"), n, i) || this;
                return s.descriptor = r, s
            }

            return jt(t, e), t
        }(mr), yr = function (e) {
            function t(t, n) {
                var r = e.call(this, cr.MISSING_TRANSLATION, 'Missing message: "'.concat(t.id, '" for locale "').concat(n, '", using ').concat(t.defaultMessage ? "default message (".concat("string" == typeof t.defaultMessage ? t.defaultMessage : t.defaultMessage.map((function (e) {
                    var t;
                    return null !== (t = e.value) && void 0 !== t ? t : JSON.stringify(e)
                })).join(), ")") : "id", " as fallback.")) || this;
                return r.descriptor = t, r
            }

            return jt(t, e), t
        }(dr);

        function vr(e, t, n) {
            return void 0 === n && (n = {}), t.reduce((function (t, r) {
                return r in e ? t[r] = e[r] : r in n && (t[r] = n[r]), t
            }), {})
        }

        var br = {
            formats: {},
            messages: {},
            timeZone: void 0,
            defaultLocale: "en",
            defaultFormats: {},
            fallbackOnEmptyString: !0,
            onError: function (e) {
            },
            onWarn: function (e) {
            }
        };

        function wr(e) {
            return {
                create: function () {
                    return {
                        get: function (t) {
                            return e[t]
                        }, set: function (t, n) {
                            e[t] = n
                        }
                    }
                }
            }
        }

        function xr(e, t, n, r) {
            var i, s = e && e[t];
            if (s && (i = s[n]), i) return i;
            r(new hr("No ".concat(t, " format named: ").concat(n)))
        }

        function Er(e) {
            Kt(e, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.")
        }

        var Sr = It(It({}, br), {textComponent: t.Fragment});

        function kr(e, t) {
            if (e === t) return !0;
            if (!e || !t) return !1;
            var n = Object.keys(e), r = Object.keys(t), i = n.length;
            if (r.length !== i) return !1;
            for (var s = 0; s < i; s++) {
                var a = n[s];
                if (e[a] !== t[a] || !Object.prototype.hasOwnProperty.call(t, a)) return !1
            }
            return !0
        }

        function Ar(e, t) {
            return Object.keys(e).reduce((function (n, r) {
                return n[r] = It({timeZone: t}, e[r]), n
            }), {})
        }

        function Tr(e, t) {
            return Object.keys(It(It({}, e), t)).reduce((function (n, r) {
                return n[r] = It(It({}, e[r] || {}), t[r] || {}), n
            }), {})
        }

        function Cr(e, t) {
            if (!t) return e;
            var n = ur.formats;
            return It(It(It({}, n), e), {
                date: Tr(Ar(n.date, t), Ar(e.date || {}, t)),
                time: Tr(Ar(n.time, t), Ar(e.time || {}, t))
            })
        }

        var Rr = function (e, t, n, r, i) {
                var s = e.locale, a = e.formats, o = e.messages, l = e.defaultLocale, c = e.defaultFormats,
                    u = e.fallbackOnEmptyString, d = e.onError, h = e.timeZone, f = e.defaultRichTextElements;
                void 0 === n && (n = {id: ""});
                var p = n.id, m = n.defaultMessage;
                Kt(!!p, "[@formatjs/intl] An `id` must be provided to format a message. You can either:\n1. Configure your build toolchain with [babel-plugin-formatjs](https://formatjs.io/docs/tooling/babel-plugin)\nor [@formatjs/ts-transformer](https://formatjs.io/docs/tooling/ts-transformer) OR\n2. Configure your `eslint` config to include [eslint-plugin-formatjs](https://formatjs.io/docs/tooling/linter#enforce-id)\nto autofix this issue");
                var g = String(p), y = o && Object.prototype.hasOwnProperty.call(o, g) && o[g];
                if (Array.isArray(y) && 1 === y.length && y[0].type === Bt.literal) return y[0].value;
                if (!r && y && "string" == typeof y && !f) return y.replace(/'\{(.*?)\}'/gi, "{$1}");
                if (r = It(It({}, f), r || {}), a = Cr(a, h), c = Cr(c, h), !y) {
                    if (!1 === u && "" === y) return y;
                    if ((!m || s && s.toLowerCase() !== l.toLowerCase()) && d(new yr(n, s)), m) try {
                        return t.getMessageFormat(m, l, c, i).format(r)
                    } catch (e) {
                        return d(new gr('Error formatting default message for: "'.concat(g, '", rendering default message verbatim'), s, n, e)), "string" == typeof m ? m : g
                    }
                    return g
                }
                try {
                    return t.getMessageFormat(y, s, a, It({formatters: t}, i || {})).format(r)
                } catch (e) {
                    d(new gr('Error formatting message: "'.concat(g, '", using ').concat(m ? "default message" : "id", " as fallback."), s, n, e))
                }
                if (m) try {
                    return t.getMessageFormat(m, l, c, i).format(r)
                } catch (e) {
                    d(new gr('Error formatting the default message for: "'.concat(g, '", rendering message verbatim'), s, n, e))
                }
                return "string" == typeof y ? y : "string" == typeof m ? m : g
            },
            Lr = ["style", "currency", "currencyDisplay", "unit", "unitDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "currencyDisplay", "currencySign", "notation", "signDisplay", "unit", "unitDisplay", "numberingSystem"];

        function _r(e, t, n) {
            var r = e.locale, i = e.formats, s = e.onError;
            void 0 === n && (n = {});
            var a = n.format, o = a && xr(i, "number", a, s) || {};
            return t(r, vr(n, Lr, o))
        }

        function Pr(e, t, n, r) {
            void 0 === r && (r = {});
            try {
                return _r(e, t, r).format(n)
            } catch (t) {
                e.onError(new dr(cr.FORMAT_ERROR, "Error formatting number.", t))
            }
            return String(n)
        }

        function Nr(e, t, n, r) {
            void 0 === r && (r = {});
            try {
                return _r(e, t, r).formatToParts(n)
            } catch (t) {
                e.onError(new dr(cr.FORMAT_ERROR, "Error formatting number.", t))
            }
            return []
        }

        var jr = ["numeric", "style"];

        function Ir(e, t, n, r, i) {
            void 0 === i && (i = {}), r || (r = "second"), Intl.RelativeTimeFormat || e.onError(new nr('Intl.RelativeTimeFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-relativetimeformat"\n', Qn.MISSING_INTL_API));
            try {
                return function (e, t, n) {
                    var r = e.locale, i = e.formats, s = e.onError;
                    void 0 === n && (n = {});
                    var a = n.format, o = !!a && xr(i, "relative", a, s) || {};
                    return t(r, vr(n, jr, o))
                }(e, t, i).format(n, r)
            } catch (t) {
                e.onError(new mr("Error formatting relative time.", e.locale, t))
            }
            return String(n)
        }

        var Mr = ["formatMatcher", "timeZone", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hourCycle", "dateStyle", "timeStyle", "calendar", "numberingSystem", "fractionalSecondDigits"];

        function Dr(e, t, n, r) {
            var i = e.locale, s = e.formats, a = e.onError, o = e.timeZone;
            void 0 === r && (r = {});
            var l = r.format, c = It(It({}, o && {timeZone: o}), l && xr(s, t, l, a)), u = vr(r, Mr, c);
            return "time" !== t || u.hour || u.minute || u.second || u.timeStyle || u.dateStyle || (u = It(It({}, u), {
                hour: "numeric",
                minute: "numeric"
            })), n(i, u)
        }

        function Or(e, t) {
            for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
            var i = n[0], s = n[1], a = void 0 === s ? {} : s, o = "string" == typeof i ? new Date(i || 0) : i;
            try {
                return Dr(e, "date", t, a).format(o)
            } catch (t) {
                e.onError(new dr(cr.FORMAT_ERROR, "Error formatting date.", t))
            }
            return String(o)
        }

        function Br(e, t) {
            for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
            var i = n[0], s = n[1], a = void 0 === s ? {} : s, o = "string" == typeof i ? new Date(i || 0) : i;
            try {
                return Dr(e, "time", t, a).format(o)
            } catch (t) {
                e.onError(new dr(cr.FORMAT_ERROR, "Error formatting time.", t))
            }
            return String(o)
        }

        function Fr(e, t) {
            for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
            var i = n[0], s = n[1], a = n[2], o = void 0 === a ? {} : a, l = e.timeZone, c = e.locale, u = e.onError,
                d = vr(o, Mr, l ? {timeZone: l} : {});
            try {
                return t(c, d).formatRange(i, s)
            } catch (e) {
                u(new dr(cr.FORMAT_ERROR, "Error formatting date time range.", e))
            }
            return String(i)
        }

        function Ur(e, t) {
            for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
            var i = n[0], s = n[1], a = void 0 === s ? {} : s, o = "string" == typeof i ? new Date(i || 0) : i;
            try {
                return Dr(e, "date", t, a).formatToParts(o)
            } catch (t) {
                e.onError(new dr(cr.FORMAT_ERROR, "Error formatting date.", t))
            }
            return []
        }

        function Hr(e, t) {
            for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
            var i = n[0], s = n[1], a = void 0 === s ? {} : s, o = "string" == typeof i ? new Date(i || 0) : i;
            try {
                return Dr(e, "time", t, a).formatToParts(o)
            } catch (t) {
                e.onError(new dr(cr.FORMAT_ERROR, "Error formatting time.", t))
            }
            return []
        }

        var $r = ["type"];

        function Kr(e, t, n, r) {
            var i = e.locale, s = e.onError;
            void 0 === r && (r = {}), Intl.PluralRules || s(new nr('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', Qn.MISSING_INTL_API));
            var a = vr(r, $r);
            try {
                return t(i, a).select(n)
            } catch (e) {
                s(new mr("Error formatting plural.", i, e))
            }
            return "other"
        }

        var zr = ["type", "style"], Gr = Date.now();

        function qr(e, t, n, r) {
            void 0 === r && (r = {});
            var i = Wr(e, t, n, r).reduce((function (e, t) {
                var n = t.value;
                return "string" != typeof n ? e.push(n) : "string" == typeof e[e.length - 1] ? e[e.length - 1] += n : e.push(n), e
            }), []);
            return 1 === i.length ? i[0] : 0 === i.length ? "" : i
        }

        function Wr(e, t, n, r) {
            var i = e.locale, s = e.onError;
            void 0 === r && (r = {}), Intl.ListFormat || s(new nr('Intl.ListFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-listformat"\n', Qn.MISSING_INTL_API));
            var a = vr(r, zr);
            try {
                var o = {}, l = n.map((function (e, t) {
                    if ("object" == typeof e) {
                        var n = function (e) {
                            return "".concat(Gr, "_").concat(e, "_").concat(Gr)
                        }(t);
                        return o[n] = e, n
                    }
                    return String(e)
                }));
                return t(i, a).formatToParts(l).map((function (e) {
                    return "literal" === e.type ? e : It(It({}, e), {value: o[e.value] || e.value})
                }))
            } catch (e) {
                s(new dr(cr.FORMAT_ERROR, "Error formatting list.", e))
            }
            return n
        }

        var Vr = ["style", "type", "fallback", "languageDisplay"];

        function Yr(e, t, n, r) {
            var i = e.locale, s = e.onError;
            Intl.DisplayNames || s(new nr('Intl.DisplayNames is not available in this environment.\nTry polyfilling it using "@formatjs/intl-displaynames"\n', Qn.MISSING_INTL_API));
            var a = vr(r, Vr);
            try {
                return t(i, a).of(n)
            } catch (e) {
                s(new dr(cr.FORMAT_ERROR, "Error formatting display name.", e))
            }
        }

        function Zr(e, t) {
            var n = function (e) {
                void 0 === e && (e = {
                    dateTime: {},
                    number: {},
                    message: {},
                    relativeTime: {},
                    pluralRules: {},
                    list: {},
                    displayNames: {}
                });
                var t = Intl.RelativeTimeFormat, n = Intl.ListFormat, r = Intl.DisplayNames, i = Gn((function () {
                    for (var e, t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                    return new ((e = Intl.DateTimeFormat).bind.apply(e, Dt([void 0], t, !1)))
                }), {cache: wr(e.dateTime), strategy: er.variadic}), s = Gn((function () {
                    for (var e, t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                    return new ((e = Intl.NumberFormat).bind.apply(e, Dt([void 0], t, !1)))
                }), {cache: wr(e.number), strategy: er.variadic}), a = Gn((function () {
                    for (var e, t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                    return new ((e = Intl.PluralRules).bind.apply(e, Dt([void 0], t, !1)))
                }), {cache: wr(e.pluralRules), strategy: er.variadic});
                return {
                    getDateTimeFormat: i,
                    getNumberFormat: s,
                    getMessageFormat: Gn((function (e, t, n, r) {
                        return new ur(e, t, n, It({
                            formatters: {
                                getNumberFormat: s,
                                getDateTimeFormat: i,
                                getPluralRules: a
                            }
                        }, r || {}))
                    }), {cache: wr(e.message), strategy: er.variadic}),
                    getRelativeTimeFormat: Gn((function () {
                        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                        return new (t.bind.apply(t, Dt([void 0], e, !1)))
                    }), {cache: wr(e.relativeTime), strategy: er.variadic}),
                    getPluralRules: a,
                    getListFormat: Gn((function () {
                        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                        return new (n.bind.apply(n, Dt([void 0], e, !1)))
                    }), {cache: wr(e.list), strategy: er.variadic}),
                    getDisplayNames: Gn((function () {
                        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                        return new (r.bind.apply(r, Dt([void 0], e, !1)))
                    }), {cache: wr(e.displayNames), strategy: er.variadic})
                }
            }(t), r = It(It({}, br), e), i = r.locale, s = r.defaultLocale, a = r.onError;
            return i ? !Intl.NumberFormat.supportedLocalesOf(i).length && a ? a(new pr('Missing locale data for locale: "'.concat(i, '" in Intl.NumberFormat. Using default locale: "').concat(s, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details'))) : !Intl.DateTimeFormat.supportedLocalesOf(i).length && a && a(new pr('Missing locale data for locale: "'.concat(i, '" in Intl.DateTimeFormat. Using default locale: "').concat(s, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details'))) : (a && a(new fr('"locale" was not configured, using "'.concat(s, '" as fallback. See https://formatjs.io/docs/react-intl/api#intlshape for more details'))), r.locale = r.defaultLocale || "en"), function (e) {
                e.onWarn && e.defaultRichTextElements && function (e) {
                    return "string" == typeof (e ? e[Object.keys(e)[0]] : void 0)
                }(e.messages || {}) && e.onWarn('[@formatjs/intl] "defaultRichTextElements" was specified but "message" was not pre-compiled. \nPlease consider using "@formatjs/cli" to pre-compile your messages for performance.\nFor more details see https://formatjs.io/docs/getting-started/message-distribution')
            }(r), It(It({}, r), {
                formatters: n,
                formatNumber: Pr.bind(null, r, n.getNumberFormat),
                formatNumberToParts: Nr.bind(null, r, n.getNumberFormat),
                formatRelativeTime: Ir.bind(null, r, n.getRelativeTimeFormat),
                formatDate: Or.bind(null, r, n.getDateTimeFormat),
                formatDateToParts: Ur.bind(null, r, n.getDateTimeFormat),
                formatTime: Br.bind(null, r, n.getDateTimeFormat),
                formatDateTimeRange: Fr.bind(null, r, n.getDateTimeFormat),
                formatTimeToParts: Hr.bind(null, r, n.getDateTimeFormat),
                formatPlural: Kr.bind(null, r, n.getPluralRules),
                formatMessage: Rr.bind(null, r, n),
                $t: Rr.bind(null, r, n),
                formatList: qr.bind(null, r, n.getListFormat),
                formatListToParts: Wr.bind(null, r, n.getListFormat),
                formatDisplayName: Yr.bind(null, r, n.getDisplayNames)
            })
        }

        function Xr(e) {
            return {
                locale: e.locale,
                timeZone: e.timeZone,
                fallbackOnEmptyString: e.fallbackOnEmptyString,
                formats: e.formats,
                textComponent: e.textComponent,
                messages: e.messages,
                defaultLocale: e.defaultLocale,
                defaultFormats: e.defaultFormats,
                onError: e.onError,
                onWarn: e.onWarn,
                wrapRichTextChunksInFragment: e.wrapRichTextChunksInFragment,
                defaultRichTextElements: e.defaultRichTextElements
            }
        }

        function Qr(e) {
            return e ? Object.keys(e).reduce((function (n, r) {
                var i, s = e[r];
                return n[r] = ar(s) ? (i = s, function (e) {
                    return i(t.Children.toArray(e))
                }) : s, n
            }), {}) : e
        }

        var Jr = function (e, n, r, i) {
            for (var s = [], a = 4; a < arguments.length; a++) s[a - 4] = arguments[a];
            var o = Qr(i), l = Rr.apply(void 0, Dt([e, n, r, o], s, !1));
            return Array.isArray(l) ? t.Children.toArray(l) : l
        }, ei = function (e, t) {
            var n = e.defaultRichTextElements, r = Mt(e, ["defaultRichTextElements"]), i = Qr(n),
                s = Zr(It(It(It({}, Sr), r), {defaultRichTextElements: i}), t), a = {
                    locale: s.locale,
                    timeZone: s.timeZone,
                    fallbackOnEmptyString: s.fallbackOnEmptyString,
                    formats: s.formats,
                    defaultLocale: s.defaultLocale,
                    defaultFormats: s.defaultFormats,
                    messages: s.messages,
                    onError: s.onError,
                    defaultRichTextElements: i
                };
            return It(It({}, s), {formatMessage: Jr.bind(null, a, s.formatters), $t: Jr.bind(null, a, s.formatters)})
        }, ti = function (e) {
            function n() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.cache = {
                    dateTime: {},
                    number: {},
                    message: {},
                    relativeTime: {},
                    pluralRules: {},
                    list: {},
                    displayNames: {}
                }, t.state = {cache: t.cache, intl: ei(Xr(t.props), t.cache), prevConfig: Xr(t.props)}, t
            }

            return jt(n, e), n.getDerivedStateFromProps = function (e, t) {
                var n = t.prevConfig, r = t.cache, i = Xr(e);
                return kr(n, i) ? null : {intl: ei(i, r), prevConfig: i}
            }, n.prototype.render = function () {
                return Er(this.state.intl), t.createElement(Ht, {value: this.state.intl}, this.props.children)
            }, n.displayName = "IntlProvider", n.defaultProps = Sr, n
        }(t.PureComponent);
        const ni = ti,
            ri = JSON.parse('{"+D82kt":"Are you sure you want to repost: {id}","+PzQ9Y":"Payout Now","+aZY2h":"Zap Type","+vA//S":"Logins","+vIQlC":"Please make sure to save the following password in order to manage your handle in the future","+vVZ/G":"Connect","/4tOwT":"Skip","/JE/X+":"Account Support","/PCavi":"Public","/RD0e2":"Nostr uses digital signature technology to provide tamper proof notes which can safely be replicated to many relays to provide redundant storage of your content.","/d6vEc":"Make your profile easier to find and share","/n5KSF":"{n} ms","08zn6O":"Export Keys","0Azlrb":"Manage","0BUTMv":"Search...","0ehN4t":"Please connect a wallet {here} to be able to pay this invoice","0jOEtS":"Invalid LNURL","0mch2Y":"name has disallowed characters","0yO7wF":"{n} secs","1A7TZk":"What is Snort and how does it work?","1Mo59U":"Are you sure you want to remove this note from bookmarks?","1R43+L":"Enter Nostr Wallet Connect config","1c4YST":"Connected to: {node} ","1iQ8GN":"Toggle Preview","1nYUGC":"{n} Following","1udzha":"Conversations","2/2yg+":"Add","25V4l1":"Banner","2IFGap":"Donate","2LbrkB":"Enter password","2a2YiP":"{n} Bookmarks","2k0Cv+":"Dislikes ({n})","2ukA4d":"{n} hours","380eol":"here","3Rx6Qo":"Advanced","3cc4Ct":"Light","3gOsZq":"Translators","3qnJlS":"You are voting with {amount} sats","3t3kok":"{n,plural,=1{{n} new note} other{{n} new notes}}","3tVy+Z":"{n} Followers","3xCwbZ":"OR","3yk8fB":"Wallet","450Fty":"None","47FYwb":"Cancel","4IPzdn":"Primary Developers","4L2vUY":"Your new NIP-05 handle is:","4OB335":"Dislike","4Vmpt4":"Nostr Plebs is one of the first NIP-05 providers in the space and offers a good collection of domains at reasonable prices","4Z3t5i":"Use imgproxy to compress images","4rYCjn":"Note to Self","5JcXdV":"Create Account","5oTnfy":"Buy Handle","5rOdPG":"Once you setup your key manager extension and generated a key, you can follow our new users flow to setup your profile and help you find some interesting people on Nostr to follow.","5u6iEc":"Transfer to Pubkey","5ykRmX":"Send zap","65BmHb":"Failed to proxy image from {host}, click here to load directly","6Yfvvp":"Get an identifier","6ewQqw":"Likes ({n})","6uMqL1":"Unpaid","7+Domh":"Notes","7BX/yC":"Account Switcher","7hp70g":"NIP-05","7xzTiH":"{action} to {target}","8/vBbP":"Reposts ({n})","89q5wc":"Confirm Reposts","8QDesP":"Zap {n} sats","8g2vyB":"name too long","8v1NN+":"Pairing phrase","9+Ddtu":"Next","9HU8vw":"Reply","9SvQep":"Follows {n}","9WRlF4":"Send","9gqH2W":"Login","9pMqYs":"Nostr Address","9qtLJC":"Payment Required","9wO4wJ":"Lightning Invoice","ADmfQT":"Parent","AGNz71":"Zap All {n} sats","ASRK0S":"This author has been muted","Adk34V":"Setup your Profile","Ai8VHU":"Unlimited note retention on Snort relay","AkCxS/":"Reason","AnLrRC":"Non-Zap","AyGauy":"Login","B4C47Y":"name too short","B6+XJy":"zapped","B6H7eJ":"nsec, npub, nip-05, hex","BGCM48":"Write access to Snort relay, with 1 year of event retention","BOUMjw":"No nostr users found for {twitterUsername}","BOr9z/":"Snort is an open source project built by passionate people in their free time","BWpuKl":"Update","BcGMo+":"Notes hold text content, the most popular usage of these notes is to store \\"tweet like\\" messages.","C5xzTC":"Premium","C81/uG":"Logout","C8HhVE":"Suggested Follows","CHTbO3":"Failed to load invoice","CVWeJ6":"Trending People","CmZ9ls":"{n} Muted","CsCUYo":"{n} sats","Cu/K85":"Translated from {lang}","D+KzKd":"Automatically zap every note when loaded","D3idYv":"Settings","DKnriN":"Send sats","DZzCem":"Show latest {n} notes","DcL8P+":"Supporter","Dh3hbq":"Auto Zap","DqLx9k":"You must pay {n} sats to access this file.","DtYelJ":"Transfer","E8a4yq":"Follow some popular accounts","ELbg9p":"Data Providers","EPYwm7":"Your private key is your password. If you lose this key, you will lose access to your account! Copy it and keep it in a safe place. There is no way to reset your private key.","EWyQH5":"Global","Ebl/B2":"Translate to {lang}","EcZF24":"Custom Relays","EcglP9":"Key","EnCOBJ":"Buy","Eqjl5K":"Only Snort and our integration partner identifier gives you a colorful domain name, but you are welcome to use other services too.","F+B3x1":"We have also partnered with nostrplebs.com to give you more options","F3l7xL":"Add Account","FDguSC":"{n} Zaps","FP+D3H":"LNURL to forward zaps to","FS3b54":"Done!","FdhSU2":"Claim Now","FfYsOb":"An error has occured!","FmXUJg":"follows you","FpxElY":"Verification","G/yZLu":"Remove","G1BGCg":"Select Wallet","GFOoEE":"Salt","GL8aXW":"Bookmarks ({n})","GUlSVG":"Claim your included Snort nostr address","Gcn9NQ":"Magnet Link","GspYR7":"{n} Dislike","H+vHiz":"Hex Key..","H0JBH6":"Log Out","H6/kLh":"Order Paid!","HAlOn1":"Name","HFls6j":"name will be available later","HOzFdo":"Muted","HWbkEK":"Clear cache and reload","HbefNb":"Open Wallet","IDjHJ6":"Thanks for using Snort, please consider donating if you can.","IEwZvs":"Are you sure you want to unpin this note?","INSqIz":"Twitter username...","IUZC+0":"This means that nobody can modify notes which you have created and everybody can easily verify that the notes they are reading are created by you.","Ig9/a1":"Sent {n} sats to {name}","Iwm6o2":"NIP-05 Shop","Ix8l+B":"Trending Notes","J+dIsA":"Subscriptions","JCIgkj":"Username","JHEHCk":"Zaps ({n})","JPFYIM":"No lightning address","JkLHGw":"Website","JymXbw":"Private Key","K3r6DQ":"Delete","K7AkdL":"Show","KAhAcM":"Enter LNDHub config","KLo3SP":"Reason: {reason}","KQvWvD":"Deleted","KWuDfz":"I have saved my keys, continue","KahimY":"Unknown event kind: {kind}","KoFlZg":"Enter mint URL","LF5kYT":"Other Connections","LXxsbk":"Anonymous","LgbKvU":"Comment","Lu5/Bj":"Open on Zapstr","M3Oirc":"Debug Menus","MBAYRO":"Shows \\"Copy ID\\" and \\"Copy Event JSON\\" in the context menu on each message","MI2jkA":"Not available:","MP54GY":"Wallet password","MRp6Ly":"Twitter username","MWTx65":"Default Page","Mrpkot":"Pay for subscription","MzRYWH":"Buying {item}","N2IrpM":"Confirm","NAuFNH":"You already have a subscription of this type, please renew or pay","NNSu3d":"Import Twitter Follows","NdOYJJ":"Hmm nothing here.. Checkout {newUsersPage} to follow some recommended nostrich\'s!","NepkXH":"Can\'t vote with {amount} sats, please set a different default zap amount","NfNk2V":"Your private key","NndBJE":"New users page","O9GTIc":"Profile picture","OEW7yJ":"Zaps","OKhRC6":"Share","OLEm6z":"Unknown login error","OQXnew":"You subscription is still active, you can\'t renew yet","ORGv1Q":"Created","P04gQm":"All zaps sent to this note will be received by the following LNURL","P61BTu":"Copy Event JSON","P7FD0F":"System (Default)","P7nJT9":"Total today (UTC): {amount} sats","PCSt5T":"Preferences","PLSbmL":"Your mnemonic phrase","PamNxw":"Unknown file header: {name}","Pe0ogR":"Theme","PrsIg7":"Reactions will be shown on every page, if disabled no reactions will be shown","QDFTjG":"{n} Relays","QWhotP":"Zap Pool only works if you use one of the supported wallet connections (WebLN, LNC, LNDHub or Nostr Wallet Connect)","QawghE":"You can change your username at any point.","QxCuTo":"Art by {name}","Qxv0B2":"You currently have {number} sats in your zap pool.","R/6nsx":"Subscription","R1fEdZ":"Forward Zaps","R2OqnW":"Delete Account","RDZVQL":"Check","RahCRH":"Expired","RfhLwC":"By: {author}","RhDAoS":"Are you sure you want to delete {id}","RjpoYG":"Recent","RoOyAh":"Relays","Rs4kCE":"Bookmark","RwFaYs":"Sort","SOqbe9":"Update Lightning Address","SP0+yi":"Buy Subscription","SX58hM":"Copy","SYQtZ7":"LN Address Proxy","Sjo1P4":"Custom","Ss0sWu":"Pay Now","TDR5ge":"Media in notes will automatically be shown for selected people, otherwise only the link will show","TMfYfY":"Cashu token","TpgeGw":"Hex Salt..","Tpy00S":"People","TwyMau":"Account","UDYlxu":"Pending Subscriptions","ULotH9":"Amount: {amount} sats","UUPFlt":"Users must accept the content warning to show the content of your note.","Up5U7K":"Block","VBadwB":"Hmm, can\'t find a key manager extension.. try reloading the page.","VN0+Fz":"Balance: {amount} sats","VOjC1i":"Pick which upload service you want to upload attachments to","VR5eHw":"Public key (npub/nprofile)","VlJkSk":"{n} muted","VnXp8Z":"Avatar","VtPV/B":"Login with Extension (NIP-07)","Vx7Zm2":"How do keys work?","W1yoZY":"It looks like you dont have any subscriptions, you can get one {link}","W2PiAr":"{n} Blocked","W9355R":"Unmute","WONP5O":"Find your twitter follows on nostr (Data provided by {provider})","WxthCV":"e.g. Jack","X7xU8J":"nsec, npub, nip-05, hex, mnemonic","XICsE8":"File hosts","XgWvGA":"Reactions","Xopqkl":"Your default zap amount is {number} sats, example values are calculated from this.","XrSk2j":"Redeem","XzF0aC":"Key manager extensions are more secure and allow you to easily login to any Nostr client, here are some well known extensions:","Y31HTH":"Help fund the development of Snort","YDURw6":"Service URL","YXA3AH":"Enable reactions","Z0FDj+":"Subscribe to Snort {plan} for {price} and receive the following rewards","Z4BMCZ":"Enter pairing phrase","ZKORll":"Activate Now","ZLmyG9":"Contributors","ZUZedV":"Lightning Donation:","Zr5TMx":"Setup profile","a5UPxh":"Fund developers and platforms providing NIP-05 verification services","a7TDNm":"Notes will stream in real time into global and notes tab","aWpBzj":"Show more","b12Goz":"Mnemonic","b5vAk0":"Your handle will act like a lightning address and will redirect to your chosen LNURL or Lightning address","bQdA2k":"Sensitive Content","bep9C3":"Public Key","brAXSu":"Pick a username","bxv59V":"Just now","c+oiJe":"Install Extension","c35bj2":"If you have an enquiry about your NIP-05 order please DM {link}","c3g2hL":"Broadcast Again","cE4Hfw":"Discover","cFbU1B":"Using Alby? Go to {link} to get your NWC config!","cPIKU2":"Following","cQfLWb":"URL..","cWx9t8":"Mute all","cg1VJ2":"Connect Wallet","cuP16y":"Multi account support","cuV2gK":"name is registered","cyR7Kh":"Back","d6CyG5":"History","d7d0/x":"LN Address","dOQCL8":"Display name","e61Jf3":"Coming soon","e7qqly":"Mark All Read","eHAneD":"Reaction emoji","eJj8HD":"Get Verified","eSzf2G":"A single zap of {nIn} sats will allocate {nOut} sats to the zap pool.","fOksnD":"Can\'t vote because LNURL service does not support zaps","fWZYP5":"Pinned","filwqD":"Read","flnGvv":"What\'s on your mind?","fsB/4p":"Saved","g5pX+a":"About","g985Wp":"Failed to send vote","gBdUXk":"Save your keys!","gDZkld":"Snort is a Nostr UI, nostr is a decentralised protocol for saving and distributing \\"notes\\".","gDzDRs":"Emoji to send when reactiong to a note","gXgY3+":"Not all clients support this yet","gczcC5":"Subscribe","gjBiyj":"Loading...","h8XMJL":"Badges","hK5ZDk":"the world","hMzcSq":"Messages","hY4lzx":"Supports","hicxcO":"Show replies","hniz8Z":"here","i/dBAR":"Zap Pool","iCqGww":"Reactions ({n})","iDGAbc":"Get a Snort identifier","iEoXYx":"DeepL translations","iGT1eE":"Prevent fake accounts from imitating you","iNWbVV":"Handle","iUsU2x":"Mint: {url}","iXPL0Z":"Can\'t login with private key on an insecure connection, please use a Nostr key manager extension instead","ieGrWo":"Follow","itPgxd":"Profile","izWS4J":"Unfollow","jA3OE/":"{n,plural,=1{{n} sat} other{{n} sats}}","jCA7Cw":"Preview on snort","jMzO1S":"Internal error: {msg}","jfV8Wr":"Back","juhqvW":"Improve login security with browser extensions","jvo0vs":"Save","jzgQ2z":"{n} Reactions","k2veDA":"Write","k7sKNy":"Our very own NIP-05 verification service, help support the development of this site and get a shiny special badge on our site!","kaaf1E":"now","l+ikU1":"Everything in {plan}","lBboHo":"If you want to try out some others, check out {link} for more!","lCILNz":"Buy Now","lD3+8a":"Pay","lPWASz":"Snort nostr address","lTbT3s":"Wallet password","lgg1KN":"account page","ll3xBp":"Image proxy service","lnaT9F":"Following {n}","lsNFM1":"Click to load content from {link}","lvlPhZ":"Pay Invoice","mErPop":"It looks like you dont have any, check {link} to buy one!","mH91FY":"Each contributor will get paid a percentage of all donations and NIP-05 orders, you can see the split amounts below","mKAr6h":"Follow all","mKh2HS":"File upload service","mKhgP9":"{n,plural,=0{} =1{zapped} other{zapped}}","mTJFgF":"Popular","mfe8RW":"Option: {n}","n1Whvj":"Switch","nDejmx":"Unblock","nGBrvw":"Bookmarks","nN9XTz":"Share your thoughts with {link}","nOaArs":"Setup Profile","nWQFic":"Renew","nn1qb3":"Your donations are greatly appreciated","nwZXeh":"{n} blocked","o6Uy3d":"Only the secret key can be used to publish (sign events), everything else logs you in read-only mode.","o7e+nJ":"{n} followers","oJ+JJN":"Nothing found :/","odFwjL":"Follows only","odhABf":"Login","osUr8O":"You can also use these extensions to login to most Nostr sites.","oxCa4R":"Getting an identifier helps confirm the real you to people who know you. Many people can have a username @jack, but there is only one jack@cash.app.","p85Uwy":"Active Subscriptions","pI+77w":"Downloadable backups from Snort relay","puLNUJ":"Pin","pzTOmv":"Followers","qD9EUF":"Email <> DM bridge for your Snort nostr address","qDwvZ4":"Unknown error","qMx1sA":"Default Zap amount","qUJTsT":"Blocked","qdGuQo":"Your Private Key Is (do not share this with anyone)","qkvYUb":"Add to Profile","qmJ8kD":"Translation failed","r3C4x/":"Software","r5srDR":"Enter wallet password","rT14Ow":"Add Relays","reJ6SM":"It is recommended to use one of the following browser extensions if you are on a desktop computer to secure your key:","rfuMjE":"(Default)","rmdsT4":"{n} days","rrfdTe":"This is the same technology which is used by Bitcoin and has been proven to be extremely secure.","rudscU":"Failed to load follows, please try again later","sWnYKw":"Snort is designed to have a similar experience to Twitter.","svOoEH":"Name-squatting and impersonation is not allowed. Snort and our partners reserve the right to terminate your handle (not your account - nobody can take that away) for violating this rule.","tOdNiY":"Dark","th5lxp":"Send note to a subset of your write relays","thnRpU":"Getting NIP-05 verified can help:","ttxS0b":"Supporter Badge","u/vOPu":"Paid","u4bHcR":"Check out the code here: {link}","uD/N6c":"Zap {target} {n} sats","uSV4Ti":"Reposts need to be manually confirmed","usAvMr":"Edit Profile","ut+2Cd":"Get a partner identifier","vOKedj":"{n,plural,=1{& {n} other} other{& {n} others}}","vU71Ez":"Paying with {wallet}","vZ4quW":"NIP-05 is a DNS based verification spec which helps to validate you as a real user.","vhlWFg":"Poll Options","vrTOHJ":"{amount} sats","wEQDC6":"Edit","wLtRCF":"Your key","wWLwvh":"Anon","wYSD2L":"Nostr Adddress","wih7iJ":"name is blocked","wqyN/i":"Find out more info about {service} at {link}","wtLjP6":"Copy ID","wvFw6Y":"Hey, it looks like you dont have a NIP-05 handle yet, you should get one! Check out {link}","x/Fx2P":"Fund the services that you use by splitting a portion of all your zaps into a pool of funds!","x/q8d5":"This note has been marked as sensitive, click here to reveal","x82IOl":"Mute","xIoGG9":"Go to","xJ9n2N":"Your public key","xKflGN":"{username}\'\'s Follows on Nostr","xQtL3v":"Unlock","xaj9Ba":"Provider","xbVgIm":"Automatically load media","xhQMeQ":"Expires","xmcVZ0":"Search","y1Z3or":"Language","yCLnBC":"LNURL or Lightning Address","yCmnnm":"Read global from","zFegDD":"Contact","zINlao":"Owner","zQvVDJ":"All","zcaOTs":"Zap amount in sats","zjJZBd":"You\'re ready!","zonsdq":"Failed to load LNURL service","zvCDao":"Automatically show latest notes"}');
        var ii = a(8995), si = a(7271), ai = a(2036);
        const oi = "https://api.snort.social", li = "https://translate.snort.social", ci = "https://void.cat",
            ui = "npub1v0lxxxxutpvrelsksy8cdhgfux9l6a42hsj2qzquu2zk7vc9qnkszrqj49",
            di = "npub1sn0rtcjcf543gj4wsg7fa59s700d5ztys5ctj0g69g2x6802npjqhjjtws",
            hi = new Map([["wss://relay.snort.social/", {read: !0, write: !0}], ["wss://nostr.wine/", {
                read: !0,
                write: !1
            }], ["wss://nos.lol/", {read: !0, write: !0}]]), fi = ["wss://relay.nostr.band"],
            pi = ["82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2", "3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d", "020f2d21ae09bf35fcdfb65decf1478b846f5f728ab30c5eaabcd6d081a81c3e", "6e468422dfb74a5738702a8823b9b28168abab8655faacb6853cd0ee15deee93", "63fe6318dc58583cfe16810f86dd09e18bfd76aabc24a0081ce2856f330504ed", "32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245", "e33fe65f1fde44c6dc17eeb38fdad0fceaf1cae8722084332ed1e32496291d42", "00000000827ffaa94bfea288c3dfce4422c794fbb96625b6b31e9049f729d700", "A341F45FF9758F570A21B000C17D4E53A3A497C8397F26C0E6D61E5ACFFC7A98", "E88A691E98D9987C964521DFF60025F60700378A4879180DCBBB4A5027850411", "C4EABAE1BE3CF657BC1855EE05E69DE9F059CB7A059227168B80B89761CBC4E0", "85080D3BAD70CCDCD7F74C29A44F55BB85CBCD3DD0CBB957DA1D215BDB931204", "C49D52A573366792B9A6E4851587C28042FB24FA5625C6D67B8C95C8751ACA15", "83E818DFBECCEA56B0F551576B3FD39A7A50E1D8159343500368FA085CCD964B", "3F770D65D3A764A9C5CB503AE123E62EC7598AD035D836E2A810F3877A745B24", "472F440F29EF996E92A186B8D320FF180C855903882E59D50DE1B8BD5669301E", "1577e4599dd10c863498fe3c20bd82aafaf829a595ce83c5cf8ac3463531b09b", "04c915daefee38317fa734444acee390a8269fe5810b2241e5e6dd343dfbecc9", "7fa56f5d6962ab1e3cd424e758c3002b8665f7b0d8dcee9fe9e288d7751ac194"],
            mi = {
                url: "https://imgproxy.snort.social",
                key: "a82fcf26aa0ccb55dfc6b4bd6a1c90744d3be0f38429f21a8828b43449ce7cebe6bdc2b09a827311bef37b18ce35cb1e6b1c60387a254541afa9e5b4264ae942",
                salt: "a897770d9abf163de055e9617891214e75a9016d748f8ef865e6ffbcb9ed932295659549773a22a019a5f06d0b440c320be411e3fddfe784e199e4f03d74bd9b"
            }, gi = "m/44'/1237'/0'/0/0",
            yi = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
            vi = /(\w+)/g, bi = /\.([\w]{1,7})$/i, wi = /(#\[\d+\])/gi, xi = /(lnbc\w+)/i,
            Ei = /(?:https?:\/\/)?(?:www|m\.)?(?:youtu\.be\/|youtube\.com\/(?:live\/|shorts\/|embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})/,
            Si = /https?:\/\/twitter\.com\/(?:#!\/)?(\w+)\/status(?:es)?\/(\d+)/,
            ki = /(#[^\s!@#$%^&*()=+.\/,\[{\]};:'"?><]+)/g, Ai = /tidal\.com\/(?:browse\/)?(\w+)\/([a-z0-9-]+)/i,
            Ti = /soundcloud\.com\/(?!live)([a-zA-Z0-9]+)\/([a-zA-Z0-9-]+)/,
            Ci = /mixcloud\.com\/(?!live)([a-zA-Z0-9]+)\/([a-zA-Z0-9-]+)/,
            Ri = /open\.spotify\.com\/(track|album|playlist|episode)\/([a-zA-Z0-9]+)/, Li = /twitch.tv\/([a-z0-9_]+$)/i,
            _i = /music\.apple\.com\/([a-z]{2}\/)?(?:album|playlist)\/[\w\d-]+\/([.a-zA-Z0-9-]+)(?:\?i=\d+)?/i,
            Pi = /nostrnests\.com\/[a-zA-Z0-9]+/i,
            Ni = /https?:\/\/(?:player\.|www\.)?wavlake\.com\/(?!top|new|artists|account|activity|login|preferences|feed|profile)(?:(?:track|album)\/[a-f0-9]{8}(?:-[a-f0-9]{4}){3}-[a-f0-9]{12}|[a-z-]+)/i,
            ji = /(cashuA[A-Za-z0-9_-]{0,10000}={0,3})/i, Ii = {
                language: "en",
                enableReactions: !0,
                reactionEmoji: "+",
                autoLoadMedia: "follows-only",
                theme: "system",
                confirmReposts: !1,
                showDebugMenus: !1,
                autoShowLatest: !1,
                fileUploader: "void.cat",
                imgProxyConfig: mi,
                defaultRootTab: "notes",
                defaultZapAmount: 50,
                autoZap: !1
            };
        var Mi, Di, Oi, Bi, Fi, Ui = function (e, t, n, r, i) {
            if ("m" === r) throw new TypeError("Private method is not writable");
            if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
        }, Hi = function (e, t, n, r) {
            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
        };
        const $i = "sessions", Ki = {
            preferences: Ii,
            tags: {item: [], timestamp: 0},
            follows: {item: [], timestamp: 0},
            muted: {item: [], timestamp: 0},
            blocked: {item: [], timestamp: 0},
            bookmarked: {item: [], timestamp: 0},
            pinned: {item: [], timestamp: 0},
            relays: {
                item: Object.fromEntries([...hi.entries()].map((e => [(0, ai.unwrap)((0, ai.sanitizeRelayUrl)(e[0])), e[1]]))),
                timestamp: 0
            },
            latestNotification: 0,
            readNotifications: 0,
            subscriptions: []
        }, zi = "secret", Gi = "pubkey", qi = "preferences";

        class Wi extends ai.ExternalStore {
            constructor() {
                super(), Mi.add(this), Di.set(this, void 0), Oi.set(this, void 0);
                const e = window.localStorage.getItem($i);
                Ui(this, Oi, e ? new Map(JSON.parse(e).map((e => [(0, ai.unwrap)(e.publicKey), e]))) : new Map, "f"), Hi(this, Mi, "m", Bi).call(this), Hi(this, Di, "f") || Ui(this, Di, Hi(this, Oi, "f").keys().next().value, "f")
            }

            getSessions() {
                return [...Hi(this, Oi, "f").keys()]
            }

            allSubscriptions() {
                return [...Hi(this, Oi, "f").values()].map((e => e.subscriptions)).flat()
            }

            switchAccount(e) {
                Hi(this, Oi, "f").has(e) && (Ui(this, Di, e, "f"), Hi(this, Mi, "m", Fi).call(this))
            }

            loginWithPubkey(e, t) {
                if (Hi(this, Oi, "f").has(e)) throw new Error("Already logged in with this pubkey");
                const n = this.decideInitRelays(t),
                    r = {...Ki, publicKey: e, relays: {item: n, timestamp: 1}, preferences: (0, ai.deepClone)(Ii)};
                return Hi(this, Oi, "f").set(e, r), Ui(this, Di, e, "f"), Hi(this, Mi, "m", Fi).call(this), r
            }

            decideInitRelays(e) {
                return e && Object.keys(e).length > 0 ? e : Object.fromEntries(hi.entries())
            }

            loginWithPrivateKey(e, t, n) {
                const r = si.ci(ii.xW.getPublicKey(e));
                if (Hi(this, Oi, "f").has(r)) throw new Error("Already logged in with this pubkey");
                const i = null != n ? n : Object.fromEntries(hi.entries()), s = {
                    ...Ki,
                    privateKey: e,
                    publicKey: r,
                    generatedEntropy: t,
                    relays: {item: i, timestamp: 1},
                    preferences: (0, ai.deepClone)(Ii)
                };
                return Hi(this, Oi, "f").set(r, s), Ui(this, Di, r, "f"), Hi(this, Mi, "m", Fi).call(this), s
            }

            updateSession(e) {
                const t = (0, ai.unwrap)(e.publicKey);
                Hi(this, Oi, "f").has(t) && (Hi(this, Oi, "f").set(t, e), Hi(this, Mi, "m", Fi).call(this))
            }

            removeSession(e) {
                Hi(this, Oi, "f").delete(e) && (Hi(this, Di, "f") === e && Ui(this, Di, void 0, "f"), Hi(this, Mi, "m", Fi).call(this))
            }

            takeSnapshot() {
                const e = Hi(this, Di, "f") ? Hi(this, Oi, "f").get(Hi(this, Di, "f")) : void 0;
                return e ? (0, ai.deepClone)(e) : Ki
            }
        }

        Di = new WeakMap, Oi = new WeakMap, Mi = new WeakSet, Bi = function () {
            let e = !1;
            const t = window.localStorage.getItem(qi), n = t ? JSON.parse(t) : (0, ai.deepClone)(Ii);
            window.localStorage.removeItem(qi);
            const r = window.localStorage.getItem(zi);
            if (r) {
                const t = si.ci(ii.xW.getPublicKey(r));
                Hi(this, Oi, "f").set(t, {
                    ...Ki,
                    privateKey: r,
                    publicKey: t,
                    preferences: n
                }), window.localStorage.removeItem(zi), window.localStorage.removeItem(Gi), e = !0
            }
            const i = window.localStorage.getItem(Gi);
            i && (Hi(this, Oi, "f").set(i, {
                ...Ki,
                publicKey: i,
                preferences: n
            }), window.localStorage.removeItem(Gi), e = !0), window.localStorage.removeItem("last-relays"), window.localStorage.removeItem("last-follows"), window.localStorage.removeItem("notifications-read");
            for (const [, t] of Hi(this, Oi, "f")) "posts" === t.preferences.defaultRootTab && (t.preferences.defaultRootTab = "notes", e = !0);
            e && (console.debug("Finished migration to MultiAccountStore"), Hi(this, Mi, "m", Fi).call(this))
        }, Fi = function () {
            !Hi(this, Di, "f") && Hi(this, Oi, "f").size > 0 && Ui(this, Di, [...Hi(this, Oi, "f").keys()][0], "f"), window.localStorage.setItem($i, JSON.stringify([...Hi(this, Oi, "f").values()])), this.notifyChange()
        };
        var Vi = a(5796), Yi = a(8050), Zi = a(846), Xi = a(5088), Qi = a(4658);
        const Ji = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]),
            es = Uint8Array.from({length: 16}, ((e, t) => t)), ts = es.map((e => (9 * e + 5) % 16));
        let ns = [es], rs = [ts];
        for (let e = 0; e < 4; e++) for (let t of [ns, rs]) t.push(t[e].map((e => Ji[e])));
        const is = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map((e => new Uint8Array(e))),
            ss = ns.map(((e, t) => e.map((e => is[t][e])))), as = rs.map(((e, t) => e.map((e => is[t][e])))),
            os = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]),
            ls = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]),
            cs = (e, t) => e << t | e >>> 32 - t;

        function us(e, t, n, r) {
            return 0 === e ? t ^ n ^ r : 1 === e ? t & n | ~t & r : 2 === e ? (t | ~n) ^ r : 3 === e ? t & r | n & ~r : t ^ (n | ~r)
        }

        const ds = new Uint32Array(16);

        class hs extends Xi.N {
            constructor() {
                super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776
            }

            get() {
                const {h0: e, h1: t, h2: n, h3: r, h4: i} = this;
                return [e, t, n, r, i]
            }

            set(e, t, n, r, i) {
                this.h0 = 0 | e, this.h1 = 0 | t, this.h2 = 0 | n, this.h3 = 0 | r, this.h4 = 0 | i
            }

            process(e, t) {
                for (let n = 0; n < 16; n++, t += 4) ds[n] = e.getUint32(t, !0);
                let n = 0 | this.h0, r = n, i = 0 | this.h1, s = i, a = 0 | this.h2, o = a, l = 0 | this.h3, c = l,
                    u = 0 | this.h4, d = u;
                for (let e = 0; e < 5; e++) {
                    const t = 4 - e, h = os[e], f = ls[e], p = ns[e], m = rs[e], g = ss[e], y = as[e];
                    for (let t = 0; t < 16; t++) {
                        const r = cs(n + us(e, i, a, l) + ds[p[t]] + h, g[t]) + u | 0;
                        n = u, u = l, l = 0 | cs(a, 10), a = i, i = r
                    }
                    for (let e = 0; e < 16; e++) {
                        const n = cs(r + us(t, s, o, c) + ds[m[e]] + f, y[e]) + d | 0;
                        r = d, d = c, c = 0 | cs(o, 10), o = s, s = n
                    }
                }
                this.set(this.h1 + a + c | 0, this.h2 + l + d | 0, this.h3 + u + r | 0, this.h4 + n + s | 0, this.h0 + i + o | 0)
            }

            roundClean() {
                ds.fill(0)
            }

            destroy() {
                this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0)
            }
        }

        const fs = (0, Qi.hE)((() => new hs));
        var ps = a(3929);
        const ms = BigInt(2 ** 32 - 1), gs = BigInt(32);

        function ys(e, t = !1) {
            return t ? {h: Number(e & ms), l: Number(e >> gs & ms)} : {
                h: 0 | Number(e >> gs & ms),
                l: 0 | Number(e & ms)
            }
        }

        const vs = {
                fromBig: ys,
                split: function (e, t = !1) {
                    let n = new Uint32Array(e.length), r = new Uint32Array(e.length);
                    for (let i = 0; i < e.length; i++) {
                        const {h: s, l: a} = ys(e[i], t);
                        [n[i], r[i]] = [s, a]
                    }
                    return [n, r]
                },
                toBig: (e, t) => BigInt(e >>> 0) << gs | BigInt(t >>> 0),
                shrSH: (e, t, n) => e >>> n,
                shrSL: (e, t, n) => e << 32 - n | t >>> n,
                rotrSH: (e, t, n) => e >>> n | t << 32 - n,
                rotrSL: (e, t, n) => e << 32 - n | t >>> n,
                rotrBH: (e, t, n) => e << 64 - n | t >>> n - 32,
                rotrBL: (e, t, n) => e >>> n - 32 | t << 64 - n,
                rotr32H: (e, t) => t,
                rotr32L: (e, t) => e,
                rotlSH: (e, t, n) => e << n | t >>> 32 - n,
                rotlSL: (e, t, n) => t << n | e >>> 32 - n,
                rotlBH: (e, t, n) => t << n - 32 | e >>> 64 - n,
                rotlBL: (e, t, n) => e << n - 32 | t >>> 64 - n,
                add: function (e, t, n, r) {
                    const i = (t >>> 0) + (r >>> 0);
                    return {h: e + n + (i / 2 ** 32 | 0) | 0, l: 0 | i}
                },
                add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
                add3H: (e, t, n, r) => t + n + r + (e / 2 ** 32 | 0) | 0,
                add4L: (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
                add4H: (e, t, n, r, i) => t + n + r + i + (e / 2 ** 32 | 0) | 0,
                add5H: (e, t, n, r, i, s) => t + n + r + i + s + (e / 2 ** 32 | 0) | 0,
                add5L: (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0)
            },
            bs = vs, [ws, xs] = bs.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e => BigInt(e)))),
            Es = new Uint32Array(80), Ss = new Uint32Array(80);

        class ks extends Xi.N {
            constructor() {
                super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
            }

            get() {
                const {
                    Ah: e,
                    Al: t,
                    Bh: n,
                    Bl: r,
                    Ch: i,
                    Cl: s,
                    Dh: a,
                    Dl: o,
                    Eh: l,
                    El: c,
                    Fh: u,
                    Fl: d,
                    Gh: h,
                    Gl: f,
                    Hh: p,
                    Hl: m
                } = this;
                return [e, t, n, r, i, s, a, o, l, c, u, d, h, f, p, m]
            }

            set(e, t, n, r, i, s, a, o, l, c, u, d, h, f, p, m) {
                this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | n, this.Bl = 0 | r, this.Ch = 0 | i, this.Cl = 0 | s, this.Dh = 0 | a, this.Dl = 0 | o, this.Eh = 0 | l, this.El = 0 | c, this.Fh = 0 | u, this.Fl = 0 | d, this.Gh = 0 | h, this.Gl = 0 | f, this.Hh = 0 | p, this.Hl = 0 | m
            }

            process(e, t) {
                for (let n = 0; n < 16; n++, t += 4) Es[n] = e.getUint32(t), Ss[n] = e.getUint32(t += 4);
                for (let e = 16; e < 80; e++) {
                    const t = 0 | Es[e - 15], n = 0 | Ss[e - 15],
                        r = bs.rotrSH(t, n, 1) ^ bs.rotrSH(t, n, 8) ^ bs.shrSH(t, n, 7),
                        i = bs.rotrSL(t, n, 1) ^ bs.rotrSL(t, n, 8) ^ bs.shrSL(t, n, 7), s = 0 | Es[e - 2],
                        a = 0 | Ss[e - 2], o = bs.rotrSH(s, a, 19) ^ bs.rotrBH(s, a, 61) ^ bs.shrSH(s, a, 6),
                        l = bs.rotrSL(s, a, 19) ^ bs.rotrBL(s, a, 61) ^ bs.shrSL(s, a, 6),
                        c = bs.add4L(i, l, Ss[e - 7], Ss[e - 16]), u = bs.add4H(c, r, o, Es[e - 7], Es[e - 16]);
                    Es[e] = 0 | u, Ss[e] = 0 | c
                }
                let {
                    Ah: n,
                    Al: r,
                    Bh: i,
                    Bl: s,
                    Ch: a,
                    Cl: o,
                    Dh: l,
                    Dl: c,
                    Eh: u,
                    El: d,
                    Fh: h,
                    Fl: f,
                    Gh: p,
                    Gl: m,
                    Hh: g,
                    Hl: y
                } = this;
                for (let e = 0; e < 80; e++) {
                    const t = bs.rotrSH(u, d, 14) ^ bs.rotrSH(u, d, 18) ^ bs.rotrBH(u, d, 41),
                        v = bs.rotrSL(u, d, 14) ^ bs.rotrSL(u, d, 18) ^ bs.rotrBL(u, d, 41), b = u & h ^ ~u & p,
                        w = d & f ^ ~d & m, x = bs.add5L(y, v, w, xs[e], Ss[e]), E = bs.add5H(x, g, t, b, ws[e], Es[e]),
                        S = 0 | x, k = bs.rotrSH(n, r, 28) ^ bs.rotrBH(n, r, 34) ^ bs.rotrBH(n, r, 39),
                        A = bs.rotrSL(n, r, 28) ^ bs.rotrBL(n, r, 34) ^ bs.rotrBL(n, r, 39), T = n & i ^ n & a ^ i & a,
                        C = r & s ^ r & o ^ s & o;
                    g = 0 | p, y = 0 | m, p = 0 | h, m = 0 | f, h = 0 | u, f = 0 | d, ({
                        h: u,
                        l: d
                    } = bs.add(0 | l, 0 | c, 0 | E, 0 | S)), l = 0 | a, c = 0 | o, a = 0 | i, o = 0 | s, i = 0 | n, s = 0 | r;
                    const R = bs.add3L(S, A, C);
                    n = bs.add3H(R, E, k, T), r = 0 | R
                }
                ({h: n, l: r} = bs.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)), ({
                    h: i,
                    l: s
                } = bs.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | s)), ({
                    h: a,
                    l: o
                } = bs.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | o)), ({
                    h: l,
                    l: c
                } = bs.add(0 | this.Dh, 0 | this.Dl, 0 | l, 0 | c)), ({
                    h: u,
                    l: d
                } = bs.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | d)), ({
                    h,
                    l: f
                } = bs.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | f)), ({
                    h: p,
                    l: m
                } = bs.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | m)), ({
                    h: g,
                    l: y
                } = bs.add(0 | this.Hh, 0 | this.Hl, 0 | g, 0 | y)), this.set(n, r, i, s, a, o, l, c, u, d, h, f, p, m, g, y)
            }

            roundClean() {
                Es.fill(0), Ss.fill(0)
            }

            destroy() {
                this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            }
        }

        class As extends ks {
            constructor() {
                super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28
            }
        }

        class Ts extends ks {
            constructor() {
                super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32
            }
        }

        class Cs extends ks {
            constructor() {
                super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48
            }
        }

        const Rs = (0, Qi.hE)((() => new ks));
        (0, Qi.hE)((() => new As)), (0, Qi.hE)((() => new Ts)), (0, Qi.hE)((() => new Cs));
        var Ls = a(9629), _s = a(5814), Ps = a(5253);
        const Ns = ii.kA.ProjectivePoint, js = (0, Ps.Av)(ps.J);

        function Is(e) {
            return BigInt(`0x${(0, Qi.ci)(e)}`)
        }

        const Ms = (0, Qi.iY)("Bitcoin seed"), Ds = {private: 76066276, public: 76067358}, Os = 2147483648, Bs = e => {
            if (!Number.isSafeInteger(e) || e < 0 || e > 2 ** 32 - 1) throw new Error(`Invalid number=${e}. Should be from 0 to 2 ** 32 - 1`);
            const t = new Uint8Array(4);
            return (0, Qi.GL)(t).setUint32(0, e, !1), t
        };

        class Fs {
            get fingerprint() {
                if (!this.pubHash) throw new Error("No publicKey set!");
                return e = this.pubHash, (0, Qi.GL)(e).getUint32(0, !1);
                var e
            }

            get identifier() {
                return this.pubHash
            }

            get pubKeyHash() {
                return this.pubHash
            }

            get privateKey() {
                return this.privKeyBytes || null
            }

            get publicKey() {
                return this.pubKey || null
            }

            get privateExtendedKey() {
                const e = this.privateKey;
                if (!e) throw new Error("No private key");
                return js.encode(this.serialize(this.versions.private, (0, Qi.eV)(new Uint8Array([0]), e)))
            }

            get publicExtendedKey() {
                if (!this.pubKey) throw new Error("No public key");
                return js.encode(this.serialize(this.versions.public, this.pubKey))
            }

            static fromMasterSeed(e, t = Ds) {
                if ((0, Ls.aI)(e), 8 * e.length < 128 || 8 * e.length > 512) throw new Error(`HDKey: wrong seed length=${e.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
                const n = (0, Zi.b)(Rs, Ms, e);
                return new Fs({versions: t, chainCode: n.slice(32), privateKey: n.slice(0, 32)})
            }

            static fromExtendedKey(e, t = Ds) {
                const n = js.decode(e), r = (0, Qi.GL)(n), i = r.getUint32(0, !1), s = {
                    versions: t,
                    depth: n[4],
                    parentFingerprint: r.getUint32(5, !1),
                    index: r.getUint32(9, !1),
                    chainCode: n.slice(13, 45)
                }, a = n.slice(45), o = 0 === a[0];
                if (i !== t[o ? "private" : "public"]) throw new Error("Version mismatch");
                return new Fs(o ? {...s, privateKey: a.slice(1)} : {...s, publicKey: a})
            }

            static fromJSON(e) {
                return Fs.fromExtendedKey(e.xpriv)
            }

            constructor(e) {
                if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !e || "object" != typeof e) throw new Error("HDKey.constructor must not be called directly");
                if (this.versions = e.versions || Ds, this.depth = e.depth || 0, this.chainCode = e.chainCode, this.index = e.index || 0, this.parentFingerprint = e.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index)) throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
                if (e.publicKey && e.privateKey) throw new Error("HDKey: publicKey and privateKey at same time.");
                if (e.privateKey) {
                    if (!ii.kA.utils.isValidPrivateKey(e.privateKey)) throw new Error("Invalid private key");
                    this.privKey = "bigint" == typeof e.privateKey ? e.privateKey : Is(e.privateKey), this.privKeyBytes = (t = this.privKey, (0, Qi.nr)(t.toString(16).padStart(64, "0"))), this.pubKey = ii.kA.getPublicKey(e.privateKey, !0)
                } else {
                    if (!e.publicKey) throw new Error("HDKey: no public or private key provided");
                    this.pubKey = Ns.fromHex(e.publicKey).toRawBytes(!0)
                }
                var t, n;
                this.pubHash = (n = this.pubKey, fs((0, ps.J)(n)))
            }

            derive(e) {
                if (!/^[mM]'?/.test(e)) throw new Error('Path must start with "m" or "M"');
                if (/^[mM]'?$/.test(e)) return this;
                const t = e.replace(/^[mM]'?\//, "").split("/");
                let n = this;
                for (const e of t) {
                    const t = /^(\d+)('?)$/.exec(e);
                    if (!t || 3 !== t.length) throw new Error(`Invalid child index: ${e}`);
                    let r = +t[1];
                    if (!Number.isSafeInteger(r) || r >= Os) throw new Error("Invalid index");
                    "'" === t[2] && (r += Os), n = n.deriveChild(r)
                }
                return n
            }

            deriveChild(e) {
                if (!this.pubKey || !this.chainCode) throw new Error("No publicKey or chainCode set");
                let t = Bs(e);
                if (e >= Os) {
                    const e = this.privateKey;
                    if (!e) throw new Error("Could not derive hardened child key");
                    t = (0, Qi.eV)(new Uint8Array([0]), e, t)
                } else t = (0, Qi.eV)(this.pubKey, t);
                const n = (0, Zi.b)(Rs, this.chainCode, t), r = Is(n.slice(0, 32)), i = n.slice(32);
                if (!ii.kA.utils.isValidPrivateKey(r)) throw new Error("Tweak bigger than curve order");
                const s = {
                    versions: this.versions,
                    chainCode: i,
                    depth: this.depth + 1,
                    parentFingerprint: this.fingerprint,
                    index: e
                };
                try {
                    if (this.privateKey) {
                        const e = (0, _s.wQ)(this.privKey + r, ii.kA.CURVE.n);
                        if (!ii.kA.utils.isValidPrivateKey(e)) throw new Error("The tweak was out of range or the resulted private key is invalid");
                        s.privateKey = e
                    } else {
                        const e = Ns.fromHex(this.pubKey).add(Ns.fromPrivateKey(r));
                        if (e.equals(Ns.ZERO)) throw new Error("The tweak was equal to negative P, which made the result key invalid");
                        s.publicKey = e.toRawBytes(!0)
                    }
                    return new Fs(s)
                } catch (t) {
                    return this.deriveChild(e + 1)
                }
            }

            sign(e) {
                if (!this.privateKey) throw new Error("No privateKey set!");
                return (0, Ls.aI)(e, 32), ii.kA.sign(e, this.privKey).toCompactRawBytes()
            }

            verify(e, t) {
                if ((0, Ls.aI)(e, 32), (0, Ls.aI)(t, 64), !this.publicKey) throw new Error("No publicKey set!");
                let n;
                try {
                    n = ii.kA.Signature.fromCompact(t)
                } catch (e) {
                    return !1
                }
                return ii.kA.verify(n, e, this.publicKey)
            }

            wipePrivateData() {
                return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this
            }

            toJSON() {
                return {xpriv: this.privateExtendedKey, xpub: this.publicExtendedKey}
            }

            serialize(e, t) {
                if (!this.chainCode) throw new Error("No chainCode set");
                return (0, Ls.aI)(t, 33), (0, Qi.eV)(Bs(e), new Uint8Array([this.depth]), Bs(this.parentFingerprint), Bs(this.index), this.chainCode, t)
            }
        }

        function Us(e) {
            try {
                const t = null != e ? e : Vi.OF(Yi.U, 256);
                return Vi.oy(t, Yi.U)
            } catch (e) {
                throw new Error("INVALID MNEMONIC PHRASE")
            }
        }

        function Hs(e) {
            const t = si.hexToBytes(e);
            return Vi.JJ(t, Yi.U)
        }

        function $s(e) {
            const t = Fs.fromMasterSeed(e).derive(gi);
            if (!t.privateKey) throw new Error("INVALID KEY DERIVATION");
            return si.ci(t.privateKey)
        }

        var Ks = a(4978);

        function zs(e, t, n) {
            if (e.relays.timestamp >= n) return;
            const r = new Map;
            for (const [e, n] of Object.entries(t)) if (e.startsWith("wss://") || e.startsWith("ws://")) {
                const t = (0, Ks.mY)(e);
                t && r.set(t, n)
            }
            e.relays.item = Object.fromEntries(r.entries()), e.relays.timestamp = n, Xs.updateSession(e)
        }

        function Gs(e, t) {
            e.preferences = t, Xs.updateSession(e)
        }

        function qs(e, t, n) {
            e.tags.timestamp >= n || (e.tags.item = t, e.tags.timestamp = n, Xs.updateSession(e))
        }

        function Ws(e, t, n) {
            e.muted.timestamp >= n || (e.muted.item = t, e.muted.timestamp = n, Xs.updateSession(e))
        }

        function Vs(e, t, n) {
            e.blocked.timestamp >= n || (e.blocked.item = t, e.blocked.timestamp = n, Xs.updateSession(e))
        }

        function Ys(e, t, n) {
            e.pinned.timestamp >= n || (e.pinned.item = t, e.pinned.timestamp = n, Xs.updateSession(e))
        }

        function Zs(e, t, n) {
            e.bookmarked.timestamp >= n || (e.bookmarked.item = t, e.bookmarked.timestamp = n, Xs.updateSession(e))
        }

        const Xs = new Wi;

        function Qs() {
            return (0, t.useSyncExternalStore)((e => Xs.hook(e)), (() => Xs.snapshot()))
        }

        const Js = "en-US";

        function ea(e) {
            for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
            throw Error("[Immer] minified error nr: " + e + (n.length ? " " + n.map((function (e) {
                return "'" + e + "'"
            })).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf")
        }

        function ta(e) {
            return !!e && !!e[Ha]
        }

        function na(e) {
            var t;
            return !!e && (function (e) {
                if (!e || "object" != typeof e) return !1;
                var t = Object.getPrototypeOf(e);
                if (null === t) return !0;
                var n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
                return n === Object || "function" == typeof n && Function.toString.call(n) === $a
            }(e) || Array.isArray(e) || !!e[Ua] || !!(null === (t = e.constructor) || void 0 === t ? void 0 : t[Ua]) || la(e) || ca(e))
        }

        function ra(e, t, n) {
            void 0 === n && (n = !1), 0 === ia(e) ? (n ? Object.keys : Ka)(e).forEach((function (r) {
                n && "symbol" == typeof r || t(r, e[r], e)
            })) : e.forEach((function (n, r) {
                return t(r, n, e)
            }))
        }

        function ia(e) {
            var t = e[Ha];
            return t ? t.i > 3 ? t.i - 4 : t.i : Array.isArray(e) ? 1 : la(e) ? 2 : ca(e) ? 3 : 0
        }

        function sa(e, t) {
            return 2 === ia(e) ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t)
        }

        function aa(e, t, n) {
            var r = ia(e);
            2 === r ? e.set(t, n) : 3 === r ? e.add(n) : e[t] = n
        }

        function oa(e, t) {
            return e === t ? 0 !== e || 1 / e == 1 / t : e != e && t != t
        }

        function la(e) {
            return Da && e instanceof Map
        }

        function ca(e) {
            return Oa && e instanceof Set
        }

        function ua(e) {
            return e.o || e.t
        }

        function da(e) {
            if (Array.isArray(e)) return Array.prototype.slice.call(e);
            var t = za(e);
            delete t[Ha];
            for (var n = Ka(t), r = 0; r < n.length; r++) {
                var i = n[r], s = t[i];
                !1 === s.writable && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (t[i] = {
                    configurable: !0,
                    writable: !0,
                    enumerable: s.enumerable,
                    value: e[i]
                })
            }
            return Object.create(Object.getPrototypeOf(e), t)
        }

        function ha(e, t) {
            return void 0 === t && (t = !1), pa(e) || ta(e) || !na(e) || (ia(e) > 1 && (e.set = e.add = e.clear = e.delete = fa), Object.freeze(e), t && ra(e, (function (e, t) {
                return ha(t, !0)
            }), !0)), e
        }

        function fa() {
            ea(2)
        }

        function pa(e) {
            return null == e || "object" != typeof e || Object.isFrozen(e)
        }

        function ma(e) {
            var t = Ga[e];
            return t || ea(18, e), t
        }

        function ga() {
            return Ia
        }

        function ya(e, t) {
            t && (ma("Patches"), e.u = [], e.s = [], e.v = t)
        }

        function va(e) {
            ba(e), e.p.forEach(xa), e.p = null
        }

        function ba(e) {
            e === Ia && (Ia = e.l)
        }

        function wa(e) {
            return Ia = {p: [], l: Ia, h: e, m: !0, _: 0}
        }

        function xa(e) {
            var t = e[Ha];
            0 === t.i || 1 === t.i ? t.j() : t.g = !0
        }

        function Ea(e, t) {
            t._ = t.p.length;
            var n = t.p[0], r = void 0 !== e && e !== n;
            return t.h.O || ma("ES5").S(t, e, r), r ? (n[Ha].P && (va(t), ea(4)), na(e) && (e = Sa(t, e), t.l || Aa(t, e)), t.u && ma("Patches").M(n[Ha].t, e, t.u, t.s)) : e = Sa(t, n, []), va(t), t.u && t.v(t.u, t.s), e !== Fa ? e : void 0
        }

        function Sa(e, t, n) {
            if (pa(t)) return t;
            var r = t[Ha];
            if (!r) return ra(t, (function (i, s) {
                return ka(e, r, t, i, s, n)
            }), !0), t;
            if (r.A !== e) return t;
            if (!r.P) return Aa(e, r.t, !0), r.t;
            if (!r.I) {
                r.I = !0, r.A._--;
                var i = 4 === r.i || 5 === r.i ? r.o = da(r.k) : r.o, s = i, a = !1;
                3 === r.i && (s = new Set(i), i.clear(), a = !0), ra(s, (function (t, s) {
                    return ka(e, r, i, t, s, n, a)
                })), Aa(e, i, !1), n && e.u && ma("Patches").N(r, n, e.u, e.s)
            }
            return r.o
        }

        function ka(e, t, n, r, i, s, a) {
            if (ta(i)) {
                var o = Sa(e, i, s && t && 3 !== t.i && !sa(t.R, r) ? s.concat(r) : void 0);
                if (aa(n, r, o), !ta(o)) return;
                e.m = !1
            } else a && n.add(i);
            if (na(i) && !pa(i)) {
                if (!e.h.D && e._ < 1) return;
                Sa(e, i), t && t.A.l || Aa(e, i)
            }
        }

        function Aa(e, t, n) {
            void 0 === n && (n = !1), !e.l && e.h.D && e.m && ha(t, n)
        }

        function Ta(e, t) {
            var n = e[Ha];
            return (n ? ua(n) : e)[t]
        }

        function Ca(e, t) {
            if (t in e) for (var n = Object.getPrototypeOf(e); n;) {
                var r = Object.getOwnPropertyDescriptor(n, t);
                if (r) return r;
                n = Object.getPrototypeOf(n)
            }
        }

        function Ra(e) {
            e.P || (e.P = !0, e.l && Ra(e.l))
        }

        function La(e) {
            e.o || (e.o = da(e.t))
        }

        function _a(e, t, n) {
            var r = la(t) ? ma("MapSet").F(t, n) : ca(t) ? ma("MapSet").T(t, n) : e.O ? function (e, t) {
                var n = Array.isArray(e), r = {
                    i: n ? 1 : 0,
                    A: t ? t.A : ga(),
                    P: !1,
                    I: !1,
                    R: {},
                    l: t,
                    t: e,
                    k: null,
                    o: null,
                    j: null,
                    C: !1
                }, i = r, s = qa;
                n && (i = [r], s = Wa);
                var a = Proxy.revocable(i, s), o = a.revoke, l = a.proxy;
                return r.k = l, r.j = o, l
            }(t, n) : ma("ES5").J(t, n);
            return (n ? n.A : ga()).p.push(r), r
        }

        function Pa(e) {
            return ta(e) || ea(22, e), function e(t) {
                if (!na(t)) return t;
                var n, r = t[Ha], i = ia(t);
                if (r) {
                    if (!r.P && (r.i < 4 || !ma("ES5").K(r))) return r.t;
                    r.I = !0, n = Na(t, i), r.I = !1
                } else n = Na(t, i);
                return ra(n, (function (t, i) {
                    r && function (e, t) {
                        return 2 === ia(e) ? e.get(t) : e[t]
                    }(r.t, t) === i || aa(n, t, e(i))
                })), 3 === i ? new Set(n) : n
            }(e)
        }

        function Na(e, t) {
            switch (t) {
                case 2:
                    return new Map(e);
                case 3:
                    return Array.from(e)
            }
            return da(e)
        }

        var ja, Ia, Ma = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), Da = "undefined" != typeof Map,
            Oa = "undefined" != typeof Set,
            Ba = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect,
            Fa = Ma ? Symbol.for("immer-nothing") : ((ja = {})["immer-nothing"] = !0, ja),
            Ua = Ma ? Symbol.for("immer-draftable") : "__$immer_draftable",
            Ha = Ma ? Symbol.for("immer-state") : "__$immer_state",
            $a = ("undefined" != typeof Symbol && Symbol.iterator, "" + Object.prototype.constructor),
            Ka = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function (e) {
                return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
            } : Object.getOwnPropertyNames, za = Object.getOwnPropertyDescriptors || function (e) {
                var t = {};
                return Ka(e).forEach((function (n) {
                    t[n] = Object.getOwnPropertyDescriptor(e, n)
                })), t
            }, Ga = {}, qa = {
                get: function (e, t) {
                    if (t === Ha) return e;
                    var n = ua(e);
                    if (!sa(n, t)) return function (e, t, n) {
                        var r, i = Ca(t, n);
                        return i ? "value" in i ? i.value : null === (r = i.get) || void 0 === r ? void 0 : r.call(e.k) : void 0
                    }(e, n, t);
                    var r = n[t];
                    return e.I || !na(r) ? r : r === Ta(e.t, t) ? (La(e), e.o[t] = _a(e.A.h, r, e)) : r
                }, has: function (e, t) {
                    return t in ua(e)
                }, ownKeys: function (e) {
                    return Reflect.ownKeys(ua(e))
                }, set: function (e, t, n) {
                    var r = Ca(ua(e), t);
                    if (null == r ? void 0 : r.set) return r.set.call(e.k, n), !0;
                    if (!e.P) {
                        var i = Ta(ua(e), t), s = null == i ? void 0 : i[Ha];
                        if (s && s.t === n) return e.o[t] = n, e.R[t] = !1, !0;
                        if (oa(n, i) && (void 0 !== n || sa(e.t, t))) return !0;
                        La(e), Ra(e)
                    }
                    return e.o[t] === n && (void 0 !== n || t in e.o) || Number.isNaN(n) && Number.isNaN(e.o[t]) || (e.o[t] = n, e.R[t] = !0), !0
                }, deleteProperty: function (e, t) {
                    return void 0 !== Ta(e.t, t) || t in e.t ? (e.R[t] = !1, La(e), Ra(e)) : delete e.R[t], e.o && delete e.o[t], !0
                }, getOwnPropertyDescriptor: function (e, t) {
                    var n = ua(e), r = Reflect.getOwnPropertyDescriptor(n, t);
                    return r ? {
                        writable: !0,
                        configurable: 1 !== e.i || "length" !== t,
                        enumerable: r.enumerable,
                        value: n[t]
                    } : r
                }, defineProperty: function () {
                    ea(11)
                }, getPrototypeOf: function (e) {
                    return Object.getPrototypeOf(e.t)
                }, setPrototypeOf: function () {
                    ea(12)
                }
            }, Wa = {};
        ra(qa, (function (e, t) {
            Wa[e] = function () {
                return arguments[0] = arguments[0][0], t.apply(this, arguments)
            }
        })), Wa.deleteProperty = function (e, t) {
            return Wa.set.call(this, e, t, void 0)
        }, Wa.set = function (e, t, n) {
            return qa.set.call(this, e[0], t, n, e[0])
        };
        var Va = function () {
            function e(e) {
                var t = this;
                this.O = Ba, this.D = !0, this.produce = function (e, n, r) {
                    if ("function" == typeof e && "function" != typeof n) {
                        var i = n;
                        n = e;
                        var s = t;
                        return function (e) {
                            var t = this;
                            void 0 === e && (e = i);
                            for (var r = arguments.length, a = Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++) a[o - 1] = arguments[o];
                            return s.produce(e, (function (e) {
                                var r;
                                return (r = n).call.apply(r, [t, e].concat(a))
                            }))
                        }
                    }
                    var a;
                    if ("function" != typeof n && ea(6), void 0 !== r && "function" != typeof r && ea(7), na(e)) {
                        var o = wa(t), l = _a(t, e, void 0), c = !0;
                        try {
                            a = n(l), c = !1
                        } finally {
                            c ? va(o) : ba(o)
                        }
                        return "undefined" != typeof Promise && a instanceof Promise ? a.then((function (e) {
                            return ya(o, r), Ea(e, o)
                        }), (function (e) {
                            throw va(o), e
                        })) : (ya(o, r), Ea(a, o))
                    }
                    if (!e || "object" != typeof e) {
                        if (void 0 === (a = n(e)) && (a = e), a === Fa && (a = void 0), t.D && ha(a, !0), r) {
                            var u = [], d = [];
                            ma("Patches").M(e, a, u, d), r(u, d)
                        }
                        return a
                    }
                    ea(21, e)
                }, this.produceWithPatches = function (e, n) {
                    if ("function" == typeof e) return function (n) {
                        for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++) i[s - 1] = arguments[s];
                        return t.produceWithPatches(n, (function (t) {
                            return e.apply(void 0, [t].concat(i))
                        }))
                    };
                    var r, i, s = t.produce(e, n, (function (e, t) {
                        r = e, i = t
                    }));
                    return "undefined" != typeof Promise && s instanceof Promise ? s.then((function (e) {
                        return [e, r, i]
                    })) : [s, r, i]
                }, "boolean" == typeof (null == e ? void 0 : e.useProxies) && this.setUseProxies(e.useProxies), "boolean" == typeof (null == e ? void 0 : e.autoFreeze) && this.setAutoFreeze(e.autoFreeze)
            }

            var t = e.prototype;
            return t.createDraft = function (e) {
                na(e) || ea(8), ta(e) && (e = Pa(e));
                var t = wa(this), n = _a(this, e, void 0);
                return n[Ha].C = !0, ba(t), n
            }, t.finishDraft = function (e, t) {
                var n = (e && e[Ha]).A;
                return ya(n, t), Ea(void 0, n)
            }, t.setAutoFreeze = function (e) {
                this.D = e
            }, t.setUseProxies = function (e) {
                e && !Ba && ea(20), this.O = e
            }, t.applyPatches = function (e, t) {
                var n;
                for (n = t.length - 1; n >= 0; n--) {
                    var r = t[n];
                    if (0 === r.path.length && "replace" === r.op) {
                        e = r.value;
                        break
                    }
                }
                n > -1 && (t = t.slice(n + 1));
                var i = ma("Patches").$;
                return ta(e) ? i(e, t) : this.produce(e, (function (e) {
                    return i(e, t)
                }))
            }, e
        }(), Ya = new Va, Za = Ya.produce;
        Ya.produceWithPatches.bind(Ya), Ya.setAutoFreeze.bind(Ya), Ya.setUseProxies.bind(Ya), Ya.applyPatches.bind(Ya), Ya.createDraft.bind(Ya), Ya.finishDraft.bind(Ya);
        const Xa = Za;

        function Qa(e) {
            return Qa = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                return typeof e
            } : function (e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            }, Qa(e)
        }

        function Ja(e, t, n) {
            return (t = function (e) {
                var t = function (e, t) {
                    if ("object" !== Qa(e) || null === e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, "string");
                        if ("object" !== Qa(r)) return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" === Qa(t) ? t : String(t)
            }(t)) in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }

        function eo(e, t) {
            var n = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
                var r = Object.getOwnPropertySymbols(e);
                t && (r = r.filter((function (t) {
                    return Object.getOwnPropertyDescriptor(e, t).enumerable
                }))), n.push.apply(n, r)
            }
            return n
        }

        function to(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = null != arguments[t] ? arguments[t] : {};
                t % 2 ? eo(Object(n), !0).forEach((function (t) {
                    Ja(e, t, n[t])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eo(Object(n)).forEach((function (t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                }))
            }
            return e
        }

        function no(e) {
            return "Minified Redux error #" + e + "; visit https://redux.js.org/Errors?code=" + e + " for the full message or use the non-minified dev environment for full errors. "
        }

        var ro = "function" == typeof Symbol && Symbol.observable || "@@observable", io = function () {
            return Math.random().toString(36).substring(7).split("").join(".")
        }, so = {
            INIT: "@@redux/INIT" + io(), REPLACE: "@@redux/REPLACE" + io(), PROBE_UNKNOWN_ACTION: function () {
                return "@@redux/PROBE_UNKNOWN_ACTION" + io()
            }
        };

        function ao(e, t, n) {
            var r;
            if ("function" == typeof t && "function" == typeof n || "function" == typeof n && "function" == typeof arguments[3]) throw new Error(no(0));
            if ("function" == typeof t && void 0 === n && (n = t, t = void 0), void 0 !== n) {
                if ("function" != typeof n) throw new Error(no(1));
                return n(ao)(e, t)
            }
            if ("function" != typeof e) throw new Error(no(2));
            var i = e, s = t, a = [], o = a, l = !1;

            function c() {
                o === a && (o = a.slice())
            }

            function u() {
                if (l) throw new Error(no(3));
                return s
            }

            function d(e) {
                if ("function" != typeof e) throw new Error(no(4));
                if (l) throw new Error(no(5));
                var t = !0;
                return c(), o.push(e), function () {
                    if (t) {
                        if (l) throw new Error(no(6));
                        t = !1, c();
                        var n = o.indexOf(e);
                        o.splice(n, 1), a = null
                    }
                }
            }

            function h(e) {
                if (!function (e) {
                    if ("object" != typeof e || null === e) return !1;
                    for (var t = e; null !== Object.getPrototypeOf(t);) t = Object.getPrototypeOf(t);
                    return Object.getPrototypeOf(e) === t
                }(e)) throw new Error(no(7));
                if (void 0 === e.type) throw new Error(no(8));
                if (l) throw new Error(no(9));
                try {
                    l = !0, s = i(s, e)
                } finally {
                    l = !1
                }
                for (var t = a = o, n = 0; n < t.length; n++) (0, t[n])();
                return e
            }

            return h({type: so.INIT}), (r = {
                dispatch: h, subscribe: d, getState: u, replaceReducer: function (e) {
                    if ("function" != typeof e) throw new Error(no(10));
                    i = e, h({type: so.REPLACE})
                }
            })[ro] = function () {
                var e, t = d;
                return (e = {
                    subscribe: function (e) {
                        if ("object" != typeof e || null === e) throw new Error(no(11));

                        function n() {
                            e.next && e.next(u())
                        }

                        return n(), {unsubscribe: t(n)}
                    }
                })[ro] = function () {
                    return this
                }, e
            }, r
        }

        function oo() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            return 0 === t.length ? function (e) {
                return e
            } : 1 === t.length ? t[0] : t.reduce((function (e, t) {
                return function () {
                    return e(t.apply(void 0, arguments))
                }
            }))
        }

        function lo() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            return function (e) {
                return function () {
                    var n = e.apply(void 0, arguments), r = function () {
                        throw new Error(no(15))
                    }, i = {
                        getState: n.getState, dispatch: function () {
                            return r.apply(void 0, arguments)
                        }
                    }, s = t.map((function (e) {
                        return e(i)
                    }));
                    return r = oo.apply(void 0, s)(n.dispatch), to(to({}, n), {}, {dispatch: r})
                }
            }
        }

        function co(e) {
            return function (t) {
                var n = t.dispatch, r = t.getState;
                return function (t) {
                    return function (i) {
                        return "function" == typeof i ? i(n, r, e) : t(i)
                    }
                }
            }
        }

        var uo = co();
        uo.withExtraArgument = co;
        const ho = uo;
        var fo = function () {
                var e = function (t, n) {
                    return e = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
                        e.__proto__ = t
                    } || function (e, t) {
                        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
                    }, e(t, n)
                };
                return function (t, n) {
                    if ("function" != typeof n && null !== n) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");

                    function r() {
                        this.constructor = t
                    }

                    e(t, n), t.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
                }
            }(), po = function (e, t) {
                for (var n = 0, r = t.length, i = e.length; n < r; n++, i++) e[i] = t[n];
                return e
            }, mo = Object.defineProperty, go = Object.defineProperties, yo = Object.getOwnPropertyDescriptors,
            vo = Object.getOwnPropertySymbols, bo = Object.prototype.hasOwnProperty,
            wo = Object.prototype.propertyIsEnumerable, xo = function (e, t, n) {
                return t in e ? mo(e, t, {enumerable: !0, configurable: !0, writable: !0, value: n}) : e[t] = n
            }, Eo = function (e, t) {
                for (var n in t || (t = {})) bo.call(t, n) && xo(e, n, t[n]);
                if (vo) for (var r = 0, i = vo(t); r < i.length; r++) n = i[r], wo.call(t, n) && xo(e, n, t[n]);
                return e
            }, So = function (e, t) {
                return go(e, yo(t))
            },
            ko = "undefined" != typeof window && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
                if (0 !== arguments.length) return "object" == typeof arguments[0] ? oo : oo.apply(null, arguments)
            };
        "undefined" != typeof window && window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__;
        var Ao = function (e) {
            function t() {
                for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
                var i = e.apply(this, n) || this;
                return Object.setPrototypeOf(i, t.prototype), i
            }

            return fo(t, e), Object.defineProperty(t, Symbol.species, {
                get: function () {
                    return t
                }, enumerable: !1, configurable: !0
            }), t.prototype.concat = function () {
                for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
                return e.prototype.concat.apply(this, t)
            }, t.prototype.prepend = function () {
                for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                return 1 === e.length && Array.isArray(e[0]) ? new (t.bind.apply(t, po([void 0], e[0].concat(this)))) : new (t.bind.apply(t, po([void 0], e.concat(this))))
            }, t
        }(Array);

        function To(e) {
            return na(e) ? Xa(e, (function () {
            })) : e
        }

        function Co(e, t) {
            function n() {
                for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
                if (t) {
                    var i = t.apply(void 0, n);
                    if (!i) throw new Error("prepareAction did not return an object");
                    return Eo(Eo({
                        type: e,
                        payload: i.payload
                    }, "meta" in i && {meta: i.meta}), "error" in i && {error: i.error})
                }
                return {type: e, payload: n[0]}
            }

            return n.toString = function () {
                return "" + e
            }, n.type = e, n.match = function (t) {
                return t.type === e
            }, n
        }

        function Ro(e) {
            var t, n = {}, r = [], i = {
                addCase: function (e, t) {
                    var r = "string" == typeof e ? e : e.type;
                    if (r in n) throw new Error("addCase cannot be called with two reducers for the same action type");
                    return n[r] = t, i
                }, addMatcher: function (e, t) {
                    return r.push({matcher: e, reducer: t}), i
                }, addDefaultCase: function (e) {
                    return t = e, i
                }
            };
            return e(i), [n, r, t]
        }

        function Lo(e) {
            var t = e.name;
            if (!t) throw new Error("`name` is a required option for createSlice");
            var n, r = "function" == typeof e.initialState ? e.initialState : To(e.initialState), i = e.reducers || {},
                s = Object.keys(i), a = {}, o = {}, l = {};

            function c() {
                var t = "function" == typeof e.extraReducers ? Ro(e.extraReducers) : [e.extraReducers], n = t[0],
                    i = void 0 === n ? {} : n, s = t[1], a = void 0 === s ? [] : s, l = t[2],
                    c = void 0 === l ? void 0 : l, u = Eo(Eo({}, i), o);
                return function (e, t, n, r) {
                    void 0 === n && (n = []);
                    var i, s = Ro(t), a = s[0], o = s[1], l = s[2];
                    if (function (e) {
                        return "function" == typeof e
                    }(e)) i = function () {
                        return To(e())
                    }; else {
                        var c = To(e);
                        i = function () {
                            return c
                        }
                    }

                    function u(e, t) {
                        void 0 === e && (e = i());
                        var n = po([a[t.type]], o.filter((function (e) {
                            return (0, e.matcher)(t)
                        })).map((function (e) {
                            return e.reducer
                        })));
                        return 0 === n.filter((function (e) {
                            return !!e
                        })).length && (n = [l]), n.reduce((function (e, n) {
                            if (n) {
                                var r;
                                if (ta(e)) return void 0 === (r = n(e, t)) ? e : r;
                                if (na(e)) return Xa(e, (function (e) {
                                    return n(e, t)
                                }));
                                if (void 0 === (r = n(e, t))) {
                                    if (null === e) return e;
                                    throw Error("A case reducer on a non-draftable value must not return undefined")
                                }
                                return r
                            }
                            return e
                        }), e)
                    }

                    return u.getInitialState = i, u
                }(r, (function (e) {
                    for (var t in u) e.addCase(t, u[t]);
                    for (var n = 0, r = a; n < r.length; n++) {
                        var i = r[n];
                        e.addMatcher(i.matcher, i.reducer)
                    }
                    c && e.addDefaultCase(c)
                }))
            }

            return s.forEach((function (e) {
                var n, r, s = i[e], c = t + "/" + e;
                "reducer" in s ? (n = s.reducer, r = s.prepare) : n = s, a[e] = n, o[c] = n, l[e] = r ? Co(c, r) : Co(c)
            })), {
                name: t, reducer: function (e, t) {
                    return n || (n = c()), n(e, t)
                }, actions: l, caseReducers: a, getInitialState: function () {
                    return n || (n = c()), n.getInitialState()
                }
            }
        }

        var _o = ["name", "message", "stack", "code"], Po = function (e, t) {
            this.payload = e, this.meta = t
        }, No = function (e, t) {
            this.payload = e, this.meta = t
        }, jo = function (e) {
            if ("object" == typeof e && null !== e) {
                for (var t = {}, n = 0, r = _o; n < r.length; n++) {
                    var i = r[n];
                    "string" == typeof e[i] && (t[i] = e[i])
                }
                return t
            }
            return {message: String(e)}
        };

        function Io(e) {
            if (e.meta && e.meta.rejectedWithValue) throw e.payload;
            if (e.error) throw e.error;
            return e.payload
        }

        !function () {
            function e(e, t, n) {
                var r = Co(e + "/fulfilled", (function (e, t, n, r) {
                    return {payload: e, meta: So(Eo({}, r || {}), {arg: n, requestId: t, requestStatus: "fulfilled"})}
                })), i = Co(e + "/pending", (function (e, t, n) {
                    return {
                        payload: void 0,
                        meta: So(Eo({}, n || {}), {arg: t, requestId: e, requestStatus: "pending"})
                    }
                })), s = Co(e + "/rejected", (function (e, t, r, i, s) {
                    return {
                        payload: i,
                        error: (n && n.serializeError || jo)(e || "Rejected"),
                        meta: So(Eo({}, s || {}), {
                            arg: r,
                            requestId: t,
                            rejectedWithValue: !!i,
                            requestStatus: "rejected",
                            aborted: "AbortError" === (null == e ? void 0 : e.name),
                            condition: "ConditionError" === (null == e ? void 0 : e.name)
                        })
                    }
                })), a = "undefined" != typeof AbortController ? AbortController : function () {
                    function e() {
                        this.signal = {
                            aborted: !1, addEventListener: function () {
                            }, dispatchEvent: function () {
                                return !1
                            }, onabort: function () {
                            }, removeEventListener: function () {
                            }, reason: void 0, throwIfAborted: function () {
                            }
                        }
                    }

                    return e.prototype.abort = function () {
                    }, e
                }();
                return Object.assign((function (e) {
                    return function (o, l, c) {
                        var u, d = (null == n ? void 0 : n.idGenerator) ? n.idGenerator(e) : function (e) {
                            void 0 === e && (e = 21);
                            for (var t = "", n = e; n--;) t += "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"[64 * Math.random() | 0];
                            return t
                        }(), h = new a;

                        function f(e) {
                            u = e, h.abort()
                        }

                        var p = function () {
                            return a = this, p = null, m = function () {
                                var a, p, m, g, y, v;
                                return function (e, t) {
                                    var n, r, i, s, a = {
                                        label: 0, sent: function () {
                                            if (1 & i[0]) throw i[1];
                                            return i[1]
                                        }, trys: [], ops: []
                                    };
                                    return s = {
                                        next: o(0),
                                        throw: o(1),
                                        return: o(2)
                                    }, "function" == typeof Symbol && (s[Symbol.iterator] = function () {
                                        return this
                                    }), s;

                                    function o(s) {
                                        return function (o) {
                                            return function (s) {
                                                if (n) throw new TypeError("Generator is already executing.");
                                                for (; a;) try {
                                                    if (n = 1, r && (i = 2 & s[0] ? r.return : s[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, s[1])).done) return i;
                                                    switch (r = 0, i && (s = [2 & s[0], i.value]), s[0]) {
                                                        case 0:
                                                        case 1:
                                                            i = s;
                                                            break;
                                                        case 4:
                                                            return a.label++, {value: s[1], done: !1};
                                                        case 5:
                                                            a.label++, r = s[1], s = [0];
                                                            continue;
                                                        case 7:
                                                            s = a.ops.pop(), a.trys.pop();
                                                            continue;
                                                        default:
                                                            if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                                                a = 0;
                                                                continue
                                                            }
                                                            if (3 === s[0] && (!i || s[1] > i[0] && s[1] < i[3])) {
                                                                a.label = s[1];
                                                                break
                                                            }
                                                            if (6 === s[0] && a.label < i[1]) {
                                                                a.label = i[1], i = s;
                                                                break
                                                            }
                                                            if (i && a.label < i[2]) {
                                                                a.label = i[2], a.ops.push(s);
                                                                break
                                                            }
                                                            i[2] && a.ops.pop(), a.trys.pop();
                                                            continue
                                                    }
                                                    s = t.call(e, a)
                                                } catch (e) {
                                                    s = [6, e], r = 0
                                                } finally {
                                                    n = i = 0
                                                }
                                                if (5 & s[0]) throw s[1];
                                                return {value: s[0] ? s[1] : void 0, done: !0}
                                            }([s, o])
                                        }
                                    }
                                }(this, (function (b) {
                                    switch (b.label) {
                                        case 0:
                                            return b.trys.push([0, 4, , 5]), null === (w = g = null == (a = null == n ? void 0 : n.condition) ? void 0 : a.call(n, e, {
                                                getState: l,
                                                extra: c
                                            })) || "object" != typeof w || "function" != typeof w.then ? [3, 2] : [4, g];
                                        case 1:
                                            g = b.sent(), b.label = 2;
                                        case 2:
                                            if (!1 === g || h.signal.aborted) throw{
                                                name: "ConditionError",
                                                message: "Aborted due to condition callback returning false."
                                            };
                                            return y = new Promise((function (e, t) {
                                                return h.signal.addEventListener("abort", (function () {
                                                    return t({name: "AbortError", message: u || "Aborted"})
                                                }))
                                            })), o(i(d, e, null == (p = null == n ? void 0 : n.getPendingMeta) ? void 0 : p.call(n, {
                                                requestId: d,
                                                arg: e
                                            }, {
                                                getState: l,
                                                extra: c
                                            }))), [4, Promise.race([y, Promise.resolve(t(e, {
                                                dispatch: o,
                                                getState: l,
                                                extra: c,
                                                requestId: d,
                                                signal: h.signal,
                                                abort: f,
                                                rejectWithValue: function (e, t) {
                                                    return new Po(e, t)
                                                },
                                                fulfillWithValue: function (e, t) {
                                                    return new No(e, t)
                                                }
                                            })).then((function (t) {
                                                if (t instanceof Po) throw t;
                                                return t instanceof No ? r(t.payload, d, e, t.meta) : r(t, d, e)
                                            }))])];
                                        case 3:
                                            return m = b.sent(), [3, 5];
                                        case 4:
                                            return v = b.sent(), m = v instanceof Po ? s(null, d, e, v.payload, v.meta) : s(v, d, e), [3, 5];
                                        case 5:
                                            return n && !n.dispatchConditionRejection && s.match(m) && m.meta.condition || o(m), [2, m]
                                    }
                                    var w
                                }))
                            }, new Promise((function (e, t) {
                                var n = function (e) {
                                    try {
                                        i(m.next(e))
                                    } catch (e) {
                                        t(e)
                                    }
                                }, r = function (e) {
                                    try {
                                        i(m.throw(e))
                                    } catch (e) {
                                        t(e)
                                    }
                                }, i = function (t) {
                                    return t.done ? e(t.value) : Promise.resolve(t.value).then(n, r)
                                };
                                i((m = m.apply(a, p)).next())
                            }));
                            var a, p, m
                        }();
                        return Object.assign(p, {
                            abort: f, requestId: d, arg: e, unwrap: function () {
                                return p.then(Io)
                            }
                        })
                    }
                }), {pending: i, rejected: s, fulfilled: r, typePrefix: e})
            }

            e.withTypes = function () {
                return e
            }
        }(), Object.assign;
        var Mo = "listenerMiddleware";
        Co(Mo + "/add"), Co(Mo + "/removeAll"), Co(Mo + "/remove"), "function" == typeof queueMicrotask && queueMicrotask.bind("undefined" != typeof window ? window : void 0 !== a.g ? a.g : globalThis);
        "undefined" != typeof window && window.requestAnimationFrame && window.requestAnimationFrame, function () {
            function e(e, t) {
                var n = i[e];
                return n ? n.enumerable = t : i[e] = n = {
                    configurable: !0, enumerable: t, get: function () {
                        var t = this[Ha];
                        return qa.get(t, e)
                    }, set: function (t) {
                        var n = this[Ha];
                        qa.set(n, e, t)
                    }
                }, n
            }

            function t(e) {
                for (var t = e.length - 1; t >= 0; t--) {
                    var i = e[t][Ha];
                    if (!i.P) switch (i.i) {
                        case 5:
                            r(i) && Ra(i);
                            break;
                        case 4:
                            n(i) && Ra(i)
                    }
                }
            }

            function n(e) {
                for (var t = e.t, n = e.k, r = Ka(n), i = r.length - 1; i >= 0; i--) {
                    var s = r[i];
                    if (s !== Ha) {
                        var a = t[s];
                        if (void 0 === a && !sa(t, s)) return !0;
                        var o = n[s], l = o && o[Ha];
                        if (l ? l.t !== a : !oa(o, a)) return !0
                    }
                }
                var c = !!t[Ha];
                return r.length !== Ka(t).length + (c ? 0 : 1)
            }

            function r(e) {
                var t = e.k;
                if (t.length !== e.t.length) return !0;
                var n = Object.getOwnPropertyDescriptor(t, t.length - 1);
                if (n && !n.get) return !0;
                for (var r = 0; r < t.length; r++) if (!t.hasOwnProperty(r)) return !0;
                return !1
            }

            var i = {};
            !function (e, t) {
                Ga[e] || (Ga[e] = t)
            }("ES5", {
                J: function (t, n) {
                    var r = Array.isArray(t), i = function (t, n) {
                        if (t) {
                            for (var r = Array(n.length), i = 0; i < n.length; i++) Object.defineProperty(r, "" + i, e(i, !0));
                            return r
                        }
                        var s = za(n);
                        delete s[Ha];
                        for (var a = Ka(s), o = 0; o < a.length; o++) {
                            var l = a[o];
                            s[l] = e(l, t || !!s[l].enumerable)
                        }
                        return Object.create(Object.getPrototypeOf(n), s)
                    }(r, t), s = {
                        i: r ? 5 : 4,
                        A: n ? n.A : ga(),
                        P: !1,
                        I: !1,
                        R: {},
                        l: n,
                        t,
                        k: i,
                        o: null,
                        g: !1,
                        C: !1
                    };
                    return Object.defineProperty(i, Ha, {value: s, writable: !0}), i
                }, S: function (e, n, i) {
                    i ? ta(n) && n[Ha].A === e && t(e.p) : (e.u && function e(t) {
                        if (t && "object" == typeof t) {
                            var n = t[Ha];
                            if (n) {
                                var i = n.t, s = n.k, a = n.R, o = n.i;
                                if (4 === o) ra(s, (function (t) {
                                    t !== Ha && (void 0 !== i[t] || sa(i, t) ? a[t] || e(s[t]) : (a[t] = !0, Ra(n)))
                                })), ra(i, (function (e) {
                                    void 0 !== s[e] || sa(s, e) || (a[e] = !1, Ra(n))
                                })); else if (5 === o) {
                                    if (r(n) && (Ra(n), a.length = !0), s.length < i.length) for (var l = s.length; l < i.length; l++) a[l] = !1; else for (var c = i.length; c < s.length; c++) a[c] = !0;
                                    for (var u = Math.min(s.length, i.length), d = 0; d < u; d++) s.hasOwnProperty(d) || (a[d] = !0), void 0 === a[d] && e(s[d])
                                }
                            }
                        }
                    }(e.p[0]), t(e.p))
                }, K: function (e) {
                    return 4 === e.i ? n(e) : r(e)
                }
            })
        }();
        const Do = {
            show: !1,
            note: "",
            error: "",
            active: !1,
            showAdvanced: !1,
            selectedCustomRelays: !1,
            zapForward: "",
            sensitive: "",
            otherEvents: []
        }, Oo = Lo({
            name: "NoteCreator", initialState: Do, reducers: {
                setShow: (e, t) => {
                    e.show = t.payload
                }, setNote: (e, t) => {
                    e.note = t.payload
                }, setError: (e, t) => {
                    e.error = t.payload
                }, setActive: (e, t) => {
                    e.active = t.payload
                }, setPreview: (e, t) => {
                    e.preview = t.payload
                }, setReplyTo: (e, t) => {
                    e.replyTo = t.payload
                }, setShowAdvanced: (e, t) => {
                    e.showAdvanced = t.payload
                }, setSelectedCustomRelays: (e, t) => {
                    e.selectedCustomRelays = t.payload
                }, setZapForward: (e, t) => {
                    e.zapForward = t.payload
                }, setSensitive: (e, t) => {
                    e.sensitive = t.payload
                }, setPollOptions: (e, t) => {
                    e.pollOptions = t.payload
                }, setOtherEvents: (e, t) => {
                    e.otherEvents = t.payload
                }, reset: () => Do
            }
        }), {
            setShow: Bo,
            setNote: Fo,
            setError: Uo,
            setActive: Ho,
            setPreview: $o,
            setReplyTo: Ko,
            setShowAdvanced: zo,
            setSelectedCustomRelays: Go,
            setZapForward: qo,
            setSensitive: Wo,
            setPollOptions: Vo,
            setOtherEvents: Yo,
            reset: Zo
        } = Oo.actions, Xo = Oo.reducer, Qo = {show: !1, selectedCustomRelays: !1}, Jo = Lo({
            name: "ReBroadcast", initialState: Qo, reducers: {
                setShow: (e, t) => {
                    e.show = t.payload
                }, setNote: (e, t) => {
                    e.note = t.payload
                }, setSelectedCustomRelays: (e, t) => {
                    e.selectedCustomRelays = t.payload
                }, reset: () => Qo
            }
        }), {setShow: el, setNote: tl, setSelectedCustomRelays: nl, reset: rl} = Jo.actions, il = function (e) {
            var t, n = function (e) {
                    return function (e) {
                        void 0 === e && (e = {});
                        var t = e.thunk, n = void 0 === t || t, r = (e.immutableCheck, e.serializableCheck, new Ao);
                        return n && (function (e) {
                            return "boolean" == typeof e
                        }(n) ? r.push(ho) : r.push(ho.withExtraArgument(n.extraArgument))), r
                    }(e)
                }, r = e || {}, i = r.reducer, s = void 0 === i ? void 0 : i, a = r.middleware, o = void 0 === a ? n() : a,
                l = r.devTools, c = void 0 === l || l, u = r.preloadedState, d = void 0 === u ? void 0 : u,
                h = r.enhancers, f = void 0 === h ? void 0 : h;
            if ("function" == typeof s) t = s; else {
                if (!function (e) {
                    if ("object" != typeof e || null === e) return !1;
                    var t = Object.getPrototypeOf(e);
                    if (null === t) return !0;
                    for (var n = t; null !== Object.getPrototypeOf(n);) n = Object.getPrototypeOf(n);
                    return t === n
                }(s)) throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
                t = function (e) {
                    for (var t = Object.keys(e), n = {}, r = 0; r < t.length; r++) {
                        var i = t[r];
                        "function" == typeof e[i] && (n[i] = e[i])
                    }
                    var s, a = Object.keys(n);
                    try {
                        !function (e) {
                            Object.keys(e).forEach((function (t) {
                                var n = e[t];
                                if (void 0 === n(void 0, {type: so.INIT})) throw new Error(no(12));
                                if (void 0 === n(void 0, {type: so.PROBE_UNKNOWN_ACTION()})) throw new Error(no(13))
                            }))
                        }(n)
                    } catch (e) {
                        s = e
                    }
                    return function (e, t) {
                        if (void 0 === e && (e = {}), s) throw s;
                        for (var r = !1, i = {}, o = 0; o < a.length; o++) {
                            var l = a[o], c = n[l], u = e[l], d = c(u, t);
                            if (void 0 === d) throw t && t.type, new Error(no(14));
                            i[l] = d, r = r || d !== u
                        }
                        return (r = r || a.length !== Object.keys(e).length) ? i : e
                    }
                }(s)
            }
            var p = o;
            "function" == typeof p && (p = p(n));
            var m = lo.apply(void 0, p), g = oo;
            c && (g = ko(Eo({trace: !1}, "object" == typeof c && c)));
            var y = [m];
            return Array.isArray(f) ? y = po([m], f) : "function" == typeof f && (y = f(y)), ao(t, d, g.apply(void 0, y))
        }({reducer: {noteCreator: Xo, reBroadcast: Jo.reducer}}), sl = il;

        function al() {
            var e = t.useContext($t);
            return Er(e), e
        }

        function ol(e) {
            var n = al(), r = n.formatMessage, i = n.textComponent, s = void 0 === i ? t.Fragment : i, a = e.id,
                o = e.description, l = e.defaultMessage, c = e.values, u = e.children, d = e.tagName,
                h = void 0 === d ? s : d,
                f = r({id: a, description: o, defaultMessage: l}, c, {ignoreTag: e.ignoreTag});
            return "function" == typeof u ? u(Array.isArray(f) ? f : [f]) : h ? t.createElement(h, null, t.Children.toArray(f)) : t.createElement(t.Fragment, null, f)
        }

        ol.displayName = "FormattedMessage";
        var ll = t.memo(ol, (function (e, t) {
            var n = e.values, r = Mt(e, ["values"]), i = t.values, s = Mt(t, ["values"]);
            return kr(i, n) && kr(r, s)
        }));
        ll.displayName = "MemoizedFormattedMessage";
        const cl = ll;
        var ul, dl, hl = a(1222);
        !function (e) {
            e.formatDate = "FormattedDate", e.formatTime = "FormattedTime", e.formatNumber = "FormattedNumber", e.formatList = "FormattedList", e.formatDisplayName = "FormattedDisplayName"
        }(ul || (ul = {})), function (e) {
            e.formatDate = "FormattedDateParts", e.formatTime = "FormattedTimeParts", e.formatNumber = "FormattedNumberParts", e.formatList = "FormattedListParts"
        }(dl || (dl = {}));
        var fl = function (e) {
            var t = al(), n = e.value, r = e.children, i = Mt(e, ["value", "children"]);
            return r(t.formatNumberToParts(n, i))
        };

        function pl(e) {
            var t = function (t) {
                var n = al(), r = t.value, i = t.children, s = Mt(t, ["value", "children"]),
                    a = "string" == typeof r ? new Date(r || 0) : r;
                return i("formatDate" === e ? n.formatDateToParts(a, s) : n.formatTimeToParts(a, s))
            };
            return t.displayName = dl[e], t
        }

        function ml(e) {
            var n = function (n) {
                var r = al(), i = n.value, s = n.children, a = Mt(n, ["value", "children"]), o = r[e](i, a);
                if ("function" == typeof s) return s(o);
                var l = r.textComponent || t.Fragment;
                return t.createElement(l, null, o)
            };
            return n.displayName = ul[e], n
        }

        fl.displayName = "FormattedNumberParts", fl.displayName = "FormattedNumberParts";
        var gl = ml("formatDate"), yl = (ml("formatTime"), ml("formatNumber"));
        ml("formatList"), ml("formatDisplayName"), pl("formatDate"), pl("formatTime");
        const vl = {id: "AyGauy", defaultMessage: "Login"}, bl = {id: "1udzha", defaultMessage: "Conversations"},
            wl = {id: "EWyQH5", defaultMessage: "Global"}, xl = {id: "NndBJE", defaultMessage: "New users page"}, El = {
                id: "NdOYJJ",
                defaultMessage: "Hmm nothing here.. Checkout {newUsersPage} to follow some recommended nostrich's!"
            }, Sl = {id: "7+Domh", defaultMessage: "Notes"}, kl = {id: "XgWvGA", defaultMessage: "Reactions"},
            Al = {id: "pzTOmv", defaultMessage: "Followers"}, Tl = {id: "cPIKU2", defaultMessage: "Following"},
            Cl = {id: "OEW7yJ", defaultMessage: "Zaps"}, Rl = {id: "HOzFdo", defaultMessage: "Muted"},
            Ll = {id: "W2PiAr", defaultMessage: "{n} Blocked"},
            _l = {id: "jA3OE/", defaultMessage: "{n} {n, plural, =1 {sat} other {sats}}"},
            Pl = {id: "D3idYv", defaultMessage: "Settings"}, Nl = {id: "hMzcSq", defaultMessage: "Messages"},
            jl = {id: "e7qqly", defaultMessage: "Mark All Read"}, Il = {id: "eJj8HD", defaultMessage: "Get Verified"},
            Ml = {
                id: "vZ4quW",
                defaultMessage: "NIP-05 is a DNS based verification spec which helps to validate you as a real user."
            }, Dl = {id: "thnRpU", defaultMessage: "Getting NIP-05 verified can help:"},
            Ol = {id: "iGT1eE", defaultMessage: "Prevent fake accounts from imitating you"},
            Bl = {id: "/d6vEc", defaultMessage: "Make your profile easier to find and share"},
            Fl = {id: "a5UPxh", defaultMessage: "Fund developers and platforms providing NIP-05 verification services"},
            Ul = {
                id: "k7sKNy",
                defaultMessage: "Our very own NIP-05 verification service, help support the development of this site and get a shiny special badge on our site!"
            }, Hl = {
                id: "4Vmpt4",
                defaultMessage: "Nostr Plebs is one of the first NIP-05 providers in the space and offers a good collection of domains at reasonable prices"
            }, $l = {id: "RoOyAh", defaultMessage: "Relays"}, Kl = {id: "nGBrvw", defaultMessage: "Bookmarks"},
            zl = a.p + "be850cbae7c9ec6f3704.svg", Gl = t => {
                const n = t.size || 20, r = `${zl}#` + t.name;
                return (0, e.jsx)("svg", {
                    width: n,
                    height: n,
                    className: t.className,
                    onClick: t.onClick,
                    children: (0, e.jsx)("use", {href: r})
                })
            }, ql = a.p + "1cc87fd8db25937e4671.webp";

        function Wl() {
            const e = Qs().preferences.imgProxyConfig, t = new TextEncoder;

            function n(e) {
                return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
            }

            return {
                proxy: (r, i) => {
                    if (!e) return r;
                    if (r.startsWith("data:") || r.startsWith("blob:")) return r;
                    const s = i ? `rs:fit:${i}:${i}/dpr:${window.devicePixelRatio}` : "", a = t.encode(r),
                        o = `/${s}/${n(Ps.US.encode(a))}`, l = function (r) {
                            const i = (0, Ks.SA)(si.hexToBytes((0, Ks.Wg)(e).key), si.hexToBytes((0, Ks.Wg)(e).salt), t.encode(r));
                            return n(Ps.US.encode(i))
                        }(o);
                    return `${new URL(e.url).toString()}${l}${o}`
                }
            }
        }

        const Vl = n => {
            let {user: r, size: i, onClick: s} = n;
            const [a, o] = (0, t.useState)(ql), {proxy: l} = Wl();
            (0, t.useEffect)((() => {
                if (null != r && r.picture) {
                    const e = l(r.picture, null != i ? i : 120);
                    o(e)
                } else o(ql)
            }), [r]);
            const c = {"--img-url": `url(${a})`}, u = (null == r ? void 0 : r.nip05) && r.nip05.split("@")[1];
            return (0, e.jsx)("div", {
                onClick: s,
                style: c,
                className: "avatar",
                "data-domain": null == u ? void 0 : u.toLowerCase()
            })
        }, Yl = t => {
            let {nip05: n, pubkey: r, verifyNip: i = !0} = t;
            const [s, a] = n ? n.split("@") : [], o = "_" === s, {isVerified: l} = function (e, t) {
                const n = (0, hl.useUserProfile)(DS, e);
                return {isVerified: t || (null == n ? void 0 : n.isNostrAddressValid)}
            }(r, !i);
            return (0, e.jsxs)("div", {
                className: "flex nip05" + (l ? "" : " failed"),
                children: [!o && l && (0, e.jsx)("span", {
                    className: "nick",
                    children: `${s}@`
                }), l && (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("span", {
                        className: "domain",
                        "data-domain": null == a ? void 0 : a.toLowerCase(),
                        children: a
                    }), (0, e.jsx)(Gl, {name: "badge", className: "badge", size: 16})]
                })]
            })
        };

        function Zl(n) {
            let {
                pubkey: r,
                subHeader: i,
                showUsername: s = !0,
                className: a,
                link: o,
                defaultNip: l,
                verifyNip: c,
                overrideUsername: u,
                profile: d
            } = n;
            const h = null != d ? d : (0, hl.useUserProfile)(DS, r), f = l || (null == h ? void 0 : h.nip05),
                p = (0, t.useMemo)((() => null != u ? u : Xl(h, r)), [h, r, u]);
            return (0, e.jsxs)(Rt, {
                className: "pfp" + (a ? ` ${a}` : ""),
                to: void 0 === o ? (0, Ks._v)(r) : o,
                onClick: function (e) {
                    "" === o && e.preventDefault()
                },
                replace: !0,
                children: [(0, e.jsx)("div", {
                    className: "avatar-wrapper",
                    children: (0, e.jsx)(Vl, {user: h})
                }), s && (0, e.jsxs)("div", {
                    className: "f-ellipsis",
                    children: [(0, e.jsxs)("div", {
                        className: "username",
                        children: [(0, e.jsx)("div", {children: p.trim()}), f && (0, e.jsx)(Yl, {
                            nip05: f,
                            pubkey: r,
                            verifyNip: c
                        })]
                    }), (0, e.jsx)("div", {className: "subheader", children: i})]
                })]
            })
        }

        function Xl(e, t) {
            let n = (0, Ks.jm)(Pt.NostrPrefix.PublicKey, t).substring(0, 12);
            return "string" == typeof (null == e ? void 0 : e.display_name) && e.display_name.length > 0 ? n = e.display_name : "string" == typeof (null == e ? void 0 : e.name) && e.name.length > 0 && (n = e.name), n
        }

        var Ql = a(9085);
        const Jl = {chats: "++id", eventInteraction: "++id", payments: "++url"};

        class ec extends Ql.default {
            constructor() {
                super("snortDB"), this.ready = !1, this.version(11).stores(Jl)
            }

            isAvailable() {
                return "indexedDB" in window ? new Promise((e => {
                    const t = window.indexedDB.open("dummy", 1);
                    t.onsuccess = () => {
                        e(!0)
                    }, t.onerror = () => {
                        e(!1)
                    }
                })) : Promise.resolve(!1)
            }
        }

        const tc = new ec;

        class nc extends ai.FeedCache {
            constructor() {
                super("EventInteraction", tc.eventInteraction)
            }

            key(e) {
                return (0, Ks.JQ)(e.event + e.by)
            }

            async preload() {
                await super.preload();
                const e = window.localStorage.getItem("zap-cache");
                if (e) {
                    const t = [...new Set(JSON.parse(e))].map((e => {
                        const t = {event: e, by: Xs.takeSnapshot().publicKey, zapped: !0, reacted: !1, reposted: !1};
                        return t.id = this.key(t), t
                    }));
                    await this.bulkSet(t), console.debug("Imported dumb-zap-cache events: ", t.length), window.localStorage.removeItem("zap-cache")
                }
                await this.buffer([...this.onTable])
            }

            takeSnapshot() {
                return [...this.cache.values()]
            }
        }

        class rc extends ai.FeedCache {
            constructor() {
                super("ChatCache", tc.chats)
            }

            key(e) {
                return e.id
            }

            async preload() {
                await super.preload(), await this.buffer([...this.onTable])
            }

            newest() {
                let e = 0;
                return this.cache.forEach((t => e = t.created_at > e ? t.created_at : e)), e
            }

            takeSnapshot() {
                return [...this.cache.values()]
            }
        }

        class ic extends ai.FeedCache {
            constructor() {
                super("PaymentsCache", tc.payments)
            }

            key(e) {
                return e.url
            }

            takeSnapshot() {
                return [...this.cache.values()]
            }
        }

        const sc = new Pt.UserProfileCache, ac = new Pt.UserRelaysCache, oc = new Pt.RelayMetricCache, lc = new rc,
            cc = new ic, uc = new nc;

        function dc(e, t) {
            return e.content.split(wi).map((n => {
                const r = n.match(/#\[(\d+)\]/);
                if (r && 2 === r.length) {
                    const n = parseInt(r[1]), i = e.tags[n];
                    if (i && "p" === i[0] && i.length > 1) {
                        const e = t.find((e => e.pubkey === i[1]));
                        return `@${Xl(e, i[1])}`
                    }
                }
                return n
            })).join()
        }

        function hc() {
            const {publicKey: e, privateKey: n} = Qs();
            return (0, t.useMemo)((() => {
                if (e) return new Pt.EventPublisher(e, n)
            }), [e, n])
        }

        function fc(e) {
            const t = (0, Ks.zb)(e);
            if (t) {
                const {created_at: e, tags: n} = t, r = n.filter((e => "p" === e[0])).map((e => e[1]));
                return {raw: t, keys: r, createdAt: e}
            }
            return {createdAt: 0, keys: []}
        }

        function pc() {
            const e = Qs(), {muted: t, blocked: n} = e, r = hc();

            async function i(e, t) {
                if (r) {
                    const n = await r.muted(e, t);
                    return DS.BroadcastEvent(n), 1e3 * n.created_at
                }
                return 0
            }

            return {
                muted: t.item, mute: async function (r) {
                    const s = t.item.includes(r) ? t.item : t.item.concat([r]), a = await i(s, n.item);
                    Ws(e, s, a)
                }, muteAll: async function (r) {
                    const s = (0, Ks.NP)(t.item, r), a = await i(s, n.item);
                    Ws(e, s, a)
                }, unmute: async function (r) {
                    const s = t.item.filter((e => e !== r)), a = await i(s, n.item);
                    Ws(e, s, a)
                }, isMuted: function (e) {
                    return t.item.includes(e) || n.item.includes(e)
                }, blocked: n.item, block: async function (r) {
                    const s = n.item.includes(r) ? n.item : n.item.concat([r]), a = await i(t.item, s);
                    Vs(e, s, a)
                }, unblock: async function (r) {
                    const s = n.item.filter((e => e !== r)), a = await i(t.item, s);
                    Vs(e, s, a)
                }, isBlocked: function (e) {
                    return n.item.includes(e)
                }
            }
        }

        var mc, gc, yc, vc, bc = a(5130), wc = a.n(bc), xc = function (e, t, n, r) {
            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
        };

        class Ec extends ai.ExternalStore {
            constructor(e) {
                super(), mc.add(this), gc.set(this, void 0), yc.set(this, (0, bc.debug)("NIP-04")), function (e, t, n, r, i) {
                    if ("m" === r) throw new TypeError("Private method is not writable");
                    if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                    if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                    "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n)
                }(this, gc, e, "f")
            }

            async onEvent(e) {
                const t = e.filter((e => e.kind === Pt.EventKind.DirectMessage));
                t.length > 0 && (await xc(this, gc, "f").bulkSet(t), this.notifyChange())
            }

            subscription(e) {
                const t = new Pt.RequestBuilder(`nip4:${e.slice(0, 12)}`),
                    n = xc(this, gc, "f").snapshot().reduce(((e, t) => t.created_at > e && t.kind === Pt.EventKind.DirectMessage ? e = t.created_at : e), 0);
                return xc(this, yc, "f").call(this, "Loading DMS since %s", new Date(1e3 * n)), t.withFilter().authors([e]).kinds([Pt.EventKind.DirectMessage]).since(n), t.withFilter().kinds([Pt.EventKind.DirectMessage]).tag("p", [e]).since(n), t
            }

            takeSnapshot() {
                return this.listChats()
            }

            listChats() {
                const e = xc(this, mc, "m", vc).call(this);
                return (0, ai.dedupe)(e.map((e => Pc(e)))).map((t => {
                    const n = e.filter((e => Pc(e) === t || e.pubkey === t));
                    return Ec.createChatObj(t, n)
                }))
            }

            static createChatObj(e, t) {
                const n = Nc(e);
                return {
                    type: Tc.DirectMessage,
                    id: e,
                    unread: t.reduce(((e, t) => t.created_at > n ? e++ : e), 0),
                    lastMessage: t.reduce(((e, t) => t.created_at > e ? t.created_at : e), 0),
                    messages: t,
                    createMessage: (t, n) => n.sendDm(t, e),
                    sendMessage: (e, t) => {
                        t.BroadcastEvent(e)
                    }
                }
            }
        }

        gc = new WeakMap, yc = new WeakMap, mc = new WeakSet, vc = function () {
            return xc(this, gc, "f").snapshot().filter((e => e.kind === Pt.EventKind.DirectMessage))
        };
        var Sc, kc, Ac, Tc, Cc = function (e, t, n, r) {
            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
        };

        class Rc extends ai.ExternalStore {
            constructor(e) {
                super(), Sc.add(this), kc.set(this, void 0), function (e, t, n, r, i) {
                    if ("m" === r) throw new TypeError("Private method is not writable");
                    if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                    if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                    "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n)
                }(this, kc, e, "f")
            }

            takeSnapshot() {
                return this.listChats()
            }

            subscription(e) {
                var t;
                const n = e.split("/", 2), r = new Pt.RequestBuilder(`nip29:${e}`),
                    i = null === (t = this.listChats().find((t => t.id === e))) || void 0 === t ? void 0 : t.lastMessage;
                return r.withFilter().relay(`wss://${n[0]}`).kinds([Pt.EventKind.SimpleChatMessage]).tag("g", [`/${n[1]}`]).since(i), r.withFilter().relay(`wss://${n[0]}`).kinds([Pt.EventKind.SimpleChatMetadata]).tag("d", [`/${n[1]}`]), r
            }

            async onEvent(e) {
                const t = e.filter((e => e.kind === Pt.EventKind.SimpleChatMessage));
                t.length > 0 && (await Cc(this, kc, "f").bulkSet(t), this.notifyChange())
            }

            listChats() {
                const e = Cc(this, Sc, "m", Ac).call(this),
                    t = (0, ai.dedupe)(e.map((e => e.tags.find((e => "g" === e[0])))).filter((e => void 0 !== e)).map((e => (0, Ks.Wg)(e))).map((e => `${e[2]}${e[1]}`)));
                return t.map((t => {
                    const [n, r] = t.split("/", 2), i = e.filter((e => {
                        var n, r;
                        return `${null === (n = e.tags.find((e => "g" === e[0]))) || void 0 === n ? void 0 : n[2]}${null === (r = e.tags.find((e => "g" === e[0]))) || void 0 === r ? void 0 : r[1]}` === t
                    })), s = Nc(t);
                    return {
                        type: Tc.PublicGroupChat,
                        id: t,
                        unread: i.reduce(((e, t) => t.created_at > s ? e++ : e), 0),
                        lastMessage: i.reduce(((e, t) => t.created_at > e ? t.created_at : e), 0),
                        messages: i,
                        createMessage: (e, t) => t.generic((t => t.kind(Pt.EventKind.SimpleChatMessage).tag(["g", `/${r}`, n]).content(e))),
                        sendMessage: async (e, t) => {
                            await t.WriteOnceToRelay(`wss://${n}`, e)
                        }
                    }
                }))
            }
        }

        kc = new WeakMap, Sc = new WeakSet, Ac = function () {
            return Cc(this, kc, "f").snapshot().filter((e => e.kind === Pt.EventKind.SimpleChatMessage))
        }, function (e) {
            e[e.DirectMessage = 1] = "DirectMessage", e[e.PublicGroupChat = 2] = "PublicGroupChat", e[e.PrivateGroupChat = 3] = "PrivateGroupChat"
        }(Tc || (Tc = {}));
        const Lc = new Ec(lc), _c = new Rc(lc);

        function Pc(e) {
            if (e.kind === Pt.EventKind.DirectMessage) return (0, ai.unwrap)((0, Ks.MV)(e, "p"));
            if (e.kind === Pt.EventKind.SimpleChatMessage) {
                const t = (0, ai.unwrap)(e.tags.find((e => "g" === e[0])));
                return `${t[2]}${t[1]}`
            }
            throw new Error("Not a chat message")
        }

        function Nc(e) {
            var t;
            const n = `dm:seen:${e}`;
            return parseInt(null !== (t = window.localStorage.getItem(n)) && void 0 !== t ? t : "0")
        }

        function jc() {
            const e = (0, t.useSyncExternalStore)((e => Lc.hook(e)), (() => Lc.snapshot())),
                n = (0, t.useSyncExternalStore)((e => _c.hook(e)), (() => _c.snapshot())), {
                    muted: r,
                    blocked: i
                } = pc();
            return [...e, ...n].filter((e => !(r.includes(e.id) || i.includes(e.id))))
        }

        var Ic = a(4124), Mc = a.n(Ic), Dc = a(2696), Oc = a.n(Dc);

        function Bc(e, t, n) {
            return t in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }

        function Fc(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function Uc(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }

        function Hc(e, t, n) {
            return t && Uc(e.prototype, t), n && Uc(e, n), e
        }

        function $c(e) {
            return $c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                return typeof e
            } : function (e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            }, $c(e)
        }

        function Kc(e) {
            return Kc = "function" == typeof Symbol && "symbol" === $c(Symbol.iterator) ? function (e) {
                return $c(e)
            } : function (e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : $c(e)
            }, Kc(e)
        }

        function zc(e, t) {
            return !t || "object" !== Kc(t) && "function" != typeof t ? function (e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }(e) : t
        }

        function Gc(e) {
            return Gc = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
                return e.__proto__ || Object.getPrototypeOf(e)
            }, Gc(e)
        }

        function qc(e, t) {
            return qc = Object.setPrototypeOf || function (e, t) {
                return e.__proto__ = t, e
            }, qc(e, t)
        }

        function Wc(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && qc(e, t)
        }

        var Vc = {ESC: 27, UP: 38, DOWN: 40, LEFT: 37, RIGHT: 39, ENTER: 13, TAB: 9}, Yc = new function e() {
                var t = this;
                Fc(this, e), this.startListen = function (e) {
                    e && e.addEventListener("keydown", t.f)
                }, this.stopListen = function (e) {
                    e && e.removeEventListener("keydown", t.f)
                }, this.add = function (e, n) {
                    var r = e;
                    return "object" != typeof r && (r = [r]), t.listeners[t.index] = {keyCode: r, fn: n}, t.index++
                }, this.remove = function (e) {
                    delete t.listeners[e]
                }, this.removeAll = function () {
                    t.listeners = {}, t.index = 1
                }, this.index = 1, this.listeners = {}, this.f = function (e) {
                    if (e) {
                        var n = e.keyCode || e.which;
                        Object.values(t.listeners).forEach((function (t) {
                            var r = t.keyCode, i = t.fn;
                            r.includes(n) && (e.stopPropagation(), e.preventDefault(), i(e))
                        }))
                    }
                }
            }, Zc = function (e) {
                function n() {
                    var e, t;
                    Fc(this, n);
                    for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++) i[s] = arguments[s];
                    return (t = zc(this, (e = Gc(n)).call.apply(e, [this].concat(i)))).selectItem = function () {
                        var e = t.props, n = e.item;
                        (0, e.onSelectHandler)(n)
                    }, t
                }

                return Wc(n, e), Hc(n, [{
                    key: "shouldComponentUpdate", value: function (e) {
                        return this.props.item !== e.item || this.props.selected !== e.selected || this.props.style !== e.style || this.props.className !== e.className
                    }
                }, {
                    key: "render", value: function () {
                        var e = this, n = this.props, r = n.component, i = n.style, s = n.onClickHandler, a = n.item,
                            o = n.selected, l = n.className, c = n.innerRef;
                        return t.createElement("li", {
                            className: "rta__item  ".concat(!0 === o ? "rta__item--selected" : "", " ").concat(l || ""),
                            style: i
                        }, t.createElement("div", {
                            className: "rta__entity ".concat(!0 === o ? "rta__entity--selected" : ""),
                            role: "button",
                            tabIndex: 0,
                            onClick: s,
                            onFocus: this.selectItem,
                            onMouseEnter: this.selectItem,
                            onTouchStart: function () {
                                e.clicked = !0, e.selectItem()
                            },
                            onTouchEnd: function (t) {
                                t.preventDefault(), e.clicked && s(t)
                            },
                            onTouchMove: function () {
                                e.clicked = !1
                            },
                            onTouchCancel: function () {
                                e.clicked = !1
                            },
                            ref: c
                        }, t.createElement(r, {selected: o, entity: a})))
                    }
                }]), n
            }(t.Component), Xc = function (e) {
                function n() {
                    var e, t;
                    Fc(this, n);
                    for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++) i[s] = arguments[s];
                    return (t = zc(this, (e = Gc(n)).call.apply(e, [this].concat(i)))).state = {selectedItem: null}, t.cachedIdOfItems = new Map, t.onPressEnter = function (e) {
                        void 0 !== e && e.preventDefault();
                        var n = t.props.values;
                        t.modifyText(n[t.getPositionInList()])
                    }, t.getPositionInList = function () {
                        var e = t.props.values, n = t.state.selectedItem;
                        return n ? e.findIndex((function (e) {
                            return t.getId(e) === t.getId(n)
                        })) : 0
                    }, t.getId = function (e) {
                        if (t.cachedIdOfItems.has(e)) return t.cachedIdOfItems.get(e);
                        var n = t.props.getTextToReplace(e), r = function () {
                            if (n) {
                                if (n.key) return n.key;
                                if ("string" == typeof e || !e.key) return n.text
                            }
                            if (!e.key) throw new Error("Item ".concat(JSON.stringify(e), ' has to have defined "key" property'));
                            return e.key
                        }();
                        return t.cachedIdOfItems.set(e, r), r
                    }, t.listeners = [], t.itemsRef = {}, t.modifyText = function (e) {
                        e && (0, t.props.onSelect)(e)
                    }, t.selectItem = function (e) {
                        var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            r = t.props.onItemHighlighted;
                        t.state.selectedItem !== e && t.setState({selectedItem: e}, (function () {
                            r(e), n && t.props.dropdownScroll(t.itemsRef[t.getId(e)])
                        }))
                    }, t.scroll = function (e) {
                        e.preventDefault();
                        var n, r = t.props.values, i = e.keyCode || e.which, s = t.getPositionInList();
                        switch (i) {
                            case Vc.DOWN:
                                n = s + 1;
                                break;
                            case Vc.UP:
                                n = s - 1;
                                break;
                            default:
                                n = s
                        }
                        n = (n % r.length + r.length) % r.length, t.selectItem(r[n], [Vc.DOWN, Vc.UP].includes(i))
                    }, t.isSelected = function (e) {
                        var n = t.state.selectedItem;
                        return !!n && t.getId(n) === t.getId(e)
                    }, t
                }

                return Wc(n, e), Hc(n, [{
                    key: "componentDidMount", value: function () {
                        this.listeners.push(Yc.add([Vc.DOWN, Vc.UP], this.scroll), Yc.add([Vc.ENTER, Vc.TAB], this.onPressEnter));
                        var e = this.props.values;
                        e && e[0] && this.selectItem(e[0])
                    }
                }, {
                    key: "componentDidUpdate", value: function (e) {
                        var t = this, n = e.values, r = this.props.values;
                        n.map((function (e) {
                            return t.getId(e)
                        })).join("") !== r.map((function (e) {
                            return t.getId(e)
                        })).join("") && r && r[0] && this.selectItem(r[0])
                    }
                }, {
                    key: "componentWillUnmount", value: function () {
                        for (var e; this.listeners.length;) e = this.listeners.pop(), Yc.remove(e)
                    }
                }, {
                    key: "render", value: function () {
                        var e = this, n = this.props, r = n.values, i = n.component, s = n.style, a = n.itemClassName,
                            o = n.className, l = n.itemStyle;
                        return t.createElement("ul", {
                            className: "rta__list ".concat(o || ""),
                            style: s
                        }, r.map((function (n) {
                            return t.createElement(Zc, {
                                key: e.getId(n),
                                innerRef: function (t) {
                                    e.itemsRef[e.getId(n)] = t
                                },
                                selected: e.isSelected(n),
                                item: n,
                                className: a,
                                style: l,
                                onClickHandler: e.onPressEnter,
                                onSelectHandler: e.selectItem,
                                component: i
                            })
                        })))
                    }
                }]), n
            }(t.Component), Qc = "next", Jc = "rta__autocomplete--left", eu = "rta__autocomplete--right",
            tu = "rta__autocomplete--top", nu = "rta__autocomplete--bottom", ru = function (e) {
                return console.error("RTA: dataProvider fails: ".concat(e, "\n    \nCheck the documentation or create issue if you think it's bug. https://github.com/webscopeio/react-textarea-autocomplete/issues"))
            }, iu = [".", "^", "$", "*", "+", "-", "?", "(", ")", "[", "]", "{", "}", "\\", "|"], su = function (e) {
                return (t = e, function (e) {
                    if (Array.isArray(e)) {
                        for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
                        return n
                    }
                }(t) || function (e) {
                    if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
                }(t) || function () {
                    throw new TypeError("Invalid attempt to spread non-iterable instance")
                }()).map((function (e) {
                    return iu.includes(e) ? "\\".concat(e) : e
                })).join("");
                var t
            }, au = function (e) {
                function n() {
                    return Fc(this, n), zc(this, Gc(n).apply(this, arguments))
                }

                return Wc(n, e), Hc(n, [{
                    key: "componentDidMount", value: function () {
                        var e = this.props.boundariesElement;
                        if ("string" == typeof e) {
                            var t = document.querySelector(e);
                            if (!t) throw new Error("RTA: Invalid prop boundariesElement: it has to be string or HTMLElement.");
                            this.containerElem = t
                        } else {
                            if (!(e instanceof HTMLElement)) throw new Error("RTA: Invalid prop boundariesElement: it has to be string or HTMLElement.");
                            this.containerElem = e
                        }
                        if (!this.containerElem || !this.containerElem.contains(this.ref)) throw new Error("RTA: Invalid prop boundariesElement: it has to be one of the parents of the RTA.")
                    }
                }, {
                    key: "componentDidUpdate", value: function () {
                        var e, t, n = this.props.top || 0, r = this.props.left || 0, i = [], s = [], a = 0, o = 0,
                            l = this.containerElem.getBoundingClientRect(), c = this.ref.getBoundingClientRect(),
                            u = this.props.textareaRef.getBoundingClientRect(), d = window.getComputedStyle(this.ref),
                            h = parseInt(d.getPropertyValue("margin-top"), 10),
                            f = parseInt(d.getPropertyValue("margin-bottom"), 10),
                            p = parseInt(d.getPropertyValue("margin-left"), 10),
                            m = parseInt(d.getPropertyValue("margin-right"), 10), g = h + f + u.top + n + c.height;
                        p + m + u.left + r + c.width > l.right && u.left + r > c.width ? (o = r - c.width, i.push(Jc), s.push(eu)) : (o = r, i.push(eu), s.push(Jc)), g > l.bottom && u.top + n > c.height ? (a = n - c.height, i.push(tu), s.push(nu)) : (a = n, i.push(nu), s.push(tu)), this.props.renderToBody && (a += u.top, o += u.left), this.ref.style.top = "".concat(a, "px"), this.ref.style.left = "".concat(o, "px"), (e = this.ref.classList).remove.apply(e, s), (t = this.ref.classList).add.apply(t, i)
                    }
                }, {
                    key: "render", value: function () {
                        var e = this, n = this.props, r = n.style, i = n.className, s = n.innerRef, a = n.children,
                            o = n.renderToBody, c = document.body, u = t.createElement("div", {
                                ref: function (t) {
                                    e.ref = t, s(t)
                                }, className: "rta__autocomplete ".concat(i || ""), style: r
                            }, a);
                        return o && null !== c ? l.createPortal(u, c) : u
                    }
                }]), n
            }(t.Component), ou = function (e) {
                function n(e) {
                    var t;
                    Fc(this, n), (t = zc(this, Gc(n).call(this, e))).state = {
                        top: null,
                        left: null,
                        currentTrigger: null,
                        actualToken: "",
                        data: null,
                        value: "",
                        dataLoading: !1,
                        selectionEnd: 0,
                        component: null,
                        textToReplace: null
                    }, t.escListenerInit = function () {
                        t.escListener || (t.escListener = Yc.add(Vc.ESC, t._closeAutocomplete))
                    }, t.escListenerDestroy = function () {
                        t.escListener && (Yc.remove(t.escListener), t.escListener = null)
                    }, t.getSelectionPosition = function () {
                        return t.textareaRef ? {
                            selectionStart: t.textareaRef.selectionStart,
                            selectionEnd: t.textareaRef.selectionEnd
                        } : null
                    }, t.getSelectedText = function () {
                        if (!t.textareaRef) return null;
                        var e = t.textareaRef, n = e.selectionStart, r = e.selectionEnd;
                        return n === r ? null : t.state.value.substr(n, r - n)
                    }, t.setCaretPosition = function () {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        t.textareaRef && (t.textareaRef.focus(), t.textareaRef.setSelectionRange(e, e))
                    }, t.getCaretPosition = function () {
                        return t.textareaRef ? t.textareaRef.selectionEnd : 0
                    }, t._handleCaretChange = function (e) {
                        var n = function () {
                            var e = t.getCaretPosition() - 1;
                            t.lastTrigger = t.lastTrigger ? e : 0
                        };
                        if ("keydown" !== e.type) n(); else switch (e.keyCode || e.which) {
                            case Vc.UP:
                            case Vc.DOWN:
                                t._isAutocompleteOpen() || n();
                                break;
                            case Vc.LEFT:
                            case Vc.RIGHT:
                                n()
                        }
                    }, t._onSelect = function (e) {
                        var n = t.state, r = n.selectionEnd, i = n.currentTrigger, s = n.value, a = t.props.onItemSelected;
                        if (i) {
                            var o = t._getTextToReplace(i);
                            if (o) {
                                var l = o(e);
                                if (l) {
                                    a && a({currentTrigger: i, item: e});
                                    var c = s.slice(0, r), u = su(i), d = c.length - c.lastIndexOf(i),
                                        h = c.search(new RegExp("(?!".concat(u, ")$"))) - d,
                                        f = "next" === l.caretPosition ? "".concat(l.text, " ") : l.text,
                                        p = function (e, t, n) {
                                            switch (e) {
                                                case"start":
                                                    return n;
                                                case"next":
                                                case"end":
                                                    return n + t.length;
                                                default:
                                                    if (!Number.isInteger(e)) throw new Error('RTA: caretPosition should be "start", "next", "end" or number.');
                                                    return e
                                            }
                                        }(l.caretPosition, f, h), m = c.substring(0, h) + f, g = s.replace(c, m);
                                    t.setState({value: g, dataLoading: !1}, (function () {
                                        var e = t.tokenRegExpEnding.exec(f), n = e ? e[0].length : 1;
                                        t.lastTrigger = p ? p - n : p, t.textareaRef.value = g, t.textareaRef.selectionEnd = p, t._changeHandler();
                                        var r = t.textareaRef.scrollTop;
                                        t.setCaretPosition(p), window.chrome && (t.textareaRef.scrollTop = r)
                                    }))
                                } else t._closeAutocomplete()
                            } else t._closeAutocomplete()
                        }
                    }, t._getTextToReplace = function (e) {
                        var n = t.props.trigger[e];
                        if (!e || !n) return null;
                        var r = n.output;
                        return function (t) {
                            if ("object" == typeof t && (!r || "function" != typeof r)) throw new Error('Output functor is not defined! If you are using items as object you have to define "output" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');
                            if (r) {
                                var n = r(t, e);
                                if (void 0 === n || "number" == typeof n) throw new Error('Output functor should return string or object in shape {text: string, caretPosition: string | number}.\nGot "'.concat(String(n), '". Check the implementation for trigger "').concat(e, '"\n\nSee https://github.com/webscopeio/react-textarea-autocomplete#trigger-type for more information.\n'));
                                if (null === n) return null;
                                if ("string" == typeof n) return {text: n, caretPosition: Qc};
                                if (!n.text && "string" != typeof n.text) throw new Error('Output "text" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger "'.concat(e, '"\n'));
                                if (!n.caretPosition) throw new Error('Output "caretPosition" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger "'.concat(e, '"\n'));
                                return n
                            }
                            if ("string" != typeof t) throw new Error("Output item should be string\n");
                            return {text: "".concat(e).concat(t).concat(e), caretPosition: Qc}
                        }
                    }, t._getCurrentTriggerSettings = function () {
                        var e = t.state.currentTrigger;
                        return e ? t.props.trigger[e] : null
                    }, t._getValuesFromProvider = function () {
                        var e = t.state, n = e.currentTrigger, r = e.actualToken, i = t._getCurrentTriggerSettings();
                        if (n && i) {
                            var s = i.dataProvider, a = i.component;
                            if ("function" != typeof s) throw new Error("Trigger provider has to be a function!");
                            t.setState({dataLoading: !0});
                            var o = s(r);
                            o instanceof Promise || (o = Promise.resolve(o)), o.then((function (e) {
                                if (!Array.isArray(e)) throw new Error("Trigger provider has to provide an array!");
                                if ("function" != typeof a) throw new Error("Component should be defined!");
                                n === t.state.currentTrigger && (e.length ? t.setState({
                                    dataLoading: !1,
                                    data: e,
                                    component: a
                                }) : t._closeAutocomplete())
                            })).catch((function (e) {
                                return ru(e.message)
                            }))
                        }
                    }, t._getSuggestions = function () {
                        var e = t.state, n = e.currentTrigger, r = e.data;
                        return !n || !r || r && !r.length ? null : r
                    }, t._createRegExp = function () {
                        var e = t.props.trigger;
                        t.tokenRegExp = new RegExp("(".concat(Object.keys(e).sort((function (e, t) {
                            return e < t ? 1 : e > t ? -1 : 0
                        })).map((function (e) {
                            return su(e)
                        })).join("|"), ")((?:(?!\\1)[^\\s])*$)")), t.tokenRegExpEnding = new RegExp("(".concat(Object.keys(e).sort((function (e, t) {
                            return e < t ? 1 : e > t ? -1 : 0
                        })).map((function (e) {
                            return su(e)
                        })).join("|"), ")$"))
                    }, t._closeAutocomplete = function () {
                        var e = t.state.currentTrigger;
                        t.escListenerDestroy(), t.setState({
                            data: null,
                            dataLoading: !1,
                            currentTrigger: null
                        }, (function () {
                            e && t._onItemHighlightedHandler(null)
                        }))
                    }, t._cleanUpProps = function () {
                        var e = function (e) {
                                for (var t = 1; t < arguments.length; t++) {
                                    var n = null != arguments[t] ? arguments[t] : {}, r = Object.keys(n);
                                    "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function (e) {
                                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                                    })))), r.forEach((function (t) {
                                        Bc(e, t, n[t])
                                    }))
                                }
                                return e
                            }({}, t.props),
                            n = ["loadingComponent", "boundariesElement", "containerStyle", "minChar", "scrollToItem", "ref", "innerRef", "onChange", "onCaretPositionChange", "className", "value", "trigger", "listStyle", "itemStyle", "containerStyle", "loaderStyle", "className", "containerClassName", "listClassName", "itemClassName", "loaderClassName", "dropdownStyle", "dropdownClassName", "movePopupAsYouType", "textAreaComponent", "renderToBody", "onItemSelected", "onItemHighlighted"];
                        for (var r in e) n.includes(r) && delete e[r];
                        return e
                    }, t._changeHandler = function (e) {
                        var n = t.props, r = n.trigger, i = n.onChange, s = n.minChar, a = n.onCaretPositionChange,
                            o = n.movePopupAsYouType, l = t.state, c = l.top, u = l.left, d = e;
                        d || (d = new (Oc())("change", {bubbles: !0}), t.textareaRef.dispatchEvent(d));
                        var h = d.target || t.textareaRef, f = h.selectionEnd, p = h.value;
                        t.lastValueBubbledEvent = p, i && d && (d.persist && d.persist(), i(new Proxy(d, {
                            get: function (e, t, n) {
                                return "target" === t ? h : Reflect.get(e, t, n)
                            }
                        }))), a && a(t.getCaretPosition()), t.setState({value: p});
                        var m = function () {
                            var e = Mc()(h, f), n = e.top, r = e.left;
                            t.setState({top: n - t.textareaRef.scrollTop || 0, left: r})
                        }, g = function (e) {
                            t.lastTrigger = f - e, t._closeAutocomplete(), m()
                        };
                        if (f <= t.lastTrigger) {
                            var y = p.slice(0, f), v = t.tokenRegExp.exec(y);
                            g(v ? v[0].length : 0)
                        }
                        var b = p.slice(t.lastTrigger, f), w = t.tokenRegExp.exec(b), x = w && w[0], E = w && w[1] || null,
                            S = E ? E.length - 1 : 0, k = t.tokenRegExpEnding.exec(b);
                        if (k ? g(k[0].length) : t._isAutocompleteOpen() || t._closeAutocomplete(), x && !(x.length <= s + S) || (!t.state.currentTrigger || r[t.state.currentTrigger].allowWhitespace) && t.state.currentTrigger) if (E && r[E].afterWhitespace && !/\s/.test(p[f - x.length - 1]) && void 0 !== p[f - x.length - 1]) t._closeAutocomplete(); else {
                            if (t.state.currentTrigger && r[t.state.currentTrigger].allowWhitespace) {
                                if (w = new RegExp("".concat(su(t.state.currentTrigger), ".*$")).exec(p.slice(0, f)), !(x = w && w[0])) return void t._closeAutocomplete();
                                E = Object.keys(r).find((function (e) {
                                    return e.slice(0, S + 1) === x.slice(0, S + 1)
                                })) || null
                            }
                            var A = x.slice(1);
                            if (E) {
                                (o || null === c && null === u || t.state.currentTrigger !== E) && m(), t.escListenerInit();
                                var T = t._getTextToReplace(E);
                                t.setState({
                                    selectionEnd: f,
                                    currentTrigger: E,
                                    textToReplace: T,
                                    actualToken: A
                                }, (function () {
                                    try {
                                        t._getValuesFromProvider()
                                    } catch (e) {
                                        ru(e.message)
                                    }
                                }))
                            }
                        } else t._closeAutocomplete()
                    }, t._selectHandler = function (e) {
                        var n = t.props, r = n.onCaretPositionChange, i = n.onSelect;
                        r && r(t.getCaretPosition()), i && (e.persist(), i(e))
                    }, t._shouldStayOpen = function (e) {
                        var n = e.relatedTarget;
                        return null === n && (n = document.activeElement), !!(t.dropdownRef && n instanceof Node && t.dropdownRef.contains(n))
                    }, t._onClick = function (e) {
                        var n = t.props.onClick;
                        n && (e.persist(), n(e)), t._shouldStayOpen(e) || t._closeAutocomplete()
                    }, t._onBlur = function (e) {
                        var n = t.props.onBlur;
                        n && (e.persist(), n(e)), t._shouldStayOpen(e) || t._closeAutocomplete()
                    }, t._onScrollHandler = function () {
                        t._closeAutocomplete()
                    }, t._onItemHighlightedHandler = function (e) {
                        var n = t.props.onItemHighlighted, r = t.state.currentTrigger;
                        if (n) {
                            if ("function" != typeof n) throw new Error("`onItemHighlighted` has to be a function");
                            n({currentTrigger: r, item: e})
                        }
                    }, t._dropdownScroll = function (e) {
                        var n = t.props.scrollToItem;
                        if (n) if (!0 !== n) {
                            if ("function" != typeof n || 2 !== n.length) throw new Error("`scrollToItem` has to be boolean (true for default implementation) or function with two parameters: container, item.");
                            n(t.dropdownRef, e)
                        } else !function (e, t) {
                            var n = parseInt(getComputedStyle(t).getPropertyValue("height"), 10),
                                r = parseInt(getComputedStyle(e).getPropertyValue("height"), 10) - n, i = t.offsetTop,
                                s = e.scrollTop;
                            i < s + r && s < i || (e.scrollTop = i)
                        }(t.dropdownRef, e)
                    }, t._isAutocompleteOpen = function () {
                        var e = t.state, n = e.dataLoading, r = e.currentTrigger, i = t._getSuggestions();
                        return !(!n && !i || !r)
                    }, t._textareaRef = function (e) {
                        t.props.innerRef && t.props.innerRef(e), t.textareaRef = e
                    }, t.lastTrigger = 0, t.escListener = null;
                    var r = t.props, i = r.loadingComponent, s = r.trigger, a = r.value;
                    if (a && (t.state.value = a), t._createRegExp(), !i) throw new Error("RTA: loadingComponent is not defined");
                    if (!s) throw new Error("RTA: trigger is not defined");
                    return t
                }

                return Wc(n, e), Hc(n, [{
                    key: "componentDidMount", value: function () {
                        Yc.startListen(this.textareaRef), this.textareaRef && this.textareaRef.addEventListener("focus", this._handleCaretChange), this.textareaRef && this.textareaRef.addEventListener("click", this._handleCaretChange), this.textareaRef && this.textareaRef.addEventListener("keydown", this._handleCaretChange)
                    }
                }, {
                    key: "componentDidUpdate", value: function (e) {
                        var t = e.trigger, n = e.value, r = this.props, i = r.trigger, s = r.value;
                        Object.keys(i).join("") !== Object.keys(t).join("") && this._createRegExp(), n !== s && this.lastValueBubbledEvent !== s && (this.lastTrigger = 0, this._changeHandler())
                    }
                }, {
                    key: "componentWillUnmount", value: function () {
                        this.escListenerDestroy(), Yc.stopListen(this.textareaRef), this.textareaRef && this.textareaRef.removeEventListener("focus", this._handleCaretChange), this.textareaRef && this.textareaRef.removeEventListener("click", this._handleCaretChange), this.textareaRef && this.textareaRef.removeEventListener("keydown", this._handleCaretChange)
                    }
                }, {
                    key: "render", value: function () {
                        var e, n = this, r = this.props, i = r.loadingComponent, s = r.style, a = r.className,
                            o = r.listStyle, l = r.itemStyle, c = r.boundariesElement, u = r.movePopupAsYouType,
                            d = r.listClassName, h = r.itemClassName, f = r.dropdownClassName, p = r.dropdownStyle,
                            m = r.containerStyle, g = r.containerClassName, y = r.loaderStyle, v = r.loaderClassName,
                            b = r.textAreaComponent, w = r.renderToBody, x = this.state, E = x.left, S = x.top,
                            k = x.dataLoading, A = x.component, T = x.value, C = x.textToReplace,
                            R = this._isAutocompleteOpen(), L = this._getSuggestions(), _ = {};
                        return b.component ? (e = b.component, _[b.ref] = this._textareaRef) : (e = b, _.ref = this._textareaRef), t.createElement("div", {
                            className: "rta ".concat(!0 === k ? "rta--loading" : "", " ").concat(g || ""),
                            style: m
                        }, t.createElement(e, Object.assign({}, this._cleanUpProps(), {
                            className: "rta__textarea ".concat(a || ""),
                            onChange: this._changeHandler,
                            onSelect: this._selectHandler,
                            onScroll: this._onScrollHandler,
                            onClick: this._onClick,
                            onBlur: this._onBlur,
                            value: T,
                            style: s
                        }, _)), R && t.createElement(au, {
                            innerRef: function (e) {
                                n.dropdownRef = e
                            },
                            top: S,
                            left: E,
                            style: p,
                            className: f,
                            movePopupAsYouType: u,
                            boundariesElement: c,
                            textareaRef: this.textareaRef,
                            renderToBody: w
                        }, L && A && C && t.createElement(Xc, {
                            values: L,
                            component: A,
                            style: o,
                            className: d,
                            itemClassName: h,
                            itemStyle: l,
                            getTextToReplace: C,
                            onItemHighlighted: this._onItemHighlightedHandler,
                            onSelect: this._onSelect,
                            dropdownScroll: this._dropdownScroll
                        }), k && t.createElement("div", {
                            className: "rta__loader ".concat(null !== L ? "rta__loader--suggestion-data" : "rta__loader--empty-suggestion-data", " ").concat(v || ""),
                            style: y
                        }, t.createElement(i, {data: L}))))
                    }
                }], [{
                    key: "getDerivedStateFromProps", value: function (e) {
                        var t = e.value;
                        return null == t ? null : {value: t}
                    }
                }]), n
            }(t.Component);
        ou.defaultProps = {
            movePopupAsYouType: !1,
            value: null,
            minChar: 1,
            boundariesElement: "body",
            scrollToItem: !0,
            textAreaComponent: "textarea",
            renderToBody: !1
        };
        const lu = ou;
        var cu = a(7896);
        const uu = t.useLayoutEffect;
        var du = function (e, t) {
            "function" != typeof e ? e.current = t : e(t)
        };
        var hu = {
                "min-height": "0",
                "max-height": "none",
                height: "0",
                visibility: "hidden",
                overflow: "hidden",
                position: "absolute",
                "z-index": "-1000",
                top: "0",
                right: "0"
            }, fu = function (e) {
                Object.keys(hu).forEach((function (t) {
                    e.style.setProperty(t, hu[t], "important")
                }))
            }, pu = null, mu = function (e, t) {
                var n = e.scrollHeight;
                return "border-box" === t.sizingStyle.boxSizing ? n + t.borderSize : n - t.paddingSize
            }, gu = function () {
            },
            yu = ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "boxSizing", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "lineHeight", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "tabSize", "textIndent", "textRendering", "textTransform", "width", "wordBreak"],
            vu = !!document.documentElement.currentStyle;

        function bu(e, n, r) {
            var i, s, a = (i = r, s = t.useRef(i), uu((function () {
                s.current = i
            })), s);
            (0, t.useLayoutEffect)((function () {
                var t = function (e) {
                    return a.current(e)
                };
                return e.addEventListener(n, t), function () {
                    return e.removeEventListener(n, t)
                }
            }), [])
        }

        var wu = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], xu = function (e, n) {
            var r = e.cacheMeasurements, i = e.maxRows, s = e.minRows, a = e.onChange, o = void 0 === a ? gu : a,
                l = e.onHeightChange, c = void 0 === l ? gu : l, u = function (e, t) {
                    if (null == e) return {};
                    var n, r, i = {}, s = Object.keys(e);
                    for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
                    return i
                }(e, wu), d = void 0 !== u.value, h = (0, t.useRef)(null), f = function (e, n) {
                    var r = (0, t.useRef)();
                    return (0, t.useCallback)((function (t) {
                        e.current = t, r.current && du(r.current, null), r.current = n, n && du(n, t)
                    }), [n])
                }(h, n), p = (0, t.useRef)(0), m = (0, t.useRef)(), g = function () {
                    var e = h.current, t = r && m.current ? m.current : function (e) {
                        var t = window.getComputedStyle(e);
                        if (null === t) return null;
                        var n, r = (n = t, yu.reduce((function (e, t) {
                            return e[t] = n[t], e
                        }), {})), i = r.boxSizing;
                        return "" === i ? null : (vu && "border-box" === i && (r.width = parseFloat(r.width) + parseFloat(r.borderRightWidth) + parseFloat(r.borderLeftWidth) + parseFloat(r.paddingRight) + parseFloat(r.paddingLeft) + "px"), {
                            sizingStyle: r,
                            paddingSize: parseFloat(r.paddingBottom) + parseFloat(r.paddingTop),
                            borderSize: parseFloat(r.borderBottomWidth) + parseFloat(r.borderTopWidth)
                        })
                    }(e);
                    if (t) {
                        m.current = t;
                        var n = function (e, t, n, r) {
                            void 0 === n && (n = 1), void 0 === r && (r = 1 / 0), pu || ((pu = document.createElement("textarea")).setAttribute("tabindex", "-1"), pu.setAttribute("aria-hidden", "true"), fu(pu)), null === pu.parentNode && document.body.appendChild(pu);
                            var i = e.paddingSize, s = e.borderSize, a = e.sizingStyle, o = a.boxSizing;
                            Object.keys(a).forEach((function (e) {
                                var t = e;
                                pu.style[t] = a[t]
                            })), fu(pu), pu.value = t;
                            var l = mu(pu, e);
                            pu.value = t, l = mu(pu, e), pu.value = "x";
                            var c = pu.scrollHeight - i, u = c * n;
                            "border-box" === o && (u = u + i + s), l = Math.max(u, l);
                            var d = c * r;
                            return "border-box" === o && (d = d + i + s), [l = Math.min(d, l), c]
                        }(t, e.value || e.placeholder || "x", s, i), a = n[0], o = n[1];
                        p.current !== a && (p.current = a, e.style.setProperty("height", a + "px", "important"), c(a, {rowHeight: o}))
                    }
                };
            return (0, t.useLayoutEffect)(g), bu(window, "resize", g), function (e) {
                bu(document.fonts, "loadingdone", e)
            }(g), (0, t.createElement)("textarea", (0, cu.Z)({}, u, {
                onChange: function (e) {
                    d || g(), o(e)
                }, ref: f
            }))
        };
        const Eu = (0, t.forwardRef)(xu), Su = {
            Cancel: {id: "47FYwb", defaultMessage: "Cancel"},
            Reply: {id: "9HU8vw", defaultMessage: "Reply"},
            Send: {id: "9WRlF4", defaultMessage: "Send"},
            NotePlaceholder: {id: "flnGvv", defaultMessage: "What's on your mind?"},
            Back: {id: "cyR7Kh", defaultMessage: "Back"},
            Block: {id: "Up5U7K", defaultMessage: "Block"},
            Unblock: {id: "nDejmx", defaultMessage: "Unblock"},
            MuteCount: {id: "VlJkSk", defaultMessage: "{n} muted"},
            Mute: {id: "x82IOl", defaultMessage: "Mute"},
            MutedAuthor: {id: "ASRK0S", defaultMessage: "This author has been muted"},
            Others: {id: "vOKedj", defaultMessage: "& {n} {n, plural, =1 {other} other {others}}"},
            Show: {id: "K7AkdL", defaultMessage: "Show"},
            Delete: {id: "K3r6DQ", defaultMessage: "Delete"},
            Deleted: {id: "KQvWvD", defaultMessage: "Deleted"},
            Unmute: {id: "W9355R", defaultMessage: "Unmute"},
            MuteAll: {id: "cWx9t8", defaultMessage: "Mute all"},
            BlockCount: {id: "nwZXeh", defaultMessage: "{n} blocked"},
            JustNow: {id: "bxv59V", defaultMessage: "Just now"},
            Follow: {id: "ieGrWo", defaultMessage: "Follow"},
            FollowAll: {id: "mKAr6h", defaultMessage: "Follow all"},
            Unfollow: {id: "izWS4J", defaultMessage: "Unfollow"},
            FollowerCount: {id: "o7e+nJ", defaultMessage: "{n} followers"},
            FollowingCount: {id: "9SvQep", defaultMessage: "Follows {n}"},
            FollowsYou: {id: "FmXUJg", defaultMessage: "follows you"},
            Invoice: {id: "9wO4wJ", defaultMessage: "Lightning Invoice"},
            PayInvoice: {id: "lvlPhZ", defaultMessage: "Pay Invoice"},
            Expired: {id: "RahCRH", defaultMessage: "Expired"},
            Pay: {id: "lD3+8a", defaultMessage: "Pay"},
            Paid: {id: "u/vOPu", defaultMessage: "Paid"},
            Loading: {id: "gjBiyj", defaultMessage: "Loading..."},
            Logout: {id: "C81/uG", defaultMessage: "Logout"},
            ShowMore: {id: "aWpBzj", defaultMessage: "Show more"},
            TranslateTo: {id: "Ebl/B2", defaultMessage: "Translate to {lang}"},
            TranslatedFrom: {id: "Cu/K85", defaultMessage: "Translated from {lang}"},
            TranslationFailed: {id: "qmJ8kD", defaultMessage: "Translation failed"},
            UnknownEventKind: {id: "KahimY", defaultMessage: "Unknown event kind: {kind}"},
            ConfirmDeletion: {id: "RhDAoS", defaultMessage: "Are you sure you want to delete {id}"},
            ConfirmRepost: {id: "+D82kt", defaultMessage: "Are you sure you want to repost: {id}"},
            Reactions: {id: "XgWvGA", defaultMessage: "Reactions"},
            ReactionsCount: {id: "iCqGww", defaultMessage: "Reactions ({n})"},
            Share: {id: "OKhRC6", defaultMessage: "Share"},
            CopyID: {id: "wtLjP6", defaultMessage: "Copy ID"},
            CopyJSON: {id: "P61BTu", defaultMessage: "Copy Event JSON"},
            Dislike: {id: "GspYR7", defaultMessage: "{n} Dislike"},
            DislikeAction: {id: "4OB335", defaultMessage: "Dislike"},
            Sats: {id: "jA3OE/", defaultMessage: "{n} {n, plural, =1 {sat} other {sats}}"},
            Zapped: {id: "B6+XJy", defaultMessage: "zapped"},
            OthersZapped: {id: "mKhgP9", defaultMessage: "{n, plural, =0 {} =1 {zapped} other {zapped}}"},
            Likes: {id: "6ewQqw", defaultMessage: "Likes ({n})"},
            Zaps: {id: "JHEHCk", defaultMessage: "Zaps ({n})"},
            Dislikes: {id: "2k0Cv+", defaultMessage: "Dislikes ({n})"},
            Reposts: {id: "8/vBbP", defaultMessage: "Reposts ({n})"},
            NoteToSelf: {id: "4rYCjn", defaultMessage: "Note to Self"},
            Read: {id: "filwqD", defaultMessage: "Read"},
            Write: {id: "k2veDA", defaultMessage: "Write"},
            Seconds: {id: "0yO7wF", defaultMessage: "{n} secs"},
            Milliseconds: {id: "/n5KSF", defaultMessage: "{n} ms"},
            ShowLatest: {id: "DZzCem", defaultMessage: "Show latest {n} notes"},
            LNURLFail: {id: "zonsdq", defaultMessage: "Failed to load LNURL service"},
            InvalidLNURL: {id: "0jOEtS", defaultMessage: "Invalid LNURL"},
            InvoiceFail: {id: "CHTbO3", defaultMessage: "Failed to load invoice"},
            Custom: {id: "Sjo1P4", defaultMessage: "Custom"},
            Confirm: {id: "N2IrpM", defaultMessage: "Confirm"},
            ZapAmount: {id: "zcaOTs", defaultMessage: "Zap amount in sats"},
            Comment: {id: "LgbKvU", defaultMessage: "Comment"},
            ZapTarget: {id: "uD/N6c", defaultMessage: "Zap {target} {n} sats"},
            ZapSats: {id: "8QDesP", defaultMessage: "Zap {n} sats"},
            OpenWallet: {id: "HbefNb", defaultMessage: "Open Wallet"},
            SendZap: {id: "5ykRmX", defaultMessage: "Send zap"},
            SendSats: {id: "DKnriN", defaultMessage: "Send sats"},
            ToTarget: {id: "7xzTiH", defaultMessage: "{action} to {target}"},
            ShowReplies: {id: "hicxcO", defaultMessage: "Show replies"},
            TooShort: {id: "B4C47Y", defaultMessage: "name too short"},
            TooLong: {id: "8g2vyB", defaultMessage: "name too long"},
            Regex: {id: "0mch2Y", defaultMessage: "name has disallowed characters"},
            Registered: {id: "cuV2gK", defaultMessage: "name is registered"},
            Disallowed: {id: "wih7iJ", defaultMessage: "name is blocked"},
            DisalledLater: {id: "HFls6j", defaultMessage: "name will be available later"},
            BuyNow: {id: "lCILNz", defaultMessage: "Buy Now"},
            NotAvailable: {id: "MI2jkA", defaultMessage: "Not available:"},
            Buying: {id: "MzRYWH", defaultMessage: "Buying {item}"},
            OrderPaid: {id: "H6/kLh", defaultMessage: "Order Paid!"},
            NewNip: {id: "4L2vUY", defaultMessage: "Your new NIP-05 handle is:"},
            ActivateNow: {id: "ZKORll", defaultMessage: "Activate Now"},
            AddToProfile: {id: "qkvYUb", defaultMessage: "Add to Profile"},
            AccountPage: {id: "lgg1KN", defaultMessage: "account page"},
            AccountSupport: {id: "/JE/X+", defaultMessage: "Account Support"},
            GoTo: {id: "xIoGG9", defaultMessage: "Go to"},
            FindMore: {id: "wqyN/i", defaultMessage: "Find out more info about {service} at {link}"},
            SavePassword: {
                id: "+vIQlC",
                defaultMessage: "Please make sure to save the following password in order to manage your handle in the future"
            },
            Handle: {id: "iNWbVV", defaultMessage: "Handle"},
            Pin: {id: "puLNUJ", defaultMessage: "Pin"},
            Pinned: {id: "fWZYP5", defaultMessage: "Pinned"},
            Bookmark: {id: "Rs4kCE", defaultMessage: "Bookmark"},
            Bookmarks: {id: "nGBrvw", defaultMessage: "Bookmarks"},
            BookmarksCount: {id: "GL8aXW", defaultMessage: "Bookmarks ({n})"},
            Bookmarked: {id: "fsB/4p", defaultMessage: "Saved"},
            All: {id: "zQvVDJ", defaultMessage: "All"},
            ConfirmUnbookmark: {
                id: "1Mo59U",
                defaultMessage: "Are you sure you want to remove this note from bookmarks?"
            },
            ConfirmUnpin: {id: "IEwZvs", defaultMessage: "Are you sure you want to unpin this note?"},
            ReactionsLink: {id: "jzgQ2z", defaultMessage: "{n} Reactions"},
            ReBroadcast: {id: "c3g2hL", defaultMessage: "Broadcast Again"}
        }, ku = t => {
            let {entity: {name: n, char: r}} = t;
            return (0, e.jsxs)("div", {
                className: "emoji-item",
                children: [(0, e.jsx)("div", {
                    className: "emoji",
                    children: r
                }), (0, e.jsx)("div", {className: "emoji-name", children: n})]
            })
        }, Au = t => {
            const {pubkey: n, display_name: r, nip05: i, ...s} = t;
            return (0, e.jsxs)("div", {
                className: "user-item",
                children: [(0, e.jsx)("div", {
                    className: "user-picture",
                    children: (0, e.jsx)(Vl, {user: t})
                }), (0, e.jsxs)("div", {
                    className: "user-details",
                    children: [(0, e.jsx)("strong", {children: r || s.name}), (0, e.jsx)(Yl, {nip05: i, pubkey: n})]
                })]
            }, n)
        }, Tu = t => {
            var n;
            const {formatMessage: r} = al();
            return (0, e.jsx)(lu, {
                dir: "auto", ...t,
                loadingComponent: () => (0, e.jsx)("span", {children: "Loading..."}),
                placeholder: null !== (n = t.placeholder) && void 0 !== n ? n : r(Su.NotePlaceholder),
                textAreaComponent: Eu,
                trigger: {
                    ":": {
                        dataProvider: async e => (await a.e(521).then(a.t.bind(a, 4521, 23))).default(e).slice(0, 5).map((e => {
                            let {name: t, char: n} = e;
                            return {name: t, char: n}
                        })), component: ku, output: e => e.char
                    },
                    "@": {
                        afterWhitespace: !0,
                        dataProvider: async e => await sc.search(e),
                        component: t => (0, e.jsx)(Au, {...t.entity}),
                        output: e => `@${(0, Ks.jm)(Pt.NostrPrefix.PublicKey, e.pubkey)}`
                    }
                }
            })
        };

        function Cu(n) {
            const r = n.onClose || (() => {
            }), i = n.className || "";
            return (0, t.useEffect)((() => (document.body.classList.add("scroll-lock"), () => document.body.classList.remove("scroll-lock"))), []), (0, e.jsx)("div", {
                className: `modal ${i}`,
                onClick: r,
                children: (0, e.jsx)("div", {
                    className: "modal-body",
                    onClick: e => e.stopPropagation(),
                    children: n.children
                })
            })
        }

        async function Ru(e) {
            const t = new FormData;
            t.append("fileToUpload", e), t.append("submit", "Upload Image");
            const n = await fetch("https://nostr.build/api/upload/snort.php", {
                body: t,
                method: "POST",
                headers: {accept: "application/json"}
            });
            if (n.ok) {
                const e = await n.json();
                return {url: new URL(e).toString()}
            }
            return {error: "Upload failed"}
        }

        var Lu = a(4622);

        async function _u(e) {
            const t = new FormData;
            t.append("image", e);
            const n = await fetch("https://nostrimg.com/api/upload", {
                body: t,
                method: "POST",
                headers: {accept: "application/json"}
            });
            if (n.ok) {
                const e = await n.json();
                if ("string" == typeof (null == e ? void 0 : e.imageUrl) && e.success) return {url: new URL(e.imageUrl).toString()}
            }
            return {error: "Upload failed"}
        }

        const Pu = [{name: "void.cat", owner: (0, Ks.FX)(ui)}, {
            name: "nostr.build",
            owner: (0, Ks.FX)("npub1nxy4qpqnld6kmpphjykvx2lqwvxmuxluddwjamm4nc29ds3elyzsm5avr7")
        }, {
            name: "nostrimg.com",
            owner: (0, Ks.FX)("npub1xv6axulxcx6mce5mfvfzpsy89r4gee3zuknulm45cqqpmyw7680q5pxea6")
        }];

        function Nu() {
            switch (Qs().preferences.fileUploader) {
                case"nostr.build":
                    return {upload: Ru};
                case"nostrimg.com":
                    return {upload: _u};
                default:
                    return {
                        upload: (e, t) => async function (e, t, n) {
                            const r = new Lu.VoidApi(ci).getUploader(e),
                                i = await r.upload({"V-Strip-Metadata": "true"});
                            if (i.ok) {
                                var s, a, o, l, c, u;
                                let e = t.match(bi);
                                "image/webp" === (null === (s = i.file) || void 0 === s || null === (a = s.metadata) || void 0 === a ? void 0 : a.mimeType) && (e = ["", "webp"]);
                                const n = null !== (o = null === (l = i.file) || void 0 === l || null === (c = l.metadata) || void 0 === c ? void 0 : c.url) && void 0 !== o ? o : `${ci}/d/${null === (u = i.file) || void 0 === u ? void 0 : u.id}${e ? `.${e[1]}` : ""}`,
                                    r = {url: n};
                                return r
                            }
                            return {error: i.errorMessage}
                        }(e, t)
                    }
            }
        }

        const ju = new Map, Iu = new WeakMap;
        let Mu, Du = 0;

        function Ou(e, t, n = {}, r = Mu) {
            if (void 0 === window.IntersectionObserver && void 0 !== r) {
                const i = e.getBoundingClientRect();
                return t(r, {
                    isIntersecting: r,
                    target: e,
                    intersectionRatio: "number" == typeof n.threshold ? n.threshold : 0,
                    time: 0,
                    boundingClientRect: i,
                    intersectionRect: i,
                    rootBounds: i
                }), () => {
                }
            }
            const {id: i, observer: s, elements: a} = function (e) {
                let t = function (e) {
                    return Object.keys(e).sort().filter((t => void 0 !== e[t])).map((t => {
                        return `${t}_${"root" === t ? (n = e.root, n ? (Iu.has(n) || (Du += 1, Iu.set(n, Du.toString())), Iu.get(n)) : "0") : e[t]}`;
                        var n
                    })).toString()
                }(e), n = ju.get(t);
                if (!n) {
                    const r = new Map;
                    let i;
                    const s = new IntersectionObserver((t => {
                        t.forEach((t => {
                            var n;
                            const s = t.isIntersecting && i.some((e => t.intersectionRatio >= e));
                            e.trackVisibility && void 0 === t.isVisible && (t.isVisible = s), null == (n = r.get(t.target)) || n.forEach((e => {
                                e(s, t)
                            }))
                        }))
                    }), e);
                    i = s.thresholds || (Array.isArray(e.threshold) ? e.threshold : [e.threshold || 0]), n = {
                        id: t,
                        observer: s,
                        elements: r
                    }, ju.set(t, n)
                }
                return n
            }(n);
            let o = a.get(e) || [];
            return a.has(e) || a.set(e, o), o.push(t), s.observe(e), function () {
                o.splice(o.indexOf(t), 1), 0 === o.length && (a.delete(e), s.unobserve(e)), 0 === a.size && (s.disconnect(), ju.delete(i))
            }
        }

        class Bu extends t.Component {
            constructor(e) {
                super(e), this.node = null, this._unobserveCb = null, this.handleNode = e => {
                    this.node && (this.unobserve(), e || this.props.triggerOnce || this.props.skip || this.setState({
                        inView: !!this.props.initialInView,
                        entry: void 0
                    })), this.node = e || null, this.observeNode()
                }, this.handleChange = (e, t) => {
                    e && this.props.triggerOnce && this.unobserve(), isPlainChildren(this.props) || this.setState({
                        inView: e,
                        entry: t
                    }), this.props.onChange && this.props.onChange(e, t)
                }, this.state = {inView: !!e.initialInView, entry: void 0}
            }

            componentDidUpdate(e) {
                e.rootMargin === this.props.rootMargin && e.root === this.props.root && e.threshold === this.props.threshold && e.skip === this.props.skip && e.trackVisibility === this.props.trackVisibility && e.delay === this.props.delay || (this.unobserve(), this.observeNode())
            }

            componentWillUnmount() {
                this.unobserve(), this.node = null
            }

            observeNode() {
                if (!this.node || this.props.skip) return;
                const {
                    threshold: e,
                    root: t,
                    rootMargin: n,
                    trackVisibility: r,
                    delay: i,
                    fallbackInView: s
                } = this.props;
                this._unobserveCb = Ou(this.node, this.handleChange, {
                    threshold: e,
                    root: t,
                    rootMargin: n,
                    trackVisibility: r,
                    delay: i
                }, s)
            }

            unobserve() {
                this._unobserveCb && (this._unobserveCb(), this._unobserveCb = null)
            }

            render() {
                if (!isPlainChildren(this.props)) {
                    const {inView: e, entry: t} = this.state;
                    return this.props.children({inView: e, entry: t, ref: this.handleNode})
                }
                const e = this.props, {children: t, as: n} = e, r = function (e, t) {
                    if (null == e) return {};
                    for (var n, r, i = {}, s = Object.keys(e); r < s.length; r++) s[r], null.indexOf(n) >= 0 || (i[n] = e[n]);
                    return i
                }(e);
                return React.createElement(n || "div", react_intersection_observer_modern_extends({ref: this.handleNode}, r), t)
            }
        }

        function Fu({
                        threshold: e,
                        delay: n,
                        trackVisibility: r,
                        rootMargin: i,
                        root: s,
                        triggerOnce: a,
                        skip: o,
                        initialInView: l,
                        fallbackInView: c,
                        onChange: u
                    } = {}) {
            var d;
            const [h, f] = t.useState(null), p = t.useRef(), [m, g] = t.useState({inView: !!l, entry: void 0});
            p.current = u, t.useEffect((() => {
                if (o || !h) return;
                let t;
                return t = Ou(h, ((e, n) => {
                    g({
                        inView: e,
                        entry: n
                    }), p.current && p.current(e, n), n.isIntersecting && a && t && (t(), t = void 0)
                }), {root: s, rootMargin: i, threshold: e, trackVisibility: r, delay: n}, c), () => {
                    t && t()
                }
            }), [Array.isArray(e) ? e.toString() : e, h, s, i, a, o, r, c, n]);
            const y = null == (d = m.entry) ? void 0 : d.target, v = t.useRef();
            h || !y || a || o || v.current === y || (v.current = y, g({inView: !!l, entry: void 0}));
            const b = [f, m.inView, m.entry];
            return b.ref = b[0], b.inView = b[1], b.entry = b[2], b
        }

        const Uu = new Intl.NumberFormat("en", {minimumFractionDigits: 0, maximumFractionDigits: 2});

        function Hu(e) {
            return e < 2e3 ? e : e < 1e6 ? `${Uu.format(e / 1e3)}K` : e < 1e9 ? `${Uu.format(e / 1e6)}M` : `${Uu.format(e / 1e9)}G`
        }

        var $u = a(3542), Ku = a.n($u);

        function zu(n) {
            var r;
            const i = (0, t.useRef)(null);
            return (0, t.useEffect)((() => {
                var e, t;
                if ((null !== (e = null === (t = n.data) || void 0 === t ? void 0 : t.length) && void 0 !== e ? e : 0) > 0 && i.current) {
                    const e = new (Ku())({
                        width: n.width || 256,
                        height: n.height || 256,
                        data: n.data,
                        margin: 5,
                        type: "canvas",
                        image: n.avatar,
                        dotsOptions: {type: "rounded"},
                        cornersSquareOptions: {type: "extra-rounded"},
                        imageOptions: {crossOrigin: "anonymous"}
                    });
                    i.current.innerHTML = "", e.append(i.current), n.link && (i.current.onclick = function () {
                        var e;
                        const t = document.createElement("a");
                        t.href = null !== (e = n.link) && void 0 !== e ? e : "", t.click()
                    })
                } else i.current && (i.current.innerHTML = "")
            }), [n.data, n.link]), (0, e.jsx)("div", {
                className: `qr${null !== (r = n.className) && void 0 !== r ? r : ""}`,
                ref: i
            })
        }

        const Gu = function () {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2e3;
            const [n, r] = (0, t.useState)(!1), [i, s] = (0, t.useState)(!1);
            return {
                error: n, copied: i, copy: async t => {
                    try {
                        await navigator.clipboard.writeText(t), s(!0), r(!1)
                    } catch (e) {
                        r(!0)
                    }
                    setTimeout((() => s(!1)), e)
                }
            }
        };

        function qu(t) {
            let {text: n, maxSize: r = 32, className: i} = t;
            const {copy: s, copied: a} = Gu(), o = r / 2, l = n.length > r ? `${n.slice(0, o)}...${n.slice(-o)}` : n;
            return (0, e.jsxs)("div", {
                className: `flex flex-row copy ${i}`,
                onClick: () => s(n),
                children: [(0, e.jsx)("span", {className: "body", children: l}), (0, e.jsx)("span", {
                    className: "icon",
                    style: {color: a ? "var(--success)" : "var(--highlight)"},
                    children: a ? (0, e.jsx)(Gl, {name: "check", size: 14}) : (0, e.jsx)(Gl, {name: "copy", size: 14})
                })]
            })
        }

        var Wu = a(3290);
        const Vu = {randomUUID: "undefined" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto)};
        let Yu;
        const Zu = new Uint8Array(16);

        function Xu() {
            if (!Yu && (Yu = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Yu)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
            return Yu(Zu)
        }

        const Qu = [];
        for (let e = 0; e < 256; ++e) Qu.push((e + 256).toString(16).slice(1));
        const Ju = function (e, t, n) {
            if (Vu.randomUUID && !t && !e) return Vu.randomUUID();
            const r = (e = e || {}).random || (e.rng || Xu)();
            if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
                n = n || 0;
                for (let e = 0; e < 16; ++e) t[n + e] = r[e];
                return t
            }
            return function (e, t = 0) {
                return (Qu[e[t + 0]] + Qu[e[t + 1]] + Qu[e[t + 2]] + Qu[e[t + 3]] + "-" + Qu[e[t + 4]] + Qu[e[t + 5]] + "-" + Qu[e[t + 6]] + Qu[e[t + 7]] + "-" + Qu[e[t + 8]] + Qu[e[t + 9]] + "-" + Qu[e[t + 10]] + Qu[e[t + 11]] + Qu[e[t + 12]] + Qu[e[t + 13]] + Qu[e[t + 14]] + Qu[e[t + 15]]).toLowerCase()
            }(r)
        };
        var ed, td, nd, rd, id = function (e, t, n, r) {
            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
        };

        class sd extends ai.ExternalStore {
            constructor() {
                super(...arguments), ed.add(this), td.set(this, []), nd.set(this, setInterval((() => id(this, ed, "m", rd).call(this)), 1e3))
            }

            push(e) {
                var t, n;
                null !== (t = e.expire) && void 0 !== t || (e.expire = (0, ai.unixNow)() + 3), null !== (n = e.id) && void 0 !== n || (e.id = Ju()), id(this, td, "f").push(e), this.notifyChange()
            }

            takeSnapshot() {
                return [...id(this, td, "f")]
            }
        }

        td = new WeakMap, nd = new WeakMap, ed = new WeakSet, rd = function () {
            const e = (0, ai.unixNow)();
            (function (e, t, n, r, i) {
                if ("m" === r) throw new TypeError("Private method is not writable");
                if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n)
            })(this, td, id(this, td, "f").filter((t => {
                var n;
                return (null !== (n = t.expire) && void 0 !== n ? n : 0) > e
            })), "f"), this.notifyChange()
        };
        const ad = new sd;

        function od() {
            const n = (0, t.useSyncExternalStore)((e => ad.hook(e)), (() => ad.snapshot()));
            return (0, e.jsx)("div", {
                className: "toaster", children: n.map((t => {
                    var n;
                    return (0, e.jsxs)("div", {
                        className: "card flex",
                        children: [(0, e.jsx)(Gl, {
                            name: null !== (n = t.icon) && void 0 !== n ? n : "bell",
                            className: "mr5"
                        }), t.element]
                    }, t.id)
                }))
            })
        }

        var ld, cd, ud, dd, hd, fd, pd, md, gd, yd = function (e, t, n, r) {
            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
        }, vd = function (e, t, n, r, i) {
            if ("m" === r) throw new TypeError("Private method is not writable");
            if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
        };
        !function (e) {
            e[e.Generic = 0] = "Generic", e[e.Relay = 1] = "Relay", e[e.FileHost = 2] = "FileHost", e[e.DataProvider = 3] = "DataProvider"
        }(gd || (gd = {}));

        class bd extends ai.ExternalStore {
            constructor() {
                super(), ld.add(this), cd.set(this, new Map), ud.set(this, !1), dd.set(this, 0), yd(this, ld, "m", pd).call(this), setTimeout((() => yd(this, ld, "m", md).call(this).catch(console.error)), 5e3)
            }

            async payout(e) {
                if (yd(this, ud, "f")) throw new Error("Payout already in progress");
                vd(this, ud, !0, "f"), vd(this, dd, (0, ai.unixNow)(), "f");
                for (const n of yd(this, cd, "f").values()) if (0 !== n.sum) try {
                    const r = await sc.get(n.pubkey);
                    if (!r) throw new Error(`Failed to get profile for ${n.pubkey}`);
                    const i = new ai.LNURL(r.lud16 || r.lud06 || "");
                    await i.load();
                    const s = n.sum, a = await i.getInvoice(s, `SnortZapPool: ${n.split}%`);
                    var t;
                    if (!a.pr) throw new Error(null !== (t = a.reason) && void 0 !== t ? t : "Failed to get invoice");
                    {
                        const t = await e.payInvoice(a.pr);
                        if (console.debug("ZPC", a, t), t.state !== Wu.kd.Paid) throw new Error("Failed to pay invoice, unknown reason");
                        n.sum -= s, ad.push({
                            element: `Sent ${s.toLocaleString()} sats to ${Xl(r, n.pubkey)} from your zap pool`,
                            expire: (0, ai.unixNow)() + 10,
                            icon: "zap"
                        })
                    }
                } catch (e) {
                    if (console.error(e), e instanceof Error) {
                        const t = sc.getFromCache(n.pubkey);
                        ad.push({
                            element: `Failed to send sats to ${Xl(t, n.pubkey)} (${e.message}), please try again later`,
                            expire: (0, ai.unixNow)() + 10,
                            icon: "close"
                        })
                    }
                }
                yd(this, ld, "m", fd).call(this), this.notifyChange(), vd(this, ud, !1, "f")
            }

            calcAllocation(e) {
                let t = 0;
                for (const n of yd(this, cd, "f").values()) t += Math.ceil(e * (n.split / 100));
                return t
            }

            allocate(e) {
                if (yd(this, ud, "f")) throw new Error("Payout is in progress, cannot allocate to pool");
                for (const t of yd(this, cd, "f").values()) t.sum += Math.ceil(e * (t.split / 100));
                yd(this, ld, "m", fd).call(this), this.notifyChange()
            }

            getOrDefault(e) {
                const t = yd(this, ld, "m", hd).call(this, e);
                return yd(this, cd, "f").has(t) ? {...yd(this, cd, "f").get(t)} : e
            }

            set(e) {
                const t = yd(this, ld, "m", hd).call(this, e);
                0 === e.split && 0 === e.sum && yd(this, cd, "f").has(t) ? yd(this, cd, "f").delete(t) : yd(this, cd, "f").set(t, e), yd(this, ld, "m", fd).call(this), this.notifyChange()
            }

            takeSnapshot() {
                return [...yd(this, cd, "f").values()]
            }
        }

        cd = new WeakMap, ud = new WeakMap, dd = new WeakMap, ld = new WeakSet, hd = function (e) {
            return `${e.pubkey}-${e.type}`
        }, fd = function () {
            self.localStorage.setItem("zap-pool", JSON.stringify(this.takeSnapshot())), self.localStorage.setItem("zap-pool-last-payout", yd(this, dd, "f").toString())
        }, pd = function () {
            const e = self.localStorage.getItem("zap-pool");
            if (e) {
                const t = JSON.parse(e);
                vd(this, cd, new Map(t.map((e => [`${e.pubkey}-${e.type}`, e]))), "f")
            }
            const t = self.localStorage.getItem("zap-pool-last-payout");
            t && vd(this, dd, Number(t), "f")
        }, md = async function e() {
            try {
                if (yd(this, dd, "f") < (0, ai.unixNow)() - 3600) {
                    const e = Wu.uo.get();
                    e && (e.canAutoLogin() && await e.login(), await this.payout(e))
                }
            } catch (e) {
                console.error(e)
            }
            setTimeout((() => yd(this, ld, "m", e).call(this).catch(console.error)), 6e4)
        };
        const wd = new bd;
        var xd;

        function Ed(n) {
            var r;
            const i = n.onClose || (() => {
                }), {note: s, author: a, target: o} = n, l = Qs(), c = l.preferences.defaultZapAmount,
                u = [c, 1e3, 5e3, 1e4, 2e4, 5e4, 1e5, 1e6], d = {
                    1e3: "",
                    5e3: "",
                    1e4: "",
                    2e4: "",
                    5e4: "",
                    1e5: "",
                    1e6: ""
                }, [h, f] = (0, t.useState)(), [p, m] = (0, t.useState)(), [g, y] = (0, t.useState)(c), [v, b] = (0, t.useState)(), [w, x] = (0, t.useState)(), [E, S] = (0, t.useState)(), [k, A] = (0, t.useState)(), [T, C] = (0, t.useState)(xd.PublicZap), [R, L] = (0, t.useState)(!1), {formatMessage: _} = al(),
                P = hc(), N = !!h && (h.canZap && T !== xd.NonZap || h.maxCommentLength > 0), j = (0, Wu.Os)(),
                I = j.wallet;
            (0, t.useEffect)((() => {
                n.show && (A(void 0), y(c), x(void 0), C(xd.PublicZap), m(n.invoice), S(void 0))
            }), [n.show]), (0, t.useEffect)((() => {
                if (E && !E.url) return (0, Ks.Ds)(1e3, (() => {
                    i()
                }))
            }), [E]), (0, t.useEffect)((() => {
                if (n.lnurl && n.show) try {
                    const e = new ai.LNURL(n.lnurl);
                    f(e), e.load().catch((e => B(e, _(Su.InvoiceFail))))
                } catch (e) {
                    e instanceof Error && A(e.message)
                }
            }), [n.lnurl, n.show]);
            const M = (0, t.useMemo)((() => {
                if (h) {
                    const e = h.min / 1e3, t = h.max / 1e3;
                    return u.filter((n => n >= e && n <= t))
                }
                return []
            }), [h]), D = (0, t.useMemo)((() => (0, Ks.OZ)(M, 3)), [M]), O = e => {
                A(void 0), y(e)
            };

            function B(e, t) {
                if (e instanceof ai.LNURLError) switch (e.code) {
                    case ai.LNURLErrorCode.ServiceUnavailable:
                        return void A(_(Su.LNURLFail));
                    case ai.LNURLErrorCode.InvalidLNURL:
                        return void A(_(Su.InvalidLNURL))
                }
                A(t)
            }

            const F = null != h && h.canZap ? _(Su.SendZap) : _(Su.SendSats),
                U = o ? _(Su.ToTarget, {action: F, target: o}) : F;
            return null !== (r = n.show) && void 0 !== r && r ? (0, e.jsx)(Cu, {
                className: "lnurl-modal", onClose: i, children: (0, e.jsxs)("div", {
                    className: "lnurl-tip",
                    onClick: e => e.stopPropagation(),
                    children: [(0, e.jsx)("div", {
                        className: "close",
                        onClick: i,
                        children: (0, e.jsx)(Gl, {name: "close"})
                    }), (0, e.jsxs)("div", {
                        className: "lnurl-header",
                        children: [a && (0, e.jsx)(Zl, {
                            pubkey: a,
                            showUsername: !1
                        }), (0, e.jsx)("h2", {children: n.title || U})]
                    }), !h || p ? null : (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("h3", {children: (0, e.jsx)(cl, {...Su.ZapAmount})}), D.map((t => function (t, n) {
                            return (0, e.jsx)("div", {
                                className: "amounts",
                                children: n.map((n => (0, e.jsxs)("span", {
                                    className: "sat-amount " + (t === n ? "active" : ""),
                                    onClick: () => O(n),
                                    children: [d[n] && (0, e.jsxs)(e.Fragment, {children: [d[n], ""]}), 1e3 === n ? "1K" : Hu(n)]
                                }, n)))
                            })
                        }(g, t))), function () {
                            if (!h) return null;
                            const t = h.min / 1e3, n = h.max / 1e3;
                            return (0, e.jsxs)("div", {
                                className: "custom-amount flex",
                                children: [(0, e.jsx)("input", {
                                    type: "number",
                                    min: t,
                                    max: n,
                                    className: "f-grow mr10",
                                    placeholder: _(Su.Custom),
                                    value: v,
                                    onChange: e => b(parseInt(e.target.value))
                                }), (0, e.jsx)("button", {
                                    className: "secondary",
                                    type: "button",
                                    disabled: !v,
                                    onClick: () => O(null != v ? v : 0),
                                    children: (0, e.jsx)(cl, {...Su.Confirm})
                                })]
                            })
                        }(), (0, e.jsx)("div", {
                            className: "flex",
                            children: N && (0, e.jsx)("input", {
                                type: "text",
                                placeholder: _(Su.Comment),
                                className: "f-grow",
                                maxLength: h.canZap && T !== xd.NonZap ? 250 : h.maxCommentLength,
                                onChange: e => x(e.target.value)
                            })
                        }), function () {
                            if (!h || !h.canZap) return;
                            const t = (t, n) => (0, e.jsx)("div", {
                                className: "tab" + (T === t ? " active" : ""),
                                onClick: () => C(t),
                                children: n
                            });
                            return (0, e.jsxs)(e.Fragment, {
                                children: [(0, e.jsx)("h3", {
                                    children: (0, e.jsx)(cl, {
                                        id: "+aZY2h",
                                        defaultMessage: "Zap Type"
                                    })
                                }), (0, e.jsxs)("div", {
                                    className: "tabs mt10",
                                    children: [t(xd.PublicZap, (0, e.jsx)(cl, {
                                        id: "/PCavi",
                                        defaultMessage: "Public"
                                    })), t(xd.AnonZap, (0, e.jsx)(cl, {
                                        id: "wWLwvh",
                                        defaultMessage: "Anon"
                                    })), t(xd.NonZap, (0, e.jsx)(cl, {id: "AnLrRC", defaultMessage: "Non-Zap"}))]
                                })]
                            })
                        }(), (null != g ? g : 0) > 0 && (0, e.jsx)("button", {
                            type: "button",
                            className: "zap-action",
                            onClick: () => async function () {
                                if (!g || !h || !P) return null;
                                let e;
                                if (a && T !== xd.NonZap) {
                                    const t = Object.keys(l.relays.item);
                                    if (T === xd.AnonZap) {
                                        const n = function () {
                                            const e = si.ci(ii.xW.utils.randomPrivateKey());
                                            return {privateKey: e, publicKey: si.ci(ii.xW.getPublicKey(e))}
                                        }();
                                        console.debug("Generated new key for zap: ", n);
                                        const r = new Pt.EventPublisher(n.publicKey, n.privateKey);
                                        e = await r.zap(1e3 * g, a, t, s, w, (e => e.tag(["anon", ""])))
                                    } else e = await P.zap(1e3 * g, a, t, s, w)
                                }
                                try {
                                    const t = await h.getInvoice(g, w, e);
                                    t.pr && (m(t.pr), await async function (e) {
                                        try {
                                            if (null != I && I.isReady()) {
                                                var t, r;
                                                L(!0);
                                                const i = await I.payInvoice(null !== (t = null == e ? void 0 : e.pr) && void 0 !== t ? t : "");
                                                n.allocatePool && wd.allocate(g), console.log(i), S(null !== (r = null == e ? void 0 : e.successAction) && void 0 !== r ? r : {})
                                            }
                                        } catch (e) {
                                            console.warn(e), e instanceof Error && A(e.toString())
                                        } finally {
                                            L(!1)
                                        }
                                    }(t))
                                } catch (e) {
                                    B(e, _(Su.InvoiceFail))
                                }
                            }(),
                            children: (0, e.jsxs)("div", {
                                className: "zap-action-container",
                                children: [(0, e.jsx)(Gl, {name: "zap"}), o ? (0, e.jsx)(cl, {
                                    ...Su.ZapTarget,
                                    values: {target: o, n: Hu(g)}
                                }) : (0, e.jsx)(cl, {...Su.ZapSats, values: {n: Hu(g)}})]
                            })
                        })]
                    }), k && (0, e.jsx)("p", {
                        className: "error",
                        children: k
                    }), E || !p ? null : (0, e.jsx)(e.Fragment, {
                        children: (0, e.jsxs)("div", {
                            className: "invoice",
                            children: [n.notice && (0, e.jsx)("b", {
                                className: "error",
                                children: n.notice
                            }), R ? (0, e.jsxs)("h4", {
                                children: [(0, e.jsx)(cl, {
                                    id: "vU71Ez",
                                    defaultMessage: "Paying with {wallet}",
                                    values: {wallet: null === ($ = j.config) || void 0 === $ ? void 0 : $.info.alias}
                                }), "..."]
                            }) : (0, e.jsx)(zu, {
                                data: p,
                                link: `lightning:${p}`
                            }), (0, e.jsx)("div", {
                                className: "actions",
                                children: p && (0, e.jsxs)(e.Fragment, {
                                    children: [(0, e.jsx)("div", {
                                        className: "copy-action",
                                        children: (0, e.jsx)(qu, {text: p, maxSize: 26})
                                    }), (0, e.jsx)("button", {
                                        className: "wallet-action",
                                        type: "button",
                                        onClick: () => window.open(`lightning:${p}`),
                                        children: (0, e.jsx)(cl, {...Su.OpenWallet})
                                    })]
                                })
                            })]
                        })
                    }), E ? (0, e.jsxs)("div", {
                        className: "success-action",
                        children: [(0, e.jsxs)("p", {
                            className: "paid",
                            children: [(0, e.jsx)(Gl, {
                                name: "check",
                                className: "success mr10"
                            }), null !== (H = null == E ? void 0 : E.description) && void 0 !== H ? H : (0, e.jsx)(cl, {...Su.Paid})]
                        }), E.url && (0, e.jsx)("p", {
                            children: (0, e.jsx)("a", {
                                href: E.url,
                                rel: "noreferrer",
                                target: "_blank",
                                children: E.url
                            })
                        })]
                    }) : null]
                })
            }) : null;
            var H, $
        }

        function Sd(n) {
            var r;
            const i = n.invoice, {formatMessage: s} = al(), [a, o] = (0, t.useState)(!1), l = (0, Wu.Os)().wallet,
                c = (0, t.useMemo)((() => (0, ai.decodeInvoice)(i)), [i]), [u, d] = (0, t.useState)(!1),
                h = null == c ? void 0 : c.expired,
                f = null !== (r = null == c ? void 0 : c.amount) && void 0 !== r ? r : 0,
                p = null == c ? void 0 : c.description;
            return (0, e.jsx)(e.Fragment, {
                children: (0, e.jsxs)("div", {
                    className: `note-invoice flex ${h ? "expired" : ""} ${u ? "paid" : ""}`,
                    children: [(0, e.jsx)("div", {
                        className: "invoice-header",
                        children: (0, e.jsxs)(e.Fragment, {
                            children: [(0, e.jsx)("h4", {children: (0, e.jsx)(cl, {...Su.Invoice})}), (0, e.jsx)(Gl, {
                                name: "zapCircle",
                                className: "zap-circle"
                            }), (0, e.jsx)(Ed, {title: s(Su.PayInvoice), invoice: i, show: a, onClose: () => o(!1)})]
                        })
                    }), (0, e.jsx)("p", {
                        className: "invoice-amount",
                        children: f > 0 && (0, e.jsxs)(e.Fragment, {
                            children: [(f / 1e3).toLocaleString(), " ", (0, e.jsxs)("span", {
                                className: "sats",
                                children: ["sat", 1e3 === f ? "" : "s"]
                            })]
                        })
                    }), (0, e.jsxs)("div", {
                        className: "invoice-body",
                        children: [p && (0, e.jsx)("p", {children: p}), u ? (0, e.jsx)("div", {
                            className: "paid",
                            children: (0, e.jsx)(cl, {...Su.Paid})
                        }) : (0, e.jsx)("button", {
                            disabled: h, type: "button", onClick: async function (e) {
                                if (e.stopPropagation(), null != l && l.isReady) try {
                                    await l.payInvoice(i), d(!0)
                                } catch (e) {
                                    o(!0)
                                } else o(!0)
                            }, children: h ? (0, e.jsx)(cl, {...Su.Expired}) : (0, e.jsx)(cl, {...Su.Pay})
                        })]
                    })]
                })
            })
        }

        !function (e) {
            e[e.PublicZap = 1] = "PublicZap", e[e.AnonZap = 2] = "AnonZap", e[e.PrivateZap = 3] = "PrivateZap", e[e.NonZap = 4] = "NonZap"
        }(xd || (xd = {}));
        const kd = t => {
            let {tag: n} = t;
            return (0, e.jsx)("span", {
                className: "hashtag",
                children: (0, e.jsxs)(Rt, {to: `/t/${n}`, onClick: e => e.stopPropagation(), children: ["#", n]})
            })
        };

        function Ad(n) {
            let {pubkey: r, relays: i} = n;
            const s = (0, hl.useUserProfile)(DS, r), a = (0, t.useMemo)((() => Xl(s, r)), [s, r]);
            return (0, e.jsxs)(Rt, {to: (0, Ks._v)(r, i), onClick: e => e.stopPropagation(), children: ["@", a]})
        }

        var Td = "createTweet", Cd = function (e) {
            var n = t.useRef(null), r = t.useState(!0), i = r[0], s = r[1];
            return t.useEffect((function () {
                var t = !0;
                return a(8391)("https://platform.twitter.com/widgets.js", "twitter-embed", (function () {
                    if (window.twttr) {
                        if (t) {
                            if (!window.twttr.widgets[Td]) return void console.error("Method " + Td + " is not present anymore in twttr.widget api");
                            window.twttr.widgets[Td](e.tweetId, null == n ? void 0 : n.current, e.options).then((function (t) {
                                s(!1), e.onLoad && e.onLoad(t)
                            }))
                        }
                    } else console.error("Failure to load window.twttr, aborting load")
                })), function () {
                    t = !1
                }
            }), []), t.createElement(t.Fragment, null, i && t.createElement(t.Fragment, null, e.placeholder), t.createElement("div", {ref: n}))
        };
        const Rd = t => {
            let {link: n} = t;
            return (0, e.jsx)("iframe", {
                width: "100%",
                height: "166",
                scrolling: "no",
                allow: "autoplay",
                src: `https://w.soundcloud.com/player/?url=${n}`
            })
        }, Ld = t => {
            let {link: n} = t;
            const r = (Ci.test(n) && RegExp.$1) + "%2F" + (Ci.test(n) && RegExp.$2),
                i = "light" === Qs().preferences.theme ? "light=1" : "light=0";
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)("br", {}), (0, e.jsx)("iframe", {
                    title: "SoundCloud player",
                    width: "100%",
                    height: "120",
                    frameBorder: "0",
                    src: `https://www.mixcloud.com/widget/iframe/?hide_cover=1&${i}&feed=%2F${r}%2F`
                })]
            })
        }, _d = t => {
            let {link: n} = t;
            const r = n.replace(/\/(track|album|playlist|episode)\/([a-zA-Z0-9]+)/, "/embed/$1/$2");
            return (0, e.jsx)("iframe", {
                style: {borderRadius: 12},
                src: r,
                width: "100%",
                height: "352",
                frameBorder: "0",
                allow: "autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture",
                loading: "lazy"
            })
        }, Pd = new DOMParser, Nd = n => {
            let {link: r} = n;
            const [i, s] = (0, t.useState)(), [a, o] = (0, t.useState)(),
                l = r.includes("video") ? {aspectRatio: "16 / 9"} : {height: a};
            return (0, t.useEffect)((() => {
                (async function (e) {
                    const t = Ai.exec(e);
                    if (!t) return Promise.reject("Not a TIDAL link.");
                    const [, n, r] = t, i = `https://oembed.tidal.com/?url=https://tidal.com/browse/${n}/${r}`,
                        s = await fetch(i), a = await s.json(),
                        o = Pd.parseFromString(a.html, "text/html").querySelector("iframe");
                    return o ? {
                        source: o.getAttribute("src"),
                        height: a.height
                    } : Promise.reject("No iframe delivered.")
                })(r).then((e => {
                    s(e.source || void 0), o(e.height)
                })).catch(console.error)
            }), [r]), i ? (0, e.jsx)("iframe", {
                src: i,
                style: l,
                width: "100%",
                title: "TIDAL Embed",
                frameBorder: 0
            }) : (0, e.jsx)("a", {
                href: r,
                target: "_blank",
                rel: "noreferrer",
                onClick: e => e.stopPropagation(),
                className: "ext",
                children: r
            })
        }, jd = t => {
            let {link: n} = t;
            const r = `?channel=${n.split("/").slice(-1)}&parent=${window.location.hostname}&muted=true`;
            return (0, e.jsx)("iframe", {src: `https://player.twitch.tv/${r}`, className: "w-max", allowFullScreen: !0})
        }, Id = t => {
            let {link: n} = t;
            const r = n.replace("music.apple.com", "embed.music.apple.com"), i = /\?i=\d+$/.test(r);
            return (0, e.jsx)("iframe", {
                allow: "autoplay *; encrypted-media *; fullscreen *; clipboard-write",
                frameBorder: "0",
                height: i ? 175 : 450,
                style: {width: "100%", maxWidth: 660, overflow: "hidden", background: "transparent"},
                sandbox: "allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation",
                src: r
            })
        }, Md = t => {
            let {link: n} = t;
            const r = n.replace(/(?:player\.|www\.)?wavlake\.com/, "embed.wavlake.com");
            return (0, e.jsx)("iframe", {
                style: {borderRadius: 12},
                src: r,
                width: "100%",
                height: "380",
                frameBorder: "0",
                loading: "lazy"
            })
        }, Dd = t => (0, e.jsx)("svg", {
            width: "20",
            height: "20",
            stroke: "currentColor",
            viewBox: "0 0 20 20",
            xmlns: "http://www.w3.org/2000/svg", ...t,
            children: (0, e.jsx)("g", {
                className: "spinner_V8m1",
                children: (0, e.jsx)("circle", {cx: "10", cy: "10", r: "7.5", fill: "none", strokeWidth: "3"})
            })
        });
        var Od, Bd, Fd, Ud, Hd, $d, Kd = function (e, t, n, r, i) {
            if ("m" === r) throw new TypeError("Private method is not writable");
            if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n), n
        }, zd = function (e, t, n, r) {
            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
        };
        !function (e) {
            e[e.InternalError = 1] = "InternalError", e[e.SubscriptionActive = 2] = "SubscriptionActive", e[e.Duplicate = 3] = "Duplicate"
        }($d || ($d = {}));

        class Gd extends Error {
            constructor(e, t) {
                super(e), this.code = t
            }
        }

        class qd {
            constructor(e, t) {
                Od.add(this), Bd.set(this, void 0), Fd.set(this, void 0), Kd(this, Bd, new URL(null != e ? e : oi).toString(), "f"), Kd(this, Fd, t, "f")
            }

            revenueSplits() {
                return zd(this, Od, "m", Hd).call(this, "api/v1/revenue/splits")
            }

            revenueToday() {
                return zd(this, Od, "m", Hd).call(this, "api/v1/revenue/today")
            }

            twitterImport(e) {
                return zd(this, Od, "m", Hd).call(this, `api/v1/twitter/follows-for-nostr?username=${encodeURIComponent(e)}`)
            }

            createSubscription(e) {
                return zd(this, Od, "m", Ud).call(this, `api/v1/subscription?type=${e}`, "PUT")
            }

            renewSubscription(e) {
                return zd(this, Od, "m", Ud).call(this, `api/v1/subscription/${e}/renew`, "GET")
            }

            listSubscriptions() {
                return zd(this, Od, "m", Ud).call(this, "api/v1/subscription")
            }

            linkPreview(e) {
                return zd(this, Od, "m", Hd).call(this, `api/v1/preview?url=${encodeURIComponent(e)}`)
            }
        }

        Bd = new WeakMap, Fd = new WeakMap, Od = new WeakSet, Ud = async function (e, t, n, r) {
            if (!zd(this, Fd, "f")) throw new Error("Publisher not set");
            const i = await zd(this, Fd, "f").generic((n => n.kind(Pt.EventKind.HttpAuthentication).tag(["url", `${zd(this, Bd, "f")}${e}`]).tag(["method", null != t ? t : "GET"])));
            return zd(this, Od, "m", Hd).call(this, e, t, n, {
                ...r,
                authorization: `Nostr ${window.btoa(JSON.stringify(i))}`
            })
        }, Hd = async function (e, t, n, r) {
            const i = await fetch(`${zd(this, Bd, "f")}${e}`, {
                method: t,
                body: n ? JSON.stringify(n) : void 0,
                headers: {accept: "application/json", ...n ? {"content-type": "application/json"} : {}, ...r}
            }), s = await i.json();
            if ("error" in s) throw new Gd(s.error, s.code);
            return s
        };
        const Wd = n => {
            const {proxy: r} = Wl(), [i, s] = (0, t.useState)(!1), [a, o] = (0, t.useState)(!1);
            return i ? a ? (0, e.jsx)("img", {...n}) : (0, e.jsx)("div", {
                className: "note-invoice error",
                onClick: e => {
                    e.stopPropagation(), o(!0)
                },
                children: (0, e.jsx)(cl, {
                    id: "65BmHb",
                    defaultMessage: "Failed to proxy image from {host}, click here to load directly",
                    values: {host: (0, Ks.Uq)(n.src)}
                })
            }) : (0, e.jsx)("img", {
                ...n, src: n.src ? r(n.src, n.size) : "", onError: e => {
                    n.onError ? n.onError(e) : s(!0)
                }
            })
        };

        function Vd(n) {
            const [r, i] = (0, t.useState)(!1);
            return (0, e.jsxs)("button", {
                className: "spinner-button",
                type: "button",
                disabled: r || n.disabled, ...n,
                onClick: async function (e) {
                    if (e.stopPropagation(), !r && !n.disabled) {
                        i(!0);
                        try {
                            if ("function" == typeof n.onClick) {
                                const t = n.onClick(e);
                                t instanceof Promise && await t
                            }
                        } finally {
                            i(!1)
                        }
                    }
                },
                children: [(0, e.jsx)("span", {
                    style: {visibility: r ? "hidden" : "visible"},
                    children: n.children
                }), r && (0, e.jsx)("span", {className: "spinner-wrapper", children: (0, e.jsx)(Dd, {})})]
            })
        }

        function Yd() {
            return (0, e.jsx)("div", {className: "flex f-center", children: (0, e.jsx)(Dd, {width: 50, height: 50})})
        }

        function Zd(e) {
            return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
        }

        var Xd, Qd, Jd, eh, th, nh = {exports: {}};
        Xd = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, Qd = /^(?=([^\/?#]*))\1([^]*)$/, Jd = /(?:\/|^)\.(?=\/)/g, eh = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, th = {
            buildAbsoluteURL: function (e, t, n) {
                if (n = n || {}, e = e.trim(), !(t = t.trim())) {
                    if (!n.alwaysNormalize) return e;
                    var r = th.parseURL(e);
                    if (!r) throw new Error("Error trying to parse base URL.");
                    return r.path = th.normalizePath(r.path), th.buildURLFromParts(r)
                }
                var i = th.parseURL(t);
                if (!i) throw new Error("Error trying to parse relative URL.");
                if (i.scheme) return n.alwaysNormalize ? (i.path = th.normalizePath(i.path), th.buildURLFromParts(i)) : t;
                var s = th.parseURL(e);
                if (!s) throw new Error("Error trying to parse base URL.");
                if (!s.netLoc && s.path && "/" !== s.path[0]) {
                    var a = Qd.exec(s.path);
                    s.netLoc = a[1], s.path = a[2]
                }
                s.netLoc && !s.path && (s.path = "/");
                var o = {
                    scheme: s.scheme,
                    netLoc: i.netLoc,
                    path: null,
                    params: i.params,
                    query: i.query,
                    fragment: i.fragment
                };
                if (!i.netLoc && (o.netLoc = s.netLoc, "/" !== i.path[0])) if (i.path) {
                    var l = s.path, c = l.substring(0, l.lastIndexOf("/") + 1) + i.path;
                    o.path = th.normalizePath(c)
                } else o.path = s.path, i.params || (o.params = s.params, i.query || (o.query = s.query));
                return null === o.path && (o.path = n.alwaysNormalize ? th.normalizePath(i.path) : i.path), th.buildURLFromParts(o)
            }, parseURL: function (e) {
                var t = Xd.exec(e);
                return t ? {
                    scheme: t[1] || "",
                    netLoc: t[2] || "",
                    path: t[3] || "",
                    params: t[4] || "",
                    query: t[5] || "",
                    fragment: t[6] || ""
                } : null
            }, normalizePath: function (e) {
                for (e = e.split("").reverse().join("").replace(Jd, ""); e.length !== (e = e.replace(eh, "")).length;) ;
                return e.split("").reverse().join("")
            }, buildURLFromParts: function (e) {
                return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
            }
        }, nh.exports = th;
        var rh = nh.exports;

        function ih(e, t) {
            var n = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
                var r = Object.getOwnPropertySymbols(e);
                t && (r = r.filter((function (t) {
                    return Object.getOwnPropertyDescriptor(e, t).enumerable
                }))), n.push.apply(n, r)
            }
            return n
        }

        function sh(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = null != arguments[t] ? arguments[t] : {};
                t % 2 ? ih(Object(n), !0).forEach((function (t) {
                    ah(e, t, n[t])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ih(Object(n)).forEach((function (t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                }))
            }
            return e
        }

        function ah(e, t, n) {
            return (t = function (e) {
                var t = function (e, t) {
                    if ("object" != typeof e || null === e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, "string");
                        if ("object" != typeof r) return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e);
                return "symbol" == typeof t ? t : String(t)
            }(t)) in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }

        function oh() {
            return oh = Object.assign ? Object.assign.bind() : function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }, oh.apply(this, arguments)
        }

        const lh = Number.isFinite || function (e) {
            return "number" == typeof e && isFinite(e)
        };
        let ch = function (e) {
            return e.MEDIA_ATTACHING = "hlsMediaAttaching", e.MEDIA_ATTACHED = "hlsMediaAttached", e.MEDIA_DETACHING = "hlsMediaDetaching", e.MEDIA_DETACHED = "hlsMediaDetached", e.BUFFER_RESET = "hlsBufferReset", e.BUFFER_CODECS = "hlsBufferCodecs", e.BUFFER_CREATED = "hlsBufferCreated", e.BUFFER_APPENDING = "hlsBufferAppending", e.BUFFER_APPENDED = "hlsBufferAppended", e.BUFFER_EOS = "hlsBufferEos", e.BUFFER_FLUSHING = "hlsBufferFlushing", e.BUFFER_FLUSHED = "hlsBufferFlushed", e.MANIFEST_LOADING = "hlsManifestLoading", e.MANIFEST_LOADED = "hlsManifestLoaded", e.MANIFEST_PARSED = "hlsManifestParsed", e.LEVEL_SWITCHING = "hlsLevelSwitching", e.LEVEL_SWITCHED = "hlsLevelSwitched", e.LEVEL_LOADING = "hlsLevelLoading", e.LEVEL_LOADED = "hlsLevelLoaded", e.LEVEL_UPDATED = "hlsLevelUpdated", e.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", e.LEVELS_UPDATED = "hlsLevelsUpdated", e.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", e.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", e.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", e.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", e.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", e.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", e.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", e.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", e.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", e.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", e.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", e.CUES_PARSED = "hlsCuesParsed", e.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", e.INIT_PTS_FOUND = "hlsInitPtsFound", e.FRAG_LOADING = "hlsFragLoading", e.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", e.FRAG_LOADED = "hlsFragLoaded", e.FRAG_DECRYPTED = "hlsFragDecrypted", e.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", e.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", e.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", e.FRAG_PARSED = "hlsFragParsed", e.FRAG_BUFFERED = "hlsFragBuffered", e.FRAG_CHANGED = "hlsFragChanged", e.FPS_DROP = "hlsFpsDrop", e.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", e.ERROR = "hlsError", e.DESTROYING = "hlsDestroying", e.KEY_LOADING = "hlsKeyLoading", e.KEY_LOADED = "hlsKeyLoaded", e.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", e.BACK_BUFFER_REACHED = "hlsBackBufferReached", e
        }({}), uh = function (e) {
            return e.NETWORK_ERROR = "networkError", e.MEDIA_ERROR = "mediaError", e.KEY_SYSTEM_ERROR = "keySystemError", e.MUX_ERROR = "muxError", e.OTHER_ERROR = "otherError", e
        }({}), dh = function (e) {
            return e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", e.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", e.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", e.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", e.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", e.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", e.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", e.MANIFEST_LOAD_ERROR = "manifestLoadError", e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", e.MANIFEST_PARSING_ERROR = "manifestParsingError", e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", e.LEVEL_EMPTY_ERROR = "levelEmptyError", e.LEVEL_LOAD_ERROR = "levelLoadError", e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", e.LEVEL_PARSING_ERROR = "levelParsingError", e.LEVEL_SWITCH_ERROR = "levelSwitchError", e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", e.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", e.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", e.FRAG_LOAD_ERROR = "fragLoadError", e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", e.FRAG_DECRYPT_ERROR = "fragDecryptError", e.FRAG_PARSING_ERROR = "fragParsingError", e.FRAG_GAP = "fragGap", e.REMUX_ALLOC_ERROR = "remuxAllocError", e.KEY_LOAD_ERROR = "keyLoadError", e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", e.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", e.BUFFER_APPEND_ERROR = "bufferAppendError", e.BUFFER_APPENDING_ERROR = "bufferAppendingError", e.BUFFER_STALLED_ERROR = "bufferStalledError", e.BUFFER_FULL_ERROR = "bufferFullError", e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", e.INTERNAL_EXCEPTION = "internalException", e.INTERNAL_ABORTED = "aborted", e.UNKNOWN = "unknown", e
        }({});
        const hh = function () {
        }, fh = {trace: hh, debug: hh, log: hh, warn: hh, info: hh, error: hh};
        let ph = fh;
        const mh = ph, gh = /^(\d+)x(\d+)$/, yh = /(.+?)=(".*?"|.*?)(?:,|$)/g;

        class vh {
            constructor(e) {
                "string" == typeof e && (e = vh.parseAttrList(e));
                for (const t in e) e.hasOwnProperty(t) && ("X-" === t.substring(0, 2) && (this.clientAttrs = this.clientAttrs || [], this.clientAttrs.push(t)), this[t] = e[t])
            }

            decimalInteger(e) {
                const t = parseInt(this[e], 10);
                return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
            }

            hexadecimalInteger(e) {
                if (this[e]) {
                    let t = (this[e] || "0x").slice(2);
                    t = (1 & t.length ? "0" : "") + t;
                    const n = new Uint8Array(t.length / 2);
                    for (let e = 0; e < t.length / 2; e++) n[e] = parseInt(t.slice(2 * e, 2 * e + 2), 16);
                    return n
                }
                return null
            }

            hexadecimalIntegerAsNumber(e) {
                const t = parseInt(this[e], 16);
                return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
            }

            decimalFloatingPoint(e) {
                return parseFloat(this[e])
            }

            optionalFloat(e, t) {
                const n = this[e];
                return n ? parseFloat(n) : t
            }

            enumeratedString(e) {
                return this[e]
            }

            bool(e) {
                return "YES" === this[e]
            }

            decimalResolution(e) {
                const t = gh.exec(this[e]);
                if (null !== t) return {width: parseInt(t[1], 10), height: parseInt(t[2], 10)}
            }

            static parseAttrList(e) {
                let t;
                const n = {};
                for (yh.lastIndex = 0; null !== (t = yh.exec(e));) {
                    let e = t[2];
                    0 === e.indexOf('"') && e.lastIndexOf('"') === e.length - 1 && (e = e.slice(1, -1)), n[t[1].trim()] = e
                }
                return n
            }
        }

        function bh(e) {
            return "SCTE35-OUT" === e || "SCTE35-IN" === e
        }

        class wh {
            constructor(e, t) {
                if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t) {
                    const n = t.attr;
                    for (const t in n) if (Object.prototype.hasOwnProperty.call(e, t) && e[t] !== n[t]) {
                        mh.warn(`DATERANGE tag attribute: "${t}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = t;
                        break
                    }
                    e = oh(new vh({}), n, e)
                }
                if (this.attr = e, this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) {
                    const e = new Date(this.attr["END-DATE"]);
                    lh(e.getTime()) && (this._endDate = e)
                }
            }

            get id() {
                return this.attr.ID
            }

            get class() {
                return this.attr.CLASS
            }

            get startDate() {
                return this._startDate
            }

            get endDate() {
                if (this._endDate) return this._endDate;
                const e = this.duration;
                return null !== e ? new Date(this._startDate.getTime() + 1e3 * e) : null
            }

            get duration() {
                if ("DURATION" in this.attr) {
                    const e = this.attr.decimalFloatingPoint("DURATION");
                    if (lh(e)) return e
                } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
                return null
            }

            get plannedDuration() {
                return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null
            }

            get endOnNext() {
                return this.attr.bool("END-ON-NEXT")
            }

            get isValid() {
                return !!this.id && !this._badValueForSameId && lh(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class)
            }
        }

        class xh {
            constructor() {
                this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
                    start: 0,
                    first: 0,
                    end: 0
                }, this.parsing = {start: 0, end: 0}, this.buffering = {start: 0, first: 0, end: 0}
            }
        }

        var Eh = "audio", Sh = "video", kh = "audiovideo";

        class Ah {
            constructor(e) {
                this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = {
                    [Eh]: null,
                    [Sh]: null,
                    [kh]: null
                }, this.baseurl = e
            }

            setByteRange(e, t) {
                const n = e.split("@", 2), r = [];
                1 === n.length ? r[0] = t ? t.byteRangeEndOffset : 0 : r[0] = parseInt(n[1]), r[1] = parseInt(n[0]) + r[0], this._byteRange = r
            }

            get byteRange() {
                return this._byteRange ? this._byteRange : []
            }

            get byteRangeStartOffset() {
                return this.byteRange[0]
            }

            get byteRangeEndOffset() {
                return this.byteRange[1]
            }

            get url() {
                return !this._url && this.baseurl && this.relurl && (this._url = rh.buildAbsoluteURL(this.baseurl, this.relurl, {alwaysNormalize: !0})), this._url || ""
            }

            set url(e) {
                this._url = e
            }
        }

        class Th extends Ah {
            constructor(e, t) {
                super(t), this._decryptdata = null, this.rawProgramDateTime = null, this.programDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.stats = new xh, this.urlId = 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.type = e
            }

            get decryptdata() {
                const {levelkeys: e} = this;
                if (!e && !this._decryptdata) return null;
                if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
                    const e = this.levelkeys.identity;
                    if (e) this._decryptdata = e.getDecryptData(this.sn); else {
                        const e = Object.keys(this.levelkeys);
                        if (1 === e.length) return this._decryptdata = this.levelkeys[e[0]].getDecryptData(this.sn)
                    }
                }
                return this._decryptdata
            }

            get end() {
                return this.start + this.duration
            }

            get endProgramDateTime() {
                if (null === this.programDateTime) return null;
                if (!lh(this.programDateTime)) return null;
                const e = lh(this.duration) ? this.duration : 0;
                return this.programDateTime + 1e3 * e
            }

            get encrypted() {
                var e;
                if (null != (e = this._decryptdata) && e.encrypted) return !0;
                if (this.levelkeys) {
                    const e = Object.keys(this.levelkeys), t = e.length;
                    if (t > 1 || 1 === t && this.levelkeys[e[0]].encrypted) return !0
                }
                return !1
            }

            setKeyFormat(e) {
                if (this.levelkeys) {
                    const t = this.levelkeys[e];
                    t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn))
                }
            }

            abortRequests() {
                var e, t;
                null == (e = this.loader) || e.abort(), null == (t = this.keyLoader) || t.abort()
            }

            setElementaryStreamInfo(e, t, n, r, i, s = !1) {
                const {elementaryStreams: a} = this, o = a[e];
                o ? (o.startPTS = Math.min(o.startPTS, t), o.endPTS = Math.max(o.endPTS, n), o.startDTS = Math.min(o.startDTS, r), o.endDTS = Math.max(o.endDTS, i)) : a[e] = {
                    startPTS: t,
                    endPTS: n,
                    startDTS: r,
                    endDTS: i,
                    partial: s
                }
            }

            clearElementaryStreamInfo() {
                const {elementaryStreams: e} = this;
                e[Eh] = null, e[Sh] = null, e[kh] = null
            }
        }

        class Ch extends Ah {
            constructor(e, t, n, r, i) {
                super(n), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.stats = new xh, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = r;
                const s = e.enumeratedString("BYTERANGE");
                s && this.setByteRange(s, i), i && (this.fragOffset = i.fragOffset + i.duration)
            }

            get start() {
                return this.fragment.start + this.fragOffset
            }

            get end() {
                return this.start + this.duration
            }

            get loaded() {
                const {elementaryStreams: e} = this;
                return !!(e.audio || e.video || e.audiovideo)
            }
        }

        class Rh {
            constructor(e) {
                this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e
            }

            reloaded(e) {
                if (!e) return this.advanced = !0, void (this.updated = !0);
                const t = this.lastPartSn - e.lastPartSn, n = this.lastPartIndex - e.lastPartIndex;
                this.updated = this.endSN !== e.endSN || !!n || !!t, this.advanced = this.endSN > e.endSN || t > 0 || 0 === t && n > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay
            }

            get hasProgramDateTime() {
                return !!this.fragments.length && lh(this.fragments[this.fragments.length - 1].programDateTime)
            }

            get levelTargetDuration() {
                return this.averagetargetduration || this.targetduration || 10
            }

            get drift() {
                const e = this.driftEndTime - this.driftStartTime;
                return e > 0 ? 1e3 * (this.driftEnd - this.driftStart) / e : 1
            }

            get edge() {
                return this.partEnd || this.fragmentEnd
            }

            get partEnd() {
                var e;
                return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
            }

            get fragmentEnd() {
                var e;
                return null != (e = this.fragments) && e.length ? this.fragments[this.fragments.length - 1].end : 0
            }

            get age() {
                return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
            }

            get lastPartIndex() {
                var e;
                return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].index : -1
            }

            get lastPartSn() {
                var e;
                return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
            }
        }

        function Lh(e) {
            return Uint8Array.from(atob(e), (e => e.charCodeAt(0)))
        }

        function _h(e) {
            return Uint8Array.from(unescape(encodeURIComponent(e)), (e => e.charCodeAt(0)))
        }

        var Ph = {
                CLEARKEY: "org.w3.clearkey",
                FAIRPLAY: "com.apple.fps",
                PLAYREADY: "com.microsoft.playready",
                WIDEVINE: "com.widevine.alpha"
            }, Nh = "org.w3.clearkey", jh = "com.apple.streamingkeydelivery", Ih = "com.microsoft.playready",
            Mh = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";

        function Dh(e) {
            switch (e) {
                case jh:
                    return Ph.FAIRPLAY;
                case Ih:
                    return Ph.PLAYREADY;
                case Mh:
                    return Ph.WIDEVINE;
                case Nh:
                    return Ph.CLEARKEY
            }
        }

        var Oh = "edef8ba979d64acea3c827dcd51d21ed";

        function Bh(e) {
            switch (e) {
                case Ph.FAIRPLAY:
                    return jh;
                case Ph.PLAYREADY:
                    return Ih;
                case Ph.WIDEVINE:
                    return Mh;
                case Ph.CLEARKEY:
                    return Nh
            }
        }

        function Fh(e) {
            const {drmSystems: t, widevineLicenseUrl: n} = e,
                r = t ? [Ph.FAIRPLAY, Ph.WIDEVINE, Ph.PLAYREADY, Ph.CLEARKEY].filter((e => !!t[e])) : [];
            return !r[Ph.WIDEVINE] && n && r.push(Ph.WIDEVINE), r
        }

        const Uh = "undefined" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;

        function Hh(e, t, n) {
            return Uint8Array.prototype.slice ? e.slice(t, n) : new Uint8Array(Array.prototype.slice.call(e, t, n))
        }

        const $h = (e, t) => t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128,
            Kh = (e, t) => t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128,
            zh = (e, t) => {
                const n = t;
                let r = 0;
                for (; $h(e, t);) r += 10, r += Gh(e, t + 6), Kh(e, t + 10) && (r += 10), t += r;
                if (r > 0) return e.subarray(n, n + r)
            }, Gh = (e, t) => {
                let n = 0;
                return n = (127 & e[t]) << 21, n |= (127 & e[t + 1]) << 14, n |= (127 & e[t + 2]) << 7, n |= 127 & e[t + 3], n
            }, qh = (e, t) => $h(e, t) && Gh(e, t + 6) + 10 <= e.length - t,
            Wh = e => e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info, Vh = e => {
                const t = String.fromCharCode(e[0], e[1], e[2], e[3]), n = Gh(e, 4);
                return {type: t, size: n, data: e.subarray(10, 10 + n)}
            }, Yh = e => {
                let t = 0;
                const n = [];
                for (; $h(e, t);) {
                    const r = Gh(e, t + 6);
                    t += 10;
                    const i = t + r;
                    for (; t + 8 < i;) {
                        const r = Vh(e.subarray(t)), i = Zh(r);
                        i && n.push(i), t += r.size + 10
                    }
                    Kh(e, t) && (t += 10)
                }
                return n
            }, Zh = e => "PRIV" === e.type ? Xh(e) : "W" === e.type[0] ? Jh(e) : Qh(e), Xh = e => {
                if (e.size < 2) return;
                const t = tf(e.data, !0), n = new Uint8Array(e.data.subarray(t.length + 1));
                return {key: e.type, info: t, data: n.buffer}
            }, Qh = e => {
                if (e.size < 2) return;
                if ("TXXX" === e.type) {
                    let t = 1;
                    const n = tf(e.data.subarray(t), !0);
                    t += n.length + 1;
                    const r = tf(e.data.subarray(t));
                    return {key: e.type, info: n, data: r}
                }
                const t = tf(e.data.subarray(1));
                return {key: e.type, data: t}
            }, Jh = e => {
                if ("WXXX" === e.type) {
                    if (e.size < 2) return;
                    let t = 1;
                    const n = tf(e.data.subarray(t), !0);
                    t += n.length + 1;
                    const r = tf(e.data.subarray(t));
                    return {key: e.type, info: n, data: r}
                }
                const t = tf(e.data);
                return {key: e.type, data: t}
            }, ef = e => {
                if (8 === e.data.byteLength) {
                    const t = new Uint8Array(e.data), n = 1 & t[3];
                    let r = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];
                    return r /= 45, n && (r += 47721858.84), Math.round(r)
                }
            }, tf = (e, t = !1) => {
                const n = rf();
                if (n) {
                    const r = n.decode(e);
                    if (t) {
                        const e = r.indexOf("\0");
                        return -1 !== e ? r.substring(0, e) : r
                    }
                    return r.replace(/\0/g, "")
                }
                const r = e.length;
                let i, s, a, o = "", l = 0;
                for (; l < r;) {
                    if (i = e[l++], 0 === i && t) return o;
                    if (0 !== i && 3 !== i) switch (i >> 4) {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            o += String.fromCharCode(i);
                            break;
                        case 12:
                        case 13:
                            s = e[l++], o += String.fromCharCode((31 & i) << 6 | 63 & s);
                            break;
                        case 14:
                            s = e[l++], a = e[l++], o += String.fromCharCode((15 & i) << 12 | (63 & s) << 6 | (63 & a) << 0)
                    }
                }
                return o
            };
        let nf;

        function rf() {
            return nf || void 0 === self.TextDecoder || (nf = new self.TextDecoder("utf-8")), nf
        }

        const sf = function (e) {
            let t = "";
            for (let n = 0; n < e.length; n++) {
                let r = e[n].toString(16);
                r.length < 2 && (r = "0" + r), t += r
            }
            return t
        }, af = Math.pow(2, 32) - 1, of = [].push, lf = {video: 1, audio: 2, id3: 3, text: 4};

        function cf(e) {
            return String.fromCharCode.apply(null, e)
        }

        function uf(e, t) {
            const n = e[t] << 8 | e[t + 1];
            return n < 0 ? 65536 + n : n
        }

        function df(e, t) {
            const n = hf(e, t);
            return n < 0 ? 4294967296 + n : n
        }

        function hf(e, t) {
            return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
        }

        function ff(e, t, n) {
            e[t] = n >> 24, e[t + 1] = n >> 16 & 255, e[t + 2] = n >> 8 & 255, e[t + 3] = 255 & n
        }

        function pf(e, t) {
            const n = [];
            if (!t.length) return n;
            const r = e.byteLength;
            for (let i = 0; i < r;) {
                const s = df(e, i), a = s > 1 ? i + s : r;
                if (cf(e.subarray(i + 4, i + 8)) === t[0]) if (1 === t.length) n.push(e.subarray(i + 8, a)); else {
                    const r = pf(e.subarray(i + 8, a), t.slice(1));
                    r.length && of.apply(n, r)
                }
                i = a
            }
            return n
        }

        function mf(e) {
            const t = [], n = e[0];
            let r = 8;
            const i = df(e, r);
            r += 4, r += 0 === n ? 8 : 16, r += 2;
            let s = e.length + 0;
            const a = uf(e, r);
            r += 2;
            for (let n = 0; n < a; n++) {
                let n = r;
                const a = df(e, n);
                n += 4;
                const o = 2147483647 & a;
                if (1 == (2147483648 & a) >>> 31) return mh.warn("SIDX has hierarchical references (not supported)"), null;
                const l = df(e, n);
                n += 4, t.push({
                    referenceSize: o,
                    subsegmentDuration: l,
                    info: {duration: l / i, start: s, end: s + o - 1}
                }), s += o, n += 4, r = n
            }
            return {earliestPresentationTime: 0, timescale: i, version: n, referencesCount: a, references: t}
        }

        function gf(e) {
            const t = [], n = pf(e, ["moov", "trak"]);
            for (let e = 0; e < n.length; e++) {
                const r = n[e], i = pf(r, ["tkhd"])[0];
                if (i) {
                    let e = i[0], n = 0 === e ? 12 : 20;
                    const s = df(i, n), a = pf(r, ["mdia", "mdhd"])[0];
                    if (a) {
                        e = a[0], n = 0 === e ? 12 : 20;
                        const i = df(a, n), o = pf(r, ["mdia", "hdlr"])[0];
                        if (o) {
                            const e = cf(o.subarray(8, 12)), n = {soun: Eh, vide: Sh}[e];
                            if (n) {
                                const e = pf(r, ["mdia", "minf", "stbl", "stsd"])[0];
                                let a;
                                e && (a = cf(e.subarray(12, 16))), t[s] = {timescale: i, type: n}, t[n] = {
                                    timescale: i,
                                    id: s,
                                    codec: a
                                }
                            }
                        }
                    }
                }
            }
            return pf(e, ["moov", "mvex", "trex"]).forEach((e => {
                const n = df(e, 4), r = t[n];
                r && (r.default = {duration: df(e, 12), flags: df(e, 20)})
            })), t
        }

        function yf(e) {
            const t = pf(e, ["schm"])[0];
            if (t) {
                const n = cf(t.subarray(4, 8));
                if ("cbcs" === n || "cenc" === n) return pf(e, ["schi", "tenc"])[0]
            }
            return mh.error("[eme] missing 'schm' box"), null
        }

        function vf(e) {
            const t = df(e, 0);
            let n = 8;
            1 & t && (n += 4), 4 & t && (n += 4);
            let r = 0;
            const i = df(e, 4);
            for (let s = 0; s < i; s++) 256 & t && (r += df(e, n), n += 4), 512 & t && (n += 4), 1024 & t && (n += 4), 2048 & t && (n += 4);
            return r
        }

        function bf(e, t) {
            const n = new Uint8Array(e.length + t.length);
            return n.set(e), n.set(t, e.length), n
        }

        function wf(e, t) {
            const n = [], r = t.samples, i = t.timescale, s = t.id;
            let a = !1;
            return pf(r, ["moof"]).map((o => {
                const l = o.byteOffset - 8;
                pf(o, ["traf"]).map((o => {
                    const c = pf(o, ["tfdt"]).map((e => {
                        const t = e[0];
                        let n = df(e, 4);
                        return 1 === t && (n *= Math.pow(2, 32), n += df(e, 8)), n / i
                    }))[0];
                    return void 0 !== c && (e = c), pf(o, ["tfhd"]).map((c => {
                        const u = df(c, 4), d = 16777215 & df(c, 0);
                        let h = 0;
                        const f = 0 != (16 & d);
                        let p = 0;
                        const m = 0 != (32 & d);
                        let g = 8;
                        u === s && (0 != (1 & d) && (g += 8), 0 != (2 & d) && (g += 4), 0 != (8 & d) && (h = df(c, g), g += 4), f && (p = df(c, g), g += 4), m && (g += 4), "video" === t.type && (a = function (e) {
                            if (!e) return !1;
                            const t = e.indexOf("."), n = t < 0 ? e : e.substring(0, t);
                            return "hvc1" === n || "hev1" === n || "dvh1" === n || "dvhe" === n
                        }(t.codec)), pf(o, ["trun"]).map((s => {
                            const o = s[0], c = 16777215 & df(s, 0), u = 0 != (1 & c);
                            let d = 0;
                            const f = 0 != (4 & c), m = 0 != (256 & c);
                            let g = 0;
                            const y = 0 != (512 & c);
                            let v = 0;
                            const b = 0 != (1024 & c), w = 0 != (2048 & c);
                            let x = 0;
                            const E = df(s, 4);
                            let S = 8;
                            u && (d = df(s, S), S += 4), f && (S += 4);
                            let k = d + l;
                            for (let l = 0; l < E; l++) {
                                if (m ? (g = df(s, S), S += 4) : g = h, y ? (v = df(s, S), S += 4) : v = p, b && (S += 4), w && (x = 0 === o ? df(s, S) : hf(s, S), S += 4), t.type === Sh) {
                                    let t = 0;
                                    for (; t < v;) {
                                        const s = df(r, k);
                                        k += 4, xf(a, r[k]) && Ef(r.subarray(k, k + s), a ? 2 : 1, e + x / i, n), k += s, t += s + 4
                                    }
                                }
                                e += g / i
                            }
                        })))
                    }))
                }))
            })), n
        }

        function xf(e, t) {
            if (e) {
                const e = t >> 1 & 63;
                return 39 === e || 40 === e
            }
            return 6 == (31 & t)
        }

        function Ef(e, t, n, r) {
            const i = Sf(e);
            let s = 0;
            s += t;
            let a = 0, o = 0, l = !1, c = 0;
            for (; s < i.length;) {
                a = 0;
                do {
                    if (s >= i.length) break;
                    c = i[s++], a += c
                } while (255 === c);
                o = 0;
                do {
                    if (s >= i.length) break;
                    c = i[s++], o += c
                } while (255 === c);
                const e = i.length - s;
                if (!l && 4 === a && s < i.length) {
                    if (l = !0, 181 === i[s++]) {
                        const e = uf(i, s);
                        if (s += 2, 49 === e) {
                            const e = df(i, s);
                            if (s += 4, 1195456820 === e) {
                                const e = i[s++];
                                if (3 === e) {
                                    const t = i[s++], o = 64 & t, l = o ? 2 + 3 * (31 & t) : 0, c = new Uint8Array(l);
                                    if (o) {
                                        c[0] = t;
                                        for (let e = 1; e < l; e++) c[e] = i[s++]
                                    }
                                    r.push({type: e, payloadType: a, pts: n, bytes: c})
                                }
                            }
                        }
                    }
                } else if (5 === a && o < e) {
                    if (l = !0, o > 16) {
                        const e = [];
                        for (let t = 0; t < 16; t++) {
                            const n = i[s++].toString(16);
                            e.push(1 == n.length ? "0" + n : n), 3 !== t && 5 !== t && 7 !== t && 9 !== t || e.push("-")
                        }
                        const t = o - 16, l = new Uint8Array(t);
                        for (let e = 0; e < t; e++) l[e] = i[s++];
                        r.push({payloadType: a, pts: n, uuid: e.join(""), userData: tf(l), userDataBytes: l})
                    }
                } else if (o < e) s += o; else if (o > e) break
            }
        }

        function Sf(e) {
            const t = e.byteLength, n = [];
            let r = 1;
            for (; r < t - 2;) 0 === e[r] && 0 === e[r + 1] && 3 === e[r + 2] ? (n.push(r + 2), r += 2) : r++;
            if (0 === n.length) return e;
            const i = t - n.length, s = new Uint8Array(i);
            let a = 0;
            for (r = 0; r < i; a++, r++) a === n[0] && (a++, n.shift()), s[r] = e[a];
            return s
        }

        let kf = {};

        class Af {
            static clearKeyUriToKeyIdMap() {
                kf = {}
            }

            constructor(e, t, n, r = [1], i = null) {
                this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = n, this.keyFormatVersions = r, this.iv = i, this.encrypted = !!e && "NONE" !== e, this.isCommonEncryption = this.encrypted && "AES-128" !== e
            }

            isSupported() {
                if (this.method) {
                    if ("AES-128" === this.method || "NONE" === this.method) return !0;
                    if ("identity" === this.keyFormat) return "SAMPLE-AES" === this.method;
                    switch (this.keyFormat) {
                        case jh:
                        case Mh:
                        case Ih:
                        case Nh:
                            return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method)
                    }
                }
                return !1
            }

            getDecryptData(e) {
                if (!this.encrypted || !this.uri) return null;
                if ("AES-128" === this.method && this.uri && !this.iv) {
                    "number" != typeof e && ("AES-128" !== this.method || this.iv || mh.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0);
                    const t = function (e) {
                        const t = new Uint8Array(16);
                        for (let n = 12; n < 16; n++) t[n] = e >> 8 * (15 - n) & 255;
                        return t
                    }(e);
                    return new Af(this.method, this.uri, "identity", this.keyFormatVersions, t)
                }
                const t = function (e) {
                    const t = e.split(":");
                    let n = null;
                    if ("data" === t[0] && 2 === t.length) {
                        const e = t[1].split(";"), r = e[e.length - 1].split(",");
                        if (2 === r.length) {
                            const t = "base64" === r[0], i = r[1];
                            t ? (e.splice(-1, 1), n = Lh(i)) : n = function (e) {
                                const t = _h(e).subarray(0, 16), n = new Uint8Array(16);
                                return n.set(t, 16 - t.length), n
                            }(i)
                        }
                    }
                    return n
                }(this.uri);
                if (t) switch (this.keyFormat) {
                    case Mh:
                        this.pssh = t, t.length >= 22 && (this.keyId = t.subarray(t.length - 22, t.length - 6));
                        break;
                    case Ih: {
                        const e = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
                        this.pssh = function (e, t, n) {
                            if (16 !== e.byteLength) throw new RangeError("Invalid system id");
                            let r, i, s;
                            if (t) {
                                r = 1, i = new Uint8Array(16 * t.length);
                                for (let e = 0; e < t.length; e++) {
                                    const n = t[e];
                                    if (16 !== n.byteLength) throw new RangeError("Invalid key");
                                    i.set(n, 16 * e)
                                }
                            } else r = 0, i = new Uint8Array;
                            r > 0 ? (s = new Uint8Array(4), t.length > 0 && new DataView(s.buffer).setUint32(0, t.length, !1)) : s = new Uint8Array;
                            const a = new Uint8Array(4);
                            return n && n.byteLength > 0 && new DataView(a.buffer).setUint32(0, n.byteLength, !1), function (e, ...t) {
                                const n = t.length;
                                let r = 8, i = n;
                                for (; i--;) r += t[i].byteLength;
                                const s = new Uint8Array(r);
                                for (s[0] = r >> 24 & 255, s[1] = r >> 16 & 255, s[2] = r >> 8 & 255, s[3] = 255 & r, s.set(e, 4), i = 0, r = 8; i < n; i++) s.set(t[i], r), r += t[i].byteLength;
                                return s
                            }([112, 115, 115, 104], new Uint8Array([r, 0, 0, 0]), e, s, i, a, n || new Uint8Array)
                        }(e, null, t);
                        const n = new Uint16Array(t.buffer, t.byteOffset, t.byteLength / 2),
                            r = String.fromCharCode.apply(null, Array.from(n)),
                            i = r.substring(r.indexOf("<"), r.length),
                            s = (new DOMParser).parseFromString(i, "text/xml").getElementsByTagName("KID")[0];
                        if (s) {
                            const e = s.childNodes[0] ? s.childNodes[0].nodeValue : s.getAttribute("VALUE");
                            if (e) {
                                const t = Lh(e).subarray(0, 16);
                                !function (e) {
                                    const t = function (e, t, n) {
                                        const r = e[t];
                                        e[t] = e[n], e[n] = r
                                    };
                                    t(e, 0, 3), t(e, 1, 2), t(e, 4, 5), t(e, 6, 7)
                                }(t), this.keyId = t
                            }
                        }
                        break
                    }
                    default: {
                        let e = t.subarray(0, 16);
                        if (16 !== e.length) {
                            const t = new Uint8Array(16);
                            t.set(e, 16 - e.length), e = t
                        }
                        this.keyId = e;
                        break
                    }
                }
                if (!this.keyId || 16 !== this.keyId.byteLength) {
                    let e = kf[this.uri];
                    if (!e) {
                        const t = Object.keys(kf).length % Number.MAX_SAFE_INTEGER;
                        e = new Uint8Array(16), new DataView(e.buffer, 12, 4).setUint32(0, t), kf[this.uri] = e
                    }
                    this.keyId = e
                }
                return this
            }
        }

        const Tf = /\{\$([a-zA-Z0-9-_]+)\}/g;

        function Cf(e) {
            return Tf.test(e)
        }

        function Rf(e, t, n) {
            if (null !== e.variableList || e.hasVariableRefs) for (let r = n.length; r--;) {
                const i = n[r], s = t[i];
                s && (t[i] = Lf(e, s))
            }
        }

        function Lf(e, t) {
            if (null !== e.variableList || e.hasVariableRefs) {
                const n = e.variableList;
                return t.replace(Tf, (t => {
                    const r = t.substring(2, t.length - 1), i = null == n ? void 0 : n[r];
                    return void 0 === i ? (e.playlistParsingError || (e.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${r}"`)), t) : i
                }))
            }
            return t
        }

        function _f(e, t, n) {
            let r, i, s = e.variableList;
            if (s || (e.variableList = s = {}), "QUERYPARAM" in t) {
                r = t.QUERYPARAM;
                try {
                    const e = new self.URL(n).searchParams;
                    if (!e.has(r)) throw new Error(`"${r}" does not match any query parameter in URI: "${n}"`);
                    i = e.get(r)
                } catch (t) {
                    e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${t.message}`))
                }
            } else r = t.NAME, i = t.VALUE;
            r in s ? e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${r}"`)) : s[r] = i || ""
        }

        function Pf(e, t, n) {
            const r = t.IMPORT;
            if (n && r in n) {
                let t = e.variableList;
                t || (e.variableList = t = {}), t[r] = n[r]
            } else e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`))
        }

        function Nf() {
            if ("undefined" != typeof self) return self.MediaSource || self.WebKitMediaSource
        }

        const jf = {
            audio: {
                a3ds: !0,
                "ac-3": !0,
                "ac-4": !0,
                alac: !0,
                alaw: !0,
                dra1: !0,
                "dts+": !0,
                "dts-": !0,
                dtsc: !0,
                dtse: !0,
                dtsh: !0,
                "ec-3": !0,
                enca: !0,
                g719: !0,
                g726: !0,
                m4ae: !0,
                mha1: !0,
                mha2: !0,
                mhm1: !0,
                mhm2: !0,
                mlpa: !0,
                mp4a: !0,
                "raw ": !0,
                Opus: !0,
                opus: !0,
                samr: !0,
                sawb: !0,
                sawp: !0,
                sevc: !0,
                sqcp: !0,
                ssmv: !0,
                twos: !0,
                ulaw: !0
            },
            video: {
                avc1: !0,
                avc2: !0,
                avc3: !0,
                avc4: !0,
                avcp: !0,
                av01: !0,
                drac: !0,
                dva1: !0,
                dvav: !0,
                dvh1: !0,
                dvhe: !0,
                encv: !0,
                hev1: !0,
                hvc1: !0,
                mjp2: !0,
                mp4v: !0,
                mvc1: !0,
                mvc2: !0,
                mvc3: !0,
                mvc4: !0,
                resv: !0,
                rv60: !0,
                s263: !0,
                svc1: !0,
                svc2: !0,
                "vc-1": !0,
                vp08: !0,
                vp09: !0
            },
            text: {stpp: !0, wvtt: !0}
        }, If = Nf();

        function Mf(e, t) {
            var n;
            return null != (n = null == If ? void 0 : If.isTypeSupported(`${t || "video"}/mp4;codecs="${e}"`)) && n
        }

        const Df = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g,
            Of = /#EXT-X-MEDIA:(.*)/g, Bf = /^#EXT(?:INF|-X-TARGETDURATION):/m,
            Ff = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"),
            Uf = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));

        class Hf {
            static findGroup(e, t) {
                for (let n = 0; n < e.length; n++) {
                    const r = e[n];
                    if (r.id === t) return r
                }
            }

            static convertAVC1ToAVCOTI(e) {
                const t = e.split(".");
                if (t.length > 2) {
                    let e = t.shift() + ".";
                    return e += parseInt(t.shift()).toString(16), e += ("000" + parseInt(t.shift()).toString(16)).slice(-4), e
                }
                return e
            }

            static resolve(e, t) {
                return rh.buildAbsoluteURL(t, e, {alwaysNormalize: !0})
            }

            static isMediaPlaylist(e) {
                return Bf.test(e)
            }

            static parseMasterPlaylist(e, t) {
                const n = {
                    contentSteering: null,
                    levels: [],
                    playlistParsingError: null,
                    sessionData: null,
                    sessionKeys: null,
                    startTimeOffset: null,
                    variableList: null,
                    hasVariableRefs: Cf(e)
                }, r = [];
                let i;
                for (Df.lastIndex = 0; null != (i = Df.exec(e));) if (i[1]) {
                    var s;
                    const e = new vh(i[1]);
                    Rf(n, e, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
                    const a = Lf(n, i[2]), o = {
                        attrs: e,
                        bitrate: e.decimalInteger("AVERAGE-BANDWIDTH") || e.decimalInteger("BANDWIDTH"),
                        name: e.NAME,
                        url: Hf.resolve(a, t)
                    }, l = e.decimalResolution("RESOLUTION");
                    l && (o.width = l.width, o.height = l.height), zf((e.CODECS || "").split(/[ ,]+/).filter((e => e)), o), o.videoCodec && -1 !== o.videoCodec.indexOf("avc1") && (o.videoCodec = Hf.convertAVC1ToAVCOTI(o.videoCodec)), null != (s = o.unknownCodecs) && s.length || r.push(o), n.levels.push(o)
                } else if (i[3]) {
                    const e = i[3], r = i[4];
                    switch (e) {
                        case"SESSION-DATA": {
                            const e = new vh(r);
                            Rf(n, e, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
                            const t = e["DATA-ID"];
                            t && (null === n.sessionData && (n.sessionData = {}), n.sessionData[t] = e);
                            break
                        }
                        case"SESSION-KEY": {
                            const e = $f(r, t, n);
                            e.encrypted && e.isSupported() ? (null === n.sessionKeys && (n.sessionKeys = []), n.sessionKeys.push(e)) : mh.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${r}"`);
                            break
                        }
                        case"DEFINE": {
                            const e = new vh(r);
                            Rf(n, e, ["NAME", "VALUE", "QUERYPARAM"]), _f(n, e, t)
                        }
                            break;
                        case"CONTENT-STEERING": {
                            const e = new vh(r);
                            Rf(n, e, ["SERVER-URI", "PATHWAY-ID"]), n.contentSteering = {
                                uri: Hf.resolve(e["SERVER-URI"], t),
                                pathwayId: e["PATHWAY-ID"] || "."
                            };
                            break
                        }
                        case"START":
                            n.startTimeOffset = Kf(r)
                    }
                }
                const a = r.length > 0 && r.length < n.levels.length;
                return n.levels = a ? r : n.levels, 0 === n.levels.length && (n.playlistParsingError = new Error("no levels found in manifest")), n
            }

            static parseMasterPlaylistMedia(e, t, n) {
                let r;
                const i = {}, s = n.levels, a = {
                    AUDIO: s.map((e => ({id: e.attrs.AUDIO, audioCodec: e.audioCodec}))),
                    SUBTITLES: s.map((e => ({id: e.attrs.SUBTITLES, textCodec: e.textCodec}))),
                    "CLOSED-CAPTIONS": []
                };
                let o = 0;
                for (Of.lastIndex = 0; null !== (r = Of.exec(e));) {
                    const e = new vh(r[1]), s = e.TYPE;
                    if (s) {
                        const r = a[s], l = i[s] || [];
                        i[s] = l, Rf(n, e, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
                        const c = {
                            attrs: e,
                            bitrate: 0,
                            id: o++,
                            groupId: e["GROUP-ID"] || "",
                            instreamId: e["INSTREAM-ID"],
                            name: e.NAME || e.LANGUAGE || "",
                            type: s,
                            default: e.bool("DEFAULT"),
                            autoselect: e.bool("AUTOSELECT"),
                            forced: e.bool("FORCED"),
                            lang: e.LANGUAGE,
                            url: e.URI ? Hf.resolve(e.URI, t) : ""
                        };
                        if (null != r && r.length) {
                            const e = Hf.findGroup(r, c.groupId) || r[0];
                            Gf(c, e, "audioCodec"), Gf(c, e, "textCodec")
                        }
                        l.push(c)
                    }
                }
                return i
            }

            static parseLevelPlaylist(e, t, n, r, i, s) {
                const a = new Rh(t), o = a.fragments;
                let l, c, u, d = null, h = 0, f = 0, p = 0, m = 0, g = null, y = new Th(r, t), v = -1, b = !1;
                for (Ff.lastIndex = 0, a.m3u8 = e, a.hasVariableRefs = Cf(e); null !== (l = Ff.exec(e));) {
                    b && (b = !1, y = new Th(r, t), y.start = p, y.sn = h, y.cc = m, y.level = n, d && (y.initSegment = d, y.rawProgramDateTime = d.rawProgramDateTime, d.rawProgramDateTime = null));
                    const e = l[1];
                    if (e) {
                        y.duration = parseFloat(e);
                        const t = (" " + l[2]).slice(1);
                        y.title = t || null, y.tagList.push(t ? ["INF", e, t] : ["INF", e])
                    } else if (l[3]) {
                        if (lh(y.duration)) {
                            y.start = p, u && Vf(y, u, a), y.sn = h, y.level = n, y.cc = m, y.urlId = i, o.push(y);
                            const e = (" " + l[3]).slice(1);
                            y.relurl = Lf(a, e), qf(y, g), g = y, p += y.duration, h++, f = 0, b = !0
                        }
                    } else if (l[4]) {
                        const e = (" " + l[4]).slice(1);
                        g ? y.setByteRange(e, g) : y.setByteRange(e)
                    } else if (l[5]) y.rawProgramDateTime = (" " + l[5]).slice(1), y.tagList.push(["PROGRAM-DATE-TIME", y.rawProgramDateTime]), -1 === v && (v = o.length); else {
                        if (l = l[0].match(Uf), !l) {
                            mh.warn("No matches on slow regex match for level playlist!");
                            continue
                        }
                        for (c = 1; c < l.length && void 0 === l[c]; c++) ;
                        const e = (" " + l[c]).slice(1), i = (" " + l[c + 1]).slice(1),
                            p = l[c + 2] ? (" " + l[c + 2]).slice(1) : "";
                        switch (e) {
                            case"PLAYLIST-TYPE":
                                a.type = i.toUpperCase();
                                break;
                            case"MEDIA-SEQUENCE":
                                h = a.startSN = parseInt(i);
                                break;
                            case"SKIP": {
                                const e = new vh(i);
                                Rf(a, e, ["RECENTLY-REMOVED-DATERANGES"]);
                                const t = e.decimalInteger("SKIPPED-SEGMENTS");
                                if (lh(t)) {
                                    a.skippedSegments = t;
                                    for (let e = t; e--;) o.unshift(null);
                                    h += t
                                }
                                const n = e.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                                n && (a.recentlyRemovedDateranges = n.split("\t"));
                                break
                            }
                            case"TARGETDURATION":
                                a.targetduration = Math.max(parseInt(i), 1);
                                break;
                            case"VERSION":
                                a.version = parseInt(i);
                                break;
                            case"EXTM3U":
                                break;
                            case"ENDLIST":
                                a.live = !1;
                                break;
                            case"#":
                                (i || p) && y.tagList.push(p ? [i, p] : [i]);
                                break;
                            case"DISCONTINUITY":
                                m++, y.tagList.push(["DIS"]);
                                break;
                            case"GAP":
                                y.gap = !0, y.tagList.push([e]);
                                break;
                            case"BITRATE":
                                y.tagList.push([e, i]);
                                break;
                            case"DATERANGE": {
                                const e = new vh(i);
                                Rf(a, e, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]), Rf(a, e, e.clientAttrs);
                                const t = new wh(e, a.dateRanges[e.ID]);
                                t.isValid || a.skippedSegments ? a.dateRanges[t.id] = t : mh.warn(`Ignoring invalid DATERANGE tag: "${i}"`), y.tagList.push(["EXT-X-DATERANGE", i]);
                                break
                            }
                            case"DEFINE": {
                                const e = new vh(i);
                                Rf(a, e, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]), "IMPORT" in e ? Pf(a, e, s) : _f(a, e, t)
                            }
                                break;
                            case"DISCONTINUITY-SEQUENCE":
                                m = parseInt(i);
                                break;
                            case"KEY": {
                                const e = $f(i, t, a);
                                if (e.isSupported()) {
                                    if ("NONE" === e.method) {
                                        u = void 0;
                                        break
                                    }
                                    u || (u = {}), u[e.keyFormat] && (u = oh({}, u)), u[e.keyFormat] = e
                                } else mh.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${i}"`);
                                break
                            }
                            case"START":
                                a.startTimeOffset = Kf(i);
                                break;
                            case"MAP": {
                                const e = new vh(i);
                                if (Rf(a, e, ["BYTERANGE", "URI"]), y.duration) {
                                    const i = new Th(r, t);
                                    Wf(i, e, n, u), d = i, y.initSegment = d, d.rawProgramDateTime && !y.rawProgramDateTime && (y.rawProgramDateTime = d.rawProgramDateTime)
                                } else Wf(y, e, n, u), d = y, b = !0;
                                break
                            }
                            case"SERVER-CONTROL": {
                                const e = new vh(i);
                                a.canBlockReload = e.bool("CAN-BLOCK-RELOAD"), a.canSkipUntil = e.optionalFloat("CAN-SKIP-UNTIL", 0), a.canSkipDateRanges = a.canSkipUntil > 0 && e.bool("CAN-SKIP-DATERANGES"), a.partHoldBack = e.optionalFloat("PART-HOLD-BACK", 0), a.holdBack = e.optionalFloat("HOLD-BACK", 0);
                                break
                            }
                            case"PART-INF": {
                                const e = new vh(i);
                                a.partTarget = e.decimalFloatingPoint("PART-TARGET");
                                break
                            }
                            case"PART": {
                                let e = a.partList;
                                e || (e = a.partList = []);
                                const n = f > 0 ? e[e.length - 1] : void 0, r = f++, s = new vh(i);
                                Rf(a, s, ["BYTERANGE", "URI"]);
                                const o = new Ch(s, y, t, r, n);
                                e.push(o), y.duration += o.duration;
                                break
                            }
                            case"PRELOAD-HINT": {
                                const e = new vh(i);
                                Rf(a, e, ["URI"]), a.preloadHint = e;
                                break
                            }
                            case"RENDITION-REPORT": {
                                const e = new vh(i);
                                Rf(a, e, ["URI"]), a.renditionReports = a.renditionReports || [], a.renditionReports.push(e);
                                break
                            }
                            default:
                                mh.warn(`line parsed but not handled: ${l}`)
                        }
                    }
                }
                g && !g.relurl ? (o.pop(), p -= g.duration, a.partList && (a.fragmentHint = g)) : a.partList && (qf(y, g), y.cc = m, a.fragmentHint = y, u && Vf(y, u, a));
                const w = o.length, x = o[0], E = o[w - 1];
                if (p += a.skippedSegments * a.targetduration, p > 0 && w && E) {
                    a.averagetargetduration = p / w;
                    const e = E.sn;
                    a.endSN = "initSegment" !== e ? e : 0, a.live || (E.endList = !0), x && (a.startCC = x.cc)
                } else a.endSN = 0, a.startCC = 0;
                return a.fragmentHint && (p += a.fragmentHint.duration), a.totalduration = p, a.endCC = m, v > 0 && function (e, t) {
                    let n = e[t];
                    for (let r = t; r--;) {
                        const t = e[r];
                        if (!t) return;
                        t.programDateTime = n.programDateTime - 1e3 * t.duration, n = t
                    }
                }(o, v), a
            }
        }

        function $f(e, t, n) {
            var r, i;
            const s = new vh(e);
            Rf(n, s, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
            const a = null != (r = s.METHOD) ? r : "", o = s.URI, l = s.hexadecimalInteger("IV"),
                c = s.KEYFORMATVERSIONS, u = null != (i = s.KEYFORMAT) ? i : "identity";
            o && s.IV && !l && mh.error(`Invalid IV: ${s.IV}`);
            const d = o ? Hf.resolve(o, t) : "", h = (c || "1").split("/").map(Number).filter(Number.isFinite);
            return new Af(a, d, u, h, l)
        }

        function Kf(e) {
            const t = new vh(e).decimalFloatingPoint("TIME-OFFSET");
            return lh(t) ? t : null
        }

        function zf(e, t) {
            ["video", "audio", "text"].forEach((n => {
                const r = e.filter((e => function (e, t) {
                    const n = jf[t];
                    return !!n && !0 === n[e.slice(0, 4)]
                }(e, n)));
                if (r.length) {
                    const i = r.filter((e => 0 === e.lastIndexOf("avc1", 0) || 0 === e.lastIndexOf("mp4a", 0)));
                    t[`${n}Codec`] = i.length > 0 ? i[0] : r[0], e = e.filter((e => -1 === r.indexOf(e)))
                }
            })), t.unknownCodecs = e
        }

        function Gf(e, t, n) {
            const r = t[n];
            r && (e[n] = r)
        }

        function qf(e, t) {
            e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), lh(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null)
        }

        function Wf(e, t, n, r) {
            e.relurl = t.URI, t.BYTERANGE && e.setByteRange(t.BYTERANGE), e.level = n, e.sn = "initSegment", r && (e.levelkeys = r), e.initSegment = null
        }

        function Vf(e, t, n) {
            e.levelkeys = t;
            const {encryptedFragments: r} = n;
            r.length && r[r.length - 1].levelkeys === t || !Object.keys(t).some((e => t[e].isCommonEncryption)) || r.push(e)
        }

        var Yf = "manifest", Zf = "level", Xf = "audioTrack", Qf = "subtitleTrack", Jf = "main", ep = "audio",
            tp = "subtitle";

        function np(e) {
            const {type: t} = e;
            switch (t) {
                case Xf:
                    return ep;
                case Qf:
                    return tp;
                default:
                    return Jf
            }
        }

        function rp(e, t) {
            let n = e.url;
            return void 0 !== n && 0 !== n.indexOf("data:") || (n = t.url), n
        }

        class ip {
            constructor(e) {
                this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.hls = e, this.registerListeners()
            }

            startLoad(e) {
            }

            stopLoad() {
                this.destroyInternalLoaders()
            }

            registerListeners() {
                const {hls: e} = this;
                e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.LEVEL_LOADING, this.onLevelLoading, this), e.on(ch.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(ch.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
            }

            unregisterListeners() {
                const {hls: e} = this;
                e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.LEVEL_LOADING, this.onLevelLoading, this), e.off(ch.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(ch.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
            }

            createInternalLoader(e) {
                const t = this.hls.config, n = t.pLoader, r = t.loader, i = new (n || r)(t);
                return this.loaders[e.type] = i, i
            }

            getInternalLoader(e) {
                return this.loaders[e.type]
            }

            resetInternalLoader(e) {
                this.loaders[e] && delete this.loaders[e]
            }

            destroyInternalLoaders() {
                for (const e in this.loaders) {
                    const t = this.loaders[e];
                    t && t.destroy(), this.resetInternalLoader(e)
                }
            }

            destroy() {
                this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders()
            }

            onManifestLoading(e, t) {
                const {url: n} = t;
                this.variableList = null, this.load({
                    id: null,
                    level: 0,
                    responseType: "text",
                    type: Yf,
                    url: n,
                    deliveryDirectives: null
                })
            }

            onLevelLoading(e, t) {
                const {id: n, level: r, url: i, deliveryDirectives: s} = t;
                this.load({id: n, level: r, responseType: "text", type: Zf, url: i, deliveryDirectives: s})
            }

            onAudioTrackLoading(e, t) {
                const {id: n, groupId: r, url: i, deliveryDirectives: s} = t;
                this.load({
                    id: n,
                    groupId: r,
                    level: null,
                    responseType: "text",
                    type: Xf,
                    url: i,
                    deliveryDirectives: s
                })
            }

            onSubtitleTrackLoading(e, t) {
                const {id: n, groupId: r, url: i, deliveryDirectives: s} = t;
                this.load({
                    id: n,
                    groupId: r,
                    level: null,
                    responseType: "text",
                    type: Qf,
                    url: i,
                    deliveryDirectives: s
                })
            }

            load(e) {
                var t;
                const n = this.hls.config;
                let r, i = this.getInternalLoader(e);
                if (i) {
                    const t = i.context;
                    if (t && t.url === e.url) return void mh.trace("[playlist-loader]: playlist request ongoing");
                    mh.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), i.abort()
                }
                if (r = e.type === Yf ? n.manifestLoadPolicy.default : oh({}, n.playlistLoadPolicy.default, {
                    timeoutRetry: null,
                    errorRetry: null
                }), i = this.createInternalLoader(e), null != (t = e.deliveryDirectives) && t.part) {
                    let t;
                    if (e.type === Zf && null !== e.level ? t = this.hls.levels[e.level].details : e.type === Xf && null !== e.id ? t = this.hls.audioTracks[e.id].details : e.type === Qf && null !== e.id && (t = this.hls.subtitleTracks[e.id].details), t) {
                        const e = t.partTarget, n = t.targetduration;
                        if (e && n) {
                            const t = 1e3 * Math.max(3 * e, .8 * n);
                            r = oh({}, r, {
                                maxTimeToFirstByteMs: Math.min(t, r.maxTimeToFirstByteMs),
                                maxLoadTimeMs: Math.min(t, r.maxTimeToFirstByteMs)
                            })
                        }
                    }
                }
                const s = r.errorRetry || r.timeoutRetry || {}, a = {
                    loadPolicy: r,
                    timeout: r.maxLoadTimeMs,
                    maxRetry: s.maxNumRetry || 0,
                    retryDelay: s.retryDelayMs || 0,
                    maxRetryDelay: s.maxRetryDelayMs || 0
                }, o = {
                    onSuccess: (e, t, n, r) => {
                        const i = this.getInternalLoader(n);
                        this.resetInternalLoader(n.type);
                        const s = e.data;
                        0 === s.indexOf("#EXTM3U") ? (t.parsing.start = performance.now(), Hf.isMediaPlaylist(s) ? this.handleTrackOrLevelPlaylist(e, t, n, r || null, i) : this.handleMasterPlaylist(e, t, n, r)) : this.handleManifestParsingError(e, n, new Error("no EXTM3U delimiter"), r || null, t)
                    }, onError: (e, t, n, r) => {
                        this.handleNetworkError(t, n, !1, e, r)
                    }, onTimeout: (e, t, n) => {
                        this.handleNetworkError(t, n, !0, void 0, e)
                    }
                };
                i.load(e, a, o)
            }

            handleMasterPlaylist(e, t, n, r) {
                const i = this.hls, s = e.data, a = rp(e, n), o = Hf.parseMasterPlaylist(s, a);
                if (o.playlistParsingError) return void this.handleManifestParsingError(e, n, o.playlistParsingError, r, t);
                const {
                    contentSteering: l,
                    levels: c,
                    sessionData: u,
                    sessionKeys: d,
                    startTimeOffset: h,
                    variableList: f
                } = o;
                this.variableList = f;
                const {AUDIO: p = [], SUBTITLES: m, "CLOSED-CAPTIONS": g} = Hf.parseMasterPlaylistMedia(s, a, o);
                p.length && (p.some((e => !e.url)) || !c[0].audioCodec || c[0].attrs.AUDIO || (mh.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), p.unshift({
                    type: "main",
                    name: "main",
                    groupId: "main",
                    default: !1,
                    autoselect: !1,
                    forced: !1,
                    id: -1,
                    attrs: new vh({}),
                    bitrate: 0,
                    url: ""
                }))), i.trigger(ch.MANIFEST_LOADED, {
                    levels: c,
                    audioTracks: p,
                    subtitles: m,
                    captions: g,
                    contentSteering: l,
                    url: a,
                    stats: t,
                    networkDetails: r,
                    sessionData: u,
                    sessionKeys: d,
                    startTimeOffset: h,
                    variableList: f
                })
            }

            handleTrackOrLevelPlaylist(e, t, n, r, i) {
                const s = this.hls, {id: a, level: o, type: l} = n, c = rp(e, n), u = lh(a) ? a : 0, d = lh(o) ? o : u,
                    h = np(n), f = Hf.parseLevelPlaylist(e.data, c, d, h, u, this.variableList);
                if (l === Yf) {
                    const e = {attrs: new vh({}), bitrate: 0, details: f, name: "", url: c};
                    s.trigger(ch.MANIFEST_LOADED, {
                        levels: [e],
                        audioTracks: [],
                        url: c,
                        stats: t,
                        networkDetails: r,
                        sessionData: null,
                        sessionKeys: null,
                        contentSteering: null,
                        startTimeOffset: null,
                        variableList: null
                    })
                }
                t.parsing.end = performance.now(), n.levelDetails = f, this.handlePlaylistLoaded(f, e, t, n, r, i)
            }

            handleManifestParsingError(e, t, n, r, i) {
                this.hls.trigger(ch.ERROR, {
                    type: uh.NETWORK_ERROR,
                    details: dh.MANIFEST_PARSING_ERROR,
                    fatal: t.type === Yf,
                    url: e.url,
                    err: n,
                    error: n,
                    reason: n.message,
                    response: e,
                    context: t,
                    networkDetails: r,
                    stats: i
                })
            }

            handleNetworkError(e, t, n = !1, r, i) {
                let s = `A network ${n ? "timeout" : "error" + (r ? " (status " + r.code + ")" : "")} occurred while loading ${e.type}`;
                e.type === Zf ? s += `: ${e.level} id: ${e.id}` : e.type !== Xf && e.type !== Qf || (s += ` id: ${e.id} group-id: "${e.groupId}"`);
                const a = new Error(s);
                mh.warn(`[playlist-loader]: ${s}`);
                let o = dh.UNKNOWN, l = !1;
                const c = this.getInternalLoader(e);
                switch (e.type) {
                    case Yf:
                        o = n ? dh.MANIFEST_LOAD_TIMEOUT : dh.MANIFEST_LOAD_ERROR, l = !0;
                        break;
                    case Zf:
                        o = n ? dh.LEVEL_LOAD_TIMEOUT : dh.LEVEL_LOAD_ERROR, l = !1;
                        break;
                    case Xf:
                        o = n ? dh.AUDIO_TRACK_LOAD_TIMEOUT : dh.AUDIO_TRACK_LOAD_ERROR, l = !1;
                        break;
                    case Qf:
                        o = n ? dh.SUBTITLE_TRACK_LOAD_TIMEOUT : dh.SUBTITLE_LOAD_ERROR, l = !1
                }
                c && this.resetInternalLoader(e.type);
                const u = {
                    type: uh.NETWORK_ERROR,
                    details: o,
                    fatal: l,
                    url: e.url,
                    loader: c,
                    context: e,
                    error: a,
                    networkDetails: t,
                    stats: i
                };
                if (r) {
                    const n = (null == t ? void 0 : t.url) || e.url;
                    u.response = sh({url: n, data: void 0}, r)
                }
                this.hls.trigger(ch.ERROR, u)
            }

            handlePlaylistLoaded(e, t, n, r, i, s) {
                const a = this.hls, {type: o, level: l, id: c, groupId: u, deliveryDirectives: d} = r, h = rp(t, r),
                    f = np(r), p = "number" == typeof r.level && f === Jf ? l : void 0;
                if (!e.fragments.length) {
                    const e = new Error("No Segments found in Playlist");
                    return void a.trigger(ch.ERROR, {
                        type: uh.NETWORK_ERROR,
                        details: dh.LEVEL_EMPTY_ERROR,
                        fatal: !1,
                        url: h,
                        error: e,
                        reason: e.message,
                        response: t,
                        context: r,
                        level: p,
                        parent: f,
                        networkDetails: i,
                        stats: n
                    })
                }
                e.targetduration || (e.playlistParsingError = new Error("Missing Target Duration"));
                const m = e.playlistParsingError;
                if (m) a.trigger(ch.ERROR, {
                    type: uh.NETWORK_ERROR,
                    details: dh.LEVEL_PARSING_ERROR,
                    fatal: !1,
                    url: h,
                    error: m,
                    reason: m.message,
                    response: t,
                    context: r,
                    level: p,
                    parent: f,
                    networkDetails: i,
                    stats: n
                }); else switch (e.live && s && (s.getCacheAge && (e.ageHeader = s.getCacheAge() || 0), s.getCacheAge && !isNaN(e.ageHeader) || (e.ageHeader = 0)), o) {
                    case Yf:
                    case Zf:
                        a.trigger(ch.LEVEL_LOADED, {
                            details: e,
                            level: p || 0,
                            id: c || 0,
                            stats: n,
                            networkDetails: i,
                            deliveryDirectives: d
                        });
                        break;
                    case Xf:
                        a.trigger(ch.AUDIO_TRACK_LOADED, {
                            details: e,
                            id: c || 0,
                            groupId: u || "",
                            stats: n,
                            networkDetails: i,
                            deliveryDirectives: d
                        });
                        break;
                    case Qf:
                        a.trigger(ch.SUBTITLE_TRACK_LOADED, {
                            details: e,
                            id: c || 0,
                            groupId: u || "",
                            stats: n,
                            networkDetails: i,
                            deliveryDirectives: d
                        })
                }
            }
        }

        function sp(e, t) {
            let n;
            try {
                n = new Event("addtrack")
            } catch (e) {
                n = document.createEvent("Event"), n.initEvent("addtrack", !1, !1)
            }
            n.track = e, t.dispatchEvent(n)
        }

        function ap(e, t) {
            const n = e.mode;
            if ("disabled" === n && (e.mode = "hidden"), e.cues && !e.cues.getCueById(t.id)) try {
                if (e.addCue(t), !e.cues.getCueById(t.id)) throw new Error(`addCue is failed for: ${t}`)
            } catch (n) {
                mh.debug(`[texttrack-utils]: ${n}`);
                const r = new self.TextTrackCue(t.startTime, t.endTime, t.text);
                r.id = t.id, e.addCue(r)
            }
            "disabled" === n && (e.mode = n)
        }

        function op(e) {
            const t = e.mode;
            if ("disabled" === t && (e.mode = "hidden"), e.cues) for (let t = e.cues.length; t--;) e.removeCue(e.cues[t]);
            "disabled" === t && (e.mode = t)
        }

        function lp(e, t, n, r) {
            const i = e.mode;
            if ("disabled" === i && (e.mode = "hidden"), e.cues && e.cues.length > 0) {
                const i = function (e, t, n) {
                    const r = [], i = function (e, t) {
                        if (t < e[0].startTime) return 0;
                        const n = e.length - 1;
                        if (t > e[n].endTime) return -1;
                        let r = 0, i = n;
                        for (; r <= i;) {
                            const s = Math.floor((i + r) / 2);
                            if (t < e[s].startTime) i = s - 1; else {
                                if (!(t > e[s].startTime && r < n)) return s;
                                r = s + 1
                            }
                        }
                        return e[r].startTime - t < t - e[i].startTime ? r : i
                    }(e, t);
                    if (i > -1) for (let s = i, a = e.length; s < a; s++) {
                        const i = e[s];
                        if (i.startTime >= t && i.endTime <= n) r.push(i); else if (i.startTime > n) return r
                    }
                    return r
                }(e.cues, t, n);
                for (let t = 0; t < i.length; t++) r && !r(i[t]) || e.removeCue(i[t])
            }
            "disabled" === i && (e.mode = i)
        }

        var cp = "org.id3", up = "https://aomedia.org/emsg/ID3";

        function dp() {
            if ("undefined" != typeof self) return self.WebKitDataCue || self.VTTCue || self.TextTrackCue
        }

        const hp = (() => {
            const e = dp();
            try {
                new e(0, Number.POSITIVE_INFINITY, "")
            } catch (e) {
                return Number.MAX_VALUE
            }
            return Number.POSITIVE_INFINITY
        })();

        function fp(e, t) {
            return e.getTime() / 1e3 - t
        }

        class pp {
            constructor(e) {
                this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners()
            }

            destroy() {
                this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null
            }

            _registerListeners() {
                const {hls: e} = this;
                e.on(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(ch.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(ch.LEVEL_UPDATED, this.onLevelUpdated, this)
            }

            _unregisterListeners() {
                const {hls: e} = this;
                e.off(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(ch.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(ch.LEVEL_UPDATED, this.onLevelUpdated, this)
            }

            onMediaAttached(e, t) {
                this.media = t.media
            }

            onMediaDetaching() {
                this.id3Track && (op(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {})
            }

            onManifestLoading() {
                this.dateRangeCuesAppended = {}
            }

            createTrack(e) {
                const t = this.getID3Track(e.textTracks);
                return t.mode = "hidden", t
            }

            getID3Track(e) {
                if (this.media) {
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        if ("metadata" === n.kind && "id3" === n.label) return sp(n, this.media), n
                    }
                    return this.media.addTextTrack("metadata", "id3")
                }
            }

            onFragParsingMetadata(e, t) {
                if (!this.media) return;
                const {hls: {config: {enableEmsgMetadataCues: n, enableID3MetadataCues: r}}} = this;
                if (!n && !r) return;
                const {samples: i} = t;
                this.id3Track || (this.id3Track = this.createTrack(this.media));
                const s = dp();
                for (let e = 0; e < i.length; e++) {
                    const t = i[e].type;
                    if (t === up && !n || !r) continue;
                    const a = Yh(i[e].data);
                    if (a) {
                        const n = i[e].pts;
                        let r = n + i[e].duration;
                        r > hp && (r = hp), r - n <= 0 && (r = n + .25);
                        for (let e = 0; e < a.length; e++) {
                            const i = a[e];
                            if (!Wh(i)) {
                                this.updateId3CueEnds(n, t);
                                const e = new s(n, r, "");
                                e.value = i, t && (e.type = t), this.id3Track.addCue(e)
                            }
                        }
                    }
                }
            }

            updateId3CueEnds(e, t) {
                var n;
                const r = null == (n = this.id3Track) ? void 0 : n.cues;
                if (r) for (let n = r.length; n--;) {
                    const i = r[n];
                    i.type === t && i.startTime < e && i.endTime === hp && (i.endTime = e)
                }
            }

            onBufferFlushing(e, {startOffset: t, endOffset: n, type: r}) {
                const {id3Track: i, hls: s} = this;
                if (!s) return;
                const {config: {enableEmsgMetadataCues: a, enableID3MetadataCues: o}} = s;
                if (i && (a || o)) {
                    let e;
                    e = "audio" === r ? e => e.type === cp && o : "video" === r ? e => e.type === up && a : e => e.type === cp && o || e.type === up && a, lp(i, t, n, e)
                }
            }

            onLevelUpdated(e, {details: t}) {
                if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) return;
                const {dateRangeCuesAppended: n, id3Track: r} = this, {dateRanges: i} = t, s = Object.keys(i);
                if (r) {
                    const e = Object.keys(n).filter((e => !s.includes(e)));
                    for (let t = e.length; t--;) {
                        const i = e[t];
                        Object.keys(n[i].cues).forEach((e => {
                            r.removeCue(n[i].cues[e])
                        })), delete n[i]
                    }
                }
                const a = t.fragments[t.fragments.length - 1];
                if (0 === s.length || !lh(null == a ? void 0 : a.programDateTime)) return;
                this.id3Track || (this.id3Track = this.createTrack(this.media));
                const o = a.programDateTime / 1e3 - a.start, l = dp();
                for (let e = 0; e < s.length; e++) {
                    const t = s[e], r = i[t], a = n[t], d = (null == a ? void 0 : a.cues) || {};
                    let h = (null == a ? void 0 : a.durationKnown) || !1;
                    const f = fp(r.startDate, o);
                    let p = hp;
                    const m = r.endDate;
                    if (m) p = fp(m, o), h = !0; else if (r.endOnNext && !h) {
                        const e = s.reduce(((e, t) => {
                            const n = i[t];
                            return n.class === r.class && n.id !== t && n.startDate > r.startDate && e.push(n), e
                        }), []).sort(((e, t) => e.startDate.getTime() - t.startDate.getTime()))[0];
                        e && (p = fp(e.startDate, o), h = !0)
                    }
                    const g = Object.keys(r.attr);
                    for (let e = 0; e < g.length; e++) {
                        const n = g[e];
                        if ("ID" === (u = n) || "CLASS" === u || "START-DATE" === u || "DURATION" === u || "END-DATE" === u || "END-ON-NEXT" === u) continue;
                        let i = d[n];
                        if (i) h && !a.durationKnown && (i.endTime = p); else {
                            let e = r.attr[n];
                            i = new l(f, p, ""), bh(n) && (c = e, e = Uint8Array.from(c.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer), i.value = {
                                key: n,
                                data: e
                            }, i.type = "com.apple.quicktime.HLS", i.id = t, this.id3Track.addCue(i), d[n] = i
                        }
                    }
                    n[t] = {cues: d, dateRange: r, durationKnown: h}
                }
                var c, u
            }
        }

        class mp {
            constructor(e) {
                this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = () => this.timeupdate(), this.hls = e, this.config = e.config, this.registerListeners()
            }

            get latency() {
                return this._latency || 0
            }

            get maxLatency() {
                const {config: e, levelDetails: t} = this;
                return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0
            }

            get targetLatency() {
                const {levelDetails: e} = this;
                if (null === e) return null;
                const {holdBack: t, partHoldBack: n, targetduration: r} = e, {
                    liveSyncDuration: i,
                    liveSyncDurationCount: s,
                    lowLatencyMode: a
                } = this.config, o = this.hls.userConfig;
                let l = a && n || t;
                (o.liveSyncDuration || o.liveSyncDurationCount || 0 === l) && (l = void 0 !== i ? i : s * r);
                const c = r;
                return l + Math.min(1 * this.stallCount, c)
            }

            get liveSyncPosition() {
                const e = this.estimateLiveEdge(), t = this.targetLatency, n = this.levelDetails;
                if (null === e || null === t || null === n) return null;
                const r = n.edge, i = e - t - this.edgeStalled, s = r - n.totalduration,
                    a = r - (this.config.lowLatencyMode && n.partTarget || n.targetduration);
                return Math.min(Math.max(s, i), a)
            }

            get drift() {
                const {levelDetails: e} = this;
                return null === e ? 1 : e.drift
            }

            get edgeStalled() {
                const {levelDetails: e} = this;
                if (null === e) return 0;
                const t = 3 * (this.config.lowLatencyMode && e.partTarget || e.targetduration);
                return Math.max(e.age - t, 0)
            }

            get forwardBufferLength() {
                const {media: e, levelDetails: t} = this;
                if (!e || !t) return 0;
                const n = e.buffered.length;
                return (n ? e.buffered.end(n - 1) : t.edge) - this.currentTime
            }

            destroy() {
                this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null
            }

            registerListeners() {
                this.hls.on(ch.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(ch.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(ch.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(ch.ERROR, this.onError, this)
            }

            unregisterListeners() {
                this.hls.off(ch.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(ch.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(ch.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off(ch.ERROR, this.onError, this)
            }

            onMediaAttached(e, t) {
                this.media = t.media, this.media.addEventListener("timeupdate", this.timeupdateHandler)
            }

            onMediaDetaching() {
                this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null)
            }

            onManifestLoading() {
                this.levelDetails = null, this._latency = null, this.stallCount = 0
            }

            onLevelUpdated(e, {details: t}) {
                this.levelDetails = t, t.advanced && this.timeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
            }

            onError(e, t) {
                var n;
                t.details === dh.BUFFER_STALLED_ERROR && (this.stallCount++, null != (n = this.levelDetails) && n.live && mh.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
            }

            timeupdate() {
                const {media: e, levelDetails: t} = this;
                if (!e || !t) return;
                this.currentTime = e.currentTime;
                const n = this.computeLatency();
                if (null === n) return;
                this._latency = n;
                const {lowLatencyMode: r, maxLiveSyncPlaybackRate: i} = this.config;
                if (!r || 1 === i) return;
                const s = this.targetLatency;
                if (null === s) return;
                const a = n - s, o = a < Math.min(this.maxLatency, s + t.targetduration);
                if (t.live && o && a > .05 && this.forwardBufferLength > 1) {
                    const t = Math.min(2, Math.max(1, i)),
                        n = Math.round(2 / (1 + Math.exp(-.75 * a - this.edgeStalled)) * 20) / 20;
                    e.playbackRate = Math.min(t, Math.max(1, n))
                } else 1 !== e.playbackRate && 0 !== e.playbackRate && (e.playbackRate = 1)
            }

            estimateLiveEdge() {
                const {levelDetails: e} = this;
                return null === e ? null : e.edge + e.age
            }

            computeLatency() {
                const e = this.estimateLiveEdge();
                return null === e ? null : e - this.currentTime
            }
        }

        const gp = ["NONE", "TYPE-0", "TYPE-1", null];

        class yp {
            constructor(e, t, n) {
                this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = n
            }

            addDirectives(e) {
                const t = new self.URL(e);
                return void 0 !== this.msn && t.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.href
            }
        }

        class vp {
            constructor(e) {
                this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.unknownCodecs = e.unknownCodecs, this.codecSet = [e.videoCodec, e.audioCodec].filter((e => e)).join(",").replace(/\.[^.,]+/g, "")
            }

            get maxBitrate() {
                return Math.max(this.realBitrate, this.bitrate)
            }

            get attrs() {
                return this._attrs[this._urlId]
            }

            get pathwayId() {
                return this.attrs["PATHWAY-ID"] || "."
            }

            get uri() {
                return this.url[this._urlId] || ""
            }

            get urlId() {
                return this._urlId
            }

            set urlId(e) {
                const t = e % this.url.length;
                this._urlId !== t && (this.fragmentError = 0, this.loadError = 0, this.details = void 0, this._urlId = t)
            }

            get audioGroupId() {
                var e;
                return null == (e = this.audioGroupIds) ? void 0 : e[this.urlId]
            }

            get textGroupId() {
                var e;
                return null == (e = this.textGroupIds) ? void 0 : e[this.urlId]
            }

            addFallback(e) {
                this.url.push(e.url), this._attrs.push(e.attrs)
            }
        }

        function bp(e, t) {
            const n = t.startPTS;
            if (lh(n)) {
                let r, i = 0;
                t.sn > e.sn ? (i = n - e.start, r = e) : (i = e.start - n, r = t), r.duration !== i && (r.duration = i)
            } else t.sn > e.sn ? e.cc === t.cc && e.minEndPTS ? t.start = e.start + (e.minEndPTS - e.start) : t.start = e.start + e.duration : t.start = Math.max(e.start - t.duration, 0)
        }

        function wp(e, t, n, r, i, s) {
            r - n <= 0 && (mh.warn("Fragment should have a positive duration", t), r = n + t.duration, s = i + t.duration);
            let a = n, o = r;
            const l = t.startPTS, c = t.endPTS;
            if (lh(l)) {
                const e = Math.abs(l - n);
                lh(t.deltaPTS) ? t.deltaPTS = Math.max(e, t.deltaPTS) : t.deltaPTS = e, a = Math.max(n, l), n = Math.min(n, l), i = Math.min(i, t.startDTS), o = Math.min(r, c), r = Math.max(r, c), s = Math.max(s, t.endDTS)
            }
            const u = n - t.start;
            0 !== t.start && (t.start = n), t.duration = r - t.start, t.startPTS = n, t.maxStartPTS = a, t.startDTS = i, t.endPTS = r, t.minEndPTS = o, t.endDTS = s;
            const d = t.sn;
            if (!e || d < e.startSN || d > e.endSN) return 0;
            let h;
            const f = d - e.startSN, p = e.fragments;
            for (p[f] = t, h = f; h > 0; h--) bp(p[h], p[h - 1]);
            for (h = f; h < p.length - 1; h++) bp(p[h], p[h + 1]);
            return e.fragmentHint && bp(p[p.length - 1], e.fragmentHint), e.PTSKnown = e.alignedSliding = !0, u
        }

        function xp(e, t) {
            const n = t.startSN + t.skippedSegments - e.startSN, r = e.fragments;
            n < 0 || n >= r.length || Ep(t, r[n].start)
        }

        function Ep(e, t) {
            if (t) {
                const n = e.fragments;
                for (let r = e.skippedSegments; r < n.length; r++) n[r].start += t;
                e.fragmentHint && (e.fragmentHint.start += t)
            }
        }

        function Sp(e, t, n) {
            var r;
            return null != e && e.details ? kp(null == (r = e.details) ? void 0 : r.partList, t, n) : null
        }

        function kp(e, t, n) {
            if (e) for (let r = e.length; r--;) {
                const i = e[r];
                if (i.index === n && i.fragment.sn === t) return i
            }
            return null
        }

        function Ap(e) {
            switch (e.details) {
                case dh.FRAG_LOAD_TIMEOUT:
                case dh.KEY_LOAD_TIMEOUT:
                case dh.LEVEL_LOAD_TIMEOUT:
                case dh.MANIFEST_LOAD_TIMEOUT:
                    return !0
            }
            return !1
        }

        function Tp(e, t) {
            const n = Ap(t);
            return e.default[(n ? "timeout" : "error") + "Retry"]
        }

        function Cp(e, t) {
            const n = "linear" === e.backoff ? 1 : Math.pow(2, t);
            return Math.min(n * e.retryDelayMs, e.maxRetryDelayMs)
        }

        function Rp(e) {
            return sh(sh({}, e), {errorRetry: null, timeoutRetry: null})
        }

        function Lp(e, t, n, r) {
            return !!e && t < e.maxNumRetry && (function (e) {
                return 0 === e && !1 === navigator.onLine || !!e && (e < 400 || e > 499)
            }(r) || !!n)
        }

        const _p = {
            search: function (e, t) {
                let n = 0, r = e.length - 1, i = null, s = null;
                for (; n <= r;) {
                    i = (n + r) / 2 | 0, s = e[i];
                    const a = t(s);
                    if (a > 0) n = i + 1; else {
                        if (!(a < 0)) return s;
                        r = i - 1
                    }
                }
                return null
            }
        };

        function Pp(e, t, n = 0, r = 0) {
            let i = null;
            if (e ? i = t[e.sn - t[0].sn + 1] || null : 0 === n && 0 === t[0].start && (i = t[0]), i && 0 === Np(n, r, i)) return i;
            const s = _p.search(t, Np.bind(null, n, r));
            return !s || s === e && i ? i : s
        }

        function Np(e = 0, t = 0, n) {
            if (n.start <= e && n.start + n.duration > e) return 0;
            const r = Math.min(t, n.duration + (n.deltaPTS ? n.deltaPTS : 0));
            return n.start + n.duration - r <= e ? 1 : n.start - r > e && n.start ? -1 : 0
        }

        function jp(e, t, n) {
            const r = 1e3 * Math.min(t, n.duration + (n.deltaPTS ? n.deltaPTS : 0));
            return (n.endProgramDateTime || 0) - r > e
        }

        function Ip(e, t, n) {
            if (performance.now() - e.lastErrorPerfMs > 3e5) return !0;
            const r = e.details;
            if (t.details === dh.FRAG_GAP && r && t.frag) {
                const e = t.frag.start, n = Pp(null, r.fragments, e);
                if (n && !n.gap) return !0
            }
            if (n && e.errors.length < n.errors.length) {
                const n = e.errors[e.errors.length - 1];
                if (r && n.frag && t.frag && Math.abs(n.frag.start - t.frag.start) > 3 * r.targetduration) return !0
            }
            return !1
        }

        class Mp {
            constructor(e, t) {
                this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = mh.log.bind(mh, `${t}:`), this.warn = mh.warn.bind(mh, `${t}:`), this.hls = e
            }

            destroy() {
                this.clearTimer(), this.hls = this.log = this.warn = null
            }

            clearTimer() {
                clearTimeout(this.timer), this.timer = -1
            }

            startLoad() {
                this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist()
            }

            stopLoad() {
                this.canLoad = !1, this.clearTimer()
            }

            switchParams(e, t) {
                const n = null == t ? void 0 : t.renditionReports;
                if (n) {
                    let r = -1;
                    for (let i = 0; i < n.length; i++) {
                        const s = n[i];
                        let a;
                        try {
                            a = new self.URL(s.URI, t.url).href
                        } catch (e) {
                            mh.warn(`Could not construct new URL for Rendition Report: ${e}`), a = s.URI || ""
                        }
                        if (a === e) {
                            r = i;
                            break
                        }
                        a === e.substring(0, a.length) && (r = i)
                    }
                    if (-1 !== r) {
                        const e = n[r], i = parseInt(e["LAST-MSN"]) || (null == t ? void 0 : t.lastPartSn);
                        let s = parseInt(e["LAST-PART"]) || (null == t ? void 0 : t.lastPartIndex);
                        if (this.hls.config.lowLatencyMode) {
                            const e = Math.min(t.age - t.partTarget, t.targetduration);
                            s >= 0 && e > t.partTarget && (s += 1)
                        }
                        return new yp(i, s >= 0 ? s : void 0, "")
                    }
                }
            }

            loadPlaylist(e) {
                -1 === this.requestScheduled && (this.requestScheduled = self.performance.now())
            }

            shouldLoadPlaylist(e) {
                return this.canLoad && !!e && !!e.url && (!e.details || e.details.live)
            }

            shouldReloadPlaylist(e) {
                return -1 === this.timer && -1 === this.requestScheduled && this.shouldLoadPlaylist(e)
            }

            playlistLoaded(e, t, n) {
                const {details: r, stats: i} = t, s = self.performance.now(),
                    a = i.loading.first ? Math.max(0, s - i.loading.first) : 0;
                if (r.advancedDateTime = Date.now() - a, r.live || null != n && n.live) {
                    if (r.reloaded(n), n && this.log(`live playlist ${e} ${r.advanced ? "REFRESHED " + r.lastPartSn + "-" + r.lastPartIndex : "MISSED"}`), n && r.fragments.length > 0 && function (e, t) {
                        let n = null;
                        const r = e.fragments;
                        for (let e = r.length - 1; e >= 0; e--) {
                            const t = r[e].initSegment;
                            if (t) {
                                n = t;
                                break
                            }
                        }
                        e.fragmentHint && delete e.fragmentHint.endPTS;
                        let i, s = 0;
                        if (function (e, t, n) {
                            const r = t.skippedSegments, i = Math.max(e.startSN, t.startSN) - t.startSN,
                                s = (e.fragmentHint ? 1 : 0) + (r ? t.endSN : Math.min(e.endSN, t.endSN)) - t.startSN,
                                a = t.startSN - e.startSN,
                                o = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments,
                                l = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments;
                            for (let e = i; e <= s; e++) {
                                const i = l[a + e];
                                let s = o[e];
                                r && !s && e < r && (s = t.fragments[e] = i), i && s && n(i, s)
                            }
                        }(e, t, ((e, r) => {
                            e.relurl && (s = e.cc - r.cc), lh(e.startPTS) && lh(e.endPTS) && (r.start = r.startPTS = e.startPTS, r.startDTS = e.startDTS, r.maxStartPTS = e.maxStartPTS, r.endPTS = e.endPTS, r.endDTS = e.endDTS, r.minEndPTS = e.minEndPTS, r.duration = e.endPTS - e.startPTS, r.duration && (i = r), t.PTSKnown = t.alignedSliding = !0), r.elementaryStreams = e.elementaryStreams, r.loader = e.loader, r.stats = e.stats, r.urlId = e.urlId, e.initSegment && (r.initSegment = e.initSegment, n = e.initSegment)
                        })), n && (t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments).forEach((e => {
                            var t;
                            e.initSegment && e.initSegment.relurl !== (null == (t = n) ? void 0 : t.relurl) || (e.initSegment = n)
                        })), t.skippedSegments) if (t.deltaUpdateFailed = t.fragments.some((e => !e)), t.deltaUpdateFailed) {
                            mh.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
                            for (let e = t.skippedSegments; e--;) t.fragments.shift();
                            t.startSN = t.fragments[0].sn, t.startCC = t.fragments[0].cc
                        } else t.canSkipDateRanges && (t.dateRanges = function (e, t, n) {
                            const r = oh({}, e);
                            return n && n.forEach((e => {
                                delete r[e]
                            })), Object.keys(t).forEach((e => {
                                const n = new wh(t[e].attr, r[e]);
                                n.isValid ? r[e] = n : mh.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(t[e].attr)}"`)
                            })), r
                        }(e.dateRanges, t.dateRanges, t.recentlyRemovedDateranges));
                        const a = t.fragments;
                        if (s) {
                            mh.warn("discontinuity sliding from playlist, take drift into account");
                            for (let e = 0; e < a.length; e++) a[e].cc += s
                        }
                        t.skippedSegments && (t.startCC = t.fragments[0].cc), function (e, t, n) {
                            if (e && t) {
                                let r = 0;
                                for (let i = 0, s = e.length; i <= s; i++) {
                                    const s = e[i], a = t[i + r];
                                    s && a && s.index === a.index && s.fragment.sn === a.fragment.sn ? n(s, a) : r--
                                }
                            }
                        }(e.partList, t.partList, ((e, t) => {
                            t.elementaryStreams = e.elementaryStreams, t.stats = e.stats
                        })), i ? wp(t, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS) : xp(e, t), a.length && (t.totalduration = t.edge - a[0].start), t.driftStartTime = e.driftStartTime, t.driftStart = e.driftStart;
                        const o = t.advancedDateTime;
                        if (t.advanced && o) {
                            const e = t.edge;
                            t.driftStart || (t.driftStartTime = o, t.driftStart = e), t.driftEndTime = o, t.driftEnd = e
                        } else t.driftEndTime = e.driftEndTime, t.driftEnd = e.driftEnd, t.advancedDateTime = e.advancedDateTime
                    }(n, r), !this.canLoad || !r.live) return;
                    let a, o, l;
                    if (r.canBlockReload && r.endSN && r.advanced) {
                        const e = this.hls.config.lowLatencyMode, i = r.lastPartSn, s = r.endSN, c = r.lastPartIndex,
                            u = i === s;
                        -1 !== c ? (o = u ? s + 1 : i, l = u ? e ? 0 : c : c + 1) : o = s + 1;
                        const d = r.age, h = d + r.ageHeader;
                        let f = Math.min(h - r.partTarget, 1.5 * r.targetduration);
                        if (f > 0) {
                            if (n && f > n.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${n.tuneInGoal} to: ${f} with playlist age: ${r.age}`), f = 0; else {
                                const e = Math.floor(f / r.targetduration);
                                o += e, void 0 !== l && (l += Math.round(f % r.targetduration / r.partTarget)), this.log(`CDN Tune-in age: ${r.ageHeader}s last advanced ${d.toFixed(2)}s goal: ${f} skip sn ${e} to part ${l}`)
                            }
                            r.tuneInGoal = f
                        }
                        if (a = this.getDeliveryDirectives(r, t.deliveryDirectives, o, l), e || !u) return void this.loadPlaylist(a)
                    } else r.canBlockReload && (a = this.getDeliveryDirectives(r, t.deliveryDirectives, o, l));
                    const c = this.hls.mainForwardBufferInfo, u = c ? c.end - c.len : 0, d = function (e, t = 1 / 0) {
                        let n = 1e3 * e.targetduration;
                        if (e.updated) {
                            const r = e.fragments, i = 4;
                            if (r.length && n * i > t) {
                                const e = 1e3 * r[r.length - 1].duration;
                                e < n && (n = e)
                            }
                        } else n /= 2;
                        return Math.round(n)
                    }(r, 1e3 * (r.edge - u));
                    r.updated && s > this.requestScheduled + d && (this.requestScheduled = i.loading.start), void 0 !== o && r.canBlockReload ? this.requestScheduled = i.loading.first + d - (1e3 * r.partTarget || 1e3) : -1 === this.requestScheduled || this.requestScheduled + d < s ? this.requestScheduled = s : this.requestScheduled - s <= 0 && (this.requestScheduled += d);
                    let h = this.requestScheduled - s;
                    h = Math.max(0, h), this.log(`reload live playlist ${e} in ${Math.round(h)} ms`), this.timer = self.setTimeout((() => this.loadPlaylist(a)), h)
                } else this.clearTimer()
            }

            getDeliveryDirectives(e, t, n, r) {
                let i = function (e, t) {
                    const {canSkipUntil: n, canSkipDateRanges: r, endSN: i} = e;
                    return n && (void 0 !== t ? t - i : 0) < n ? r ? "v2" : "YES" : ""
                }(e, n);
                return null != t && t.skip && e.deltaUpdateFailed && (n = t.msn, r = t.part, i = ""), new yp(n, r, i)
            }

            checkRetry(e) {
                const t = e.details, n = Ap(e), r = e.errorAction, {
                    action: i,
                    retryCount: s = 0,
                    retryConfig: a
                } = r || {}, o = !!r && !!a && (5 === i || !r.resolved && 2 === i);
                if (o) {
                    var l;
                    if (this.requestScheduled = -1, s >= a.maxNumRetry) return !1;
                    if (n && null != (l = e.context) && l.deliveryDirectives) this.warn(`Retrying playlist loading ${s + 1}/${a.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist(); else {
                        const e = Cp(a, s);
                        this.timer = self.setTimeout((() => this.loadPlaylist()), e), this.warn(`Retrying playlist loading ${s + 1}/${a.maxNumRetry} after "${t}" in ${e}ms`)
                    }
                    e.levelRetry = !0, r.resolved = !0
                }
                return o
            }
        }

        let Dp;

        class Op extends Mp {
            constructor(e, t) {
                super(e, "[level-controller]"), this._levels = [], this._firstLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners()
            }

            _registerListeners() {
                const {hls: e} = this;
                e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(ch.LEVEL_LOADED, this.onLevelLoaded, this), e.on(ch.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(ch.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(ch.FRAG_LOADED, this.onFragLoaded, this), e.on(ch.ERROR, this.onError, this)
            }

            _unregisterListeners() {
                const {hls: e} = this;
                e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(ch.LEVEL_LOADED, this.onLevelLoaded, this), e.off(ch.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(ch.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(ch.FRAG_LOADED, this.onFragLoaded, this), e.off(ch.ERROR, this.onError, this)
            }

            destroy() {
                this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy()
            }

            startLoad() {
                this._levels.forEach((e => {
                    e.loadError = 0, e.fragmentError = 0
                })), super.startLoad()
            }

            resetLevels() {
                this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = []
            }

            onManifestLoading(e, t) {
                this.resetLevels()
            }

            onManifestLoaded(e, t) {
                const n = [], r = {};
                let i;
                t.levels.forEach((e => {
                    var t;
                    const s = e.attrs;
                    -1 !== (null == (t = e.audioCodec) ? void 0 : t.indexOf("mp4a.40.34")) && (Dp || (Dp = /chrome|firefox/i.test(navigator.userAgent)), Dp && (e.audioCodec = void 0));
                    const {AUDIO: a, CODECS: o, "FRAME-RATE": l, "PATHWAY-ID": c, RESOLUTION: u, SUBTITLES: d} = s,
                        h = `${c || "."}-${e.bitrate}-${u}-${l}-${o}`;
                    i = r[h], i ? i.addFallback(e) : (i = new vp(e), r[h] = i, n.push(i)), Bp(i, "audio", a), Bp(i, "text", d)
                })), this.filterAndSortMediaOptions(n, t)
            }

            filterAndSortMediaOptions(e, t) {
                let n = [], r = [], i = !1, s = !1, a = !1, o = e.filter((({
                                                                               audioCodec: e,
                                                                               videoCodec: t,
                                                                               width: n,
                                                                               height: r,
                                                                               unknownCodecs: o
                                                                           }) => (i || (i = !(!n || !r)), s || (s = !!t), a || (a = !!e), !(null != o && o.length) && (!e || Mf(e, "audio")) && (!t || Mf(t, "video")))));
                if ((i || s) && a && (o = o.filter((({
                                                         videoCodec: e,
                                                         width: t,
                                                         height: n
                                                     }) => !!e || !(!t || !n)))), 0 === o.length) return void Promise.resolve().then((() => {
                    if (this.hls) {
                        const e = new Error("no level with compatible codecs found in manifest");
                        this.hls.trigger(ch.ERROR, {
                            type: uh.MEDIA_ERROR,
                            details: dh.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                            fatal: !0,
                            url: t.url,
                            error: e,
                            reason: e.message
                        })
                    }
                }));
                t.audioTracks && (n = t.audioTracks.filter((e => !e.audioCodec || Mf(e.audioCodec, "audio"))), Fp(n)), t.subtitles && (r = t.subtitles, Fp(r));
                const l = o.slice(0);
                o.sort(((e, t) => e.attrs["HDCP-LEVEL"] !== t.attrs["HDCP-LEVEL"] ? (e.attrs["HDCP-LEVEL"] || "") > (t.attrs["HDCP-LEVEL"] || "") ? 1 : -1 : e.bitrate !== t.bitrate ? e.bitrate - t.bitrate : e.attrs["FRAME-RATE"] !== t.attrs["FRAME-RATE"] ? e.attrs.decimalFloatingPoint("FRAME-RATE") - t.attrs.decimalFloatingPoint("FRAME-RATE") : e.attrs.SCORE !== t.attrs.SCORE ? e.attrs.decimalFloatingPoint("SCORE") - t.attrs.decimalFloatingPoint("SCORE") : i && e.height !== t.height ? e.height - t.height : 0));
                let c = l[0];
                if (this.steering && (o = this.steering.filterParsedLevels(o), o.length !== l.length)) for (let e = 0; e < l.length; e++) if (l[e].pathwayId === o[0].pathwayId) {
                    c = l[e];
                    break
                }
                this._levels = o;
                for (let e = 0; e < o.length; e++) if (o[e] === c) {
                    this._firstLevel = e, this.log(`manifest loaded, ${o.length} level(s) found, first bitrate: ${c.bitrate}`);
                    break
                }
                const u = a && !s, d = {
                    levels: o,
                    audioTracks: n,
                    subtitleTracks: r,
                    sessionData: t.sessionData,
                    sessionKeys: t.sessionKeys,
                    firstLevel: this._firstLevel,
                    stats: t.stats,
                    audio: a,
                    video: s,
                    altAudio: !u && n.some((e => !!e.url))
                };
                this.hls.trigger(ch.MANIFEST_PARSED, d), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
            }

            get levels() {
                return 0 === this._levels.length ? null : this._levels
            }

            get level() {
                return this.currentLevelIndex
            }

            set level(e) {
                const t = this._levels;
                if (0 === t.length) return;
                if (e < 0 || e >= t.length) {
                    const n = new Error("invalid level idx"), r = e < 0;
                    if (this.hls.trigger(ch.ERROR, {
                        type: uh.OTHER_ERROR,
                        details: dh.LEVEL_SWITCH_ERROR,
                        level: e,
                        fatal: r,
                        error: n,
                        reason: n.message
                    }), r) return;
                    e = Math.min(e, t.length - 1)
                }
                const n = this.currentLevelIndex, r = this.currentLevel, i = r ? r.attrs["PATHWAY-ID"] : void 0,
                    s = t[e], a = s.attrs["PATHWAY-ID"];
                if (this.currentLevelIndex = e, this.currentLevel = s, n === e && s.details && r && i === a) return;
                this.log(`Switching to level ${e}${a ? " with Pathway " + a : ""} from level ${n}${i ? " with Pathway " + i : ""}`);
                const o = oh({}, s, {level: e, maxBitrate: s.maxBitrate, attrs: s.attrs, uri: s.uri, urlId: s.urlId});
                delete o._attrs, delete o._urlId, this.hls.trigger(ch.LEVEL_SWITCHING, o);
                const l = s.details;
                if (!l || l.live) {
                    const e = this.switchParams(s.uri, null == r ? void 0 : r.details);
                    this.loadPlaylist(e)
                }
            }

            get manualLevel() {
                return this.manualLevelIndex
            }

            set manualLevel(e) {
                this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e)
            }

            get firstLevel() {
                return this._firstLevel
            }

            set firstLevel(e) {
                this._firstLevel = e
            }

            get startLevel() {
                if (void 0 === this._startLevel) {
                    const e = this.hls.config.startLevel;
                    return void 0 !== e ? e : this._firstLevel
                }
                return this._startLevel
            }

            set startLevel(e) {
                this._startLevel = e
            }

            onError(e, t) {
                !t.fatal && t.context && t.context.type === Zf && t.context.level === this.level && this.checkRetry(t)
            }

            onFragLoaded(e, {frag: t}) {
                if (void 0 !== t && t.type === Jf) {
                    const e = this._levels[t.level];
                    void 0 !== e && (e.loadError = 0)
                }
            }

            onLevelLoaded(e, t) {
                var n;
                const {level: r, details: i} = t, s = this._levels[r];
                var a;
                if (!s) return this.warn(`Invalid level index ${r}`), void (null != (a = t.deliveryDirectives) && a.skip && (i.deltaUpdateFailed = !0));
                r === this.currentLevelIndex ? (0 === s.fragmentError && (s.loadError = 0), this.playlistLoaded(r, t, s.details)) : null != (n = t.deliveryDirectives) && n.skip && (i.deltaUpdateFailed = !0)
            }

            onAudioTrackSwitched(e, t) {
                const n = this.currentLevel;
                if (!n) return;
                const r = this.hls.audioTracks[t.id].groupId;
                if (n.audioGroupIds && n.audioGroupId !== r) {
                    let e = -1;
                    for (let t = 0; t < n.audioGroupIds.length; t++) if (n.audioGroupIds[t] === r) {
                        e = t;
                        break
                    }
                    -1 !== e && e !== n.urlId && (n.urlId = e, this.canLoad && this.startLoad())
                }
            }

            loadPlaylist(e) {
                super.loadPlaylist();
                const t = this.currentLevelIndex, n = this.currentLevel;
                if (n && this.shouldLoadPlaylist(n)) {
                    const r = n.urlId;
                    let i = n.uri;
                    if (e) try {
                        i = e.addDirectives(i)
                    } catch (e) {
                        this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`)
                    }
                    const s = n.attrs["PATHWAY-ID"];
                    this.log(`Loading level index ${t}${void 0 !== (null == e ? void 0 : e.msn) ? " at sn " + e.msn + " part " + e.part : ""} with${s ? " Pathway " + s : ""} URI ${r + 1}/${n.url.length} ${i}`), this.clearTimer(), this.hls.trigger(ch.LEVEL_LOADING, {
                        url: i,
                        level: t,
                        id: r,
                        deliveryDirectives: e || null
                    })
                }
            }

            get nextLoadLevel() {
                return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
            }

            set nextLoadLevel(e) {
                this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e)
            }

            removeLevel(e, t) {
                const n = (e, n) => n !== t,
                    r = this._levels.filter(((r, i) => i !== e || (r.url.length > 1 && void 0 !== t ? (r.url = r.url.filter(n), r.audioGroupIds && (r.audioGroupIds = r.audioGroupIds.filter(n)), r.textGroupIds && (r.textGroupIds = r.textGroupIds.filter(n)), r.urlId = 0, !0) : (this.steering && this.steering.removeLevel(r), !1))));
                this.hls.trigger(ch.LEVELS_UPDATED, {levels: r})
            }

            onLevelsUpdated(e, {levels: t}) {
                t.forEach(((e, t) => {
                    const {details: n} = e;
                    null != n && n.fragments && n.fragments.forEach((e => {
                        e.level = t
                    }))
                })), this._levels = t
            }
        }

        function Bp(e, t, n) {
            n && ("audio" === t ? (e.audioGroupIds || (e.audioGroupIds = []), e.audioGroupIds[e.url.length - 1] = n) : "text" === t && (e.textGroupIds || (e.textGroupIds = []), e.textGroupIds[e.url.length - 1] = n))
        }

        function Fp(e) {
            const t = {};
            e.forEach((e => {
                const n = e.groupId || "";
                e.id = t[n] = t[n] || 0, t[n]++
            }))
        }

        var Up = "NOT_LOADED", Hp = "APPENDING", $p = "PARTIAL", Kp = "OK";

        class zp {
            constructor(e) {
                this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners()
            }

            _registerListeners() {
                const {hls: e} = this;
                e.on(ch.BUFFER_APPENDED, this.onBufferAppended, this), e.on(ch.FRAG_BUFFERED, this.onFragBuffered, this), e.on(ch.FRAG_LOADED, this.onFragLoaded, this)
            }

            _unregisterListeners() {
                const {hls: e} = this;
                e.off(ch.BUFFER_APPENDED, this.onBufferAppended, this), e.off(ch.FRAG_BUFFERED, this.onFragBuffered, this), e.off(ch.FRAG_LOADED, this.onFragLoaded, this)
            }

            destroy() {
                this._unregisterListeners(), this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null
            }

            getAppendedFrag(e, t) {
                const n = this.activePartLists[t];
                if (n) for (let t = n.length; t--;) {
                    const r = n[t];
                    if (!r) break;
                    const i = r.end;
                    if (r.start <= e && null !== i && e <= i) return r
                }
                return this.getBufferedFrag(e, t)
            }

            getBufferedFrag(e, t) {
                const {fragments: n} = this, r = Object.keys(n);
                for (let i = r.length; i--;) {
                    const s = n[r[i]];
                    if ((null == s ? void 0 : s.body.type) === t && s.buffered) {
                        const t = s.body;
                        if (t.start <= e && e <= t.end) return t
                    }
                }
                return null
            }

            detectEvictedFragments(e, t, n, r) {
                this.timeRanges && (this.timeRanges[e] = t);
                const i = (null == r ? void 0 : r.fragment.sn) || -1;
                Object.keys(this.fragments).forEach((r => {
                    const s = this.fragments[r];
                    if (!s) return;
                    if (i >= s.body.sn) return;
                    if (!s.buffered && !s.loaded) return void (s.body.type === n && this.removeFragment(s.body));
                    const a = s.range[e];
                    a && a.time.some((e => {
                        const n = !this.isTimeBuffered(e.startPTS, e.endPTS, t);
                        return n && this.removeFragment(s.body), n
                    }))
                }))
            }

            detectPartialFragments(e) {
                const t = this.timeRanges, {frag: n, part: r} = e;
                if (!t || "initSegment" === n.sn) return;
                const i = qp(n), s = this.fragments[i];
                if (!s) return;
                const a = !n.relurl;
                Object.keys(t).forEach((e => {
                    const i = n.elementaryStreams[e];
                    if (!i) return;
                    const o = t[e], l = a || !0 === i.partial;
                    s.range[e] = this.getBufferedTimes(n, r, l, o)
                })), s.loaded = null, Object.keys(s.range).length ? (s.buffered = !0, s.body.endList && (this.endListFragments[s.body.type] = s), Gp(s) || this.removeParts(n.sn - 1, n.type)) : this.removeFragment(s.body)
            }

            removeParts(e, t) {
                const n = this.activePartLists[t];
                n && (this.activePartLists[t] = n.filter((t => t.fragment.sn >= e)))
            }

            fragBuffered(e, t) {
                const n = qp(e);
                let r = this.fragments[n];
                !r && t && (r = this.fragments[n] = {
                    body: e,
                    appendedPTS: null,
                    loaded: null,
                    buffered: !1,
                    range: Object.create(null)
                }, e.gap && (this.hasGaps = !0)), r && (r.loaded = null, r.buffered = !0)
            }

            getBufferedTimes(e, t, n, r) {
                const i = {time: [], partial: n}, s = e.start, a = e.end, o = e.minEndPTS || a, l = e.maxStartPTS || s;
                for (let e = 0; e < r.length; e++) {
                    const t = r.start(e) - this.bufferPadding, n = r.end(e) + this.bufferPadding;
                    if (l >= t && o <= n) {
                        i.time.push({startPTS: Math.max(s, r.start(e)), endPTS: Math.min(a, r.end(e))});
                        break
                    }
                    if (s < n && a > t) i.partial = !0, i.time.push({
                        startPTS: Math.max(s, r.start(e)),
                        endPTS: Math.min(a, r.end(e))
                    }); else if (a <= t) break
                }
                return i
            }

            getPartialFragment(e) {
                let t, n, r, i = null, s = 0;
                const {bufferPadding: a, fragments: o} = this;
                return Object.keys(o).forEach((l => {
                    const c = o[l];
                    c && Gp(c) && (n = c.body.start - a, r = c.body.end + a, e >= n && e <= r && (t = Math.min(e - n, r - e), s <= t && (i = c.body, s = t)))
                })), i
            }

            isEndListAppended(e) {
                const t = this.endListFragments[e];
                return void 0 !== t && (t.buffered || Gp(t))
            }

            getState(e) {
                const t = qp(e), n = this.fragments[t];
                return n ? n.buffered ? Gp(n) ? $p : Kp : Hp : Up
            }

            isTimeBuffered(e, t, n) {
                let r, i;
                for (let s = 0; s < n.length; s++) {
                    if (r = n.start(s) - this.bufferPadding, i = n.end(s) + this.bufferPadding, e >= r && t <= i) return !0;
                    if (t <= r) return !1
                }
                return !1
            }

            onFragLoaded(e, t) {
                const {frag: n, part: r} = t;
                if ("initSegment" === n.sn || n.bitrateTest) return;
                const i = r ? null : t, s = qp(n);
                this.fragments[s] = {body: n, appendedPTS: null, loaded: i, buffered: !1, range: Object.create(null)}
            }

            onBufferAppended(e, t) {
                const {frag: n, part: r, timeRanges: i} = t;
                if ("initSegment" === n.sn) return;
                const s = n.type;
                if (r) {
                    let e = this.activePartLists[s];
                    e || (this.activePartLists[s] = e = []), e.push(r)
                }
                this.timeRanges = i, Object.keys(i).forEach((e => {
                    const t = i[e];
                    this.detectEvictedFragments(e, t, s, r)
                }))
            }

            onFragBuffered(e, t) {
                this.detectPartialFragments(t)
            }

            hasFragment(e) {
                const t = qp(e);
                return !!this.fragments[t]
            }

            hasParts(e) {
                var t;
                return !(null == (t = this.activePartLists[e]) || !t.length)
            }

            removeFragmentsInRange(e, t, n, r, i) {
                r && !this.hasGaps || Object.keys(this.fragments).forEach((s => {
                    const a = this.fragments[s];
                    if (!a) return;
                    const o = a.body;
                    o.type !== n || r && !o.gap || o.start < t && o.end > e && (a.buffered || i) && this.removeFragment(o)
                }))
            }

            removeFragment(e) {
                const t = qp(e);
                e.stats.loaded = 0, e.clearElementaryStreamInfo();
                const n = this.activePartLists[e.type];
                if (n) {
                    const t = e.sn;
                    this.activePartLists[e.type] = n.filter((e => e.fragment.sn !== t))
                }
                delete this.fragments[t], e.endList && delete this.endListFragments[e.type]
            }

            removeAllFragments() {
                this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1
            }
        }

        function Gp(e) {
            var t, n, r;
            return e.buffered && (e.body.gap || (null == (t = e.range.video) ? void 0 : t.partial) || (null == (n = e.range.audio) ? void 0 : n.partial) || (null == (r = e.range.audiovideo) ? void 0 : r.partial))
        }

        function qp(e) {
            return `${e.type}_${e.level}_${e.urlId}_${e.sn}`
        }

        const Wp = Math.pow(2, 17);

        class Vp {
            constructor(e) {
                this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e
            }

            destroy() {
                this.loader && (this.loader.destroy(), this.loader = null)
            }

            abort() {
                this.loader && this.loader.abort()
            }

            load(e, t) {
                const n = e.url;
                if (!n) return Promise.reject(new Xp({
                    type: uh.NETWORK_ERROR,
                    details: dh.FRAG_LOAD_ERROR,
                    fatal: !1,
                    frag: e,
                    error: new Error("Fragment does not have a " + (n ? "part list" : "url")),
                    networkDetails: null
                }));
                this.abort();
                const r = this.config, i = r.fLoader, s = r.loader;
                return new Promise(((a, o) => {
                    if (this.loader && this.loader.destroy(), e.gap) return void o(Zp(e));
                    const l = this.loader = e.loader = i ? new i(r) : new s(r), c = Yp(e),
                        u = Rp(r.fragLoadPolicy.default), d = {
                            loadPolicy: u,
                            timeout: u.maxLoadTimeMs,
                            maxRetry: 0,
                            retryDelay: 0,
                            maxRetryDelay: 0,
                            highWaterMark: "initSegment" === e.sn ? 1 / 0 : Wp
                        };
                    e.stats = l.stats, l.load(c, d, {
                        onSuccess: (t, n, r, i) => {
                            this.resetLoader(e, l);
                            let s = t.data;
                            r.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(s.slice(0, 16)), s = s.slice(16)), a({
                                frag: e,
                                part: null,
                                payload: s,
                                networkDetails: i
                            })
                        }, onError: (t, r, i, s) => {
                            this.resetLoader(e, l), o(new Xp({
                                type: uh.NETWORK_ERROR,
                                details: dh.FRAG_LOAD_ERROR,
                                fatal: !1,
                                frag: e,
                                response: sh({url: n, data: void 0}, t),
                                error: new Error(`HTTP Error ${t.code} ${t.text}`),
                                networkDetails: i,
                                stats: s
                            }))
                        }, onAbort: (t, n, r) => {
                            this.resetLoader(e, l), o(new Xp({
                                type: uh.NETWORK_ERROR,
                                details: dh.INTERNAL_ABORTED,
                                fatal: !1,
                                frag: e,
                                error: new Error("Aborted"),
                                networkDetails: r,
                                stats: t
                            }))
                        }, onTimeout: (t, n, r) => {
                            this.resetLoader(e, l), o(new Xp({
                                type: uh.NETWORK_ERROR,
                                details: dh.FRAG_LOAD_TIMEOUT,
                                fatal: !1,
                                frag: e,
                                error: new Error(`Timeout after ${d.timeout}ms`),
                                networkDetails: r,
                                stats: t
                            }))
                        }, onProgress: (n, r, i, s) => {
                            t && t({frag: e, part: null, payload: i, networkDetails: s})
                        }
                    })
                }))
            }

            loadPart(e, t, n) {
                this.abort();
                const r = this.config, i = r.fLoader, s = r.loader;
                return new Promise(((a, o) => {
                    if (this.loader && this.loader.destroy(), e.gap || t.gap) return void o(Zp(e, t));
                    const l = this.loader = e.loader = i ? new i(r) : new s(r), c = Yp(e, t),
                        u = Rp(r.fragLoadPolicy.default), d = {
                            loadPolicy: u,
                            timeout: u.maxLoadTimeMs,
                            maxRetry: 0,
                            retryDelay: 0,
                            maxRetryDelay: 0,
                            highWaterMark: Wp
                        };
                    t.stats = l.stats, l.load(c, d, {
                        onSuccess: (r, i, s, o) => {
                            this.resetLoader(e, l), this.updateStatsFromPart(e, t);
                            const c = {frag: e, part: t, payload: r.data, networkDetails: o};
                            n(c), a(c)
                        }, onError: (n, r, i, s) => {
                            this.resetLoader(e, l), o(new Xp({
                                type: uh.NETWORK_ERROR,
                                details: dh.FRAG_LOAD_ERROR,
                                fatal: !1,
                                frag: e,
                                part: t,
                                response: sh({url: c.url, data: void 0}, n),
                                error: new Error(`HTTP Error ${n.code} ${n.text}`),
                                networkDetails: i,
                                stats: s
                            }))
                        }, onAbort: (n, r, i) => {
                            e.stats.aborted = t.stats.aborted, this.resetLoader(e, l), o(new Xp({
                                type: uh.NETWORK_ERROR,
                                details: dh.INTERNAL_ABORTED,
                                fatal: !1,
                                frag: e,
                                part: t,
                                error: new Error("Aborted"),
                                networkDetails: i,
                                stats: n
                            }))
                        }, onTimeout: (n, r, i) => {
                            this.resetLoader(e, l), o(new Xp({
                                type: uh.NETWORK_ERROR,
                                details: dh.FRAG_LOAD_TIMEOUT,
                                fatal: !1,
                                frag: e,
                                part: t,
                                error: new Error(`Timeout after ${d.timeout}ms`),
                                networkDetails: i,
                                stats: n
                            }))
                        }
                    })
                }))
            }

            updateStatsFromPart(e, t) {
                const n = e.stats, r = t.stats, i = r.total;
                if (n.loaded += r.loaded, i) {
                    const r = Math.round(e.duration / t.duration), s = Math.min(Math.round(n.loaded / i), r),
                        a = (r - s) * Math.round(n.loaded / s);
                    n.total = n.loaded + a
                } else n.total = Math.max(n.loaded, n.total);
                const s = n.loading, a = r.loading;
                s.start ? s.first += a.first - a.start : (s.start = a.start, s.first = a.first), s.end = a.end
            }

            resetLoader(e, t) {
                e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy()
            }
        }

        function Yp(e, t = null) {
            const n = t || e, r = {
                frag: e,
                part: t,
                responseType: "arraybuffer",
                url: n.url,
                headers: {},
                rangeStart: 0,
                rangeEnd: 0
            }, i = n.byteRangeStartOffset, s = n.byteRangeEndOffset;
            if (lh(i) && lh(s)) {
                var a;
                let t = i, n = s;
                if ("initSegment" === e.sn && "AES-128" === (null == (a = e.decryptdata) ? void 0 : a.method)) {
                    const e = s - i;
                    e % 16 && (n = s + (16 - e % 16)), 0 !== i && (r.resetIV = !0, t = i - 16)
                }
                r.rangeStart = t, r.rangeEnd = n
            }
            return r
        }

        function Zp(e, t) {
            const n = new Error(`GAP ${e.gap ? "tag" : "attribute"} found`),
                r = {type: uh.MEDIA_ERROR, details: dh.FRAG_GAP, fatal: !1, frag: e, error: n, networkDetails: null};
            return t && (r.part = t), (t || e).stats.aborted = !0, new Xp(r)
        }

        class Xp extends Error {
            constructor(e) {
                super(e.error.message), this.data = void 0, this.data = e
            }
        }

        class Qp {
            constructor(e) {
                this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e
            }

            abort(e) {
                for (const t in this.keyUriToKeyInfo) {
                    const n = this.keyUriToKeyInfo[t].loader;
                    if (n) {
                        if (e && e !== n.context.frag.type) return;
                        n.abort()
                    }
                }
            }

            detach() {
                for (const e in this.keyUriToKeyInfo) {
                    const t = this.keyUriToKeyInfo[e];
                    (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e]
                }
            }

            destroy() {
                this.detach();
                for (const e in this.keyUriToKeyInfo) {
                    const t = this.keyUriToKeyInfo[e].loader;
                    t && t.destroy()
                }
                this.keyUriToKeyInfo = {}
            }

            createKeyLoadError(e, t = dh.KEY_LOAD_ERROR, n, r, i) {
                return new Xp({
                    type: uh.NETWORK_ERROR,
                    details: t,
                    fatal: !1,
                    frag: e,
                    response: i,
                    error: n,
                    networkDetails: r
                })
            }

            loadClear(e, t) {
                if (this.emeController && this.config.emeEnabled) {
                    const {sn: n, cc: r} = e;
                    for (let e = 0; e < t.length; e++) {
                        const i = t[e];
                        if (r <= i.cc && ("initSegment" === n || "initSegment" === i.sn || n < i.sn)) {
                            this.emeController.selectKeySystemFormat(i).then((e => {
                                i.setKeyFormat(e)
                            }));
                            break
                        }
                    }
                }
            }

            load(e) {
                return !e.decryptdata && e.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(e).then((t => this.loadInternal(e, t))) : this.loadInternal(e)
            }

            loadInternal(e, t) {
                var n, r;
                t && e.setKeyFormat(t);
                const i = e.decryptdata;
                if (!i) {
                    const n = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : "Missing decryption data on fragment in onKeyLoading");
                    return Promise.reject(this.createKeyLoadError(e, dh.KEY_LOAD_ERROR, n))
                }
                const s = i.uri;
                if (!s) return Promise.reject(this.createKeyLoadError(e, dh.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${s}"`)));
                let a = this.keyUriToKeyInfo[s];
                if (null != (n = a) && n.decryptdata.key) return i.key = a.decryptdata.key, Promise.resolve({
                    frag: e,
                    keyInfo: a
                });
                var o;
                if (null != (r = a) && r.keyLoadPromise) switch (null == (o = a.mediaKeySessionContext) ? void 0 : o.keyStatus) {
                    case void 0:
                    case"status-pending":
                    case"usable":
                    case"usable-in-future":
                        return a.keyLoadPromise.then((t => (i.key = t.keyInfo.decryptdata.key, {frag: e, keyInfo: a})))
                }
                switch (a = this.keyUriToKeyInfo[s] = {
                    decryptdata: i,
                    keyLoadPromise: null,
                    loader: null,
                    mediaKeySessionContext: null
                }, i.method) {
                    case"ISO-23001-7":
                    case"SAMPLE-AES":
                    case"SAMPLE-AES-CENC":
                    case"SAMPLE-AES-CTR":
                        return "identity" === i.keyFormat ? this.loadKeyHTTP(a, e) : this.loadKeyEME(a, e);
                    case"AES-128":
                        return this.loadKeyHTTP(a, e);
                    default:
                        return Promise.reject(this.createKeyLoadError(e, dh.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${i.method}"`)))
                }
            }

            loadKeyEME(e, t) {
                const n = {frag: t, keyInfo: e};
                if (this.emeController && this.config.emeEnabled) {
                    const t = this.emeController.loadKey(n);
                    if (t) return (e.keyLoadPromise = t.then((t => (e.mediaKeySessionContext = t, n)))).catch((t => {
                        throw e.keyLoadPromise = null, t
                    }))
                }
                return Promise.resolve(n)
            }

            loadKeyHTTP(e, t) {
                const n = this.config, r = new (0, n.loader)(n);
                return t.keyLoader = e.loader = r, e.keyLoadPromise = new Promise(((i, s) => {
                    const a = {keyInfo: e, frag: t, responseType: "arraybuffer", url: e.decryptdata.uri},
                        o = n.keyLoadPolicy.default,
                        l = {loadPolicy: o, timeout: o.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0},
                        c = {
                            onSuccess: (e, t, n, r) => {
                                const {frag: a, keyInfo: o, url: l} = n;
                                if (!a.decryptdata || o !== this.keyUriToKeyInfo[l]) return s(this.createKeyLoadError(a, dh.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), r));
                                o.decryptdata.key = a.decryptdata.key = new Uint8Array(e.data), a.keyLoader = null, o.loader = null, i({
                                    frag: a,
                                    keyInfo: o
                                })
                            }, onError: (e, n, r, i) => {
                                this.resetLoader(n), s(this.createKeyLoadError(t, dh.KEY_LOAD_ERROR, new Error(`HTTP Error ${e.code} loading key ${e.text}`), r, sh({
                                    url: a.url,
                                    data: void 0
                                }, e)))
                            }, onTimeout: (e, n, r) => {
                                this.resetLoader(n), s(this.createKeyLoadError(t, dh.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), r))
                            }, onAbort: (e, n, r) => {
                                this.resetLoader(n), s(this.createKeyLoadError(t, dh.INTERNAL_ABORTED, new Error("key loading aborted"), r))
                            }
                        };
                    r.load(a, l, c)
                }))
            }

            resetLoader(e) {
                const {frag: t, keyInfo: n, url: r} = e, i = n.loader;
                t.keyLoader === i && (t.keyLoader = null, n.loader = null), delete this.keyUriToKeyInfo[r], i && i.destroy()
            }
        }

        class Jp {
            constructor() {
                this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
            }

            destroy() {
                this.onHandlerDestroying(), this.onHandlerDestroyed()
            }

            onHandlerDestroying() {
                this.clearNextTick(), this.clearInterval()
            }

            onHandlerDestroyed() {
            }

            hasInterval() {
                return !!this._tickInterval
            }

            hasNextTick() {
                return !!this._tickTimer
            }

            setInterval(e) {
                return !this._tickInterval && (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0)
            }

            clearInterval() {
                return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0)
            }

            clearNextTick() {
                return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0)
            }

            tick() {
                this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0)
            }

            tickImmediate() {
                this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)
            }

            doTick() {
            }
        }

        const em = {length: 0, start: () => 0, end: () => 0};

        class tm {
            static isBuffered(e, t) {
                try {
                    if (e) {
                        const n = tm.getBuffered(e);
                        for (let e = 0; e < n.length; e++) if (t >= n.start(e) && t <= n.end(e)) return !0
                    }
                } catch (e) {
                }
                return !1
            }

            static bufferInfo(e, t, n) {
                try {
                    if (e) {
                        const r = tm.getBuffered(e), i = [];
                        let s;
                        for (s = 0; s < r.length; s++) i.push({start: r.start(s), end: r.end(s)});
                        return this.bufferedInfo(i, t, n)
                    }
                } catch (e) {
                }
                return {len: 0, start: t, end: t, nextStart: void 0}
            }

            static bufferedInfo(e, t, n) {
                t = Math.max(0, t), e.sort((function (e, t) {
                    return e.start - t.start || t.end - e.end
                }));
                let r = [];
                if (n) for (let t = 0; t < e.length; t++) {
                    const i = r.length;
                    if (i) {
                        const s = r[i - 1].end;
                        e[t].start - s < n ? e[t].end > s && (r[i - 1].end = e[t].end) : r.push(e[t])
                    } else r.push(e[t])
                } else r = e;
                let i, s = 0, a = t, o = t;
                for (let e = 0; e < r.length; e++) {
                    const l = r[e].start, c = r[e].end;
                    if (t + n >= l && t < c) a = l, o = c, s = o - t; else if (t + n < l) {
                        i = l;
                        break
                    }
                }
                return {len: s, start: a || 0, end: o || 0, nextStart: i}
            }

            static getBuffered(e) {
                try {
                    return e.buffered
                } catch (e) {
                    return mh.log("failed to get media.buffered", e), em
                }
            }
        }

        class nm {
            constructor(e, t, n, r = 0, i = -1, s = !1) {
                this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {
                    start: 0,
                    executeStart: 0,
                    executeEnd: 0,
                    end: 0
                }, this.buffering = {
                    audio: {start: 0, executeStart: 0, executeEnd: 0, end: 0},
                    video: {start: 0, executeStart: 0, executeEnd: 0, end: 0},
                    audiovideo: {start: 0, executeStart: 0, executeEnd: 0, end: 0}
                }, this.level = e, this.sn = t, this.id = n, this.size = r, this.part = i, this.partial = s
            }
        }

        function rm(e, t) {
            let n = null;
            for (let r = 0, i = e.length; r < i; r++) {
                const i = e[r];
                if (i && i.cc === t) {
                    n = i;
                    break
                }
            }
            return n
        }

        function im(e, t) {
            if (e) {
                const n = e.start + t;
                e.start = e.startPTS = n, e.endPTS = n + e.duration
            }
        }

        function sm(e, t) {
            const n = t.fragments;
            for (let t = 0, r = n.length; t < r; t++) im(n[t], e);
            t.fragmentHint && im(t.fragmentHint, e), t.alignedSliding = !0
        }

        function am(e, t) {
            if (!e.hasProgramDateTime || !t.hasProgramDateTime) return;
            const n = e.fragments, r = t.fragments;
            if (!n.length || !r.length) return;
            const i = r[Math.round(r.length / 2) - 1], s = rm(n, i.cc) || n[Math.round(n.length / 2) - 1],
                a = i.programDateTime, o = s.programDateTime;
            null !== a && null !== o && sm((o - a) / 1e3 - (s.start - i.start), e)
        }

        class om {
            constructor(e, t) {
                this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t
            }

            decrypt(e, t) {
                return this.subtle.decrypt({name: "AES-CBC", iv: this.aesIV}, t, e)
            }
        }

        class lm {
            constructor(e, t) {
                this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t
            }

            expandKey() {
                return this.subtle.importKey("raw", this.key, {name: "AES-CBC"}, !1, ["encrypt", "decrypt"])
            }
        }

        class cm {
            constructor() {
                this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
            }

            uint8ArrayToUint32Array_(e) {
                const t = new DataView(e), n = new Uint32Array(4);
                for (let e = 0; e < 4; e++) n[e] = t.getUint32(4 * e);
                return n
            }

            initTable() {
                const e = this.sBox, t = this.invSBox, n = this.subMix, r = n[0], i = n[1], s = n[2], a = n[3],
                    o = this.invSubMix, l = o[0], c = o[1], u = o[2], d = o[3], h = new Uint32Array(256);
                let f = 0, p = 0, m = 0;
                for (m = 0; m < 256; m++) h[m] = m < 128 ? m << 1 : m << 1 ^ 283;
                for (m = 0; m < 256; m++) {
                    let n = p ^ p << 1 ^ p << 2 ^ p << 3 ^ p << 4;
                    n = n >>> 8 ^ 255 & n ^ 99, e[f] = n, t[n] = f;
                    const o = h[f], m = h[o], g = h[m];
                    let y = 257 * h[n] ^ 16843008 * n;
                    r[f] = y << 24 | y >>> 8, i[f] = y << 16 | y >>> 16, s[f] = y << 8 | y >>> 24, a[f] = y, y = 16843009 * g ^ 65537 * m ^ 257 * o ^ 16843008 * f, l[n] = y << 24 | y >>> 8, c[n] = y << 16 | y >>> 16, u[n] = y << 8 | y >>> 24, d[n] = y, f ? (f = o ^ h[h[h[g ^ o]]], p ^= h[h[p]]) : f = p = 1
                }
            }

            expandKey(e) {
                const t = this.uint8ArrayToUint32Array_(e);
                let n = !0, r = 0;
                for (; r < t.length && n;) n = t[r] === this.key[r], r++;
                if (n) return;
                this.key = t;
                const i = this.keySize = t.length;
                if (4 !== i && 6 !== i && 8 !== i) throw new Error("Invalid aes key size=" + i);
                const s = this.ksRows = 4 * (i + 6 + 1);
                let a, o;
                const l = this.keySchedule = new Uint32Array(s), c = this.invKeySchedule = new Uint32Array(s),
                    u = this.sBox, d = this.rcon, h = this.invSubMix, f = h[0], p = h[1], m = h[2], g = h[3];
                let y, v;
                for (a = 0; a < s; a++) a < i ? y = l[a] = t[a] : (v = y, a % i == 0 ? (v = v << 8 | v >>> 24, v = u[v >>> 24] << 24 | u[v >>> 16 & 255] << 16 | u[v >>> 8 & 255] << 8 | u[255 & v], v ^= d[a / i | 0] << 24) : i > 6 && a % i == 4 && (v = u[v >>> 24] << 24 | u[v >>> 16 & 255] << 16 | u[v >>> 8 & 255] << 8 | u[255 & v]), l[a] = y = (l[a - i] ^ v) >>> 0);
                for (o = 0; o < s; o++) a = s - o, v = 3 & o ? l[a] : l[a - 4], c[o] = o < 4 || a <= 4 ? v : f[u[v >>> 24]] ^ p[u[v >>> 16 & 255]] ^ m[u[v >>> 8 & 255]] ^ g[u[255 & v]], c[o] = c[o] >>> 0
            }

            networkToHostOrderSwap(e) {
                return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
            }

            decrypt(e, t, n) {
                const r = this.keySize + 6, i = this.invKeySchedule, s = this.invSBox, a = this.invSubMix, o = a[0],
                    l = a[1], c = a[2], u = a[3], d = this.uint8ArrayToUint32Array_(n);
                let h = d[0], f = d[1], p = d[2], m = d[3];
                const g = new Int32Array(e), y = new Int32Array(g.length);
                let v, b, w, x, E, S, k, A, T, C, R, L, _, P;
                const N = this.networkToHostOrderSwap;
                for (; t < g.length;) {
                    for (T = N(g[t]), C = N(g[t + 1]), R = N(g[t + 2]), L = N(g[t + 3]), E = T ^ i[0], S = L ^ i[1], k = R ^ i[2], A = C ^ i[3], _ = 4, P = 1; P < r; P++) v = o[E >>> 24] ^ l[S >> 16 & 255] ^ c[k >> 8 & 255] ^ u[255 & A] ^ i[_], b = o[S >>> 24] ^ l[k >> 16 & 255] ^ c[A >> 8 & 255] ^ u[255 & E] ^ i[_ + 1], w = o[k >>> 24] ^ l[A >> 16 & 255] ^ c[E >> 8 & 255] ^ u[255 & S] ^ i[_ + 2], x = o[A >>> 24] ^ l[E >> 16 & 255] ^ c[S >> 8 & 255] ^ u[255 & k] ^ i[_ + 3], E = v, S = b, k = w, A = x, _ += 4;
                    v = s[E >>> 24] << 24 ^ s[S >> 16 & 255] << 16 ^ s[k >> 8 & 255] << 8 ^ s[255 & A] ^ i[_], b = s[S >>> 24] << 24 ^ s[k >> 16 & 255] << 16 ^ s[A >> 8 & 255] << 8 ^ s[255 & E] ^ i[_ + 1], w = s[k >>> 24] << 24 ^ s[A >> 16 & 255] << 16 ^ s[E >> 8 & 255] << 8 ^ s[255 & S] ^ i[_ + 2], x = s[A >>> 24] << 24 ^ s[E >> 16 & 255] << 16 ^ s[S >> 8 & 255] << 8 ^ s[255 & k] ^ i[_ + 3], y[t] = N(v ^ h), y[t + 1] = N(x ^ f), y[t + 2] = N(w ^ p), y[t + 3] = N(b ^ m), h = T, f = C, p = R, m = L, t += 4
                }
                return y.buffer
            }
        }

        class um {
            constructor(e, {removePKCS7Padding: t = !0} = {}) {
                if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = t, t) try {
                    const e = self.crypto;
                    e && (this.subtle = e.subtle || e.webkitSubtle)
                } catch (e) {
                }
                null === this.subtle && (this.useSoftware = !0)
            }

            destroy() {
                this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null
            }

            isSync() {
                return this.useSoftware
            }

            flush() {
                const {currentResult: e, remainderData: t} = this;
                if (!e || t) return this.reset(), null;
                const n = new Uint8Array(e);
                return this.reset(), this.removePKCS7Padding ? function (e) {
                    const t = e.byteLength, n = t && new DataView(e.buffer).getUint8(t - 1);
                    return n ? Hh(e, 0, t - n) : e
                }(n) : n
            }

            reset() {
                this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
            }

            decrypt(e, t, n) {
                return this.useSoftware ? new Promise(((r, i) => {
                    this.softwareDecrypt(new Uint8Array(e), t, n);
                    const s = this.flush();
                    s ? r(s.buffer) : i(new Error("[softwareDecrypt] Failed to decrypt data"))
                })) : this.webCryptoDecrypt(new Uint8Array(e), t, n)
            }

            softwareDecrypt(e, t, n) {
                const {currentIV: r, currentResult: i, remainderData: s} = this;
                this.logOnce("JS AES decrypt"), s && (e = bf(s, e), this.remainderData = null);
                const a = this.getValidChunk(e);
                if (!a.length) return null;
                r && (n = r);
                let o = this.softwareDecrypter;
                o || (o = this.softwareDecrypter = new cm), o.expandKey(t);
                const l = i;
                return this.currentResult = o.decrypt(a.buffer, 0, n), this.currentIV = Hh(a, -16).buffer, l || null
            }

            webCryptoDecrypt(e, t, n) {
                const r = this.subtle;
                return this.key === t && this.fastAesKey || (this.key = t, this.fastAesKey = new lm(r, t)), this.fastAesKey.expandKey().then((t => r ? (this.logOnce("WebCrypto AES decrypt"), new om(r, new Uint8Array(n)).decrypt(e.buffer, t)) : Promise.reject(new Error("web crypto not initialized")))).catch((r => (mh.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${r.name}: ${r.message}`), this.onWebCryptoError(e, t, n))))
            }

            onWebCryptoError(e, t, n) {
                this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, n);
                const r = this.flush();
                if (r) return r.buffer;
                throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data")
            }

            getValidChunk(e) {
                let t = e;
                const n = e.length - e.length % 16;
                return n !== e.length && (t = Hh(e, 0, n), this.remainderData = Hh(e, n)), t
            }

            logOnce(e) {
                this.logEnabled && (mh.log(`[decrypter]: ${e}`), this.logEnabled = !1)
            }
        }

        const dm = "STOPPED", hm = "IDLE", fm = "KEY_LOADING", pm = "FRAG_LOADING", mm = "FRAG_LOADING_WAITING_RETRY",
            gm = "WAITING_TRACK", ym = "PARSING", vm = "PARSED", bm = "ENDED", wm = "ERROR", xm = "WAITING_INIT_PTS",
            Em = "WAITING_LEVEL";

        class Sm extends Jp {
            constructor(e, t, n, r, i) {
                super(), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = dm, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.loadedmetadata = !1, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.onvseeking = null, this.onvended = null, this.logPrefix = "", this.log = void 0, this.warn = void 0, this.playlistType = i, this.logPrefix = r, this.log = mh.log.bind(mh, `${r}:`), this.warn = mh.warn.bind(mh, `${r}:`), this.hls = e, this.fragmentLoader = new Vp(e.config), this.keyLoader = n, this.fragmentTracker = t, this.config = e.config, this.decrypter = new um(e.config), e.on(ch.MANIFEST_LOADED, this.onManifestLoaded, this)
            }

            doTick() {
                this.onTickEnd()
            }

            onTickEnd() {
            }

            startLoad(e) {
            }

            stopLoad() {
                this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
                const e = this.fragCurrent;
                null != e && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = dm
            }

            _streamEnded(e, t) {
                if (t.live || e.nextStart || !e.end || !this.media) return !1;
                const n = t.partList;
                if (null != n && n.length) {
                    const e = n[n.length - 1];
                    return tm.isBuffered(this.media, e.start + e.duration / 2)
                }
                const r = t.fragments[t.fragments.length - 1].type;
                return this.fragmentTracker.isEndListAppended(r)
            }

            getLevelDetails() {
                var e;
                if (this.levels && null !== this.levelLastLoaded) return null == (e = this.levels[this.levelLastLoaded]) ? void 0 : e.details
            }

            onMediaAttached(e, t) {
                const n = this.media = this.mediaBuffer = t.media;
                this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), n.addEventListener("seeking", this.onvseeking), n.addEventListener("ended", this.onvended);
                const r = this.config;
                this.levels && r.autoStartLoad && this.state === dm && this.startLoad(r.startPosition)
            }

            onMediaDetaching() {
                const e = this.media;
                null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad()
            }

            onMediaSeeking() {
                const {config: e, fragCurrent: t, media: n, mediaBuffer: r, state: i} = this, s = n ? n.currentTime : 0,
                    a = tm.bufferInfo(r || n, s, e.maxBufferHole);
                if (this.log(`media seeking to ${lh(s) ? s.toFixed(3) : s}, state: ${i}`), this.state === bm) this.resetLoadingState(); else if (t) {
                    const n = e.maxFragLookUpTolerance, r = t.start - n, i = t.start + t.duration + n;
                    if (!a.len || i < a.start || r > a.end) {
                        const e = s > i;
                        (s < r || e) && (e && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), t.abortRequests(), this.resetLoadingState()), this.fragPrevious = null)
                    }
                }
                n && (this.fragmentTracker.removeFragmentsInRange(s, 1 / 0, this.playlistType, !0), this.lastCurrentTime = s), this.loadedmetadata || a.len || (this.nextLoadPosition = this.startPosition = s), this.tickImmediate()
            }

            onMediaEnded() {
                this.startPosition = this.lastCurrentTime = 0
            }

            onManifestLoaded(e, t) {
                this.startTimeOffset = t.startTimeOffset, this.initPTS = []
            }

            onHandlerDestroying() {
                this.stopLoad(), super.onHandlerDestroying()
            }

            onHandlerDestroyed() {
                this.state = dm, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed()
            }

            loadFragment(e, t, n) {
                this._loadFragForPlayback(e, t, n)
            }

            _loadFragForPlayback(e, t, n) {
                this._doFragLoad(e, t, n, (t => {
                    if (this.fragContextChanged(e)) return this.warn(`Fragment ${e.sn}${t.part ? " p: " + t.part.index : ""} of level ${e.level} was dropped during download.`), void this.fragmentTracker.removeFragment(e);
                    e.stats.chunkCount++, this._handleFragmentLoadProgress(t)
                })).then((t => {
                    if (!t) return;
                    const n = this.state;
                    this.fragContextChanged(e) ? (n === pm || !this.fragCurrent && n === ym) && (this.fragmentTracker.removeFragment(e), this.state = hm) : ("payload" in t && (this.log(`Loaded fragment ${e.sn} of level ${e.level}`), this.hls.trigger(ch.FRAG_LOADED, t)), this._handleFragmentLoadComplete(t))
                })).catch((t => {
                    this.state !== dm && this.state !== wm && (this.warn(t), this.resetFragmentLoading(e))
                }))
            }

            clearTrackerIfNeeded(e) {
                var t;
                const {fragmentTracker: n} = this;
                if (n.getState(e) === Hp) {
                    const t = e.type, r = this.getFwdBufferInfo(this.mediaBuffer, t),
                        i = Math.max(e.duration, r ? r.len : this.config.maxBufferLength);
                    this.reduceMaxBufferLength(i) && n.removeFragment(e)
                } else 0 === (null == (t = this.mediaBuffer) ? void 0 : t.buffered.length) ? n.removeAllFragments() : n.hasParts(e.type) && (n.detectPartialFragments({
                    frag: e,
                    part: null,
                    stats: e.stats,
                    id: e.type
                }), n.getState(e) === $p && n.removeFragment(e))
            }

            flushMainBuffer(e, t, n = null) {
                if (!(e - t)) return;
                const r = {startOffset: e, endOffset: t, type: n};
                this.hls.trigger(ch.BUFFER_FLUSHING, r)
            }

            _loadInitSegment(e, t) {
                this._doFragLoad(e, t).then((t => {
                    if (!t || this.fragContextChanged(e) || !this.levels) throw new Error("init load aborted");
                    return t
                })).then((t => {
                    const {hls: n} = this, {payload: r} = t, i = e.decryptdata;
                    if (r && r.byteLength > 0 && i && i.key && i.iv && "AES-128" === i.method) {
                        const s = self.performance.now();
                        return this.decrypter.decrypt(new Uint8Array(r), i.key.buffer, i.iv.buffer).catch((t => {
                            throw n.trigger(ch.ERROR, {
                                type: uh.MEDIA_ERROR,
                                details: dh.FRAG_DECRYPT_ERROR,
                                fatal: !1,
                                error: t,
                                reason: t.message,
                                frag: e
                            }), t
                        })).then((r => {
                            const i = self.performance.now();
                            return n.trigger(ch.FRAG_DECRYPTED, {
                                frag: e,
                                payload: r,
                                stats: {tstart: s, tdecrypt: i}
                            }), t.payload = r, t
                        }))
                    }
                    return t
                })).then((n => {
                    const {fragCurrent: r, hls: i, levels: s} = this;
                    if (!s) throw new Error("init load aborted, missing levels");
                    const a = e.stats;
                    this.state = hm, t.fragmentError = 0, e.data = new Uint8Array(n.payload), a.parsing.start = a.buffering.start = self.performance.now(), a.parsing.end = a.buffering.end = self.performance.now(), n.frag === r && i.trigger(ch.FRAG_BUFFERED, {
                        stats: a,
                        frag: r,
                        part: null,
                        id: e.type
                    }), this.tick()
                })).catch((t => {
                    this.state !== dm && this.state !== wm && (this.warn(t), this.resetFragmentLoading(e))
                }))
            }

            fragContextChanged(e) {
                const {fragCurrent: t} = this;
                return !e || !t || e.level !== t.level || e.sn !== t.sn || e.urlId !== t.urlId
            }

            fragBufferedComplete(e, t) {
                var n, r, i, s;
                const a = this.mediaBuffer ? this.mediaBuffer : this.media;
                this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.playlistType === Jf ? "level" : "track"} ${e.level} (frag:[${(null != (n = e.startPTS) ? n : NaN).toFixed(3)}-${(null != (r = e.endPTS) ? r : NaN).toFixed(3)}] > buffer:${a ? function (e) {
                    let t = "";
                    const n = e.length;
                    for (let r = 0; r < n; r++) t += `[${e.start(r).toFixed(3)}-${e.end(r).toFixed(3)}]`;
                    return t
                }(tm.getBuffered(a)) : "(detached)"})`), this.state = hm, a && (!this.loadedmetadata && e.type == Jf && a.buffered.length && (null == (i = this.fragCurrent) ? void 0 : i.sn) === (null == (s = this.fragPrevious) ? void 0 : s.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick())
            }

            seekToStartPos() {
            }

            _handleFragmentLoadComplete(e) {
                const {transmuxer: t} = this;
                if (!t) return;
                const {frag: n, part: r, partsLoaded: i} = e, s = !i || 0 === i.length || i.some((e => !e)),
                    a = new nm(n.level, n.sn, n.stats.chunkCount + 1, 0, r ? r.index : -1, !s);
                t.flush(a)
            }

            _handleFragmentLoadProgress(e) {
            }

            _doFragLoad(e, t, n = null, r) {
                var i;
                const s = null == t ? void 0 : t.details;
                if (!this.levels || !s) throw new Error(`frag load aborted, missing level${s ? "" : " detail"}s`);
                let a = null;
                if (!e.encrypted || null != (i = e.decryptdata) && i.key ? !e.encrypted && s.encryptedFragments.length && this.keyLoader.loadClear(e, s.encryptedFragments) : (this.log(`Loading key for ${e.sn} of [${s.startSN}-${s.endSN}], ${"[stream-controller]" === this.logPrefix ? "level" : "track"} ${e.level}`), this.state = fm, this.fragCurrent = e, a = this.keyLoader.load(e).then((e => {
                    if (!this.fragContextChanged(e.frag)) return this.hls.trigger(ch.KEY_LOADED, e), this.state === fm && (this.state = hm), e
                })), this.hls.trigger(ch.KEY_LOADING, {frag: e}), null === this.fragCurrent && (a = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING")))), n = Math.max(e.start, n || 0), this.config.lowLatencyMode && "initSegment" !== e.sn) {
                    const i = s.partList;
                    if (i && r) {
                        n > e.end && s.fragmentHint && (e = s.fragmentHint);
                        const o = this.getNextPart(i, e, n);
                        if (o > -1) {
                            const l = i[o];
                            let c;
                            return this.log(`Loading part sn: ${e.sn} p: ${l.index} cc: ${e.cc} of playlist [${s.startSN}-${s.endSN}] parts [0-${o}-${i.length - 1}] ${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${e.level}, target: ${parseFloat(n.toFixed(3))}`), this.nextLoadPosition = l.start + l.duration, this.state = pm, c = a ? a.then((n => !n || this.fragContextChanged(n.frag) ? null : this.doFragPartsLoad(e, l, t, r))).catch((e => this.handleFragLoadError(e))) : this.doFragPartsLoad(e, l, t, r).catch((e => this.handleFragLoadError(e))), this.hls.trigger(ch.FRAG_LOADING, {
                                frag: e,
                                part: l,
                                targetBufferTime: n
                            }), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : c
                        }
                        if (!e.url || this.loadedEndOfParts(i, n)) return Promise.resolve(null)
                    }
                }
                this.log(`Loading fragment ${e.sn} cc: ${e.cc} ${s ? "of [" + s.startSN + "-" + s.endSN + "] " : ""}${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${e.level}, target: ${parseFloat(n.toFixed(3))}`), lh(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = pm;
                const o = this.config.progressive;
                let l;
                return l = o && a ? a.then((t => !t || this.fragContextChanged(null == t ? void 0 : t.frag) ? null : this.fragmentLoader.load(e, r))).catch((e => this.handleFragLoadError(e))) : Promise.all([this.fragmentLoader.load(e, o ? r : void 0), a]).then((([e]) => (!o && e && r && r(e), e))).catch((e => this.handleFragLoadError(e))), this.hls.trigger(ch.FRAG_LOADING, {
                    frag: e,
                    targetBufferTime: n
                }), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : l
            }

            doFragPartsLoad(e, t, n, r) {
                return new Promise(((i, s) => {
                    var a;
                    const o = [], l = null == (a = n.details) ? void 0 : a.partList, c = t => {
                        this.fragmentLoader.loadPart(e, t, r).then((r => {
                            o[t.index] = r;
                            const s = r.part;
                            this.hls.trigger(ch.FRAG_LOADED, r);
                            const a = Sp(n, e.sn, t.index + 1) || kp(l, e.sn, t.index + 1);
                            if (!a) return i({frag: e, part: s, partsLoaded: o});
                            c(a)
                        })).catch(s)
                    };
                    c(t)
                }))
            }

            handleFragLoadError(e) {
                if ("data" in e) {
                    const t = e.data;
                    e.data && t.details === dh.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(ch.ERROR, t)
                } else this.hls.trigger(ch.ERROR, {
                    type: uh.OTHER_ERROR,
                    details: dh.INTERNAL_EXCEPTION,
                    err: e,
                    error: e,
                    fatal: !0
                });
                return null
            }

            _handleTransmuxerFlush(e) {
                const t = this.getCurrentContext(e);
                if (!t || this.state !== ym) return void (this.fragCurrent || this.state === dm || this.state === wm || (this.state = hm));
                const {frag: n, part: r, level: i} = t, s = self.performance.now();
                n.stats.parsing.end = s, r && (r.stats.parsing.end = s), this.updateLevelTiming(n, r, i, e.partial)
            }

            getCurrentContext(e) {
                const {levels: t, fragCurrent: n} = this, {level: r, sn: i, part: s} = e;
                if (null == t || !t[r]) return this.warn(`Levels object was unset while buffering fragment ${i} of level ${r}. The current chunk will not be buffered.`), null;
                const a = t[r], o = s > -1 ? Sp(a, i, s) : null, l = o ? o.fragment : function (e, t, n) {
                    if (null == e || !e.details) return null;
                    const r = e.details;
                    let i = r.fragments[t - r.startSN];
                    return i || (i = r.fragmentHint, i && i.sn === t ? i : t < r.startSN && n && n.sn === t ? n : null)
                }(a, i, n);
                return l ? (n && n !== l && (l.stats = n.stats), {frag: l, part: o, level: a}) : null
            }

            bufferFragmentData(e, t, n, r) {
                var i;
                if (!e || this.state !== ym) return;
                const {data1: s, data2: a} = e;
                let o = s;
                if (s && a && (o = bf(s, a)), null == (i = o) || !i.length) return;
                const l = {type: e.type, frag: t, part: n, chunkMeta: r, parent: t.type, data: o};
                this.hls.trigger(ch.BUFFER_APPENDING, l), e.dropped && e.independent && !n && this.flushBufferGap(t)
            }

            flushBufferGap(e) {
                const t = this.media;
                if (!t) return;
                if (!tm.isBuffered(t, t.currentTime)) return void this.flushMainBuffer(0, e.start);
                const n = t.currentTime, r = tm.bufferInfo(t, n, 0), i = e.duration,
                    s = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * i),
                    a = Math.max(Math.min(e.start - s, r.end - s), n + s);
                e.start - a > s && this.flushMainBuffer(a, e.start)
            }

            getFwdBufferInfo(e, t) {
                const n = this.getLoadPosition();
                return lh(n) ? this.getFwdBufferInfoAtPos(e, n, t) : null
            }

            getFwdBufferInfoAtPos(e, t, n) {
                const {config: {maxBufferHole: r}} = this, i = tm.bufferInfo(e, t, r);
                if (0 === i.len && void 0 !== i.nextStart) {
                    const s = this.fragmentTracker.getBufferedFrag(t, n);
                    if (s && i.nextStart < s.end) return tm.bufferInfo(e, t, Math.max(i.nextStart, r))
                }
                return i
            }

            getMaxBufferLength(e) {
                const {config: t} = this;
                let n;
                return n = e ? Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : t.maxBufferLength, Math.min(n, t.maxMaxBufferLength)
            }

            reduceMaxBufferLength(e) {
                const t = this.config, n = e || t.maxBufferLength;
                return t.maxMaxBufferLength >= n && (t.maxMaxBufferLength /= 2, this.warn(`Reduce max buffer length to ${t.maxMaxBufferLength}s`), !0)
            }

            getAppendedFrag(e, t = Jf) {
                const n = this.fragmentTracker.getAppendedFrag(e, Jf);
                return n && "fragment" in n ? n.fragment : n
            }

            getNextFragment(e, t) {
                const n = t.fragments, r = n.length;
                if (!r) return null;
                const {config: i} = this, s = n[0].start;
                let a;
                if (t.live) {
                    const s = i.initialLiveManifestSize;
                    if (r < s) return this.warn(`Not enough fragments to start playback (have: ${r}, need: ${s})`), null;
                    t.PTSKnown || this.startFragRequested || -1 !== this.startPosition || (a = this.getInitialLiveFragment(t, n), this.startPosition = a ? this.hls.liveSyncPosition || a.start : e)
                } else e <= s && (a = n[0]);
                if (!a) {
                    const n = i.lowLatencyMode ? t.partEnd : t.fragmentEnd;
                    a = this.getFragmentAtPosition(e, n, t)
                }
                return this.mapToInitFragWhenRequired(a)
            }

            isLoopLoading(e, t) {
                const n = this.fragmentTracker.getState(e);
                return (n === Kp || n === $p && !!e.gap) && this.nextLoadPosition > t
            }

            getNextFragmentLoopLoading(e, t, n, r, i) {
                const s = e.gap, a = this.getNextFragment(this.nextLoadPosition, t);
                if (null === a) return a;
                if (e = a, s && e && !e.gap && n.nextStart) {
                    const t = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, n.nextStart, r);
                    if (null !== t && n.len + t.len >= i) return this.log(`buffer full after gaps in "${r}" playlist starting at sn: ${e.sn}`), null
                }
                return e
            }

            mapToInitFragWhenRequired(e) {
                return null == e || !e.initSegment || null != e && e.initSegment.data || this.bitrateTest ? e : e.initSegment
            }

            getNextPart(e, t, n) {
                let r = -1, i = !1, s = !0;
                for (let a = 0, o = e.length; a < o; a++) {
                    const o = e[a];
                    if (s = s && !o.independent, r > -1 && n < o.start) break;
                    const l = o.loaded;
                    l ? r = -1 : (i || o.independent || s) && o.fragment === t && (r = a), i = l
                }
                return r
            }

            loadedEndOfParts(e, t) {
                const n = e[e.length - 1];
                return n && t > n.start && n.loaded
            }

            getInitialLiveFragment(e, t) {
                const n = this.fragPrevious;
                let r = null;
                if (n) {
                    if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${n.programDateTime}`), r = function (e, t, n) {
                        if (null === t || !Array.isArray(e) || !e.length || !lh(t)) return null;
                        if (t < (e[0].programDateTime || 0)) return null;
                        if (t >= (e[e.length - 1].endProgramDateTime || 0)) return null;
                        n = n || 0;
                        for (let r = 0; r < e.length; ++r) {
                            const i = e[r];
                            if (jp(t, n, i)) return i
                        }
                        return null
                    }(t, n.endProgramDateTime, this.config.maxFragLookUpTolerance)), !r) {
                        const i = n.sn + 1;
                        if (i >= e.startSN && i <= e.endSN) {
                            const s = t[i - e.startSN];
                            n.cc === s.cc && (r = s, this.log(`Live playlist, switching playlist, load frag with next SN: ${r.sn}`))
                        }
                        r || (r = function (e, t) {
                            return _p.search(e, (e => e.cc < t ? 1 : e.cc > t ? -1 : 0))
                        }(t, n.cc), r && this.log(`Live playlist, switching playlist, load frag with same CC: ${r.sn}`))
                    }
                } else {
                    const t = this.hls.liveSyncPosition;
                    null !== t && (r = this.getFragmentAtPosition(t, this.bitrateTest ? e.fragmentEnd : e.edge, e))
                }
                return r
            }

            getFragmentAtPosition(e, t, n) {
                const {config: r} = this;
                let {fragPrevious: i} = this, {fragments: s, endSN: a} = n;
                const {fragmentHint: o} = n, l = r.maxFragLookUpTolerance, c = n.partList,
                    u = !!(r.lowLatencyMode && null != c && c.length && o);
                let d;
                if (u && o && !this.bitrateTest && (s = s.concat(o), a = o.sn), d = e < t ? Pp(i, s, e, e > t - l ? 0 : l) : s[s.length - 1], d) {
                    const e = d.sn - n.startSN, t = this.fragmentTracker.getState(d);
                    if ((t === Kp || t === $p && d.gap) && (i = d), i && d.sn === i.sn && (!u || c[0].fragment.sn > d.sn) && i && d.level === i.level) {
                        const t = s[e + 1];
                        d = d.sn < a && this.fragmentTracker.getState(t) !== Kp ? t : null
                    }
                }
                return d
            }

            synchronizeToLiveEdge(e) {
                const {config: t, media: n} = this;
                if (!n) return;
                const r = this.hls.liveSyncPosition, i = n.currentTime, s = e.fragments[0].start, a = e.edge,
                    o = i >= s - t.maxFragLookUpTolerance && i <= a;
                if (null !== r && n.duration > r && (i < r || !o)) {
                    const s = void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
                    (!o && n.readyState < 4 || i < a - s) && (this.loadedmetadata || (this.nextLoadPosition = r), n.readyState && (this.warn(`Playback: ${i.toFixed(3)} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${r.toFixed(3)}`), n.currentTime = r))
                }
            }

            alignPlaylists(e, t) {
                const {levels: n, levelLastLoaded: r, fragPrevious: i} = this, s = null !== r ? n[r] : null,
                    a = e.fragments.length;
                if (!a) return this.warn("No fragments in live playlist"), 0;
                const o = e.fragments[0].start, l = !t, c = e.alignedSliding && lh(o);
                if (l || !c && !o) {
                    !function (e, t, n) {
                        t && (function (e, t, n) {
                            if (function (e, t, n) {
                                return !(!t.details || !(n.endCC > n.startCC || e && e.cc < n.startCC))
                            }(e, n, t)) {
                                const e = function (e, t, n = 0) {
                                    const r = e.fragments, i = t.fragments;
                                    if (!i.length || !r.length) return void mh.log("No fragments to align");
                                    const s = rm(r, i[0].cc);
                                    if (s && (!s || s.startPTS)) return s;
                                    mh.log("No frag in previous level to align on")
                                }(n.details, t);
                                e && lh(e.start) && (mh.log(`Adjusting PTS using last level due to CC increase within current level ${t.url}`), sm(e.start, t))
                            }
                        }(e, n, t), !n.alignedSliding && t.details && function (e, t) {
                            if (!t.fragments.length || !e.hasProgramDateTime || !t.hasProgramDateTime) return;
                            const n = t.fragments[0].programDateTime, r = e.fragments[0].programDateTime,
                                i = (r - n) / 1e3 + t.fragments[0].start;
                            i && lh(i) && (mh.log(`Adjusting PTS using programDateTime delta ${r - n}ms, sliding:${i.toFixed(3)} ${e.url} `), sm(i, e))
                        }(n, t.details), n.alignedSliding || !t.details || n.skippedSegments || xp(t.details, n))
                    }(i, s, e);
                    const n = e.fragments[0].start;
                    return this.log(`Live playlist sliding: ${n.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} prev-sn: ${i ? i.sn : "na"} fragments: ${a}`), n
                }
                return o
            }

            waitForCdnTuneIn(e) {
                return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget)
            }

            setStartPosition(e, t) {
                let n = this.startPosition;
                if (n < t && (n = -1), -1 === n || -1 === this.lastCurrentTime) {
                    const r = null !== this.startTimeOffset, i = r ? this.startTimeOffset : e.startTimeOffset;
                    null !== i && lh(i) ? (n = t + i, i < 0 && (n += e.totalduration), n = Math.min(Math.max(t, n), t + e.totalduration), this.log(`Start time offset ${i} found in ${r ? "multivariant" : "media"} playlist, adjust startPosition to ${n}`), this.startPosition = n) : e.live ? n = this.hls.liveSyncPosition || t : this.startPosition = n = 0, this.lastCurrentTime = n
                }
                this.nextLoadPosition = n
            }

            getLoadPosition() {
                const {media: e} = this;
                let t = 0;
                return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t
            }

            handleFragLoadAborted(e, t) {
                this.transmuxer && "initSegment" !== e.sn && e.stats.aborted && (this.warn(`Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} was aborted`), this.resetFragmentLoading(e))
            }

            resetFragmentLoading(e) {
                this.fragCurrent && (this.fragContextChanged(e) || this.state === mm) || (this.state = hm)
            }

            onFragmentOrKeyLoadError(e, t) {
                if (t.chunkMeta && !t.frag) {
                    const e = this.getCurrentContext(t.chunkMeta);
                    e && (t.frag = e.frag)
                }
                const n = t.frag;
                if (!n || n.type !== e || !this.levels) return;
                var r;
                if (this.fragContextChanged(n)) return void this.warn(`Frag load error must match current frag to retry ${n.url} > ${null == (r = this.fragCurrent) ? void 0 : r.url}`);
                const i = t.details === dh.FRAG_GAP;
                i && this.fragmentTracker.fragBuffered(n, !0);
                const s = t.errorAction, {action: a, retryCount: o = 0, retryConfig: l} = s || {};
                if (s && 5 === a && l) {
                    this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition);
                    const r = Cp(l, o);
                    this.warn(`Fragment ${n.sn} of ${e} ${n.level} errored with ${t.details}, retrying loading ${o + 1}/${l.maxNumRetry} in ${r}ms`), s.resolved = !0, this.retryDate = self.performance.now() + r, this.state = mm
                } else l && s ? (this.resetFragmentErrors(e), o < l.maxNumRetry ? i || (s.resolved = !0) : mh.warn(`${t.details} reached or exceeded max retry (${o})`)) : this.state = wm;
                this.tickImmediate()
            }

            reduceLengthAndFlushBuffer(e) {
                if (this.state === ym || this.state === vm) {
                    const t = e.parent, n = this.getFwdBufferInfo(this.mediaBuffer, t), r = n && n.len > .5;
                    r && this.reduceMaxBufferLength(n.len);
                    const i = !r;
                    return i && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${t} buffer`), e.frag && (this.fragmentTracker.removeFragment(e.frag), this.nextLoadPosition = e.frag.start), this.resetLoadingState(), i
                }
                return !1
            }

            resetFragmentErrors(e) {
                e === ep && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== dm && (this.state = hm)
            }

            afterBufferFlushed(e, t, n) {
                if (!e) return;
                const r = tm.getBuffered(e);
                this.fragmentTracker.detectEvictedFragments(t, r, n), this.state === bm && this.resetLoadingState()
            }

            resetLoadingState() {
                this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = hm
            }

            resetStartWhenNotLoaded(e) {
                if (!this.loadedmetadata) {
                    this.startFragRequested = !1;
                    const t = this.levels ? this.levels[e].details : null;
                    null != t && t.live ? (this.startPosition = -1, this.setStartPosition(t, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
                }
            }

            resetWhenMissingContext(e) {
                this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(e.level), this.resetLoadingState()
            }

            removeUnbufferedFrags(e = 0) {
                this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0)
            }

            updateLevelTiming(e, t, n, r) {
                var i;
                const s = n.details;
                if (s) {
                    if (Object.keys(e.elementaryStreams).reduce(((t, i) => {
                        const a = e.elementaryStreams[i];
                        if (a) {
                            const o = a.endPTS - a.startPTS;
                            if (o <= 0) return this.warn(`Could not parse fragment ${e.sn} ${i} duration reliably (${o})`), t || !1;
                            const l = r ? 0 : wp(s, e, a.startPTS, a.endPTS, a.startDTS, a.endDTS);
                            return this.hls.trigger(ch.LEVEL_PTS_UPDATED, {
                                details: s,
                                level: n,
                                drift: l,
                                type: i,
                                frag: e,
                                start: a.startPTS,
                                end: a.endPTS
                            }), !0
                        }
                        return t
                    }), !1)) n.fragmentError = 0; else if (null === (null == (i = this.transmuxer) ? void 0 : i.error)) {
                        const t = new Error(`Found no media in fragment ${e.sn} of level ${n.id} resetting transmuxer to fallback to playlist timing`);
                        if (this.warn(t.message), this.hls.trigger(ch.ERROR, {
                            type: uh.MEDIA_ERROR,
                            details: dh.FRAG_PARSING_ERROR,
                            fatal: !1,
                            error: t,
                            frag: e,
                            reason: `Found no media in msn ${e.sn} of level "${n.url}"`
                        }), !this.hls) return;
                        this.resetTransmuxer()
                    }
                    this.state = vm, this.hls.trigger(ch.FRAG_PARSED, {frag: e, part: t})
                } else this.warn("level.details undefined")
            }

            resetTransmuxer() {
                this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null)
            }

            recoverWorkerError(e) {
                "demuxerWorker" === e.event && (this.resetTransmuxer(), this.resetLoadingState())
            }

            set state(e) {
                const t = this._state;
                t !== e && (this._state = e, this.log(`${t}->${e}`))
            }

            get state() {
                return this._state
            }
        }

        function km() {
            return self.SourceBuffer || self.WebKitSourceBuffer
        }

        function Am(e = "", t = 9e4) {
            return {type: e, id: -1, pid: -1, inputTimeScale: t, sequenceNumber: -1, samples: [], dropped: 0}
        }

        class Tm {
            constructor() {
                this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null
            }

            resetInitSegment(e, t, n, r) {
                this._id3Track = {
                    type: "id3",
                    id: 3,
                    pid: -1,
                    inputTimeScale: 9e4,
                    sequenceNumber: 0,
                    samples: [],
                    dropped: 0
                }
            }

            resetTimeStamp(e) {
                this.initPTS = e, this.resetContiguity()
            }

            resetContiguity() {
                this.basePTS = null, this.lastPTS = null, this.frameIndex = 0
            }

            canParse(e, t) {
                return !1
            }

            appendFrame(e, t, n) {
            }

            demux(e, t) {
                this.cachedData && (e = bf(this.cachedData, e), this.cachedData = null);
                let n, r = zh(e, 0), i = r ? r.length : 0;
                const s = this._audioTrack, a = this._id3Track, o = r ? (e => {
                    const t = Yh(e);
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e];
                        if (Wh(n)) return ef(n)
                    }
                })(r) : void 0, l = e.length;
                for ((null === this.basePTS || 0 === this.frameIndex && lh(o)) && (this.basePTS = Cm(o, t, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), r && r.length > 0 && a.samples.push({
                    pts: this.lastPTS,
                    dts: this.lastPTS,
                    data: r,
                    type: cp,
                    duration: Number.POSITIVE_INFINITY
                }); i < l;) {
                    if (this.canParse(e, i)) {
                        const t = this.appendFrame(s, e, i);
                        t ? (this.frameIndex++, this.lastPTS = t.sample.pts, i += t.length, n = i) : i = l
                    } else qh(e, i) ? (r = zh(e, i), a.samples.push({
                        pts: this.lastPTS,
                        dts: this.lastPTS,
                        data: r,
                        type: cp,
                        duration: Number.POSITIVE_INFINITY
                    }), i += r.length, n = i) : i++;
                    if (i === l && n !== l) {
                        const t = Hh(e, n);
                        this.cachedData ? this.cachedData = bf(this.cachedData, t) : this.cachedData = t
                    }
                }
                return {audioTrack: s, videoTrack: Am(), id3Track: a, textTrack: Am()}
            }

            demuxSampleAes(e, t, n) {
                return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`))
            }

            flush(e) {
                const t = this.cachedData;
                return t && (this.cachedData = null, this.demux(t, 0)), {
                    audioTrack: this._audioTrack,
                    videoTrack: Am(),
                    id3Track: this._id3Track,
                    textTrack: Am()
                }
            }

            destroy() {
            }
        }

        const Cm = (e, t, n) => lh(e) ? 90 * e : 9e4 * t + (n ? 9e4 * n.baseTime / n.timescale : 0);

        function Rm(e, t) {
            return 255 === e[t] && 240 == (246 & e[t + 1])
        }

        function Lm(e, t) {
            return 1 & e[t + 1] ? 7 : 9
        }

        function _m(e, t) {
            return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5
        }

        function Pm(e, t) {
            return t + 1 < e.length && Rm(e, t)
        }

        function Nm(e, t) {
            if (Pm(e, t)) {
                const n = Lm(e, t);
                if (t + n >= e.length) return !1;
                const r = _m(e, t);
                if (r <= n) return !1;
                const i = t + r;
                return i === e.length || Pm(e, i)
            }
            return !1
        }

        function jm(e, t, n, r, i) {
            if (!e.samplerate) {
                const s = function (e, t, n, r) {
                    let i, s, a, o;
                    const l = navigator.userAgent.toLowerCase(), c = r,
                        u = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
                    i = 1 + ((192 & t[n + 2]) >>> 6);
                    const d = (60 & t[n + 2]) >>> 2;
                    if (!(d > u.length - 1)) return a = (1 & t[n + 2]) << 2, a |= (192 & t[n + 3]) >>> 6, mh.log(`manifest codec:${r}, ADTS type:${i}, samplingIndex:${d}`), /firefox/i.test(l) ? d >= 6 ? (i = 5, o = new Array(4), s = d - 3) : (i = 2, o = new Array(2), s = d) : -1 !== l.indexOf("android") ? (i = 2, o = new Array(2), s = d) : (i = 5, o = new Array(4), r && (-1 !== r.indexOf("mp4a.40.29") || -1 !== r.indexOf("mp4a.40.5")) || !r && d >= 6 ? s = d - 3 : ((r && -1 !== r.indexOf("mp4a.40.2") && (d >= 6 && 1 === a || /vivaldi/i.test(l)) || !r && 1 === a) && (i = 2, o = new Array(2)), s = d)), o[0] = i << 3, o[0] |= (14 & d) >> 1, o[1] |= (1 & d) << 7, o[1] |= a << 3, 5 === i && (o[1] |= (14 & s) >> 1, o[2] = (1 & s) << 7, o[2] |= 8, o[3] = 0), {
                        config: o,
                        samplerate: u[d],
                        channelCount: a,
                        codec: "mp4a.40." + i,
                        manifestCodec: c
                    };
                    e.trigger(ch.ERROR, {
                        type: uh.MEDIA_ERROR,
                        details: dh.FRAG_PARSING_ERROR,
                        fatal: !0,
                        reason: `invalid ADTS sampling index:${d}`
                    })
                }(t, n, r, i);
                if (!s) return;
                e.config = s.config, e.samplerate = s.samplerate, e.channelCount = s.channelCount, e.codec = s.codec, e.manifestCodec = s.manifestCodec, mh.log(`parsed codec:${e.codec}, rate:${s.samplerate}, channels:${s.channelCount}`)
            }
        }

        function Im(e) {
            return 9216e4 / e
        }

        function Mm(e, t, n, r, i) {
            const s = r + i * Im(e.samplerate), a = function (e, t) {
                const n = Lm(e, t);
                if (t + n <= e.length) {
                    const r = _m(e, t) - n;
                    if (r > 0) return {headerLength: n, frameLength: r}
                }
            }(t, n);
            let o;
            if (a) {
                const {frameLength: r, headerLength: i} = a, l = i + r, c = Math.max(0, n + l - t.length);
                c ? (o = new Uint8Array(l - i), o.set(t.subarray(n + i, t.length), 0)) : o = t.subarray(n + i, n + l);
                const u = {unit: o, pts: s};
                return c || e.samples.push(u), {sample: u, length: l, missing: c}
            }
            const l = t.length - n;
            return o = new Uint8Array(l), o.set(t.subarray(n, t.length), 0), {
                sample: {unit: o, pts: s},
                length: l,
                missing: -1
            }
        }

        const Dm = /\/emsg[-/]ID3/i;
        let Om = null;
        const Bm = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
            Fm = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
            Um = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]], Hm = [0, 1, 1, 4];

        function $m(e, t, n, r, i) {
            if (n + 24 > t.length) return;
            const s = Km(t, n);
            if (s && n + s.frameLength <= t.length) {
                const a = r + i * (9e4 * s.samplesPerFrame / s.sampleRate),
                    o = {unit: t.subarray(n, n + s.frameLength), pts: a, dts: a};
                return e.config = [], e.channelCount = s.channelCount, e.samplerate = s.sampleRate, e.samples.push(o), {
                    sample: o,
                    length: s.frameLength,
                    missing: 0
                }
            }
        }

        function Km(e, t) {
            const n = e[t + 1] >> 3 & 3, r = e[t + 1] >> 1 & 3, i = e[t + 2] >> 4 & 15, s = e[t + 2] >> 2 & 3;
            if (1 !== n && 0 !== i && 15 !== i && 3 !== s) {
                const a = e[t + 2] >> 1 & 1, o = e[t + 3] >> 6,
                    l = 1e3 * Bm[14 * (3 === n ? 3 - r : 3 === r ? 3 : 4) + i - 1],
                    c = Fm[3 * (3 === n ? 0 : 2 === n ? 1 : 2) + s], u = 3 === o ? 1 : 2, d = Um[n][r], h = Hm[r],
                    f = 8 * d * h, p = Math.floor(d * l / c + a) * h;
                if (null === Om) {
                    const e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
                    Om = e ? parseInt(e[1]) : 0
                }
                return !!Om && Om <= 87 && 2 === r && l >= 224e3 && 0 === o && (e[t + 3] = 128 | e[t + 3]), {
                    sampleRate: c,
                    channelCount: u,
                    frameLength: p,
                    samplesPerFrame: f
                }
            }
        }

        function zm(e, t) {
            return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1])
        }

        function Gm(e, t) {
            return t + 1 < e.length && zm(e, t)
        }

        function qm(e, t) {
            if (t + 1 < e.length && zm(e, t)) {
                const n = 4, r = Km(e, t);
                let i = n;
                null != r && r.frameLength && (i = r.frameLength);
                const s = t + i;
                return s === e.length || Gm(e, s)
            }
            return !1
        }

        class Wm {
            constructor(e) {
                this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0
            }

            loadWord() {
                const e = this.data, t = this.bytesAvailable, n = e.byteLength - t, r = new Uint8Array(4),
                    i = Math.min(4, t);
                if (0 === i) throw new Error("no bytes available");
                r.set(e.subarray(n, n + i)), this.word = new DataView(r.buffer).getUint32(0), this.bitsAvailable = 8 * i, this.bytesAvailable -= i
            }

            skipBits(e) {
                let t;
                e = Math.min(e, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (t = (e -= this.bitsAvailable) >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e)
            }

            readBits(e) {
                let t = Math.min(this.bitsAvailable, e);
                const n = this.word >>> 32 - t;
                if (e > 32 && mh.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0) this.word <<= t; else {
                    if (!(this.bytesAvailable > 0)) throw new Error("no bits available");
                    this.loadWord()
                }
                return t = e - t, t > 0 && this.bitsAvailable ? n << t | this.readBits(t) : n
            }

            skipLZ() {
                let e;
                for (e = 0; e < this.bitsAvailable; ++e) if (0 != (this.word & 2147483648 >>> e)) return this.word <<= e, this.bitsAvailable -= e, e;
                return this.loadWord(), e + this.skipLZ()
            }

            skipUEG() {
                this.skipBits(1 + this.skipLZ())
            }

            skipEG() {
                this.skipBits(1 + this.skipLZ())
            }

            readUEG() {
                const e = this.skipLZ();
                return this.readBits(e + 1) - 1
            }

            readEG() {
                const e = this.readUEG();
                return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
            }

            readBoolean() {
                return 1 === this.readBits(1)
            }

            readUByte() {
                return this.readBits(8)
            }

            readUShort() {
                return this.readBits(16)
            }

            readUInt() {
                return this.readBits(32)
            }

            skipScalingList(e) {
                let t, n = 8, r = 8;
                for (let i = 0; i < e; i++) 0 !== r && (t = this.readEG(), r = (n + t + 256) % 256), n = 0 === r ? n : r
            }

            readSPS() {
                let e, t, n, r = 0, i = 0, s = 0, a = 0;
                const o = this.readUByte.bind(this), l = this.readBits.bind(this), c = this.readUEG.bind(this),
                    u = this.readBoolean.bind(this), d = this.skipBits.bind(this), h = this.skipEG.bind(this),
                    f = this.skipUEG.bind(this), p = this.skipScalingList.bind(this);
                o();
                const m = o();
                if (l(5), d(3), o(), f(), 100 === m || 110 === m || 122 === m || 244 === m || 44 === m || 83 === m || 86 === m || 118 === m || 128 === m) {
                    const e = c();
                    if (3 === e && d(1), f(), f(), d(1), u()) for (t = 3 !== e ? 8 : 12, n = 0; n < t; n++) u() && p(n < 6 ? 16 : 64)
                }
                f();
                const g = c();
                if (0 === g) c(); else if (1 === g) for (d(1), h(), h(), e = c(), n = 0; n < e; n++) h();
                f(), d(1);
                const y = c(), v = c(), b = l(1);
                0 === b && d(1), d(1), u() && (r = c(), i = c(), s = c(), a = c());
                let w = [1, 1];
                if (u() && u()) switch (o()) {
                    case 1:
                        w = [1, 1];
                        break;
                    case 2:
                        w = [12, 11];
                        break;
                    case 3:
                        w = [10, 11];
                        break;
                    case 4:
                        w = [16, 11];
                        break;
                    case 5:
                        w = [40, 33];
                        break;
                    case 6:
                        w = [24, 11];
                        break;
                    case 7:
                        w = [20, 11];
                        break;
                    case 8:
                        w = [32, 11];
                        break;
                    case 9:
                        w = [80, 33];
                        break;
                    case 10:
                        w = [18, 11];
                        break;
                    case 11:
                        w = [15, 11];
                        break;
                    case 12:
                        w = [64, 33];
                        break;
                    case 13:
                        w = [160, 99];
                        break;
                    case 14:
                        w = [4, 3];
                        break;
                    case 15:
                        w = [3, 2];
                        break;
                    case 16:
                        w = [2, 1];
                        break;
                    case 255:
                        w = [o() << 8 | o(), o() << 8 | o()]
                }
                return {
                    width: Math.ceil(16 * (y + 1) - 2 * r - 2 * i),
                    height: (2 - b) * (v + 1) * 16 - (b ? 2 : 4) * (s + a),
                    pixelRatio: w
                }
            }

            readSliceType() {
                return this.readUByte(), this.readUEG(), this.readUEG()
            }
        }

        class Vm {
            constructor(e, t, n) {
                this.keyData = void 0, this.decrypter = void 0, this.keyData = n, this.decrypter = new um(t, {removePKCS7Padding: !1})
            }

            decryptBuffer(e) {
                return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer)
            }

            decryptAacSample(e, t, n) {
                const r = e[t].unit;
                if (r.length <= 16) return;
                const i = r.subarray(16, r.length - r.length % 16),
                    s = i.buffer.slice(i.byteOffset, i.byteOffset + i.length);
                this.decryptBuffer(s).then((i => {
                    const s = new Uint8Array(i);
                    r.set(s, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, n)
                }))
            }

            decryptAacSamples(e, t, n) {
                for (; ; t++) {
                    if (t >= e.length) return void n();
                    if (!(e[t].unit.length < 32 || (this.decryptAacSample(e, t, n), this.decrypter.isSync()))) return
                }
            }

            getAvcEncryptedData(e) {
                const t = 16 * Math.floor((e.length - 48) / 160) + 16, n = new Int8Array(t);
                let r = 0;
                for (let t = 32; t < e.length - 16; t += 160, r += 16) n.set(e.subarray(t, t + 16), r);
                return n
            }

            getAvcDecryptedUnit(e, t) {
                const n = new Uint8Array(t);
                let r = 0;
                for (let t = 32; t < e.length - 16; t += 160, r += 16) e.set(n.subarray(r, r + 16), t);
                return e
            }

            decryptAvcSample(e, t, n, r, i) {
                const s = Sf(i.data), a = this.getAvcEncryptedData(s);
                this.decryptBuffer(a.buffer).then((a => {
                    i.data = this.getAvcDecryptedUnit(s, a), this.decrypter.isSync() || this.decryptAvcSamples(e, t, n + 1, r)
                }))
            }

            decryptAvcSamples(e, t, n, r) {
                if (e instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
                for (; ; t++, n = 0) {
                    if (t >= e.length) return void r();
                    const i = e[t].units;
                    for (; !(n >= i.length); n++) {
                        const s = i[n];
                        if (!(s.data.length <= 48 || 1 !== s.type && 5 !== s.type || (this.decryptAvcSample(e, t, n, r, s), this.decrypter.isSync()))) return
                    }
                }
            }
        }

        const Ym = 188;

        class Zm {
            constructor(e, t, n) {
                this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = e, this.config = t, this.typeSupported = n
            }

            static probe(e) {
                const t = Zm.syncOffset(e);
                return t > 0 && mh.warn(`MPEG2-TS detected but first sync word found @ offset ${t}`), -1 !== t
            }

            static syncOffset(e) {
                const t = e.length;
                let n = Math.min(940, e.length - Ym) + 1, r = 0;
                for (; r < n;) {
                    let i = !1, s = -1, a = 0;
                    for (let o = r; o < t; o += Ym) {
                        if (71 !== e[o]) {
                            if (a) return -1;
                            break
                        }
                        if (a++, -1 === s && (s = o, 0 !== s && (n = Math.min(s + 18612, e.length - Ym) + 1)), i || (i = 0 === Qm(e, o)), i && a > 1 && (0 === s && a > 2 || o + Ym > n)) return s
                    }
                    r++
                }
                return -1
            }

            static createTrack(e, t) {
                return {
                    container: "video" === e || "audio" === e ? "video/mp2t" : void 0,
                    type: e,
                    id: lf[e],
                    pid: -1,
                    inputTimeScale: 9e4,
                    sequenceNumber: 0,
                    samples: [],
                    dropped: 0,
                    duration: "audio" === e ? t : void 0
                }
            }

            resetInitSegment(e, t, n, r) {
                this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = Zm.createTrack("video"), this._audioTrack = Zm.createTrack("audio", r), this._id3Track = Zm.createTrack("id3"), this._txtTrack = Zm.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = n, this._duration = r
            }

            resetTimeStamp() {
            }

            resetContiguity() {
                const {_audioTrack: e, _avcTrack: t, _id3Track: n} = this;
                e && (e.pesData = null), t && (t.pesData = null), n && (n.pesData = null), this.aacOverFlow = null, this.avcSample = null, this.remainderData = null
            }

            demux(e, t, n = !1, r = !1) {
                let i;
                n || (this.sampleAes = null);
                const s = this._avcTrack, a = this._audioTrack, o = this._id3Track, l = this._txtTrack;
                let c = s.pid, u = s.pesData, d = a.pid, h = o.pid, f = a.pesData, p = o.pesData, m = null,
                    g = this.pmtParsed, y = this._pmtId, v = e.length;
                if (this.remainderData && (v = (e = bf(this.remainderData, e)).length, this.remainderData = null), v < Ym && !r) return this.remainderData = e, {
                    audioTrack: a,
                    videoTrack: s,
                    id3Track: o,
                    textTrack: l
                };
                const b = Math.max(0, Zm.syncOffset(e));
                v -= (v - b) % Ym, v < e.byteLength && !r && (this.remainderData = new Uint8Array(e.buffer, v, e.buffer.byteLength - v));
                let w = 0;
                for (let t = b; t < v; t += Ym) if (71 === e[t]) {
                    const r = !!(64 & e[t + 1]), v = Qm(e, t);
                    let w;
                    if ((48 & e[t + 3]) >> 4 > 1) {
                        if (w = t + 5 + e[t + 4], w === t + Ym) continue
                    } else w = t + 4;
                    switch (v) {
                        case c:
                            r && (u && (i = tg(u)) && this.parseAVCPES(s, l, i, !1), u = {
                                data: [],
                                size: 0
                            }), u && (u.data.push(e.subarray(w, t + Ym)), u.size += t + Ym - w);
                            break;
                        case d:
                            if (r) {
                                if (f && (i = tg(f))) switch (a.segmentCodec) {
                                    case"aac":
                                        this.parseAACPES(a, i);
                                        break;
                                    case"mp3":
                                        this.parseMPEGPES(a, i)
                                }
                                f = {data: [], size: 0}
                            }
                            f && (f.data.push(e.subarray(w, t + Ym)), f.size += t + Ym - w);
                            break;
                        case h:
                            r && (p && (i = tg(p)) && this.parseID3PES(o, i), p = {
                                data: [],
                                size: 0
                            }), p && (p.data.push(e.subarray(w, t + Ym)), p.size += t + Ym - w);
                            break;
                        case 0:
                            r && (w += e[w] + 1), y = this._pmtId = Jm(e, w);
                            break;
                        case y: {
                            r && (w += e[w] + 1);
                            const i = eg(e, w, this.typeSupported, n);
                            c = i.avc, c > 0 && (s.pid = c), d = i.audio, d > 0 && (a.pid = d, a.segmentCodec = i.segmentCodec), h = i.id3, h > 0 && (o.pid = h), null === m || g || (mh.warn(`MPEG-TS PMT found at ${t} after unknown PID '${m}'. Backtracking to sync byte @${b} to parse all TS packets.`), m = null, t = b - 188), g = this.pmtParsed = !0;
                            break
                        }
                        case 17:
                        case 8191:
                            break;
                        default:
                            m = v
                    }
                } else w++;
                if (w > 0) {
                    const e = new Error(`Found ${w} TS packet/s that do not start with 0x47`);
                    this.observer.emit(ch.ERROR, ch.ERROR, {
                        type: uh.MEDIA_ERROR,
                        details: dh.FRAG_PARSING_ERROR,
                        fatal: !1,
                        error: e,
                        reason: e.message
                    })
                }
                s.pesData = u, a.pesData = f, o.pesData = p;
                const x = {audioTrack: a, videoTrack: s, id3Track: o, textTrack: l};
                return r && this.extractRemainingSamples(x), x
            }

            flush() {
                const {remainderData: e} = this;
                let t;
                return this.remainderData = null, t = e ? this.demux(e, -1, !1, !0) : {
                    videoTrack: this._avcTrack,
                    audioTrack: this._audioTrack,
                    id3Track: this._id3Track,
                    textTrack: this._txtTrack
                }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t
            }

            extractRemainingSamples(e) {
                const {audioTrack: t, videoTrack: n, id3Track: r, textTrack: i} = e, s = n.pesData, a = t.pesData,
                    o = r.pesData;
                let l;
                if (s && (l = tg(s)) ? (this.parseAVCPES(n, i, l, !0), n.pesData = null) : n.pesData = s, a && (l = tg(a))) {
                    switch (t.segmentCodec) {
                        case"aac":
                            this.parseAACPES(t, l);
                            break;
                        case"mp3":
                            this.parseMPEGPES(t, l)
                    }
                    t.pesData = null
                } else null != a && a.size && mh.log("last AAC PES packet truncated,might overlap between fragments"), t.pesData = a;
                o && (l = tg(o)) ? (this.parseID3PES(r, l), r.pesData = null) : r.pesData = o
            }

            demuxSampleAes(e, t, n) {
                const r = this.demux(e, n, !0, !this.config.progressive),
                    i = this.sampleAes = new Vm(this.observer, this.config, t);
                return this.decrypt(r, i)
            }

            decrypt(e, t) {
                return new Promise((n => {
                    const {audioTrack: r, videoTrack: i} = e;
                    r.samples && "aac" === r.segmentCodec ? t.decryptAacSamples(r.samples, 0, (() => {
                        i.samples ? t.decryptAvcSamples(i.samples, 0, 0, (() => {
                            n(e)
                        })) : n(e)
                    })) : i.samples && t.decryptAvcSamples(i.samples, 0, 0, (() => {
                        n(e)
                    }))
                }))
            }

            destroy() {
                this._duration = 0
            }

            parseAVCPES(e, t, n, r) {
                const i = this.parseAVCNALu(e, n.data);
                let s, a = this.avcSample, o = !1;
                n.data = null, a && i.length && !e.audFound && (ng(a, e), a = this.avcSample = Xm(!1, n.pts, n.dts, "")), i.forEach((r => {
                    switch (r.type) {
                        case 1: {
                            s = !0, a || (a = this.avcSample = Xm(!0, n.pts, n.dts, "")), a.frame = !0;
                            const e = r.data;
                            if (o && e.length > 4) {
                                const t = new Wm(e).readSliceType();
                                2 !== t && 4 !== t && 7 !== t && 9 !== t || (a.key = !0)
                            }
                            break
                        }
                        case 5:
                            s = !0, a || (a = this.avcSample = Xm(!0, n.pts, n.dts, "")), a.key = !0, a.frame = !0;
                            break;
                        case 6:
                            s = !0, Ef(r.data, 1, n.pts, t.samples);
                            break;
                        case 7:
                            if (s = !0, o = !0, !e.sps) {
                                const t = r.data, n = new Wm(t).readSPS();
                                e.width = n.width, e.height = n.height, e.pixelRatio = n.pixelRatio, e.sps = [t], e.duration = this._duration;
                                const i = t.subarray(1, 4);
                                let s = "avc1.";
                                for (let e = 0; e < 3; e++) {
                                    let t = i[e].toString(16);
                                    t.length < 2 && (t = "0" + t), s += t
                                }
                                e.codec = s
                            }
                            break;
                        case 8:
                            s = !0, e.pps || (e.pps = [r.data]);
                            break;
                        case 9:
                            s = !1, e.audFound = !0, a && ng(a, e), a = this.avcSample = Xm(!1, n.pts, n.dts, "");
                            break;
                        case 12:
                            s = !0;
                            break;
                        default:
                            s = !1, a && (a.debug += "unknown NAL " + r.type + " ")
                    }
                    a && s && a.units.push(r)
                })), r && a && (ng(a, e), this.avcSample = null)
            }

            getLastNalUnit(e) {
                var t;
                let n, r = this.avcSample;
                if (r && 0 !== r.units.length || (r = e[e.length - 1]), null != (t = r) && t.units) {
                    const e = r.units;
                    n = e[e.length - 1]
                }
                return n
            }

            parseAVCNALu(e, t) {
                const n = t.byteLength;
                let r = e.naluState || 0;
                const i = r, s = [];
                let a, o, l, c = 0, u = -1, d = 0;
                for (-1 === r && (u = 0, d = 31 & t[0], r = 0, c = 1); c < n;) if (a = t[c++], r) if (1 !== r) if (a) if (1 === a) {
                    if (u >= 0) {
                        const e = {data: t.subarray(u, c - r - 1), type: d};
                        s.push(e)
                    } else {
                        const n = this.getLastNalUnit(e.samples);
                        if (n && (i && c <= 4 - i && n.state && (n.data = n.data.subarray(0, n.data.byteLength - i)), o = c - r - 1, o > 0)) {
                            const e = new Uint8Array(n.data.byteLength + o);
                            e.set(n.data, 0), e.set(t.subarray(0, o), n.data.byteLength), n.data = e, n.state = 0
                        }
                    }
                    c < n ? (l = 31 & t[c], u = c, d = l, r = 0) : r = -1
                } else r = 0; else r = 3; else r = a ? 0 : 2; else r = a ? 0 : 1;
                if (u >= 0 && r >= 0) {
                    const e = {data: t.subarray(u, n), type: d, state: r};
                    s.push(e)
                }
                if (0 === s.length) {
                    const n = this.getLastNalUnit(e.samples);
                    if (n) {
                        const e = new Uint8Array(n.data.byteLength + t.byteLength);
                        e.set(n.data, 0), e.set(t, n.data.byteLength), n.data = e
                    }
                }
                return e.naluState = r, s
            }

            parseAACPES(e, t) {
                let n = 0;
                const r = this.aacOverFlow;
                let i, s, a, o = t.data;
                if (r) {
                    this.aacOverFlow = null;
                    const t = r.missing, i = r.sample.unit.byteLength;
                    if (-1 === t) {
                        const e = new Uint8Array(i + o.byteLength);
                        e.set(r.sample.unit, 0), e.set(o, i), o = e
                    } else {
                        const s = i - t;
                        r.sample.unit.set(o.subarray(0, t), s), e.samples.push(r.sample), n = r.missing
                    }
                }
                for (i = n, s = o.length; i < s - 1 && !Pm(o, i); i++) ;
                if (i !== n) {
                    let e;
                    const t = i < s - 1;
                    e = t ? `AAC PES did not start with ADTS header,offset:${i}` : "No ADTS header found in AAC PES";
                    const n = new Error(e);
                    if (mh.warn(`parsing error: ${e}`), this.observer.emit(ch.ERROR, ch.ERROR, {
                        type: uh.MEDIA_ERROR,
                        details: dh.FRAG_PARSING_ERROR,
                        fatal: !1,
                        levelRetry: t,
                        error: n,
                        reason: e
                    }), !t) return
                }
                if (jm(e, this.observer, o, i, this.audioCodec), void 0 !== t.pts) a = t.pts; else {
                    if (!r) return void mh.warn("[tsdemuxer]: AAC PES unknown PTS");
                    {
                        const t = Im(e.samplerate);
                        a = r.sample.pts + t
                    }
                }
                let l, c = 0;
                for (; i < s;) {
                    if (l = Mm(e, o, i, a, c), i += l.length, l.missing) {
                        this.aacOverFlow = l;
                        break
                    }
                    for (c++; i < s - 1 && !Pm(o, i); i++) ;
                }
            }

            parseMPEGPES(e, t) {
                const n = t.data, r = n.length;
                let i = 0, s = 0;
                const a = t.pts;
                if (void 0 !== a) for (; s < r;) if (Gm(n, s)) {
                    const t = $m(e, n, s, a, i);
                    if (!t) break;
                    s += t.length, i++
                } else s++; else mh.warn("[tsdemuxer]: MPEG PES unknown PTS")
            }

            parseID3PES(e, t) {
                if (void 0 === t.pts) return void mh.warn("[tsdemuxer]: ID3 PES unknown PTS");
                const n = oh({}, t, {type: this._avcTrack ? up : cp, duration: Number.POSITIVE_INFINITY});
                e.samples.push(n)
            }
        }

        function Xm(e, t, n, r) {
            return {key: e, frame: !1, pts: t, dts: n, units: [], debug: r, length: 0}
        }

        function Qm(e, t) {
            return ((31 & e[t + 1]) << 8) + e[t + 2]
        }

        function Jm(e, t) {
            return (31 & e[t + 10]) << 8 | e[t + 11]
        }

        function eg(e, t, n, r) {
            const i = {audio: -1, avc: -1, id3: -1, segmentCodec: "aac"},
                s = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4;
            for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < s;) {
                const s = Qm(e, t);
                switch (e[t]) {
                    case 207:
                        if (!r) {
                            mh.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                            break
                        }
                    case 15:
                        -1 === i.audio && (i.audio = s);
                        break;
                    case 21:
                        -1 === i.id3 && (i.id3 = s);
                        break;
                    case 219:
                        if (!r) {
                            mh.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                            break
                        }
                    case 27:
                        -1 === i.avc && (i.avc = s);
                        break;
                    case 3:
                    case 4:
                        !0 !== n.mpeg && !0 !== n.mp3 ? mh.log("MPEG audio found, not supported in this browser") : -1 === i.audio && (i.audio = s, i.segmentCodec = "mp3");
                        break;
                    case 36:
                        mh.warn("Unsupported HEVC stream type found")
                }
                t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4])
            }
            return i
        }

        function tg(e) {
            let t, n, r, i, s, a = 0;
            const o = e.data;
            if (!e || 0 === e.size) return null;
            for (; o[0].length < 19 && o.length > 1;) {
                const e = new Uint8Array(o[0].length + o[1].length);
                e.set(o[0]), e.set(o[1], o[0].length), o[0] = e, o.splice(1, 1)
            }
            if (t = o[0], 1 === (t[0] << 16) + (t[1] << 8) + t[2]) {
                if (n = (t[4] << 8) + t[5], n && n > e.size - 6) return null;
                const l = t[7];
                192 & l && (i = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2, 64 & l ? (s = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2, i - s > 54e5 && (mh.warn(`${Math.round((i - s) / 9e4)}s delta between PTS and DTS, align them`), i = s)) : s = i), r = t[8];
                let c = r + 9;
                if (e.size <= c) return null;
                e.size -= c;
                const u = new Uint8Array(e.size);
                for (let e = 0, n = o.length; e < n; e++) {
                    t = o[e];
                    let n = t.byteLength;
                    if (c) {
                        if (c > n) {
                            c -= n;
                            continue
                        }
                        t = t.subarray(c), n -= c, c = 0
                    }
                    u.set(t, a), a += n
                }
                return n && (n -= r + 3), {data: u, pts: i, dts: s, len: n}
            }
            return null
        }

        function ng(e, t) {
            if (e.units.length && e.frame) {
                if (void 0 === e.pts) {
                    const n = t.samples, r = n.length;
                    if (!r) return void t.dropped++;
                    {
                        const t = n[r - 1];
                        e.pts = t.pts, e.dts = t.dts
                    }
                }
                t.samples.push(e)
            }
            e.debug.length && mh.log(e.pts + "/" + e.dts + ":" + e.debug)
        }

        class rg {
            static getSilentFrame(e, t) {
                if ("mp4a.40.2" === e) {
                    if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);
                    if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                    if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                    if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                    if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                    if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
                } else {
                    if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                    if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                    if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
                }
            }
        }

        const ig = Math.pow(2, 32) - 1;

        class sg {
            static init() {
                let e;
                for (e in sg.types = {
                    avc1: [],
                    avcC: [],
                    btrt: [],
                    dinf: [],
                    dref: [],
                    esds: [],
                    ftyp: [],
                    hdlr: [],
                    mdat: [],
                    mdhd: [],
                    mdia: [],
                    mfhd: [],
                    minf: [],
                    moof: [],
                    moov: [],
                    mp4a: [],
                    ".mp3": [],
                    mvex: [],
                    mvhd: [],
                    pasp: [],
                    sdtp: [],
                    stbl: [],
                    stco: [],
                    stsc: [],
                    stsd: [],
                    stsz: [],
                    stts: [],
                    tfdt: [],
                    tfhd: [],
                    traf: [],
                    trak: [],
                    trun: [],
                    trex: [],
                    tkhd: [],
                    vmhd: [],
                    smhd: []
                }, sg.types) sg.types.hasOwnProperty(e) && (sg.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
                const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
                    n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                sg.HDLR_TYPES = {video: t, audio: n};
                const r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
                    i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                sg.STTS = sg.STSC = sg.STCO = i, sg.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), sg.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), sg.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), sg.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                const s = new Uint8Array([105, 115, 111, 109]), a = new Uint8Array([97, 118, 99, 49]),
                    o = new Uint8Array([0, 0, 0, 1]);
                sg.FTYP = sg.box(sg.types.ftyp, s, o, s, a), sg.DINF = sg.box(sg.types.dinf, sg.box(sg.types.dref, r))
            }

            static box(e, ...t) {
                let n = 8, r = t.length;
                const i = r;
                for (; r--;) n += t[r].byteLength;
                const s = new Uint8Array(n);
                for (s[0] = n >> 24 & 255, s[1] = n >> 16 & 255, s[2] = n >> 8 & 255, s[3] = 255 & n, s.set(e, 4), r = 0, n = 8; r < i; r++) s.set(t[r], n), n += t[r].byteLength;
                return s
            }

            static hdlr(e) {
                return sg.box(sg.types.hdlr, sg.HDLR_TYPES[e])
            }

            static mdat(e) {
                return sg.box(sg.types.mdat, e)
            }

            static mdhd(e, t) {
                t *= e;
                const n = Math.floor(t / (ig + 1)), r = Math.floor(t % (ig + 1));
                return sg.box(sg.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 85, 196, 0, 0]))
            }

            static mdia(e) {
                return sg.box(sg.types.mdia, sg.mdhd(e.timescale, e.duration), sg.hdlr(e.type), sg.minf(e))
            }

            static mfhd(e) {
                return sg.box(sg.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e]))
            }

            static minf(e) {
                return "audio" === e.type ? sg.box(sg.types.minf, sg.box(sg.types.smhd, sg.SMHD), sg.DINF, sg.stbl(e)) : sg.box(sg.types.minf, sg.box(sg.types.vmhd, sg.VMHD), sg.DINF, sg.stbl(e))
            }

            static moof(e, t, n) {
                return sg.box(sg.types.moof, sg.mfhd(e), sg.traf(n, t))
            }

            static moov(e) {
                let t = e.length;
                const n = [];
                for (; t--;) n[t] = sg.trak(e[t]);
                return sg.box.apply(null, [sg.types.moov, sg.mvhd(e[0].timescale, e[0].duration)].concat(n).concat(sg.mvex(e)))
            }

            static mvex(e) {
                let t = e.length;
                const n = [];
                for (; t--;) n[t] = sg.trex(e[t]);
                return sg.box.apply(null, [sg.types.mvex, ...n])
            }

            static mvhd(e, t) {
                t *= e;
                const n = Math.floor(t / (ig + 1)), r = Math.floor(t % (ig + 1)),
                    i = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                return sg.box(sg.types.mvhd, i)
            }

            static sdtp(e) {
                const t = e.samples || [], n = new Uint8Array(4 + t.length);
                let r, i;
                for (r = 0; r < t.length; r++) i = t[r].flags, n[r + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy;
                return sg.box(sg.types.sdtp, n)
            }

            static stbl(e) {
                return sg.box(sg.types.stbl, sg.stsd(e), sg.box(sg.types.stts, sg.STTS), sg.box(sg.types.stsc, sg.STSC), sg.box(sg.types.stsz, sg.STSZ), sg.box(sg.types.stco, sg.STCO))
            }

            static avc1(e) {
                let t, n, r, i = [], s = [];
                for (t = 0; t < e.sps.length; t++) n = e.sps[t], r = n.byteLength, i.push(r >>> 8 & 255), i.push(255 & r), i = i.concat(Array.prototype.slice.call(n));
                for (t = 0; t < e.pps.length; t++) n = e.pps[t], r = n.byteLength, s.push(r >>> 8 & 255), s.push(255 & r), s = s.concat(Array.prototype.slice.call(n));
                const a = sg.box(sg.types.avcC, new Uint8Array([1, i[3], i[4], i[5], 255, 224 | e.sps.length].concat(i).concat([e.pps.length]).concat(s))),
                    o = e.width, l = e.height, c = e.pixelRatio[0], u = e.pixelRatio[1];
                return sg.box(sg.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, o >> 8 & 255, 255 & o, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), a, sg.box(sg.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), sg.box(sg.types.pasp, new Uint8Array([c >> 24, c >> 16 & 255, c >> 8 & 255, 255 & c, u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u])))
            }

            static esds(e) {
                const t = e.config.length;
                return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]))
            }

            static mp4a(e) {
                const t = e.samplerate;
                return sg.box(sg.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]), sg.box(sg.types.esds, sg.esds(e)))
            }

            static mp3(e) {
                const t = e.samplerate;
                return sg.box(sg.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]))
            }

            static stsd(e) {
                return "audio" === e.type ? "mp3" === e.segmentCodec && "mp3" === e.codec ? sg.box(sg.types.stsd, sg.STSD, sg.mp3(e)) : sg.box(sg.types.stsd, sg.STSD, sg.mp4a(e)) : sg.box(sg.types.stsd, sg.STSD, sg.avc1(e))
            }

            static tkhd(e) {
                const t = e.id, n = e.duration * e.timescale, r = e.width, i = e.height, s = Math.floor(n / (ig + 1)),
                    a = Math.floor(n % (ig + 1));
                return sg.box(sg.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0, i >> 8 & 255, 255 & i, 0, 0]))
            }

            static traf(e, t) {
                const n = sg.sdtp(e), r = e.id, i = Math.floor(t / (ig + 1)), s = Math.floor(t % (ig + 1));
                return sg.box(sg.types.traf, sg.box(sg.types.tfhd, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), sg.box(sg.types.tfdt, new Uint8Array([1, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), sg.trun(e, n.length + 16 + 20 + 8 + 16 + 8 + 8), n)
            }

            static trak(e) {
                return e.duration = e.duration || 4294967295, sg.box(sg.types.trak, sg.tkhd(e), sg.mdia(e))
            }

            static trex(e) {
                const t = e.id;
                return sg.box(sg.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
            }

            static trun(e, t) {
                const n = e.samples || [], r = n.length, i = 12 + 16 * r, s = new Uint8Array(i);
                let a, o, l, c, u, d;
                for (t += 8 + i, s.set(["video" === e.type ? 1 : 0, 0, 15, 1, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0), a = 0; a < r; a++) o = n[a], l = o.duration, c = o.size, u = o.flags, d = o.cts, s.set([l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l, c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, 255 & c, u.isLeading << 2 | u.dependsOn, u.isDependedOn << 6 | u.hasRedundancy << 4 | u.paddingValue << 1 | u.isNonSync, 61440 & u.degradPrio, 15 & u.degradPrio, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d], 12 + 16 * a);
                return sg.box(sg.types.trun, s)
            }

            static initSegment(e) {
                sg.types || sg.init();
                const t = sg.moov(e), n = new Uint8Array(sg.FTYP.byteLength + t.byteLength);
                return n.set(sg.FTYP), n.set(t, sg.FTYP.byteLength), n
            }
        }

        sg.types = void 0, sg.HDLR_TYPES = void 0, sg.STTS = void 0, sg.STSC = void 0, sg.STCO = void 0, sg.STSZ = void 0, sg.VMHD = void 0, sg.SMHD = void 0, sg.STSD = void 0, sg.FTYP = void 0, sg.DINF = void 0;

        function ag(e, t, n = 1, r = !1) {
            const i = e * t * n;
            return r ? Math.round(i) : i
        }

        function og(e, t = !1) {
            return ag(e, 1e3, 1 / 9e4, t)
        }

        let lg, cg = null, ug = null;

        class dg {
            constructor(e, t, n, r = "") {
                if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = e, this.config = t, this.typeSupported = n, this.ISGenerated = !1, null === cg) {
                    const e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
                    cg = e ? parseInt(e[1]) : 0
                }
                if (null === ug) {
                    const e = navigator.userAgent.match(/Safari\/(\d+)/i);
                    ug = e ? parseInt(e[1]) : 0
                }
            }

            destroy() {
            }

            resetTimeStamp(e) {
                mh.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e
            }

            resetNextTimestamp() {
                mh.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
            }

            resetInitSegment() {
                mh.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1
            }

            getVideoStartPts(e) {
                let t = !1;
                const n = e.reduce(((e, n) => {
                    const r = n.pts - e;
                    return r < -4294967296 ? (t = !0, hg(e, n.pts)) : r > 0 ? e : n.pts
                }), e[0].pts);
                return t && mh.debug("PTS rollover detected"), n
            }

            remux(e, t, n, r, i, s, a, o) {
                let l, c, u, d, h, f, p = i, m = i;
                const g = e.pid > -1, y = t.pid > -1, v = t.samples.length, b = e.samples.length > 0,
                    w = a && v > 0 || v > 1;
                if ((!g || b) && (!y || w) || this.ISGenerated || a) {
                    this.ISGenerated || (u = this.generateIS(e, t, i, s));
                    const n = this.isVideoContiguous;
                    let r, a = -1;
                    if (w && (a = function (e) {
                        for (let t = 0; t < e.length; t++) if (e[t].key) return t;
                        return -1
                    }(t.samples), !n && this.config.forceKeyFrameOnDiscontinuity)) if (f = !0, a > 0) {
                        mh.warn(`[mp4-remuxer]: Dropped ${a} out of ${v} video samples due to a missing keyframe`);
                        const e = this.getVideoStartPts(t.samples);
                        t.samples = t.samples.slice(a), t.dropped += a, m += (t.samples[0].pts - e) / t.inputTimeScale, r = m
                    } else -1 === a && (mh.warn(`[mp4-remuxer]: No keyframe found out of ${v} video samples`), f = !1);
                    if (this.ISGenerated) {
                        if (b && w) {
                            const n = this.getVideoStartPts(t.samples),
                                r = (hg(e.samples[0].pts, n) - n) / t.inputTimeScale;
                            p += Math.max(0, r), m += Math.max(0, -r)
                        }
                        if (b) {
                            if (e.samplerate || (mh.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), u = this.generateIS(e, t, i, s)), c = this.remuxAudio(e, p, this.isAudioContiguous, s, y || w || o === ep ? m : void 0), w) {
                                const r = c ? c.endPTS - c.startPTS : 0;
                                t.inputTimeScale || (mh.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), u = this.generateIS(e, t, i, s)), l = this.remuxVideo(t, m, n, r)
                            }
                        } else w && (l = this.remuxVideo(t, m, n, 0));
                        l && (l.firstKeyFrame = a, l.independent = -1 !== a, l.firstKeyFramePTS = r)
                    }
                }
                return this.ISGenerated && this._initPTS && this._initDTS && (n.samples.length && (h = fg(n, i, this._initPTS, this._initDTS)), r.samples.length && (d = pg(r, i, this._initPTS))), {
                    audio: c,
                    video: l,
                    initSegment: u,
                    independent: f,
                    text: d,
                    id3: h
                }
            }

            generateIS(e, t, n, r) {
                const i = e.samples, s = t.samples, a = this.typeSupported, o = {}, l = this._initPTS;
                let c, u, d, h = !l || r, f = "audio/mp4";
                if (h && (c = u = 1 / 0), e.config && i.length && (e.timescale = e.samplerate, "mp3" === e.segmentCodec && (a.mpeg ? (f = "audio/mpeg", e.codec = "") : a.mp3 && (e.codec = "mp3")), o.audio = {
                    id: "audio",
                    container: f,
                    codec: e.codec,
                    initSegment: "mp3" === e.segmentCodec && a.mpeg ? new Uint8Array(0) : sg.initSegment([e]),
                    metadata: {channelCount: e.channelCount}
                }, h && (d = e.inputTimeScale, l && d === l.timescale ? h = !1 : c = u = i[0].pts - Math.round(d * n))), t.sps && t.pps && s.length && (t.timescale = t.inputTimeScale, o.video = {
                    id: "main",
                    container: "video/mp4",
                    codec: t.codec,
                    initSegment: sg.initSegment([t]),
                    metadata: {width: t.width, height: t.height}
                }, h)) if (d = t.inputTimeScale, l && d === l.timescale) h = !1; else {
                    const e = this.getVideoStartPts(s), t = Math.round(d * n);
                    u = Math.min(u, hg(s[0].dts, e) - t), c = Math.min(c, e - t)
                }
                if (Object.keys(o).length) return this.ISGenerated = !0, h ? (this._initPTS = {
                    baseTime: c,
                    timescale: d
                }, this._initDTS = {baseTime: u, timescale: d}) : c = d = void 0, {tracks: o, initPTS: c, timescale: d}
            }

            remuxVideo(e, t, n, r) {
                const i = e.inputTimeScale, s = e.samples, a = [], o = s.length, l = this._initPTS;
                let c, u, d = this.nextAvcDts, h = 8, f = this.videoSampleDuration, p = Number.POSITIVE_INFINITY,
                    m = Number.NEGATIVE_INFINITY, g = !1;
                n && null !== d || (d = t * i - (s[0].pts - hg(s[0].dts, s[0].pts)));
                const y = l.baseTime * i / l.timescale;
                for (let e = 0; e < o; e++) {
                    const t = s[e];
                    t.pts = hg(t.pts - y, d), t.dts = hg(t.dts - y, d), t.dts < s[e > 0 ? e - 1 : e].dts && (g = !0)
                }
                g && s.sort((function (e, t) {
                    const n = e.dts - t.dts, r = e.pts - t.pts;
                    return n || r
                })), c = s[0].dts, u = s[s.length - 1].dts;
                const v = u - c, b = v ? Math.round(v / (o - 1)) : f || e.inputTimeScale / 30;
                if (n) {
                    const e = c - d, t = e > b, n = e < -1;
                    if ((t || n) && (t ? mh.warn(`AVC: ${og(e, !0)} ms (${e}dts) hole between fragments detected, filling it`) : mh.warn(`AVC: ${og(-e, !0)} ms (${e}dts) overlapping between fragments detected`), !n || d >= s[0].pts)) {
                        c = d;
                        const t = s[0].pts - e;
                        s[0].dts = c, s[0].pts = t, mh.log(`Video: First PTS/DTS adjusted: ${og(t, !0)}/${og(c, !0)}, delta: ${og(e, !0)} ms`)
                    }
                }
                c = Math.max(0, c);
                let w = 0, x = 0;
                for (let e = 0; e < o; e++) {
                    const t = s[e], n = t.units, r = n.length;
                    let i = 0;
                    for (let e = 0; e < r; e++) i += n[e].data.length;
                    x += i, w += r, t.length = i, t.dts = Math.max(t.dts, c), p = Math.min(t.pts, p), m = Math.max(t.pts, m)
                }
                u = s[o - 1].dts;
                const E = x + 4 * w + 8;
                let S;
                try {
                    S = new Uint8Array(E)
                } catch (e) {
                    return void this.observer.emit(ch.ERROR, ch.ERROR, {
                        type: uh.MUX_ERROR,
                        details: dh.REMUX_ALLOC_ERROR,
                        fatal: !1,
                        error: e,
                        bytes: E,
                        reason: `fail allocating video mdat ${E}`
                    })
                }
                const k = new DataView(S.buffer);
                k.setUint32(0, E), S.set(sg.types.mdat, 4);
                let A = !1, T = Number.POSITIVE_INFINITY, C = Number.POSITIVE_INFINITY, R = Number.NEGATIVE_INFINITY,
                    L = Number.NEGATIVE_INFINITY;
                for (let e = 0; e < o; e++) {
                    const t = s[e], n = t.units;
                    let l, c = 0;
                    for (let e = 0, t = n.length; e < t; e++) {
                        const t = n[e], r = t.data, i = t.data.byteLength;
                        k.setUint32(h, i), h += 4, S.set(r, h), h += i, c += 4 + i
                    }
                    if (e < o - 1) f = s[e + 1].dts - t.dts, l = s[e + 1].pts - t.pts; else {
                        const n = this.config, a = e > 0 ? t.dts - s[e - 1].dts : b;
                        if (l = e > 0 ? t.pts - s[e - 1].pts : b, n.stretchShortVideoTrack && null !== this.nextAudioPts) {
                            const e = Math.floor(n.maxBufferHole * i), s = (r ? p + r * i : this.nextAudioPts) - t.pts;
                            s > e ? (f = s - a, f < 0 ? f = a : A = !0, mh.log(`[mp4-remuxer]: It is approximately ${s / 90} ms to the next segment; using duration ${f / 90} ms for the last video frame.`)) : f = a
                        } else f = a
                    }
                    const u = Math.round(t.pts - t.dts);
                    T = Math.min(T, f), R = Math.max(R, f), C = Math.min(C, l), L = Math.max(L, l), a.push(new mg(t.key, f, c, u))
                }
                if (a.length) if (cg) {
                    if (cg < 70) {
                        const e = a[0].flags;
                        e.dependsOn = 2, e.isNonSync = 0
                    }
                } else if (ug && L - C < R - T && b / R < .025 && 0 === a[0].cts) {
                    mh.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                    let e = c;
                    for (let t = 0, n = a.length; t < n; t++) {
                        const r = e + a[t].duration, i = e + a[t].cts;
                        if (t < n - 1) {
                            const e = r + a[t + 1].cts;
                            a[t].duration = e - i
                        } else a[t].duration = t ? a[t - 1].duration : b;
                        a[t].cts = 0, e = r
                    }
                }
                f = A || !f ? b : f, this.nextAvcDts = d = u + f, this.videoSampleDuration = f, this.isVideoContiguous = !0;
                const _ = {
                    data1: sg.moof(e.sequenceNumber++, c, oh({}, e, {samples: a})),
                    data2: S,
                    startPTS: p / i,
                    endPTS: (m + f) / i,
                    startDTS: c / i,
                    endDTS: d / i,
                    type: "video",
                    hasAudio: !1,
                    hasVideo: !0,
                    nb: a.length,
                    dropped: e.dropped
                };
                return e.samples = [], e.dropped = 0, _
            }

            remuxAudio(e, t, n, r, i) {
                const s = e.inputTimeScale, a = s / (e.samplerate ? e.samplerate : s),
                    o = "aac" === e.segmentCodec ? 1024 : 1152, l = o * a, c = this._initPTS,
                    u = "mp3" === e.segmentCodec && this.typeSupported.mpeg, d = [], h = void 0 !== i;
                let f = e.samples, p = u ? 0 : 8, m = this.nextAudioPts || -1;
                const g = t * s, y = c.baseTime * s / c.timescale;
                if (this.isAudioContiguous = n = n || f.length && m > 0 && (r && Math.abs(g - m) < 9e3 || Math.abs(hg(f[0].pts - y, g) - m) < 20 * l), f.forEach((function (e) {
                    e.pts = hg(e.pts - y, g)
                })), !n || m < 0) {
                    if (f = f.filter((e => e.pts >= 0)), !f.length) return;
                    m = 0 === i ? 0 : r && !h ? Math.max(0, g) : f[0].pts
                }
                if ("aac" === e.segmentCodec) {
                    const t = this.config.maxAudioFramesDrift;
                    for (let n = 0, r = m; n < f.length; n++) {
                        const i = f[n], a = i.pts, o = a - r, c = Math.abs(1e3 * o / s);
                        if (o <= -t * l && h) 0 === n && (mh.warn(`Audio frame @ ${(a / s).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * o / s)} ms.`), this.nextAudioPts = m = r = a); else if (o >= t * l && c < 1e4 && h) {
                            let t = Math.round(o / l);
                            r = a - t * l, r < 0 && (t--, r += l), 0 === n && (this.nextAudioPts = m = r), mh.warn(`[mp4-remuxer]: Injecting ${t} audio frame @ ${(r / s).toFixed(3)}s due to ${Math.round(1e3 * o / s)} ms gap.`);
                            for (let s = 0; s < t; s++) {
                                const t = Math.max(r, 0);
                                let s = rg.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
                                s || (mh.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), s = i.unit.subarray()), f.splice(n, 0, {
                                    unit: s,
                                    pts: t
                                }), r += l, n++
                            }
                        }
                        i.pts = r, r += l
                    }
                }
                let v, b = null, w = null, x = 0, E = f.length;
                for (; E--;) x += f[E].unit.byteLength;
                for (let t = 0, r = f.length; t < r; t++) {
                    const r = f[t], i = r.unit;
                    let s = r.pts;
                    if (null !== w) d[t - 1].duration = Math.round((s - w) / a); else {
                        if (n && "aac" === e.segmentCodec && (s = m), b = s, !(x > 0)) return;
                        x += p;
                        try {
                            v = new Uint8Array(x)
                        } catch (e) {
                            return void this.observer.emit(ch.ERROR, ch.ERROR, {
                                type: uh.MUX_ERROR,
                                details: dh.REMUX_ALLOC_ERROR,
                                fatal: !1,
                                error: e,
                                bytes: x,
                                reason: `fail allocating audio mdat ${x}`
                            })
                        }
                        u || (new DataView(v.buffer).setUint32(0, x), v.set(sg.types.mdat, 4))
                    }
                    v.set(i, p);
                    const l = i.byteLength;
                    p += l, d.push(new mg(!0, o, l, 0)), w = s
                }
                const S = d.length;
                if (!S) return;
                const k = d[d.length - 1];
                this.nextAudioPts = m = w + a * k.duration;
                const A = u ? new Uint8Array(0) : sg.moof(e.sequenceNumber++, b / a, oh({}, e, {samples: d}));
                e.samples = [];
                const T = b / s, C = m / s, R = {
                    data1: A,
                    data2: v,
                    startPTS: T,
                    endPTS: C,
                    startDTS: T,
                    endDTS: C,
                    type: "audio",
                    hasAudio: !0,
                    hasVideo: !1,
                    nb: S
                };
                return this.isAudioContiguous = !0, R
            }

            remuxEmptyAudio(e, t, n, r) {
                const i = e.inputTimeScale, s = i / (e.samplerate ? e.samplerate : i), a = this.nextAudioPts,
                    o = this._initDTS, l = 9e4 * o.baseTime / o.timescale, c = (null !== a ? a : r.startDTS * i) + l,
                    u = r.endDTS * i + l, d = 1024 * s, h = Math.ceil((u - c) / d),
                    f = rg.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
                if (mh.warn("[mp4-remuxer]: remux empty Audio"), !f) return void mh.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
                const p = [];
                for (let e = 0; e < h; e++) {
                    const t = c + e * d;
                    p.push({unit: f, pts: t, dts: t})
                }
                return e.samples = p, this.remuxAudio(e, t, n, !1)
            }
        }

        function hg(e, t) {
            let n;
            if (null === t) return e;
            for (n = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;) e += n;
            return e
        }

        function fg(e, t, n, r) {
            const i = e.samples.length;
            if (!i) return;
            const s = e.inputTimeScale;
            for (let a = 0; a < i; a++) {
                const i = e.samples[a];
                i.pts = hg(i.pts - n.baseTime * s / n.timescale, t * s) / s, i.dts = hg(i.dts - r.baseTime * s / r.timescale, t * s) / s
            }
            const a = e.samples;
            return e.samples = [], {samples: a}
        }

        function pg(e, t, n) {
            const r = e.samples.length;
            if (!r) return;
            const i = e.inputTimeScale;
            for (let s = 0; s < r; s++) {
                const r = e.samples[s];
                r.pts = hg(r.pts - 9e4 * n.baseTime / n.timescale, t * i) / i
            }
            e.samples.sort(((e, t) => e.pts - t.pts));
            const s = e.samples;
            return e.samples = [], {samples: s}
        }

        class mg {
            constructor(e, t, n, r) {
                this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = n, this.cts = r, this.flags = new gg(e)
            }
        }

        class gg {
            constructor(e) {
                this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = e ? 2 : 1, this.isNonSync = e ? 0 : 1
            }
        }

        function yg(e, t) {
            const n = null == e ? void 0 : e.codec;
            return n && n.length > 4 ? n : "hvc1" === n || "hev1" === n ? "hvc1.1.6.L120.90" : "av01" === n ? "av01.0.04M.08" : "avc1" === n || t === Sh ? "avc1.42e01e" : "mp4a.40.5"
        }

        try {
            lg = self.performance.now.bind(self.performance)
        } catch (e) {
            mh.debug("Unable to use Performance API on this environment"), lg = "undefined" != typeof self && self.Date.now
        }
        const vg = [{
            demux: class {
                constructor(e, t) {
                    this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t
                }

                resetTimeStamp() {
                }

                resetInitSegment(e, t, n, r) {
                    const i = this.videoTrack = Am("video", 1), s = this.audioTrack = Am("audio", 1),
                        a = this.txtTrack = Am("text", 1);
                    if (this.id3Track = Am("id3", 1), this.timeOffset = 0, null == e || !e.byteLength) return;
                    const o = gf(e);
                    if (o.video) {
                        const {id: e, timescale: t, codec: n} = o.video;
                        i.id = e, i.timescale = a.timescale = t, i.codec = n
                    }
                    if (o.audio) {
                        const {id: e, timescale: t, codec: n} = o.audio;
                        s.id = e, s.timescale = t, s.codec = n
                    }
                    a.id = lf.text, i.sampleDuration = 0, i.duration = s.duration = r
                }

                resetContiguity() {
                    this.remainderData = null
                }

                static probe(e) {
                    return pf(e = e.length > 16384 ? e.subarray(0, 16384) : e, ["moof"]).length > 0
                }

                demux(e, t) {
                    this.timeOffset = t;
                    let n = e;
                    const r = this.videoTrack, i = this.txtTrack;
                    if (this.config.progressive) {
                        this.remainderData && (n = bf(this.remainderData, e));
                        const t = function (e) {
                            const t = {valid: null, remainder: null}, n = pf(e, ["moof"]);
                            if (!n) return t;
                            if (n.length < 2) return t.remainder = e, t;
                            const r = n[n.length - 1];
                            return t.valid = Hh(e, 0, r.byteOffset - 8), t.remainder = Hh(e, r.byteOffset - 8), t
                        }(n);
                        this.remainderData = t.remainder, r.samples = t.valid || new Uint8Array
                    } else r.samples = n;
                    const s = this.extractID3Track(r, t);
                    return i.samples = wf(t, r), {
                        videoTrack: r,
                        audioTrack: this.audioTrack,
                        id3Track: s,
                        textTrack: this.txtTrack
                    }
                }

                flush() {
                    const e = this.timeOffset, t = this.videoTrack, n = this.txtTrack;
                    t.samples = this.remainderData || new Uint8Array, this.remainderData = null;
                    const r = this.extractID3Track(t, this.timeOffset);
                    return n.samples = wf(e, t), {videoTrack: t, audioTrack: Am(), id3Track: r, textTrack: Am()}
                }

                extractID3Track(e, t) {
                    const n = this.id3Track;
                    if (e.samples.length) {
                        const r = pf(e.samples, ["emsg"]);
                        r && r.forEach((e => {
                            const r = function (e) {
                                const t = e[0];
                                let n = "", r = "", i = 0, s = 0, a = 0, o = 0, l = 0, c = 0;
                                if (0 === t) {
                                    for (; "\0" !== cf(e.subarray(c, c + 1));) n += cf(e.subarray(c, c + 1)), c += 1;
                                    for (n += cf(e.subarray(c, c + 1)), c += 1; "\0" !== cf(e.subarray(c, c + 1));) r += cf(e.subarray(c, c + 1)), c += 1;
                                    r += cf(e.subarray(c, c + 1)), c += 1, i = df(e, 12), s = df(e, 16), o = df(e, 20), l = df(e, 24), c = 28
                                } else if (1 === t) {
                                    c += 4, i = df(e, c), c += 4;
                                    const t = df(e, c);
                                    c += 4;
                                    const s = df(e, c);
                                    for (c += 4, a = 2 ** 32 * t + s, Number.isSafeInteger(a) || (a = Number.MAX_SAFE_INTEGER, mh.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = df(e, c), c += 4, l = df(e, c), c += 4; "\0" !== cf(e.subarray(c, c + 1));) n += cf(e.subarray(c, c + 1)), c += 1;
                                    for (n += cf(e.subarray(c, c + 1)), c += 1; "\0" !== cf(e.subarray(c, c + 1));) r += cf(e.subarray(c, c + 1)), c += 1;
                                    r += cf(e.subarray(c, c + 1)), c += 1
                                }
                                return {
                                    schemeIdUri: n,
                                    value: r,
                                    timeScale: i,
                                    presentationTime: a,
                                    presentationTimeDelta: s,
                                    eventDuration: o,
                                    id: l,
                                    payload: e.subarray(c, e.byteLength)
                                }
                            }(e);
                            if (Dm.test(r.schemeIdUri)) {
                                const e = lh(r.presentationTime) ? r.presentationTime / r.timeScale : t + r.presentationTimeDelta / r.timeScale;
                                let i = 4294967295 === r.eventDuration ? Number.POSITIVE_INFINITY : r.eventDuration / r.timeScale;
                                i <= .001 && (i = Number.POSITIVE_INFINITY);
                                const s = r.payload;
                                n.samples.push({data: s, len: s.byteLength, dts: e, pts: e, type: up, duration: i})
                            }
                        }))
                    }
                    return n
                }

                demuxSampleAes(e, t, n) {
                    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
                }

                destroy() {
                }
            }, remux: class {
                constructor() {
                    this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null
                }

                destroy() {
                }

                resetTimeStamp(e) {
                    this.initPTS = e, this.lastEndTime = null
                }

                resetNextTimestamp() {
                    this.lastEndTime = null
                }

                resetInitSegment(e, t, n, r) {
                    this.audioCodec = t, this.videoCodec = n, this.generateInitSegment(function (e, t) {
                        if (!e || !t) return e;
                        const n = t.keyId;
                        return n && t.isCommonEncryption && pf(e, ["moov", "trak"]).forEach((e => {
                            const t = pf(e, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
                            let r = pf(t, ["enca"]);
                            const i = r.length > 0;
                            i || (r = pf(t, ["encv"])), r.forEach((e => {
                                pf(i ? e.subarray(28) : e.subarray(78), ["sinf"]).forEach((e => {
                                    const t = yf(e);
                                    if (t) {
                                        const e = t.subarray(8, 24);
                                        e.some((e => 0 !== e)) || (mh.log(`[eme] Patching keyId in 'enc${i ? "a" : "v"}>sinf>>tenc' box: ${sf(e)} -> ${sf(n)}`), t.set(n, 8))
                                    }
                                }))
                            }))
                        })), e
                    }(e, r)), this.emitInitSegment = !0
                }

                generateInitSegment(e) {
                    let {audioCodec: t, videoCodec: n} = this;
                    if (null == e || !e.byteLength) return this.initTracks = void 0, void (this.initData = void 0);
                    const r = this.initData = gf(e);
                    t || (t = yg(r.audio, Eh)), n || (n = yg(r.video, Sh));
                    const i = {};
                    r.audio && r.video ? i.audiovideo = {
                        container: "video/mp4",
                        codec: t + "," + n,
                        initSegment: e,
                        id: "main"
                    } : r.audio ? i.audio = {
                        container: "audio/mp4",
                        codec: t,
                        initSegment: e,
                        id: "audio"
                    } : r.video ? i.video = {
                        container: "video/mp4",
                        codec: n,
                        initSegment: e,
                        id: "main"
                    } : mh.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = i
                }

                remux(e, t, n, r, i, s) {
                    var a, o;
                    let {initPTS: l, lastEndTime: c} = this;
                    const u = {audio: void 0, video: void 0, text: r, id3: n, initSegment: void 0};
                    lh(c) || (c = this.lastEndTime = i || 0);
                    const d = t.samples;
                    if (null == d || !d.length) return u;
                    const h = {initPTS: void 0, timescale: 1};
                    let f = this.initData;
                    if (null != (a = f) && a.length || (this.generateInitSegment(d), f = this.initData), null == (o = f) || !o.length) return mh.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), u;
                    this.emitInitSegment && (h.tracks = this.initTracks, this.emitInitSegment = !1);
                    const p = function (e, t) {
                        let n = 0, r = 0, i = 0;
                        const s = pf(e, ["moof", "traf"]);
                        for (let e = 0; e < s.length; e++) {
                            const a = s[e], o = pf(a, ["tfhd"])[0], l = t[df(o, 4)];
                            if (!l) continue;
                            const c = l.default, u = df(o, 0) | (null == c ? void 0 : c.flags);
                            let d = null == c ? void 0 : c.duration;
                            8 & u && (d = df(o, 2 & u ? 12 : 8));
                            const h = l.timescale || 9e4, f = pf(a, ["trun"]);
                            for (let e = 0; e < f.length; e++) n = vf(f[e]), !n && d && (n = d * df(f[e], 4)), l.type === Sh ? r += n / h : l.type === Eh && (i += n / h)
                        }
                        if (0 === r && 0 === i) {
                            let t = 0;
                            const n = pf(e, ["sidx"]);
                            for (let e = 0; e < n.length; e++) {
                                const r = mf(n[e]);
                                null != r && r.references && (t += r.references.reduce(((e, t) => e + t.info.duration || 0), 0))
                            }
                            return t
                        }
                        return r || i
                    }(d, f), m = function (e, t) {
                        return pf(t, ["moof", "traf"]).reduce(((t, n) => {
                            const r = pf(n, ["tfdt"])[0], i = r[0], s = pf(n, ["tfhd"]).reduce(((t, n) => {
                                const s = df(n, 4), a = e[s];
                                if (a) {
                                    let e = df(r, 4);
                                    if (1 === i) {
                                        if (e === af) return mh.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"), t;
                                        e *= af + 1, e += df(r, 8)
                                    }
                                    const n = e / (a.timescale || 9e4);
                                    if (isFinite(n) && (null === t || n < t)) return n
                                }
                                return t
                            }), null);
                            return null !== s && isFinite(s) && (null === t || s < t) ? s : t
                        }), null)
                    }(f, d), g = null === m ? i : m;
                    (function (e, t, n, r) {
                        if (null === e) return !0;
                        const i = Math.max(r, 1), s = t - e.baseTime / e.timescale;
                        return Math.abs(s - n) > i
                    }(l, g, i, p) || h.timescale !== l.timescale && s) && (h.initPTS = g - i, l && 1 === l.timescale && mh.warn("Adjusting initPTS by " + (h.initPTS - l.baseTime)), this.initPTS = l = {
                        baseTime: h.initPTS,
                        timescale: 1
                    });
                    const y = e ? g - l.baseTime / l.timescale : c, v = y + p;
                    !function (e, t, n) {
                        pf(t, ["moof", "traf"]).forEach((t => {
                            pf(t, ["tfhd"]).forEach((r => {
                                const i = df(r, 4), s = e[i];
                                if (!s) return;
                                const a = s.timescale || 9e4;
                                pf(t, ["tfdt"]).forEach((e => {
                                    const t = e[0];
                                    let r = df(e, 4);
                                    if (0 === t) r -= n * a, r = Math.max(r, 0), ff(e, 4, r); else {
                                        r *= Math.pow(2, 32), r += df(e, 8), r -= n * a, r = Math.max(r, 0);
                                        const t = Math.floor(r / (af + 1)), i = Math.floor(r % (af + 1));
                                        ff(e, 4, t), ff(e, 8, i)
                                    }
                                }))
                            }))
                        }))
                    }(f, d, l.baseTime / l.timescale), p > 0 ? this.lastEndTime = v : (mh.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
                    const b = !!f.audio, w = !!f.video;
                    let x = "";
                    b && (x += "audio"), w && (x += "video");
                    const E = {
                        data1: d,
                        startPTS: y,
                        startDTS: y,
                        endPTS: v,
                        endDTS: v,
                        type: x,
                        hasAudio: b,
                        hasVideo: w,
                        nb: 1,
                        dropped: 0
                    };
                    return u.audio = "audio" === E.type ? E : void 0, u.video = "audio" !== E.type ? E : void 0, u.initSegment = h, u.id3 = fg(n, i, l, l), r.samples.length && (u.text = pg(r, i, l)), u
                }
            }
        }, {demux: Zm, remux: dg}, {
            demux: class extends Tm {
                constructor(e, t) {
                    super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t
                }

                resetInitSegment(e, t, n, r) {
                    super.resetInitSegment(e, t, n, r), this._audioTrack = {
                        container: "audio/adts",
                        type: "audio",
                        id: 2,
                        pid: -1,
                        sequenceNumber: 0,
                        segmentCodec: "aac",
                        samples: [],
                        manifestCodec: t,
                        duration: r,
                        inputTimeScale: 9e4,
                        dropped: 0
                    }
                }

                static probe(e) {
                    if (!e) return !1;
                    let t = (zh(e, 0) || []).length;
                    for (let n = e.length; t < n; t++) if (Nm(e, t)) return mh.log("ADTS sync word found !"), !0;
                    return !1
                }

                canParse(e, t) {
                    return function (e, t) {
                        return function (e, t) {
                            return t + 5 < e.length
                        }(e, t) && Rm(e, t) && _m(e, t) <= e.length - t
                    }(e, t)
                }

                appendFrame(e, t, n) {
                    jm(e, this.observer, t, n, e.manifestCodec);
                    const r = Mm(e, t, n, this.basePTS, this.frameIndex);
                    if (r && 0 === r.missing) return r
                }
            }, remux: dg
        }, {
            demux: class extends Tm {
                resetInitSegment(e, t, n, r) {
                    super.resetInitSegment(e, t, n, r), this._audioTrack = {
                        container: "audio/mpeg",
                        type: "audio",
                        id: 2,
                        pid: -1,
                        sequenceNumber: 0,
                        segmentCodec: "mp3",
                        samples: [],
                        manifestCodec: t,
                        duration: r,
                        inputTimeScale: 9e4,
                        dropped: 0
                    }
                }

                static probe(e) {
                    if (!e) return !1;
                    let t = (zh(e, 0) || []).length;
                    for (let n = e.length; t < n; t++) if (qm(e, t)) return mh.log("MPEG Audio sync word found !"), !0;
                    return !1
                }

                canParse(e, t) {
                    return function (e, t) {
                        return zm(e, t) && 4 <= e.length - t
                    }(e, t)
                }

                appendFrame(e, t, n) {
                    if (null !== this.basePTS) return $m(e, t, n, this.basePTS, this.frameIndex)
                }
            }, remux: dg
        }];

        class bg {
            constructor(e, t, n, r, i) {
                this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = n, this.vendor = r, this.id = i
            }

            configure(e) {
                this.transmuxConfig = e, this.decrypter && this.decrypter.reset()
            }

            push(e, t, n, r) {
                const i = n.transmuxing;
                i.executeStart = lg();
                let s = new Uint8Array(e);
                const {currentTransmuxState: a, transmuxConfig: o} = this;
                r && (this.currentTransmuxState = r);
                const {
                        contiguous: l,
                        discontinuity: c,
                        trackSwitch: u,
                        accurateTimeOffset: d,
                        timeOffset: h,
                        initSegmentChange: f
                    } = r || a, {audioCodec: p, videoCodec: m, defaultInitPts: g, duration: y, initSegmentData: v} = o,
                    b = function (e, t) {
                        let n = null;
                        return e.byteLength > 0 && null != t && null != t.key && null !== t.iv && null != t.method && (n = t), n
                    }(s, t);
                if (b && "AES-128" === b.method) {
                    const e = this.getDecrypter();
                    if (!e.isSync()) return this.decryptionPromise = e.webCryptoDecrypt(s, b.key.buffer, b.iv.buffer).then((e => {
                        const t = this.push(e, null, n);
                        return this.decryptionPromise = null, t
                    })), this.decryptionPromise;
                    {
                        let t = e.softwareDecrypt(s, b.key.buffer, b.iv.buffer);
                        if (n.part > -1 && (t = e.flush()), !t) return i.executeEnd = lg(), wg(n);
                        s = new Uint8Array(t)
                    }
                }
                const w = this.needsProbing(c, u);
                if (w) {
                    const e = this.configureTransmuxer(s);
                    if (e) return mh.warn(`[transmuxer] ${e.message}`), this.observer.emit(ch.ERROR, ch.ERROR, {
                        type: uh.MEDIA_ERROR,
                        details: dh.FRAG_PARSING_ERROR,
                        fatal: !1,
                        error: e,
                        reason: e.message
                    }), i.executeEnd = lg(), wg(n)
                }
                (c || u || f || w) && this.resetInitSegment(v, p, m, y, t), (c || f || w) && this.resetInitialTimestamp(g), l || this.resetContiguity();
                const x = this.transmux(s, b, h, d, n), E = this.currentTransmuxState;
                return E.contiguous = !0, E.discontinuity = !1, E.trackSwitch = !1, i.executeEnd = lg(), x
            }

            flush(e) {
                const t = e.transmuxing;
                t.executeStart = lg();
                const {decrypter: n, currentTransmuxState: r, decryptionPromise: i} = this;
                if (i) return i.then((() => this.flush(e)));
                const s = [], {timeOffset: a} = r;
                if (n) {
                    const t = n.flush();
                    t && s.push(this.push(t, null, e))
                }
                const {demuxer: o, remuxer: l} = this;
                if (!o || !l) return t.executeEnd = lg(), [wg(e)];
                const c = o.flush(a);
                return xg(c) ? c.then((t => (this.flushRemux(s, t, e), s))) : (this.flushRemux(s, c, e), s)
            }

            flushRemux(e, t, n) {
                const {audioTrack: r, videoTrack: i, id3Track: s, textTrack: a} = t, {
                    accurateTimeOffset: o,
                    timeOffset: l
                } = this.currentTransmuxState;
                mh.log(`[transmuxer.ts]: Flushed fragment ${n.sn}${n.part > -1 ? " p: " + n.part : ""} of level ${n.level}`);
                const c = this.remuxer.remux(r, i, s, a, l, o, !0, this.id);
                e.push({remuxResult: c, chunkMeta: n}), n.transmuxing.executeEnd = lg()
            }

            resetInitialTimestamp(e) {
                const {demuxer: t, remuxer: n} = this;
                t && n && (t.resetTimeStamp(e), n.resetTimeStamp(e))
            }

            resetContiguity() {
                const {demuxer: e, remuxer: t} = this;
                e && t && (e.resetContiguity(), t.resetNextTimestamp())
            }

            resetInitSegment(e, t, n, r, i) {
                const {demuxer: s, remuxer: a} = this;
                s && a && (s.resetInitSegment(e, t, n, r), a.resetInitSegment(e, t, n, i))
            }

            destroy() {
                this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
            }

            transmux(e, t, n, r, i) {
                let s;
                return s = t && "SAMPLE-AES" === t.method ? this.transmuxSampleAes(e, t, n, r, i) : this.transmuxUnencrypted(e, n, r, i), s
            }

            transmuxUnencrypted(e, t, n, r) {
                const {
                    audioTrack: i,
                    videoTrack: s,
                    id3Track: a,
                    textTrack: o
                } = this.demuxer.demux(e, t, !1, !this.config.progressive);
                return {remuxResult: this.remuxer.remux(i, s, a, o, t, n, !1, this.id), chunkMeta: r}
            }

            transmuxSampleAes(e, t, n, r, i) {
                return this.demuxer.demuxSampleAes(e, t, n).then((e => ({
                    remuxResult: this.remuxer.remux(e.audioTrack, e.videoTrack, e.id3Track, e.textTrack, n, r, !1, this.id),
                    chunkMeta: i
                })))
            }

            configureTransmuxer(e) {
                const {config: t, observer: n, typeSupported: r, vendor: i} = this;
                let s;
                for (let t = 0, n = vg.length; t < n; t++) if (vg[t].demux.probe(e)) {
                    s = vg[t];
                    break
                }
                if (!s) return new Error("Failed to find demuxer by probing fragment data");
                const a = this.demuxer, o = this.remuxer, l = s.remux, c = s.demux;
                o && o instanceof l || (this.remuxer = new l(n, t, r, i)), a && a instanceof c || (this.demuxer = new c(n, t, r), this.probe = c.probe)
            }

            needsProbing(e, t) {
                return !this.demuxer || !this.remuxer || e || t
            }

            getDecrypter() {
                let e = this.decrypter;
                return e || (e = this.decrypter = new um(this.config)), e
            }
        }

        const wg = e => ({remuxResult: {}, chunkMeta: e});

        function xg(e) {
            return "then" in e && e.then instanceof Function
        }

        class Eg {
            constructor(e, t, n, r, i) {
                this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = n, this.duration = r, this.defaultInitPts = i || null
            }
        }

        class Sg {
            constructor(e, t, n, r, i, s) {
                this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = n, this.trackSwitch = r, this.timeOffset = i, this.initSegmentChange = s
            }
        }

        var kg = {exports: {}};
        !function (e) {
            var t = Object.prototype.hasOwnProperty, n = "~";

            function r() {
            }

            function i(e, t, n) {
                this.fn = e, this.context = t, this.once = n || !1
            }

            function s(e, t, r, s, a) {
                if ("function" != typeof r) throw new TypeError("The listener must be a function");
                var o = new i(r, s || e, a), l = n ? n + t : t;
                return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], o] : e._events[l].push(o) : (e._events[l] = o, e._eventsCount++), e
            }

            function a(e, t) {
                0 == --e._eventsCount ? e._events = new r : delete e._events[t]
            }

            function o() {
                this._events = new r, this._eventsCount = 0
            }

            Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (n = !1)), o.prototype.eventNames = function () {
                var e, r, i = [];
                if (0 === this._eventsCount) return i;
                for (r in e = this._events) t.call(e, r) && i.push(n ? r.slice(1) : r);
                return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i
            }, o.prototype.listeners = function (e) {
                var t = n ? n + e : e, r = this._events[t];
                if (!r) return [];
                if (r.fn) return [r.fn];
                for (var i = 0, s = r.length, a = new Array(s); i < s; i++) a[i] = r[i].fn;
                return a
            }, o.prototype.listenerCount = function (e) {
                var t = n ? n + e : e, r = this._events[t];
                return r ? r.fn ? 1 : r.length : 0
            }, o.prototype.emit = function (e, t, r, i, s, a) {
                var o = n ? n + e : e;
                if (!this._events[o]) return !1;
                var l, c, u = this._events[o], d = arguments.length;
                if (u.fn) {
                    switch (u.once && this.removeListener(e, u.fn, void 0, !0), d) {
                        case 1:
                            return u.fn.call(u.context), !0;
                        case 2:
                            return u.fn.call(u.context, t), !0;
                        case 3:
                            return u.fn.call(u.context, t, r), !0;
                        case 4:
                            return u.fn.call(u.context, t, r, i), !0;
                        case 5:
                            return u.fn.call(u.context, t, r, i, s), !0;
                        case 6:
                            return u.fn.call(u.context, t, r, i, s, a), !0
                    }
                    for (c = 1, l = new Array(d - 1); c < d; c++) l[c - 1] = arguments[c];
                    u.fn.apply(u.context, l)
                } else {
                    var h, f = u.length;
                    for (c = 0; c < f; c++) switch (u[c].once && this.removeListener(e, u[c].fn, void 0, !0), d) {
                        case 1:
                            u[c].fn.call(u[c].context);
                            break;
                        case 2:
                            u[c].fn.call(u[c].context, t);
                            break;
                        case 3:
                            u[c].fn.call(u[c].context, t, r);
                            break;
                        case 4:
                            u[c].fn.call(u[c].context, t, r, i);
                            break;
                        default:
                            if (!l) for (h = 1, l = new Array(d - 1); h < d; h++) l[h - 1] = arguments[h];
                            u[c].fn.apply(u[c].context, l)
                    }
                }
                return !0
            }, o.prototype.on = function (e, t, n) {
                return s(this, e, t, n, !1)
            }, o.prototype.once = function (e, t, n) {
                return s(this, e, t, n, !0)
            }, o.prototype.removeListener = function (e, t, r, i) {
                var s = n ? n + e : e;
                if (!this._events[s]) return this;
                if (!t) return a(this, s), this;
                var o = this._events[s];
                if (o.fn) o.fn !== t || i && !o.once || r && o.context !== r || a(this, s); else {
                    for (var l = 0, c = [], u = o.length; l < u; l++) (o[l].fn !== t || i && !o[l].once || r && o[l].context !== r) && c.push(o[l]);
                    c.length ? this._events[s] = 1 === c.length ? c[0] : c : a(this, s)
                }
                return this
            }, o.prototype.removeAllListeners = function (e) {
                var t;
                return e ? (t = n ? n + e : e, this._events[t] && a(this, t)) : (this._events = new r, this._eventsCount = 0), this
            }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = n, o.EventEmitter = o, e.exports = o
        }(kg);
        var Ag = Zd(kg.exports);
        const Tg = Nf() || {isTypeSupported: () => !1};

        class Cg {
            constructor(e, t, n, r) {
                this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0;
                const i = e.config;
                this.hls = e, this.id = t, this.useWorker = !!i.enableWorker, this.onTransmuxComplete = n, this.onFlush = r;
                const s = (e, t) => {
                    (t = t || {}).frag = this.frag, t.id = this.id, e === ch.ERROR && (this.error = t.error), this.hls.trigger(e, t)
                };
                this.observer = new Ag, this.observer.on(ch.FRAG_DECRYPTED, s), this.observer.on(ch.ERROR, s);
                const a = {
                    mp4: Tg.isTypeSupported("video/mp4"),
                    mpeg: Tg.isTypeSupported("audio/mpeg"),
                    mp3: Tg.isTypeSupported('audio/mp4; codecs="mp3"')
                }, o = navigator.vendor;
                if (!this.useWorker || "undefined" == typeof Worker || !i.workerPath && "function" != typeof __HLS_WORKER_BUNDLE__) this.transmuxer = new bg(this.observer, a, i, o, t); else try {
                    i.workerPath ? (mh.log(`loading Web Worker ${i.workerPath} for "${t}"`), this.workerContext = function (e) {
                        const t = new self.URL(e, self.location.href).href;
                        return {worker: new self.Worker(t), scriptURL: t}
                    }(i.workerPath)) : (mh.log(`injecting Web Worker for "${t}"`), this.workerContext = function () {
                        const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {type: "text/javascript"}),
                            t = self.URL.createObjectURL(e);
                        return {worker: new self.Worker(t), objectURL: t}
                    }()), this.onwmsg = e => this.onWorkerMessage(e);
                    const {worker: e} = this.workerContext;
                    e.addEventListener("message", this.onwmsg), e.onerror = e => {
                        const n = new Error(`${e.message}  (${e.filename}:${e.lineno})`);
                        i.enableWorker = !1, mh.warn(`Error in "${t}" Web Worker, fallback to inline`), this.hls.trigger(ch.ERROR, {
                            type: uh.OTHER_ERROR,
                            details: dh.INTERNAL_EXCEPTION,
                            fatal: !1,
                            event: "demuxerWorker",
                            error: n
                        })
                    }, e.postMessage({cmd: "init", typeSupported: a, vendor: o, id: t, config: JSON.stringify(i)})
                } catch (e) {
                    mh.warn(`Error setting up "${t}" Web Worker, fallback to inline`, e), this.resetWorker(), this.error = null, this.transmuxer = new bg(this.observer, a, i, o, t)
                }
            }

            resetWorker() {
                if (this.workerContext) {
                    const {worker: e, objectURL: t} = this.workerContext;
                    t && self.URL.revokeObjectURL(t), e.removeEventListener("message", this.onwmsg), e.onerror = null, e.terminate(), this.workerContext = null
                }
            }

            destroy() {
                if (this.workerContext) this.resetWorker(), this.onwmsg = void 0; else {
                    const e = this.transmuxer;
                    e && (e.destroy(), this.transmuxer = null)
                }
                const e = this.observer;
                e && e.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null
            }

            push(e, t, n, r, i, s, a, o, l, c) {
                var u, d;
                l.transmuxing.start = self.performance.now();
                const {transmuxer: h} = this, f = s ? s.start : i.start, p = i.decryptdata, m = this.frag,
                    g = !(m && i.cc === m.cc), y = !(m && l.level === m.level), v = m ? l.sn - m.sn : -1,
                    b = this.part ? l.part - this.part.index : -1,
                    w = 0 === v && l.id > 1 && l.id === (null == m ? void 0 : m.stats.chunkCount),
                    x = !y && (1 === v || 0 === v && (1 === b || w && b <= 0)), E = self.performance.now();
                (y || v || 0 === i.stats.parsing.start) && (i.stats.parsing.start = E), !s || !b && x || (s.stats.parsing.start = E);
                const S = !(m && (null == (u = i.initSegment) ? void 0 : u.url) === (null == (d = m.initSegment) ? void 0 : d.url)),
                    k = new Sg(g, x, o, y, f, S);
                if (!x || g || S) {
                    mh.log(`[transmuxer-interface, ${i.type}]: Starting new transmux session for sn: ${l.sn} p: ${l.part} level: ${l.level} id: ${l.id}\n        discontinuity: ${g}\n        trackSwitch: ${y}\n        contiguous: ${x}\n        accurateTimeOffset: ${o}\n        timeOffset: ${f}\n        initSegmentChange: ${S}`);
                    const e = new Eg(n, r, t, a, c);
                    this.configureTransmuxer(e)
                }
                if (this.frag = i, this.part = s, this.workerContext) this.workerContext.worker.postMessage({
                    cmd: "demux",
                    data: e,
                    decryptdata: p,
                    chunkMeta: l,
                    state: k
                }, e instanceof ArrayBuffer ? [e] : []); else if (h) {
                    const t = h.push(e, p, l, k);
                    xg(t) ? (h.async = !0, t.then((e => {
                        this.handleTransmuxComplete(e)
                    })).catch((e => {
                        this.transmuxerError(e, l, "transmuxer-interface push error")
                    }))) : (h.async = !1, this.handleTransmuxComplete(t))
                }
            }

            flush(e) {
                e.transmuxing.start = self.performance.now();
                const {transmuxer: t} = this;
                if (this.workerContext) this.workerContext.worker.postMessage({
                    cmd: "flush",
                    chunkMeta: e
                }); else if (t) {
                    let n = t.flush(e);
                    xg(n) || t.async ? (xg(n) || (n = Promise.resolve(n)), n.then((t => {
                        this.handleFlushResult(t, e)
                    })).catch((t => {
                        this.transmuxerError(t, e, "transmuxer-interface flush error")
                    }))) : this.handleFlushResult(n, e)
                }
            }

            transmuxerError(e, t, n) {
                this.hls && (this.error = e, this.hls.trigger(ch.ERROR, {
                    type: uh.MEDIA_ERROR,
                    details: dh.FRAG_PARSING_ERROR,
                    chunkMeta: t,
                    fatal: !1,
                    error: e,
                    err: e,
                    reason: n
                }))
            }

            handleFlushResult(e, t) {
                e.forEach((e => {
                    this.handleTransmuxComplete(e)
                })), this.onFlush(t)
            }

            onWorkerMessage(e) {
                const t = e.data, n = this.hls;
                switch (t.event) {
                    case"init": {
                        var r;
                        const e = null == (r = this.workerContext) ? void 0 : r.objectURL;
                        e && self.URL.revokeObjectURL(e);
                        break
                    }
                    case"transmuxComplete":
                        this.handleTransmuxComplete(t.data);
                        break;
                    case"flush":
                        this.onFlush(t.data);
                        break;
                    case"workerLog":
                        mh[t.data.logType] && mh[t.data.logType](t.data.message);
                        break;
                    default:
                        t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, n.trigger(t.event, t.data)
                }
            }

            configureTransmuxer(e) {
                const {transmuxer: t} = this;
                this.workerContext ? this.workerContext.worker.postMessage({
                    cmd: "configure",
                    config: e
                }) : t && t.configure(e)
            }

            handleTransmuxComplete(e) {
                e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e)
            }
        }

        class Rg {
            constructor(e, t, n, r) {
                this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = n, this.hls = r
            }

            destroy() {
                this.media = null, this.hls = this.fragmentTracker = null
            }

            poll(e, t) {
                const {config: n, media: r, stalled: i} = this;
                if (null === r) return;
                const {currentTime: s, seeking: a} = r, o = this.seeking && !a, l = !this.seeking && a;
                if (this.seeking = a, s !== e) {
                    if (this.moved = !0, null !== i) {
                        if (this.stallReported) {
                            const e = self.performance.now() - i;
                            mh.warn(`playback not stuck anymore @${s}, after ${Math.round(e)}ms`), this.stallReported = !1
                        }
                        this.stalled = null, this.nudgeRetry = 0
                    }
                    return
                }
                if (l || o) return void (this.stalled = null);
                if (r.paused && !a || r.ended || 0 === r.playbackRate || !tm.getBuffered(r).length) return;
                const c = tm.bufferInfo(r, s, 0), u = c.len > 0, d = c.nextStart || 0;
                if (!u && !d) return;
                if (a) {
                    const e = c.len > 2,
                        n = !d || t && t.start <= s || d - s > 2 && !this.fragmentTracker.getPartialFragment(s);
                    if (e || n) return;
                    this.moved = !1
                }
                if (!this.moved && null !== this.stalled) {
                    var h;
                    const e = Math.max(d, c.start || 0) - s,
                        t = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,
                        n = (null == t || null == (h = t.details) ? void 0 : h.live) ? 2 * t.details.targetduration : 2,
                        r = this.fragmentTracker.getPartialFragment(s);
                    if (e > 0 && (e <= n || r)) return void this._trySkipBufferHole(r)
                }
                const f = self.performance.now();
                if (null === i) return void (this.stalled = f);
                const p = f - i;
                if (!a && p >= 250 && (this._reportStall(c), !this.media)) return;
                const m = tm.bufferInfo(r, s, n.maxBufferHole);
                this._tryFixBufferStall(m, p)
            }

            _tryFixBufferStall(e, t) {
                const {config: n, fragmentTracker: r, media: i} = this;
                if (null === i) return;
                const s = i.currentTime, a = r.getPartialFragment(s);
                (!a || !this._trySkipBufferHole(a) && this.media) && (e.len > n.maxBufferHole || e.nextStart && e.nextStart - s < n.maxBufferHole) && t > 1e3 * n.highBufferWatchdogPeriod && (mh.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer())
            }

            _reportStall(e) {
                const {hls: t, media: n, stallReported: r} = this;
                if (!r && n) {
                    this.stallReported = !0;
                    const r = new Error(`Playback stalling at @${n.currentTime} due to low buffer (${JSON.stringify(e)})`);
                    mh.warn(r.message), t.trigger(ch.ERROR, {
                        type: uh.MEDIA_ERROR,
                        details: dh.BUFFER_STALLED_ERROR,
                        fatal: !1,
                        error: r,
                        buffer: e.len
                    })
                }
            }

            _trySkipBufferHole(e) {
                const {config: t, hls: n, media: r} = this;
                if (null === r) return 0;
                const i = r.currentTime, s = tm.bufferInfo(r, i, 0), a = i < s.start ? s.start : s.nextStart;
                if (a) {
                    const o = s.len <= t.maxBufferHole, l = s.len > 0 && s.len < 1 && r.readyState < 3, c = a - i;
                    if (c > 0 && (o || l)) {
                        if (c > t.maxBufferHole) {
                            const {fragmentTracker: t} = this;
                            let n = !1;
                            if (0 === i) {
                                const e = t.getAppendedFrag(0, Jf);
                                e && a < e.end && (n = !0)
                            }
                            if (!n) {
                                const n = e || t.getAppendedFrag(i, Jf);
                                if (n) {
                                    let e = !1, r = n.end;
                                    for (; r < a;) {
                                        const n = t.getPartialFragment(r);
                                        if (!n) {
                                            e = !0;
                                            break
                                        }
                                        r += n.duration
                                    }
                                    if (e) return 0
                                }
                            }
                        }
                        const s = Math.max(a + .05, i + .1);
                        if (mh.warn(`skipping hole, adjusting currentTime from ${i} to ${s}`), this.moved = !0, this.stalled = null, r.currentTime = s, e && !e.gap) {
                            const t = new Error(`fragment loaded with buffer holes, seeking from ${i} to ${s}`);
                            n.trigger(ch.ERROR, {
                                type: uh.MEDIA_ERROR,
                                details: dh.BUFFER_SEEK_OVER_HOLE,
                                fatal: !1,
                                error: t,
                                reason: t.message,
                                frag: e
                            })
                        }
                        return s
                    }
                }
                return 0
            }

            _tryNudgeBuffer() {
                const {config: e, hls: t, media: n, nudgeRetry: r} = this;
                if (null === n) return;
                const i = n.currentTime;
                if (this.nudgeRetry++, r < e.nudgeMaxRetry) {
                    const s = i + (r + 1) * e.nudgeOffset, a = new Error(`Nudging 'currentTime' from ${i} to ${s}`);
                    mh.warn(a.message), n.currentTime = s, t.trigger(ch.ERROR, {
                        type: uh.MEDIA_ERROR,
                        details: dh.BUFFER_NUDGE_ON_STALL,
                        error: a,
                        fatal: !1
                    })
                } else {
                    const n = new Error(`Playhead still not moving while enough data buffered @${i} after ${e.nudgeMaxRetry} nudges`);
                    mh.error(n.message), t.trigger(ch.ERROR, {
                        type: uh.MEDIA_ERROR,
                        details: dh.BUFFER_STALLED_ERROR,
                        error: n,
                        fatal: !0
                    })
                }
            }
        }

        class Lg extends Sm {
            constructor(e, t, n) {
                super(e, t, n, "[stream-controller]", Jf), this.audioCodecSwap = !1, this.gapController = null, this.level = -1, this._forceStartLoad = !1, this.altAudio = !1, this.audioOnly = !1, this.fragPlaying = null, this.onvplaying = null, this.onvseeked = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this._registerListeners()
            }

            _registerListeners() {
                const {hls: e} = this;
                e.on(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.on(ch.LEVEL_LOADING, this.onLevelLoading, this), e.on(ch.LEVEL_LOADED, this.onLevelLoaded, this), e.on(ch.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(ch.ERROR, this.onError, this), e.on(ch.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(ch.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(ch.BUFFER_CREATED, this.onBufferCreated, this), e.on(ch.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(ch.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(ch.FRAG_BUFFERED, this.onFragBuffered, this)
            }

            _unregisterListeners() {
                const {hls: e} = this;
                e.off(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.off(ch.LEVEL_LOADED, this.onLevelLoaded, this), e.off(ch.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(ch.ERROR, this.onError, this), e.off(ch.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(ch.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(ch.BUFFER_CREATED, this.onBufferCreated, this), e.off(ch.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(ch.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(ch.FRAG_BUFFERED, this.onFragBuffered, this)
            }

            onHandlerDestroying() {
                this._unregisterListeners(), this.onMediaDetaching()
            }

            startLoad(e) {
                if (this.levels) {
                    const {lastCurrentTime: t, hls: n} = this;
                    if (this.stopLoad(), this.setInterval(100), this.level = -1, !this.startFragRequested) {
                        let e = n.startLevel;
                        -1 === e && (n.config.testBandwidth && this.levels.length > 1 ? (e = 0, this.bitrateTest = !0) : e = n.nextAutoLevel), this.level = n.nextLoadLevel = e, this.loadedmetadata = !1
                    }
                    t > 0 && -1 === e && (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t), this.state = hm, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
                } else this._forceStartLoad = !0, this.state = dm
            }

            stopLoad() {
                this._forceStartLoad = !1, super.stopLoad()
            }

            doTick() {
                switch (this.state) {
                    case Em: {
                        var e;
                        const {levels: t, level: n} = this, r = null == t || null == (e = t[n]) ? void 0 : e.details;
                        if (r && (!r.live || this.levelLastLoaded === this.level)) {
                            if (this.waitForCdnTuneIn(r)) break;
                            this.state = hm;
                            break
                        }
                        if (this.hls.nextLoadLevel !== this.level) {
                            this.state = hm;
                            break
                        }
                        break
                    }
                    case mm: {
                        var t;
                        const e = self.performance.now(), n = this.retryDate;
                        (!n || e >= n || null != (t = this.media) && t.seeking) && (this.resetStartWhenNotLoaded(this.level), this.state = hm)
                    }
                }
                this.state === hm && this.doTickIdle(), this.onTickEnd()
            }

            onTickEnd() {
                super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged()
            }

            doTickIdle() {
                const {hls: e, levelLastLoaded: t, levels: n, media: r} = this, {config: i, nextLoadLevel: s} = e;
                if (null === t || !r && (this.startFragRequested || !i.startFragPrefetch)) return;
                if (this.altAudio && this.audioOnly) return;
                if (null == n || !n[s]) return;
                const a = n[s], o = this.getMainFwdBufferInfo();
                if (null === o) return;
                const l = this.getLevelDetails();
                if (l && this._streamEnded(o, l)) {
                    const e = {};
                    return this.altAudio && (e.type = "video"), this.hls.trigger(ch.BUFFER_EOS, e), void (this.state = bm)
                }
                e.loadLevel !== s && -1 === e.manualLevel && this.log(`Adapting to level ${s} from level ${this.level}`), this.level = e.nextLoadLevel = s;
                const c = a.details;
                if (!c || this.state === Em || c.live && this.levelLastLoaded !== s) return this.level = s, void (this.state = Em);
                const u = o.len, d = this.getMaxBufferLength(a.maxBitrate);
                if (u >= d) return;
                this.backtrackFragment && this.backtrackFragment.start > o.end && (this.backtrackFragment = null);
                const h = this.backtrackFragment ? this.backtrackFragment.start : o.end;
                let f = this.getNextFragment(h, c);
                if (this.couldBacktrack && !this.fragPrevious && f && "initSegment" !== f.sn && this.fragmentTracker.getState(f) !== Kp) {
                    var p;
                    const e = (null != (p = this.backtrackFragment) ? p : f).sn - c.startSN, t = c.fragments[e - 1];
                    t && f.cc === t.cc && (f = t, this.fragmentTracker.removeFragment(t))
                } else this.backtrackFragment && o.len && (this.backtrackFragment = null);
                if (f && this.isLoopLoading(f, h)) {
                    if (!f.gap) {
                        const e = this.audioOnly && !this.altAudio ? Eh : Sh,
                            t = (e === Sh ? this.videoBuffer : this.mediaBuffer) || this.media;
                        t && this.afterBufferFlushed(t, e, Jf)
                    }
                    f = this.getNextFragmentLoopLoading(f, c, o, Jf, d)
                }
                f && (!f.initSegment || f.initSegment.data || this.bitrateTest || (f = f.initSegment), this.loadFragment(f, a, h))
            }

            loadFragment(e, t, n) {
                const r = this.fragmentTracker.getState(e);
                this.fragCurrent = e, r === Up || r === $p ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0, super.loadFragment(e, t, n)) : this.clearTrackerIfNeeded(e)
            }

            getBufferedFrag(e) {
                return this.fragmentTracker.getBufferedFrag(e, Jf)
            }

            followingBufferedFrag(e) {
                return e ? this.getBufferedFrag(e.end + .5) : null
            }

            immediateLevelSwitch() {
                this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
            }

            nextLevelSwitch() {
                const {levels: e, media: t} = this;
                if (null != t && t.readyState) {
                    let n;
                    const r = this.getAppendedFrag(t.currentTime);
                    r && r.start > 1 && this.flushMainBuffer(0, r.start - 1);
                    const i = this.getLevelDetails();
                    if (null != i && i.live) {
                        const e = this.getMainFwdBufferInfo();
                        if (!e || e.len < 2 * i.targetduration) return
                    }
                    if (!t.paused && e) {
                        const t = e[this.hls.nextLoadLevel], r = this.fragLastKbps;
                        n = r && this.fragCurrent ? this.fragCurrent.duration * t.maxBitrate / (1e3 * r) + 1 : 0
                    } else n = 0;
                    const s = this.getBufferedFrag(t.currentTime + n);
                    if (s) {
                        const e = this.followingBufferedFrag(s);
                        if (e) {
                            this.abortCurrentFrag();
                            const t = e.maxStartPTS ? e.maxStartPTS : e.start, n = e.duration,
                                r = Math.max(s.end, t + Math.min(Math.max(n - this.config.maxFragLookUpTolerance, .5 * n), .75 * n));
                            this.flushMainBuffer(r, Number.POSITIVE_INFINITY)
                        }
                    }
                }
            }

            abortCurrentFrag() {
                const e = this.fragCurrent;
                switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {
                    case fm:
                    case pm:
                    case mm:
                    case ym:
                    case vm:
                        this.state = hm
                }
                this.nextLoadPosition = this.getLoadPosition()
            }

            flushMainBuffer(e, t) {
                super.flushMainBuffer(e, t, this.altAudio ? "video" : null)
            }

            onMediaAttached(e, t) {
                super.onMediaAttached(e, t);
                const n = t.media;
                this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), n.addEventListener("playing", this.onvplaying), n.addEventListener("seeked", this.onvseeked), this.gapController = new Rg(this.config, n, this.fragmentTracker, this.hls)
            }

            onMediaDetaching() {
                const {media: e} = this;
                e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), super.onMediaDetaching()
            }

            onMediaPlaying() {
                this.tick()
            }

            onMediaSeeked() {
                const e = this.media, t = e ? e.currentTime : null;
                lh(t) && this.log(`Media seeked to ${t.toFixed(3)}`);
                const n = this.getMainFwdBufferInfo();
                null !== n && 0 !== n.len ? this.tick() : this.warn(`Main forward buffer length on "seeked" event ${n ? n.len : "empty"})`)
            }

            onManifestLoading() {
                this.log("Trigger BUFFER_RESET"), this.hls.trigger(ch.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = 0, this.levels = this.fragPlaying = this.backtrackFragment = null, this.altAudio = this.audioOnly = !1
            }

            onManifestParsed(e, t) {
                let n, r = !1, i = !1;
                t.levels.forEach((e => {
                    n = e.audioCodec, n && (-1 !== n.indexOf("mp4a.40.2") && (r = !0), -1 !== n.indexOf("mp4a.40.5") && (i = !0))
                })), this.audioCodecSwitch = r && i && !function () {
                    var e;
                    const t = km();
                    return "function" == typeof (null == t || null == (e = t.prototype) ? void 0 : e.changeType)
                }(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1
            }

            onLevelLoading(e, t) {
                const {levels: n} = this;
                if (!n || this.state !== hm) return;
                const r = n[t.level];
                (!r.details || r.details.live && this.levelLastLoaded !== t.level || this.waitForCdnTuneIn(r.details)) && (this.state = Em)
            }

            onLevelLoaded(e, t) {
                var n;
                const {levels: r} = this, i = t.level, s = t.details, a = s.totalduration;
                if (!r) return void this.warn(`Levels were reset while loading level ${i}`);
                this.log(`Level ${i} loaded [${s.startSN},${s.endSN}]${s.lastPartSn ? `[part-${s.lastPartSn}-${s.lastPartIndex}]` : ""}, cc [${s.startCC}, ${s.endCC}] duration:${a}`);
                const o = r[i], l = this.fragCurrent;
                !l || this.state !== pm && this.state !== mm || l.level === t.level && l.urlId === o.urlId || !l.loader || this.abortCurrentFrag();
                let c = 0;
                if (s.live || null != (n = o.details) && n.live) {
                    if (s.fragments[0] || (s.deltaUpdateFailed = !0), s.deltaUpdateFailed) return;
                    c = this.alignPlaylists(s, o.details)
                }
                if (o.details = s, this.levelLastLoaded = i, this.hls.trigger(ch.LEVEL_UPDATED, {
                    details: s,
                    level: i
                }), this.state === Em) {
                    if (this.waitForCdnTuneIn(s)) return;
                    this.state = hm
                }
                this.startFragRequested ? s.live && this.synchronizeToLiveEdge(s) : this.setStartPosition(s, c), this.tick()
            }

            _handleFragmentLoadProgress(e) {
                var t;
                const {frag: n, part: r, payload: i} = e, {levels: s} = this;
                if (!s) return void this.warn(`Levels were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
                const a = s[n.level], o = a.details;
                if (!o) return this.warn(`Dropping fragment ${n.sn} of level ${n.level} after level details were reset`), void this.fragmentTracker.removeFragment(n);
                const l = a.videoCodec, c = o.PTSKnown || !o.live, u = null == (t = n.initSegment) ? void 0 : t.data,
                    d = this._getAudioCodec(a),
                    h = this.transmuxer = this.transmuxer || new Cg(this.hls, Jf, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),
                    f = r ? r.index : -1, p = -1 !== f,
                    m = new nm(n.level, n.sn, n.stats.chunkCount, i.byteLength, f, p), g = this.initPTS[n.cc];
                h.push(i, u, d, l, n, r, o.totalduration, c, m, g)
            }

            onAudioTrackSwitching(e, t) {
                const n = this.altAudio;
                if (!t.url) {
                    if (this.mediaBuffer !== this.media) {
                        this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                        const e = this.fragCurrent;
                        e && (this.log("Switching to main audio track, cancel main fragment load"), e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.resetLoadingState()
                    } else this.audioOnly && this.resetTransmuxer();
                    const e = this.hls;
                    n && (e.trigger(ch.BUFFER_FLUSHING, {
                        startOffset: 0,
                        endOffset: Number.POSITIVE_INFINITY,
                        type: null
                    }), this.fragmentTracker.removeAllFragments()), e.trigger(ch.AUDIO_TRACK_SWITCHED, t)
                }
            }

            onAudioTrackSwitched(e, t) {
                const n = t.id, r = !!this.hls.audioTracks[n].url;
                if (r) {
                    const e = this.videoBuffer;
                    e && this.mediaBuffer !== e && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = e)
                }
                this.altAudio = r, this.tick()
            }

            onBufferCreated(e, t) {
                const n = t.tracks;
                let r, i, s = !1;
                for (const e in n) {
                    const t = n[e];
                    if ("main" === t.id) {
                        if (i = e, r = t, "video" === e) {
                            const t = n[e];
                            t && (this.videoBuffer = t.buffer)
                        }
                    } else s = !0
                }
                s && r ? (this.log(`Alternate track found, use ${i}.buffered to schedule main fragment loading`), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media
            }

            onFragBuffered(e, t) {
                const {frag: n, part: r} = t;
                if (n && n.type !== Jf) return;
                if (this.fragContextChanged(n)) return this.warn(`Fragment ${n.sn}${r ? " p: " + r.index : ""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}`), void (this.state === vm && (this.state = hm));
                const i = r ? r.stats : n.stats;
                this.fragLastKbps = Math.round(8 * i.total / (i.buffering.end - i.loading.first)), "initSegment" !== n.sn && (this.fragPrevious = n), this.fragBufferedComplete(n, r)
            }

            onError(e, t) {
                var n;
                if (t.fatal) this.state = wm; else switch (t.details) {
                    case dh.FRAG_GAP:
                    case dh.FRAG_PARSING_ERROR:
                    case dh.FRAG_DECRYPT_ERROR:
                    case dh.FRAG_LOAD_ERROR:
                    case dh.FRAG_LOAD_TIMEOUT:
                    case dh.KEY_LOAD_ERROR:
                    case dh.KEY_LOAD_TIMEOUT:
                        this.onFragmentOrKeyLoadError(Jf, t);
                        break;
                    case dh.LEVEL_LOAD_ERROR:
                    case dh.LEVEL_LOAD_TIMEOUT:
                    case dh.LEVEL_PARSING_ERROR:
                        t.levelRetry || this.state !== Em || (null == (n = t.context) ? void 0 : n.type) !== Zf || (this.state = hm);
                        break;
                    case dh.BUFFER_FULL_ERROR:
                        if (!t.parent || "main" !== t.parent) return;
                        this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                        break;
                    case dh.INTERNAL_EXCEPTION:
                        this.recoverWorkerError(t)
                }
            }

            checkBuffer() {
                const {media: e, gapController: t} = this;
                if (e && t && e.readyState) {
                    if (this.loadedmetadata || !tm.getBuffered(e).length) {
                        const e = this.state !== hm ? this.fragCurrent : null;
                        t.poll(this.lastCurrentTime, e)
                    }
                    this.lastCurrentTime = e.currentTime
                }
            }

            onFragLoadEmergencyAborted() {
                this.state = hm, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate()
            }

            onBufferFlushed(e, {type: t}) {
                if (t !== Eh || this.audioOnly && !this.altAudio) {
                    const e = (t === Sh ? this.videoBuffer : this.mediaBuffer) || this.media;
                    this.afterBufferFlushed(e, t, Jf)
                }
            }

            onLevelsUpdated(e, t) {
                this.levels = t.levels
            }

            swapAudioCodec() {
                this.audioCodecSwap = !this.audioCodecSwap
            }

            seekToStartPos() {
                const {media: e} = this;
                if (!e) return;
                const t = e.currentTime;
                let n = this.startPosition;
                if (n >= 0 && t < n) {
                    if (e.seeking) return void this.log(`could not seek to ${n}, already seeking at ${t}`);
                    const r = tm.getBuffered(e), i = (r.length ? r.start(0) : 0) - n;
                    i > 0 && (i < this.config.maxBufferHole || i < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${i} to match buffer start`), n += i, this.startPosition = n), this.log(`seek to target start position ${n} from current time ${t}`), e.currentTime = n
                }
            }

            _getAudioCodec(e) {
                let t = this.config.defaultAudioCodec || e.audioCodec;
                return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), t
            }

            _loadBitrateTestFrag(e, t) {
                e.bitrateTest = !0, this._doFragLoad(e, t).then((n => {
                    const {hls: r} = this;
                    if (!n || this.fragContextChanged(e)) return;
                    t.fragmentError = 0, this.state = hm, this.startFragRequested = !1, this.bitrateTest = !1;
                    const i = e.stats;
                    i.parsing.start = i.parsing.end = i.buffering.start = i.buffering.end = self.performance.now(), r.trigger(ch.FRAG_LOADED, n), e.bitrateTest = !1
                }))
            }

            _handleTransmuxComplete(e) {
                var t;
                const n = "main", {hls: r} = this, {remuxResult: i, chunkMeta: s} = e, a = this.getCurrentContext(s);
                if (!a) return void this.resetWhenMissingContext(s);
                const {frag: o, part: l, level: c} = a, {
                    video: u,
                    text: d,
                    id3: h,
                    initSegment: f
                } = i, {details: p} = c, m = this.altAudio ? void 0 : i.audio;
                if (this.fragContextChanged(o)) this.fragmentTracker.removeFragment(o); else {
                    if (this.state = ym, f) {
                        if (null != f && f.tracks) {
                            const e = o.initSegment || o;
                            this._bufferInitSegment(c, f.tracks, e, s), r.trigger(ch.FRAG_PARSING_INIT_SEGMENT, {
                                frag: e,
                                id: n,
                                tracks: f.tracks
                            })
                        }
                        const e = f.initPTS, t = f.timescale;
                        lh(e) && (this.initPTS[o.cc] = {
                            baseTime: e,
                            timescale: t
                        }, r.trigger(ch.INIT_PTS_FOUND, {frag: o, id: n, initPTS: e, timescale: t}))
                    }
                    if (u && !1 !== i.independent) {
                        if (p) {
                            const {startPTS: e, endPTS: t, startDTS: n, endDTS: r} = u;
                            if (l) l.elementaryStreams[u.type] = {
                                startPTS: e,
                                endPTS: t,
                                startDTS: n,
                                endDTS: r
                            }; else if (u.firstKeyFrame && u.independent && 1 === s.id && (this.couldBacktrack = !0), u.dropped && u.independent) {
                                const n = this.getMainFwdBufferInfo();
                                if ((n ? n.end : this.getLoadPosition()) + this.config.maxBufferHole < (u.firstKeyFramePTS ? u.firstKeyFramePTS : e) - this.config.maxBufferHole) return void this.backtrack(o);
                                o.setElementaryStreamInfo(u.type, o.start, t, o.start, r, !0)
                            }
                            o.setElementaryStreamInfo(u.type, e, t, n, r), this.backtrackFragment && (this.backtrackFragment = o), this.bufferFragmentData(u, o, l, s)
                        }
                    } else if (!1 === i.independent) return void this.backtrack(o);
                    if (m) {
                        const {startPTS: e, endPTS: t, startDTS: n, endDTS: r} = m;
                        l && (l.elementaryStreams[Eh] = {
                            startPTS: e,
                            endPTS: t,
                            startDTS: n,
                            endDTS: r
                        }), o.setElementaryStreamInfo(Eh, e, t, n, r), this.bufferFragmentData(m, o, l, s)
                    }
                    if (p && null != h && null != (t = h.samples) && t.length) {
                        const e = {id: n, frag: o, details: p, samples: h.samples};
                        r.trigger(ch.FRAG_PARSING_METADATA, e)
                    }
                    if (p && d) {
                        const e = {id: n, frag: o, details: p, samples: d.samples};
                        r.trigger(ch.FRAG_PARSING_USERDATA, e)
                    }
                }
            }

            _bufferInitSegment(e, t, n, r) {
                if (this.state !== ym) return;
                this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && delete t.audio;
                const {audio: i, video: s, audiovideo: a} = t;
                if (i) {
                    let t = e.audioCodec;
                    const n = navigator.userAgent.toLowerCase();
                    this.audioCodecSwitch && (t && (t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), 1 !== i.metadata.channelCount && -1 === n.indexOf("firefox") && (t = "mp4a.40.5")), -1 !== n.indexOf("android") && "audio/mpeg" !== i.container && (t = "mp4a.40.2", this.log(`Android: force audio codec to ${t}`)), e.audioCodec && e.audioCodec !== t && this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${t}"`), i.levelCodec = t, i.id = "main", this.log(`Init audio buffer, container:${i.container}, codecs[selected/level/parsed]=[${t || ""}/${e.audioCodec || ""}/${i.codec}]`)
                }
                s && (s.levelCodec = e.videoCodec, s.id = "main", this.log(`Init video buffer, container:${s.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${s.codec}]`)), a && this.log(`Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${e.attrs.CODECS || ""}/${a.codec}]`), this.hls.trigger(ch.BUFFER_CODECS, t), Object.keys(t).forEach((e => {
                    const i = t[e].initSegment;
                    null != i && i.byteLength && this.hls.trigger(ch.BUFFER_APPENDING, {
                        type: e,
                        data: i,
                        frag: n,
                        part: null,
                        chunkMeta: r,
                        parent: n.type
                    })
                })), this.tick()
            }

            getMainFwdBufferInfo() {
                return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, Jf)
            }

            backtrack(e) {
                this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = hm
            }

            checkFragmentChanged() {
                const e = this.media;
                let t = null;
                if (e && e.readyState > 1 && !1 === e.seeking) {
                    const n = e.currentTime;
                    if (tm.isBuffered(e, n) ? t = this.getAppendedFrag(n) : tm.isBuffered(e, n + .1) && (t = this.getAppendedFrag(n + .1)), t) {
                        this.backtrackFragment = null;
                        const e = this.fragPlaying, n = t.level;
                        e && t.sn === e.sn && e.level === n && t.urlId === e.urlId || (this.fragPlaying = t, this.hls.trigger(ch.FRAG_CHANGED, {frag: t}), e && e.level === n || this.hls.trigger(ch.LEVEL_SWITCHED, {level: n}))
                    }
                }
            }

            get nextLevel() {
                const e = this.nextBufferedFrag;
                return e ? e.level : -1
            }

            get currentFrag() {
                const e = this.media;
                return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null
            }

            get currentProgramDateTime() {
                const e = this.media;
                if (e) {
                    const t = e.currentTime, n = this.currentFrag;
                    if (n && lh(t) && lh(n.programDateTime)) {
                        const e = n.programDateTime + 1e3 * (t - n.start);
                        return new Date(e)
                    }
                }
                return null
            }

            get currentLevel() {
                const e = this.currentFrag;
                return e ? e.level : -1
            }

            get nextBufferedFrag() {
                const e = this.currentFrag;
                return e ? this.followingBufferedFrag(e) : null
            }

            get forceStartLoad() {
                return this._forceStartLoad
            }
        }

        class _g {
            constructor(e, t = 0, n = 0) {
                this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = n
            }

            sample(e, t) {
                const n = Math.pow(this.alpha_, e);
                this.estimate_ = t * (1 - n) + n * this.estimate_, this.totalWeight_ += e
            }

            getTotalWeight() {
                return this.totalWeight_
            }

            getEstimate() {
                if (this.alpha_) {
                    const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
                    if (e) return this.estimate_ / e
                }
                return this.estimate_
            }
        }

        class Pg {
            constructor(e, t, n, r = 100) {
                this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = n, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new _g(e), this.fast_ = new _g(t), this.defaultTTFB_ = r, this.ttfb_ = new _g(e)
            }

            update(e, t) {
                const {slow_: n, fast_: r, ttfb_: i} = this;
                n.halfLife !== e && (this.slow_ = new _g(e, n.getEstimate(), n.getTotalWeight())), r.halfLife !== t && (this.fast_ = new _g(t, r.getEstimate(), r.getTotalWeight())), i.halfLife !== e && (this.ttfb_ = new _g(e, i.getEstimate(), i.getTotalWeight()))
            }

            sample(e, t) {
                const n = (e = Math.max(e, this.minDelayMs_)) / 1e3, r = 8 * t / n;
                this.fast_.sample(n, r), this.slow_.sample(n, r)
            }

            sampleTTFB(e) {
                const t = e / 1e3, n = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
                this.ttfb_.sample(n, Math.max(e, 5))
            }

            canEstimate() {
                return this.fast_.getTotalWeight() >= this.minWeight_
            }

            getEstimate() {
                return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
            }

            getEstimateTTFB() {
                return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_
            }

            destroy() {
            }
        }

        class Ng {
            constructor() {
                this.chunks = [], this.dataLength = 0
            }

            push(e) {
                this.chunks.push(e), this.dataLength += e.length
            }

            flush() {
                const {chunks: e, dataLength: t} = this;
                let n;
                return e.length ? (n = 1 === e.length ? e[0] : function (e, t) {
                    const n = new Uint8Array(t);
                    let r = 0;
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t];
                        n.set(i, r), r += i.length
                    }
                    return n
                }(e, t), this.reset(), n) : new Uint8Array(0)
            }

            reset() {
                this.chunks.length = 0, this.dataLength = 0
            }
        }

        function jg(e, t) {
            if (e.length !== t.length) return !1;
            for (let n = 0; n < e.length; n++) if (!Ig(e[n].attrs, t[n].attrs)) return !1;
            return !0
        }

        function Ig(e, t) {
            const n = e["STABLE-RENDITION-ID"];
            return n ? n === t["STABLE-RENDITION-ID"] : !["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED"].some((n => e[n] !== t[n]))
        }

        class Mg {
            constructor(e) {
                this.buffered = void 0;
                const t = (t, n, r) => {
                    if ((n >>>= 0) > r - 1) throw new DOMException(`Failed to execute '${t}' on 'TimeRanges': The index provided (${n}) is greater than the maximum bound (${r})`);
                    return e[n][t]
                };
                this.buffered = {
                    get length() {
                        return e.length
                    }, end: n => t("end", n, e.length), start: n => t("start", n, e.length)
                }
            }
        }

        function Dg(e) {
            const t = [];
            for (let n = 0; n < e.length; n++) {
                const r = e[n];
                "subtitles" !== r.kind && "captions" !== r.kind || !r.label || t.push(e[n])
            }
            return t
        }

        class Og {
            constructor(e) {
                this.buffers = void 0, this.queues = {video: [], audio: [], audiovideo: []}, this.buffers = e
            }

            append(e, t) {
                const n = this.queues[t];
                n.push(e), 1 === n.length && this.buffers[t] && this.executeNext(t)
            }

            insertAbort(e, t) {
                this.queues[t].unshift(e), this.executeNext(t)
            }

            appendBlocker(e) {
                let t;
                const n = new Promise((e => {
                    t = e
                })), r = {
                    execute: t, onStart: () => {
                    }, onComplete: () => {
                    }, onError: () => {
                    }
                };
                return this.append(r, e), n
            }

            executeNext(e) {
                const {buffers: t, queues: n} = this, r = t[e], i = n[e];
                if (i.length) {
                    const t = i[0];
                    try {
                        t.execute()
                    } catch (n) {
                        mh.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), t.onError(n), null != r && r.updating || (i.shift(), this.executeNext(e))
                    }
                }
            }

            shiftAndExecuteNext(e) {
                this.queues[e].shift(), this.executeNext(e)
            }

            current(e) {
                return this.queues[e][0]
            }
        }

        const Bg = Nf(), Fg = /([ha]vc.)(?:\.[^.,]+)+/, Ug = {
                42: 225,
                92: 233,
                94: 237,
                95: 243,
                96: 250,
                123: 231,
                124: 247,
                125: 209,
                126: 241,
                127: 9608,
                128: 174,
                129: 176,
                130: 189,
                131: 191,
                132: 8482,
                133: 162,
                134: 163,
                135: 9834,
                136: 224,
                137: 32,
                138: 232,
                139: 226,
                140: 234,
                141: 238,
                142: 244,
                143: 251,
                144: 193,
                145: 201,
                146: 211,
                147: 218,
                148: 220,
                149: 252,
                150: 8216,
                151: 161,
                152: 42,
                153: 8217,
                154: 9473,
                155: 169,
                156: 8480,
                157: 8226,
                158: 8220,
                159: 8221,
                160: 192,
                161: 194,
                162: 199,
                163: 200,
                164: 202,
                165: 203,
                166: 235,
                167: 206,
                168: 207,
                169: 239,
                170: 212,
                171: 217,
                172: 249,
                173: 219,
                174: 171,
                175: 187,
                176: 195,
                177: 227,
                178: 205,
                179: 204,
                180: 236,
                181: 210,
                182: 242,
                183: 213,
                184: 245,
                185: 123,
                186: 125,
                187: 92,
                188: 94,
                189: 95,
                190: 124,
                191: 8764,
                192: 196,
                193: 228,
                194: 214,
                195: 246,
                196: 223,
                197: 165,
                198: 164,
                199: 9475,
                200: 197,
                201: 229,
                202: 216,
                203: 248,
                204: 9487,
                205: 9491,
                206: 9495,
                207: 9499
            }, Hg = function (e) {
                let t = e;
                return Ug.hasOwnProperty(e) && (t = Ug[e]), String.fromCharCode(t)
            }, $g = 15, Kg = 100, zg = {17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14},
            Gg = {17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15},
            qg = {25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14},
            Wg = {25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15},
            Vg = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];

        class Yg {
            constructor() {
                this.time = null, this.verboseLevel = 0
            }

            log(e, t) {
                if (this.verboseLevel >= e) {
                    const n = "function" == typeof t ? t() : t;
                    mh.log(`${this.time} [${e}] ${n}`)
                }
            }
        }

        const Zg = function (e) {
            const t = [];
            for (let n = 0; n < e.length; n++) t.push(e[n].toString(16));
            return t
        };

        class Xg {
            constructor(e, t, n, r, i) {
                this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = e || "white", this.underline = t || !1, this.italics = n || !1, this.background = r || "black", this.flash = i || !1
            }

            reset() {
                this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
            }

            setStyles(e) {
                const t = ["foreground", "underline", "italics", "background", "flash"];
                for (let n = 0; n < t.length; n++) {
                    const r = t[n];
                    e.hasOwnProperty(r) && (this[r] = e[r])
                }
            }

            isDefault() {
                return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
            }

            equals(e) {
                return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
            }

            copy(e) {
                this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash
            }

            toString() {
                return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
            }
        }

        class Qg {
            constructor(e, t, n, r, i, s) {
                this.uchar = void 0, this.penState = void 0, this.uchar = e || " ", this.penState = new Xg(t, n, r, i, s)
            }

            reset() {
                this.uchar = " ", this.penState.reset()
            }

            setChar(e, t) {
                this.uchar = e, this.penState.copy(t)
            }

            setPenState(e) {
                this.penState.copy(e)
            }

            equals(e) {
                return this.uchar === e.uchar && this.penState.equals(e.penState)
            }

            copy(e) {
                this.uchar = e.uchar, this.penState.copy(e.penState)
            }

            isEmpty() {
                return " " === this.uchar && this.penState.isDefault()
            }
        }

        class Jg {
            constructor(e) {
                this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chars = [];
                for (let e = 0; e < Kg; e++) this.chars.push(new Qg);
                this.logger = e, this.pos = 0, this.currPenState = new Xg
            }

            equals(e) {
                let t = !0;
                for (let n = 0; n < Kg; n++) if (!this.chars[n].equals(e.chars[n])) {
                    t = !1;
                    break
                }
                return t
            }

            copy(e) {
                for (let t = 0; t < Kg; t++) this.chars[t].copy(e.chars[t])
            }

            isEmpty() {
                let e = !0;
                for (let t = 0; t < Kg; t++) if (!this.chars[t].isEmpty()) {
                    e = !1;
                    break
                }
                return e
            }

            setCursor(e) {
                this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > Kg && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = Kg)
            }

            moveCursor(e) {
                const t = this.pos + e;
                if (e > 1) for (let e = this.pos + 1; e < t + 1; e++) this.chars[e].setPenState(this.currPenState);
                this.setCursor(t)
            }

            backSpace() {
                this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
            }

            insertChar(e) {
                e >= 144 && this.backSpace();
                const t = Hg(e);
                this.pos >= Kg ? this.logger.log(0, (() => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!")) : (this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1))
            }

            clearFromPos(e) {
                let t;
                for (t = e; t < Kg; t++) this.chars[t].reset()
            }

            clear() {
                this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
            }

            clearToEndOfRow() {
                this.clearFromPos(this.pos)
            }

            getTextString() {
                const e = [];
                let t = !0;
                for (let n = 0; n < Kg; n++) {
                    const r = this.chars[n].uchar;
                    " " !== r && (t = !1), e.push(r)
                }
                return t ? "" : e.join("")
            }

            setPenStyles(e) {
                this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState)
            }
        }

        class ey {
            constructor(e) {
                this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.logger = void 0, this.rows = [];
                for (let t = 0; t < $g; t++) this.rows.push(new Jg(e));
                this.logger = e, this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.reset()
            }

            reset() {
                for (let e = 0; e < $g; e++) this.rows[e].clear();
                this.currRow = 14
            }

            equals(e) {
                let t = !0;
                for (let n = 0; n < $g; n++) if (!this.rows[n].equals(e.rows[n])) {
                    t = !1;
                    break
                }
                return t
            }

            copy(e) {
                for (let t = 0; t < $g; t++) this.rows[t].copy(e.rows[t])
            }

            isEmpty() {
                let e = !0;
                for (let t = 0; t < $g; t++) if (!this.rows[t].isEmpty()) {
                    e = !1;
                    break
                }
                return e
            }

            backSpace() {
                this.rows[this.currRow].backSpace()
            }

            clearToEndOfRow() {
                this.rows[this.currRow].clearToEndOfRow()
            }

            insertChar(e) {
                this.rows[this.currRow].insertChar(e)
            }

            setPen(e) {
                this.rows[this.currRow].setPenStyles(e)
            }

            moveCursor(e) {
                this.rows[this.currRow].moveCursor(e)
            }

            setCursor(e) {
                this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e)
            }

            setPAC(e) {
                this.logger.log(2, (() => "pacData = " + JSON.stringify(e)));
                let t = e.row - 1;
                if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) {
                    for (let e = 0; e < $g; e++) this.rows[e].clear();
                    const e = this.currRow + 1 - this.nrRollUpRows, n = this.lastOutputScreen;
                    if (n) {
                        const r = n.rows[e].cueStartTime, i = this.logger.time;
                        if (r && null !== i && r < i) for (let r = 0; r < this.nrRollUpRows; r++) this.rows[t - this.nrRollUpRows + r + 1].copy(n.rows[e + r])
                    }
                }
                this.currRow = t;
                const n = this.rows[this.currRow];
                if (null !== e.indent) {
                    const t = e.indent, r = Math.max(t - 1, 0);
                    n.setCursor(e.indent), e.color = n.chars[r].penState.foreground
                }
                const r = {
                    foreground: e.color,
                    underline: e.underline,
                    italics: e.italics,
                    background: "black",
                    flash: !1
                };
                this.setPen(r)
            }

            setBkgData(e) {
                this.logger.log(2, (() => "bkgData = " + JSON.stringify(e))), this.backSpace(), this.setPen(e), this.insertChar(32)
            }

            setRollUpRows(e) {
                this.nrRollUpRows = e
            }

            rollUp() {
                if (null === this.nrRollUpRows) return void this.logger.log(3, "roll_up but nrRollUpRows not set yet");
                this.logger.log(1, (() => this.getDisplayText()));
                const e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0];
                t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, "Rolling up")
            }

            getDisplayText(e) {
                e = e || !1;
                const t = [];
                let n = "", r = -1;
                for (let n = 0; n < $g; n++) {
                    const i = this.rows[n].getTextString();
                    i && (r = n + 1, e ? t.push("Row " + r + ": '" + i + "'") : t.push(i.trim()))
                }
                return t.length > 0 && (n = e ? "[" + t.join(" | ") + "]" : t.join("\n")), n
            }

            getTextAndFormat() {
                return this.rows
            }
        }

        class ty {
            constructor(e, t, n) {
                this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new ey(n), this.nonDisplayedMemory = new ey(n), this.lastOutputScreen = new ey(n), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = n
            }

            reset() {
                this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
            }

            getHandler() {
                return this.outputFilter
            }

            setHandler(e) {
                this.outputFilter = e
            }

            setPAC(e) {
                this.writeScreen.setPAC(e)
            }

            setBkgData(e) {
                this.writeScreen.setBkgData(e)
            }

            setMode(e) {
                e !== this.mode && (this.mode = e, this.logger.log(2, (() => "MODE=" + e)), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e)
            }

            insertChars(e) {
                for (let t = 0; t < e.length; t++) this.writeScreen.insertChar(e[t]);
                const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                this.logger.log(2, (() => t + ": " + this.writeScreen.getDisplayText(!0))), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (this.logger.log(1, (() => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0))), this.outputDataUpdate())
            }

            ccRCL() {
                this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
            }

            ccBS() {
                this.logger.log(2, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
            }

            ccAOF() {
            }

            ccAON() {
            }

            ccDER() {
                this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
            }

            ccRU(e) {
                this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e)
            }

            ccFON() {
                this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({flash: !0})
            }

            ccRDC() {
                this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
            }

            ccTR() {
                this.logger.log(2, "TR"), this.setMode("MODE_TEXT")
            }

            ccRTD() {
                this.logger.log(2, "RTD"), this.setMode("MODE_TEXT")
            }

            ccEDM() {
                this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
            }

            ccCR() {
                this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
            }

            ccENM() {
                this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
            }

            ccEOC() {
                if (this.logger.log(2, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) {
                    const e = this.displayedMemory;
                    this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, (() => "DISP: " + this.displayedMemory.getDisplayText()))
                }
                this.outputDataUpdate(!0)
            }

            ccTO(e) {
                this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e)
            }

            ccMIDROW(e) {
                const t = {flash: !1};
                if (t.underline = e % 2 == 1, t.italics = e >= 46, t.italics) t.foreground = "white"; else {
                    const n = Math.floor(e / 2) - 16,
                        r = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                    t.foreground = r[n]
                }
                this.logger.log(2, "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t)
            }

            outputDataUpdate(e = !1) {
                const t = this.logger.time;
                null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory))
            }

            cueSplitAtTime(e) {
                this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e))
            }
        }

        class ny {
            constructor(e, t, n) {
                this.channels = void 0, this.currentChannel = 0, this.cmdHistory = void 0, this.logger = void 0;
                const r = new Yg;
                this.channels = [null, new ty(e, t, r), new ty(e + 1, n, r)], this.cmdHistory = {
                    a: null,
                    b: null
                }, this.logger = r
            }

            getHandler(e) {
                return this.channels[e].getHandler()
            }

            setHandler(e, t) {
                this.channels[e].setHandler(t)
            }

            addData(e, t) {
                let n, r, i, s = !1;
                this.logger.time = e;
                for (let e = 0; e < t.length; e += 2) if (r = 127 & t[e], i = 127 & t[e + 1], 0 !== r || 0 !== i) {
                    if (this.logger.log(3, "[" + Zg([t[e], t[e + 1]]) + "] -> (" + Zg([r, i]) + ")"), n = this.parseCmd(r, i), n || (n = this.parseMidrow(r, i)), n || (n = this.parsePAC(r, i)), n || (n = this.parseBackgroundAttributes(r, i)), !n && (s = this.parseChars(r, i), s)) {
                        const e = this.currentChannel;
                        e && e > 0 ? this.channels[e].insertChars(s) : this.logger.log(2, "No channel found yet. TEXT-MODE?")
                    }
                    n || s || this.logger.log(2, "Couldn't parse cleaned data " + Zg([r, i]) + " orig: " + Zg([t[e], t[e + 1]]))
                }
            }

            parseCmd(e, t) {
                const {cmdHistory: n} = this;
                if (!((20 === e || 28 === e || 21 === e || 29 === e) && t >= 32 && t <= 47 || (23 === e || 31 === e) && t >= 33 && t <= 35)) return !1;
                if (iy(e, t, n)) return ry(null, null, n), this.logger.log(3, "Repeated command (" + Zg([e, t]) + ") is dropped"), !0;
                const r = 20 === e || 21 === e || 23 === e ? 1 : 2, i = this.channels[r];
                return 20 === e || 21 === e || 28 === e || 29 === e ? 32 === t ? i.ccRCL() : 33 === t ? i.ccBS() : 34 === t ? i.ccAOF() : 35 === t ? i.ccAON() : 36 === t ? i.ccDER() : 37 === t ? i.ccRU(2) : 38 === t ? i.ccRU(3) : 39 === t ? i.ccRU(4) : 40 === t ? i.ccFON() : 41 === t ? i.ccRDC() : 42 === t ? i.ccTR() : 43 === t ? i.ccRTD() : 44 === t ? i.ccEDM() : 45 === t ? i.ccCR() : 46 === t ? i.ccENM() : 47 === t && i.ccEOC() : i.ccTO(t - 32), ry(e, t, n), this.currentChannel = r, !0
            }

            parseMidrow(e, t) {
                let n = 0;
                if ((17 === e || 25 === e) && t >= 32 && t <= 47) {
                    if (n = 17 === e ? 1 : 2, n !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
                    const r = this.channels[n];
                    return !!r && (r.ccMIDROW(t), this.logger.log(3, "MIDROW (" + Zg([e, t]) + ")"), !0)
                }
                return !1
            }

            parsePAC(e, t) {
                let n;
                const r = this.cmdHistory;
                if (!((e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127 || (16 === e || 24 === e) && t >= 64 && t <= 95)) return !1;
                if (iy(e, t, r)) return ry(null, null, r), !0;
                const i = e <= 23 ? 1 : 2;
                n = t >= 64 && t <= 95 ? 1 === i ? zg[e] : qg[e] : 1 === i ? Gg[e] : Wg[e];
                const s = this.channels[i];
                return !!s && (s.setPAC(this.interpretPAC(n, t)), ry(e, t, r), this.currentChannel = i, !0)
            }

            interpretPAC(e, t) {
                let n;
                const r = {color: null, italics: !1, indent: null, underline: !1, row: e};
                return n = t > 95 ? t - 96 : t - 64, r.underline = 1 == (1 & n), n <= 13 ? r.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(n / 2)] : n <= 15 ? (r.italics = !0, r.color = "white") : r.indent = 4 * Math.floor((n - 16) / 2), r
            }

            parseChars(e, t) {
                let n, r = null, i = null;
                if (e >= 25 ? (n = 2, i = e - 8) : (n = 1, i = e), i >= 17 && i <= 19) {
                    let e;
                    e = 17 === i ? t + 80 : 18 === i ? t + 112 : t + 144, this.logger.log(2, "Special char '" + Hg(e) + "' in channel " + n), r = [e]
                } else e >= 32 && e <= 127 && (r = 0 === t ? [e] : [e, t]);
                if (r) {
                    const n = Zg(r);
                    this.logger.log(3, "Char codes =  " + n.join(",")), ry(e, t, this.cmdHistory)
                }
                return r
            }

            parseBackgroundAttributes(e, t) {
                if (!((16 === e || 24 === e) && t >= 32 && t <= 47 || (23 === e || 31 === e) && t >= 45 && t <= 47)) return !1;
                let n;
                const r = {};
                16 === e || 24 === e ? (n = Math.floor((t - 32) / 2), r.background = Vg[n], t % 2 == 1 && (r.background = r.background + "_semi")) : 45 === t ? r.background = "transparent" : (r.foreground = "black", 47 === t && (r.underline = !0));
                const i = e <= 23 ? 1 : 2;
                return this.channels[i].setBkgData(r), ry(e, t, this.cmdHistory), !0
            }

            reset() {
                for (let e = 0; e < Object.keys(this.channels).length; e++) {
                    const t = this.channels[e];
                    t && t.reset()
                }
                this.cmdHistory = {a: null, b: null}
            }

            cueSplitAtTime(e) {
                for (let t = 0; t < this.channels.length; t++) {
                    const n = this.channels[t];
                    n && n.cueSplitAtTime(e)
                }
            }
        }

        function ry(e, t, n) {
            n.a = e, n.b = t
        }

        function iy(e, t, n) {
            return n.a === e && n.b === t
        }

        class sy {
            constructor(e, t) {
                this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t
            }

            dispatchCue() {
                null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null)
            }

            newCue(e, t, n) {
                (null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = n, this.timelineController.createCaptionsTrack(this.trackName)
            }

            reset() {
                this.cueRanges = [], this.startTime = null
            }
        }

        var ay = function () {
            if ("undefined" != typeof self && self.VTTCue) return self.VTTCue;
            const e = ["", "lr", "rl"], t = ["start", "middle", "end", "left", "right"];

            function n(e, t) {
                if ("string" != typeof t) return !1;
                if (!Array.isArray(e)) return !1;
                const n = t.toLowerCase();
                return !!~e.indexOf(n) && n
            }

            function r(e) {
                return n(t, e)
            }

            function i(e, ...t) {
                let n = 1;
                for (; n < arguments.length; n++) {
                    const t = arguments[n];
                    for (const n in t) e[n] = t[n]
                }
                return e
            }

            function s(t, s, a) {
                const o = this, l = {enumerable: !0};
                o.hasBeenReset = !1;
                let c = "", u = !1, d = t, h = s, f = a, p = null, m = "", g = !0, y = "auto", v = "start", b = 50,
                    w = "middle", x = 50, E = "middle";
                Object.defineProperty(o, "id", i({}, l, {
                    get: function () {
                        return c
                    }, set: function (e) {
                        c = "" + e
                    }
                })), Object.defineProperty(o, "pauseOnExit", i({}, l, {
                    get: function () {
                        return u
                    }, set: function (e) {
                        u = !!e
                    }
                })), Object.defineProperty(o, "startTime", i({}, l, {
                    get: function () {
                        return d
                    }, set: function (e) {
                        if ("number" != typeof e) throw new TypeError("Start time must be set to a number.");
                        d = e, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "endTime", i({}, l, {
                    get: function () {
                        return h
                    }, set: function (e) {
                        if ("number" != typeof e) throw new TypeError("End time must be set to a number.");
                        h = e, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "text", i({}, l, {
                    get: function () {
                        return f
                    }, set: function (e) {
                        f = "" + e, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "region", i({}, l, {
                    get: function () {
                        return p
                    }, set: function (e) {
                        p = e, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "vertical", i({}, l, {
                    get: function () {
                        return m
                    }, set: function (t) {
                        const r = function (t) {
                            return n(e, t)
                        }(t);
                        if (!1 === r) throw new SyntaxError("An invalid or illegal string was specified.");
                        m = r, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "snapToLines", i({}, l, {
                    get: function () {
                        return g
                    }, set: function (e) {
                        g = !!e, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "line", i({}, l, {
                    get: function () {
                        return y
                    }, set: function (e) {
                        if ("number" != typeof e && "auto" !== e) throw new SyntaxError("An invalid number or illegal string was specified.");
                        y = e, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "lineAlign", i({}, l, {
                    get: function () {
                        return v
                    }, set: function (e) {
                        const t = r(e);
                        if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
                        v = t, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "position", i({}, l, {
                    get: function () {
                        return b
                    }, set: function (e) {
                        if (e < 0 || e > 100) throw new Error("Position must be between 0 and 100.");
                        b = e, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "positionAlign", i({}, l, {
                    get: function () {
                        return w
                    }, set: function (e) {
                        const t = r(e);
                        if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
                        w = t, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "size", i({}, l, {
                    get: function () {
                        return x
                    }, set: function (e) {
                        if (e < 0 || e > 100) throw new Error("Size must be between 0 and 100.");
                        x = e, this.hasBeenReset = !0
                    }
                })), Object.defineProperty(o, "align", i({}, l, {
                    get: function () {
                        return E
                    }, set: function (e) {
                        const t = r(e);
                        if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
                        E = t, this.hasBeenReset = !0
                    }
                })), o.displayState = void 0
            }

            return s.prototype.getCueAsHTML = function () {
                return self.WebVTT.convertCueToDOMTree(self, this.text)
            }, s
        }();

        class oy {
            decode(e, t) {
                if (!e) return "";
                if ("string" != typeof e) throw new Error("Error - expected string data.");
                return decodeURIComponent(encodeURIComponent(e))
            }
        }

        function ly(e) {
            function t(e, t, n, r) {
                return 3600 * (0 | e) + 60 * (0 | t) + (0 | n) + parseFloat(r || 0)
            }

            const n = e.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
            return n ? parseFloat(n[2]) > 59 ? t(n[2], n[3], 0, n[4]) : t(n[1], n[2], n[3], n[4]) : null
        }

        class cy {
            constructor() {
                this.values = Object.create(null)
            }

            set(e, t) {
                this.get(e) || "" === t || (this.values[e] = t)
            }

            get(e, t, n) {
                return n ? this.has(e) ? this.values[e] : t[n] : this.has(e) ? this.values[e] : t
            }

            has(e) {
                return e in this.values
            }

            alt(e, t, n) {
                for (let r = 0; r < n.length; ++r) if (t === n[r]) {
                    this.set(e, t);
                    break
                }
            }

            integer(e, t) {
                /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
            }

            percent(e, t) {
                if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
                    const n = parseFloat(t);
                    if (n >= 0 && n <= 100) return this.set(e, n), !0
                }
                return !1
            }
        }

        function uy(e, t, n, r) {
            const i = r ? e.split(r) : [e];
            for (const e in i) {
                if ("string" != typeof i[e]) continue;
                const r = i[e].split(n);
                2 === r.length && t(r[0], r[1])
            }
        }

        const dy = new ay(0, 0, ""), hy = "middle" === dy.align ? "middle" : "center";

        function fy(e, t, n) {
            const r = e;

            function i() {
                const t = ly(e);
                if (null === t) throw new Error("Malformed timestamp: " + r);
                return e = e.replace(/^[^\sa-zA-Z-]+/, ""), t
            }

            function s() {
                e = e.replace(/^\s+/, "")
            }

            if (s(), t.startTime = i(), s(), "--\x3e" !== e.slice(0, 3)) throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + r);
            e = e.slice(3), s(), t.endTime = i(), s(), function (e, t) {
                const r = new cy;
                uy(e, (function (e, t) {
                    let i;
                    switch (e) {
                        case"region":
                            for (let i = n.length - 1; i >= 0; i--) if (n[i].id === t) {
                                r.set(e, n[i].region);
                                break
                            }
                            break;
                        case"vertical":
                            r.alt(e, t, ["rl", "lr"]);
                            break;
                        case"line":
                            i = t.split(","), r.integer(e, i[0]), r.percent(e, i[0]) && r.set("snapToLines", !1), r.alt(e, i[0], ["auto"]), 2 === i.length && r.alt("lineAlign", i[1], ["start", hy, "end"]);
                            break;
                        case"position":
                            i = t.split(","), r.percent(e, i[0]), 2 === i.length && r.alt("positionAlign", i[1], ["start", hy, "end", "line-left", "line-right", "auto"]);
                            break;
                        case"size":
                            r.percent(e, t);
                            break;
                        case"align":
                            r.alt(e, t, ["start", hy, "end", "left", "right"])
                    }
                }), /:/, /\s/), t.region = r.get("region", null), t.vertical = r.get("vertical", "");
                let i = r.get("line", "auto");
                "auto" === i && -1 === dy.line && (i = -1), t.line = i, t.lineAlign = r.get("lineAlign", "start"), t.snapToLines = r.get("snapToLines", !0), t.size = r.get("size", 100), t.align = r.get("align", hy);
                let s = r.get("position", "auto");
                "auto" === s && 50 === dy.position && (s = "start" === t.align || "left" === t.align ? 0 : "end" === t.align || "right" === t.align ? 100 : 50), t.position = s
            }(e, t)
        }

        function py(e) {
            return e.replace(/<br(?: \/)?>/gi, "\n")
        }

        class my {
            constructor() {
                this.state = "INITIAL", this.buffer = "", this.decoder = new oy, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0
            }

            parse(e) {
                const t = this;

                function n() {
                    let e = t.buffer, n = 0;
                    for (e = py(e); n < e.length && "\r" !== e[n] && "\n" !== e[n];) ++n;
                    const r = e.slice(0, n);
                    return "\r" === e[n] && ++n, "\n" === e[n] && ++n, t.buffer = e.slice(n), r
                }

                e && (t.buffer += t.decoder.decode(e, {stream: !0}));
                try {
                    let e = "";
                    if ("INITIAL" === t.state) {
                        if (!/\r\n|\n/.test(t.buffer)) return this;
                        e = n();
                        const r = e.match(/^()?WEBVTT([ \t].*)?$/);
                        if (null == r || !r[0]) throw new Error("Malformed WebVTT signature.");
                        t.state = "HEADER"
                    }
                    let r = !1;
                    for (; t.buffer;) {
                        if (!/\r\n|\n/.test(t.buffer)) return this;
                        switch (r ? r = !1 : e = n(), t.state) {
                            case"HEADER":
                                /:/.test(e) ? uy(e, (function (e, t) {
                                }), /:/) : e || (t.state = "ID");
                                continue;
                            case"NOTE":
                                e || (t.state = "ID");
                                continue;
                            case"ID":
                                if (/^NOTE($|[ \t])/.test(e)) {
                                    t.state = "NOTE";
                                    break
                                }
                                if (!e) continue;
                                if (t.cue = new ay(0, 0, ""), t.state = "CUE", -1 === e.indexOf("--\x3e")) {
                                    t.cue.id = e;
                                    continue
                                }
                            case"CUE":
                                if (!t.cue) {
                                    t.state = "BADCUE";
                                    continue
                                }
                                try {
                                    fy(e, t.cue, t.regionList)
                                } catch (e) {
                                    t.cue = null, t.state = "BADCUE";
                                    continue
                                }
                                t.state = "CUETEXT";
                                continue;
                            case"CUETEXT": {
                                const n = -1 !== e.indexOf("--\x3e");
                                if (!e || n && (r = !0)) {
                                    t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID";
                                    continue
                                }
                                if (null === t.cue) continue;
                                t.cue.text && (t.cue.text += "\n"), t.cue.text += e
                            }
                                continue;
                            case"BADCUE":
                                e || (t.state = "ID")
                        }
                    }
                } catch (e) {
                    "CUETEXT" === t.state && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = "INITIAL" === t.state ? "BADWEBVTT" : "BADCUE"
                }
                return this
            }

            flush() {
                const e = this;
                try {
                    if ((e.cue || "HEADER" === e.state) && (e.buffer += "\n\n", e.parse()), "INITIAL" === e.state || "BADWEBVTT" === e.state) throw new Error("Malformed WebVTT signature.")
                } catch (t) {
                    e.onparsingerror && e.onparsingerror(t)
                }
                return e.onflush && e.onflush(), this
            }
        }

        const gy = /\r\n|\n\r|\n|\r/g, yy = function (e, t, n = 0) {
            return e.slice(n, n + t.length) === t
        }, vy = function (e) {
            let t = 5381, n = e.length;
            for (; n;) t = 33 * t ^ e.charCodeAt(--n);
            return (t >>> 0).toString()
        };

        function by(e, t, n) {
            return vy(e.toString()) + vy(t.toString()) + vy(n)
        }

        const wy = "stpp.ttml.im1t", xy = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
            Ey = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
            Sy = {left: "start", center: "center", right: "end", start: "start", end: "end"};

        function ky(e, t, n, r) {
            const i = pf(new Uint8Array(e), ["mdat"]);
            if (0 === i.length) return void r(new Error("Could not parse IMSC1 mdat"));
            const s = i.map((e => tf(e))), a = function (e, t, n = 1, r = !1) {
                return ag(e, t, 1 / n, r)
            }(t.baseTime, 1, t.timescale);
            try {
                s.forEach((e => n(function (e, t) {
                    const n = (new DOMParser).parseFromString(e, "text/xml").getElementsByTagName("tt")[0];
                    if (!n) throw new Error("Invalid ttml");
                    const r = {frameRate: 30, subFrameRate: 1, frameRateMultiplier: 0, tickRate: 0},
                        i = Object.keys(r).reduce(((e, t) => (e[t] = n.getAttribute(`ttp:${t}`) || r[t], e)), {}),
                        s = "preserve" !== n.getAttribute("xml:space"), a = Ty(Ay(n, "styling", "style")),
                        o = Ty(Ay(n, "layout", "region")), l = Ay(n, "body", "[begin]");
                    return [].map.call(l, (e => {
                        const n = Cy(e, s);
                        if (!n || !e.hasAttribute("begin")) return null;
                        const r = _y(e.getAttribute("begin"), i), l = _y(e.getAttribute("dur"), i);
                        let c = _y(e.getAttribute("end"), i);
                        if (null === r) throw Ly(e);
                        if (null === c) {
                            if (null === l) throw Ly(e);
                            c = r + l
                        }
                        const u = new ay(r - t, c - t, n);
                        u.id = by(u.startTime, u.endTime, u.text);
                        const d = function (e, t, n) {
                            const r = "http://www.w3.org/ns/ttml#styling";
                            let i = null;
                            const s = null != e && e.hasAttribute("style") ? e.getAttribute("style") : null;
                            return s && n.hasOwnProperty(s) && (i = n[s]), ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"].reduce(((n, s) => {
                                const a = Ry(t, r, s) || Ry(e, r, s) || Ry(i, r, s);
                                return a && (n[s] = a), n
                            }), {})
                        }(o[e.getAttribute("region")], a[e.getAttribute("style")], a), {textAlign: h} = d;
                        if (h) {
                            const e = Sy[h];
                            e && (u.lineAlign = e), u.align = h
                        }
                        return oh(u, d), u
                    })).filter((e => null !== e))
                }(e, a))))
            } catch (e) {
                r(e)
            }
        }

        function Ay(e, t, n) {
            const r = e.getElementsByTagName(t)[0];
            return r ? [].slice.call(r.querySelectorAll(n)) : []
        }

        function Ty(e) {
            return e.reduce(((e, t) => {
                const n = t.getAttribute("xml:id");
                return n && (e[n] = t), e
            }), {})
        }

        function Cy(e, t) {
            return [].slice.call(e.childNodes).reduce(((e, n, r) => {
                var i;
                return "br" === n.nodeName && r ? e + "\n" : null != (i = n.childNodes) && i.length ? Cy(n, t) : t ? e + n.textContent.trim().replace(/\s+/g, " ") : e + n.textContent
            }), "")
        }

        function Ry(e, t, n) {
            return e && e.hasAttributeNS(t, n) ? e.getAttributeNS(t, n) : null
        }

        function Ly(e) {
            return new Error(`Could not parse ttml timestamp ${e}`)
        }

        function _y(e, t) {
            if (!e) return null;
            let n = ly(e);
            return null === n && (xy.test(e) ? n = function (e, t) {
                const n = xy.exec(e), r = (0 | n[4]) + (0 | n[5]) / t.subFrameRate;
                return 3600 * (0 | n[1]) + 60 * (0 | n[2]) + (0 | n[3]) + r / t.frameRate
            }(e, t) : Ey.test(e) && (n = function (e, t) {
                const n = Ey.exec(e), r = Number(n[1]);
                switch (n[2]) {
                    case"h":
                        return 3600 * r;
                    case"m":
                        return 60 * r;
                    case"ms":
                        return 1e3 * r;
                    case"f":
                        return r / t.frameRate;
                    case"t":
                        return r / t.tickRate
                }
                return r
            }(e, t))), n
        }

        function Py(e, t) {
            return !!e && e.label === t.name && !(e.textTrack1 || e.textTrack2)
        }

        class Ny {
            constructor(e) {
                this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
            }

            setStreamController(e) {
                this.streamController = e
            }

            destroy() {
                this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null
            }

            registerListeners() {
                const {hls: e} = this;
                e.on(ch.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(ch.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.on(ch.BUFFER_CODECS, this.onBufferCodecs, this), e.on(ch.MEDIA_DETACHING, this.onMediaDetaching, this)
            }

            unregisterListener() {
                const {hls: e} = this;
                e.off(ch.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(ch.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.off(ch.BUFFER_CODECS, this.onBufferCodecs, this), e.off(ch.MEDIA_DETACHING, this.onMediaDetaching, this)
            }

            onFpsDropLevelCapping(e, t) {
                const n = this.hls.levels[t.droppedLevel];
                this.isLevelAllowed(n) && this.restrictedLevels.push({
                    bitrate: n.bitrate,
                    height: n.height,
                    width: n.width
                })
            }

            onMediaAttaching(e, t) {
                this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null
            }

            onManifestParsed(e, t) {
                const n = this.hls;
                this.restrictedLevels = [], this.firstLevel = t.firstLevel, n.config.capLevelToPlayerSize && t.video && this.startCapping()
            }

            onBufferCodecs(e, t) {
                this.hls.config.capLevelToPlayerSize && t.video && this.startCapping()
            }

            onMediaDetaching() {
                this.stopCapping()
            }

            detectPlayerSize() {
                if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
                    const e = this.hls.levels;
                    if (e.length) {
                        const t = this.hls;
                        t.autoLevelCapping = this.getMaxLevel(e.length - 1), t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping
                    }
                }
            }

            getMaxLevel(e) {
                const t = this.hls.levels;
                if (!t.length) return -1;
                const n = t.filter(((t, n) => this.isLevelAllowed(t) && n <= e));
                return this.clientRect = null, Ny.getMaxLevelByMediaSize(n, this.mediaWidth, this.mediaHeight)
            }

            startCapping() {
                this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
            }

            stopCapping() {
                this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
            }

            getDimensions() {
                if (this.clientRect) return this.clientRect;
                const e = this.media, t = {width: 0, height: 0};
                if (e) {
                    const n = e.getBoundingClientRect();
                    t.width = n.width, t.height = n.height, t.width || t.height || (t.width = n.right - n.left || e.width || 0, t.height = n.bottom - n.top || e.height || 0)
                }
                return this.clientRect = t, t
            }

            get mediaWidth() {
                return this.getDimensions().width * this.contentScaleFactor
            }

            get mediaHeight() {
                return this.getDimensions().height * this.contentScaleFactor
            }

            get contentScaleFactor() {
                let e = 1;
                if (!this.hls.config.ignoreDevicePixelRatio) try {
                    e = self.devicePixelRatio
                } catch (e) {
                }
                return e
            }

            isLevelAllowed(e) {
                return !this.restrictedLevels.some((t => e.bitrate === t.bitrate && e.width === t.width && e.height === t.height))
            }

            static getMaxLevelByMediaSize(e, t, n) {
                if (null == e || !e.length) return -1;
                let r = e.length - 1;
                for (let a = 0; a < e.length; a += 1) {
                    const o = e[a];
                    if ((o.width >= t || o.height >= n) && (i = o, !(s = e[a + 1]) || i.width !== s.width || i.height !== s.height)) {
                        r = a;
                        break
                    }
                }
                var i, s;
                return r
            }
        }

        const jy = "[eme]";

        class Iy {
            constructor(e) {
                this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = Iy.CDMCleanupPromise ? [Iy.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = mh.debug.bind(mh, jy), this.log = mh.log.bind(mh, jy), this.warn = mh.warn.bind(mh, jy), this.error = mh.error.bind(mh, jy), this.hls = e, this.config = e.config, this.registerListeners()
            }

            destroy() {
                this.unregisterListeners(), this.onMediaDetached();
                const e = this.config;
                e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null, this.config = null
            }

            registerListeners() {
                this.hls.on(ch.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(ch.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(ch.MANIFEST_LOADED, this.onManifestLoaded, this)
            }

            unregisterListeners() {
                this.hls.off(ch.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(ch.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(ch.MANIFEST_LOADED, this.onManifestLoaded, this)
            }

            getLicenseServerUrl(e) {
                const {drmSystems: t, widevineLicenseUrl: n} = this.config, r = t[e];
                if (r) return r.licenseUrl;
                if (e === Ph.WIDEVINE && n) return n;
                throw new Error(`no license server URL configured for key-system "${e}"`)
            }

            getServerCertificateUrl(e) {
                const {drmSystems: t} = this.config, n = t[e];
                if (n) return n.serverCertificateUrl;
                this.log(`No Server Certificate in config.drmSystems["${e}"]`)
            }

            attemptKeySystemAccess(e) {
                const t = this.hls.levels, n = (e, t, n) => !!e && n.indexOf(e) === t,
                    r = t.map((e => e.audioCodec)).filter(n), i = t.map((e => e.videoCodec)).filter(n);
                return r.length + i.length === 0 && i.push("avc1.42e01e"), new Promise(((t, n) => {
                    const s = e => {
                        const a = e.shift();
                        this.getMediaKeysPromise(a, r, i).then((e => t({keySystem: a, mediaKeys: e}))).catch((t => {
                            e.length ? s(e) : n(t instanceof My ? t : new My({
                                type: uh.KEY_SYSTEM_ERROR,
                                details: dh.KEY_SYSTEM_NO_ACCESS,
                                error: t,
                                fatal: !0
                            }, t.message))
                        }))
                    };
                    s(e)
                }))
            }

            requestMediaKeySystemAccess(e, t) {
                const {requestMediaKeySystemAccessFunc: n} = this.config;
                if ("function" != typeof n) {
                    let e = `Configured requestMediaKeySystemAccess is not a function ${n}`;
                    return null === Uh && "http:" === self.location.protocol && (e = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(e))
                }
                return n(e, t)
            }

            getMediaKeysPromise(e, t, n) {
                const r = function (e, t, n, r) {
                    let i;
                    switch (e) {
                        case Ph.FAIRPLAY:
                            i = ["cenc", "sinf"];
                            break;
                        case Ph.WIDEVINE:
                        case Ph.PLAYREADY:
                            i = ["cenc"];
                            break;
                        case Ph.CLEARKEY:
                            i = ["cenc", "keyids"];
                            break;
                        default:
                            throw new Error(`Unknown key-system: ${e}`)
                    }
                    return function (e, t, n, r) {
                        return [{
                            initDataTypes: e,
                            persistentState: r.persistentState || "not-allowed",
                            distinctiveIdentifier: r.distinctiveIdentifier || "not-allowed",
                            sessionTypes: r.sessionTypes || [r.sessionType || "temporary"],
                            audioCapabilities: t.map((e => ({
                                contentType: `audio/mp4; codecs="${e}"`,
                                robustness: r.audioRobustness || "",
                                encryptionScheme: r.audioEncryptionScheme || null
                            }))),
                            videoCapabilities: n.map((e => ({
                                contentType: `video/mp4; codecs="${e}"`,
                                robustness: r.videoRobustness || "",
                                encryptionScheme: r.videoEncryptionScheme || null
                            })))
                        }]
                    }(i, t, n, r)
                }(e, t, n, this.config.drmSystemOptions), i = this.keySystemAccessPromises[e];
                let s = null == i ? void 0 : i.keySystemAccess;
                if (!s) {
                    this.log(`Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(r)}`), s = this.requestMediaKeySystemAccess(e, r);
                    const t = this.keySystemAccessPromises[e] = {keySystemAccess: s};
                    return s.catch((t => {
                        this.log(`Failed to obtain access to key-system "${e}": ${t}`)
                    })), s.then((n => {
                        this.log(`Access for key-system "${n.keySystem}" obtained`);
                        const r = this.fetchServerCertificate(e);
                        return this.log(`Create media-keys for "${e}"`), t.mediaKeys = n.createMediaKeys().then((t => (this.log(`Media-keys created for "${e}"`), r.then((n => n ? this.setMediaKeysServerCertificate(t, e, n) : t))))), t.mediaKeys.catch((t => {
                            this.error(`Failed to create media-keys for "${e}"}: ${t}`)
                        })), t.mediaKeys
                    }))
                }
                return s.then((() => i.mediaKeys))
            }

            createMediaKeySessionContext({decryptdata: e, keySystem: t, mediaKeys: n}) {
                this.log(`Creating key-system session "${t}" keyId: ${sf(e.keyId || [])}`);
                const r = n.createSession(),
                    i = {decryptdata: e, keySystem: t, mediaKeys: n, mediaKeysSession: r, keyStatus: "status-pending"};
                return this.mediaKeySessions.push(i), i
            }

            renewKeySession(e) {
                const t = e.decryptdata;
                if (t.pssh) {
                    const n = this.createMediaKeySessionContext(e), r = this.getKeyIdString(t), i = "cenc";
                    this.keyIdToKeySessionPromise[r] = this.generateRequestWithPreferredKeySession(n, i, t.pssh, "expired")
                } else this.warn("Could not renew expired session. Missing pssh initData.");
                this.removeSession(e)
            }

            getKeyIdString(e) {
                if (!e) throw new Error("Could not read keyId of undefined decryptdata");
                if (null === e.keyId) throw new Error("keyId is null");
                return sf(e.keyId)
            }

            updateKeySession(e, t) {
                var n;
                const r = e.mediaKeysSession;
                return this.log(`Updating key-session "${r.sessionId}" for keyID ${sf((null == (n = e.decryptdata) ? void 0 : n.keyId) || [])}\n      } (data length: ${t ? t.byteLength : t})`), r.update(t)
            }

            selectKeySystemFormat(e) {
                const t = Object.keys(e.levelkeys || {});
                return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise
            }

            getKeyFormatPromise(e) {
                return new Promise(((t, n) => {
                    const r = Fh(this.config), i = e.map(Dh).filter((e => !!e && -1 !== r.indexOf(e)));
                    return this.getKeySystemSelectionPromise(i).then((({keySystem: e}) => {
                        const r = Bh(e);
                        r ? t(r) : n(new Error(`Unable to find format for key-system "${e}"`))
                    })).catch(n)
                }))
            }

            loadKey(e) {
                const t = e.keyInfo.decryptdata, n = this.getKeyIdString(t),
                    r = `(keyId: ${n} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
                this.log(`Starting session for key ${r}`);
                let i = this.keyIdToKeySessionPromise[n];
                return i || (i = this.keyIdToKeySessionPromise[n] = this.getKeySystemForKeyPromise(t).then((({
                                                                                                                 keySystem: n,
                                                                                                                 mediaKeys: i
                                                                                                             }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${r}`), this.attemptSetMediaKeys(n, i).then((() => {
                    this.throwIfDestroyed();
                    const e = this.createMediaKeySessionContext({keySystem: n, mediaKeys: i, decryptdata: t});
                    return this.generateRequestWithPreferredKeySession(e, "cenc", t.pssh, "playlist-key")
                }))))), i.catch((e => this.handleError(e)))), i
            }

            throwIfDestroyed(e = "Invalid state") {
                if (!this.hls) throw new Error("invalid state")
            }

            handleError(e) {
                this.hls && (this.error(e.message), e instanceof My ? this.hls.trigger(ch.ERROR, e.data) : this.hls.trigger(ch.ERROR, {
                    type: uh.KEY_SYSTEM_ERROR,
                    details: dh.KEY_SYSTEM_NO_KEYS,
                    error: e,
                    fatal: !0
                }))
            }

            getKeySystemForKeyPromise(e) {
                const t = this.getKeyIdString(e), n = this.keyIdToKeySessionPromise[t];
                if (!n) {
                    const t = Dh(e.keyFormat), n = t ? [t] : Fh(this.config);
                    return this.attemptKeySystemAccess(n)
                }
                return n
            }

            getKeySystemSelectionPromise(e) {
                if (e.length || (e = Fh(this.config)), 0 === e.length) throw new My({
                    type: uh.KEY_SYSTEM_ERROR,
                    details: dh.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
                    fatal: !0
                }, `Missing key-system license configuration options ${JSON.stringify({drmSystems: this.config.drmSystems})}`);
                return this.attemptKeySystemAccess(e)
            }

            _onMediaEncrypted(e) {
                const {initDataType: t, initData: n} = e;
                if (this.debug(`"${e.type}" event: init data type: "${t}"`), null === n) return;
                let r, i;
                if ("sinf" === t && this.config.drmSystems[Ph.FAIRPLAY]) {
                    const e = cf(new Uint8Array(n));
                    try {
                        const t = Lh(JSON.parse(e).sinf), n = yf(new Uint8Array(t));
                        if (!n) return;
                        r = n.subarray(8, 24), i = Ph.FAIRPLAY
                    } catch (e) {
                        return void this.warn('Failed to parse sinf "encrypted" event message initData')
                    }
                } else {
                    const e = function (e) {
                        if (!(e instanceof ArrayBuffer) || e.byteLength < 32) return null;
                        const t = {version: 0, systemId: "", kids: null, data: null}, n = new DataView(e),
                            r = n.getUint32(0);
                        if (e.byteLength !== r && r > 44) return null;
                        if (1886614376 !== n.getUint32(4)) return null;
                        if (t.version = n.getUint32(8) >>> 24, t.version > 1) return null;
                        t.systemId = sf(new Uint8Array(e, 12, 16));
                        const i = n.getUint32(28);
                        if (0 === t.version) {
                            if (r - 32 < i) return null;
                            t.data = new Uint8Array(e, 32, i)
                        } else if (1 === t.version) {
                            t.kids = [];
                            for (let n = 0; n < i; n++) t.kids.push(new Uint8Array(e, 32 + 16 * n, 16))
                        }
                        return t
                    }(n);
                    if (null === e) return;
                    0 === e.version && e.systemId === Oh && e.data && (r = e.data.subarray(8, 24)), i = function (e) {
                        if (e === Oh) return Ph.WIDEVINE
                    }(e.systemId)
                }
                if (!i || !r) return;
                const s = sf(r), {keyIdToKeySessionPromise: a, mediaKeySessions: o} = this;
                let l = a[s];
                for (let e = 0; e < o.length; e++) {
                    const i = o[e], c = i.decryptdata;
                    if (c.pssh || !c.keyId) continue;
                    const u = sf(c.keyId);
                    if (s === u || -1 !== c.uri.replace(/-/g, "").indexOf(s)) {
                        l = a[u], delete a[u], c.pssh = new Uint8Array(n), c.keyId = r, l = a[s] = l.then((() => this.generateRequestWithPreferredKeySession(i, t, n, "encrypted-event-key-match")));
                        break
                    }
                }
                l || (l = a[s] = this.getKeySystemSelectionPromise([i]).then((({keySystem: e, mediaKeys: i}) => {
                    var a;
                    this.throwIfDestroyed();
                    const o = new Af("ISO-23001-7", s, null != (a = Bh(e)) ? a : "");
                    return o.pssh = new Uint8Array(n), o.keyId = r, this.attemptSetMediaKeys(e, i).then((() => {
                        this.throwIfDestroyed();
                        const r = this.createMediaKeySessionContext({decryptdata: o, keySystem: e, mediaKeys: i});
                        return this.generateRequestWithPreferredKeySession(r, t, n, "encrypted-event-no-match")
                    }))
                }))), l.catch((e => this.handleError(e)))
            }

            _onWaitingForKey(e) {
                this.log(`"${e.type}" event`)
            }

            attemptSetMediaKeys(e, t) {
                const n = this.setMediaKeysQueue.slice();
                this.log(`Setting media-keys for "${e}"`);
                const r = Promise.all(n).then((() => {
                    if (!this.media) throw new Error("Attempted to set mediaKeys without media element attached");
                    return this.media.setMediaKeys(t)
                }));
                return this.setMediaKeysQueue.push(r), r.then((() => {
                    this.log(`Media-keys set for "${e}"`), n.push(r), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((e => -1 === n.indexOf(e)))
                }))
            }

            generateRequestWithPreferredKeySession(e, t, n, r) {
                var i, s;
                const a = null == (i = this.config.drmSystems) || null == (s = i[e.keySystem]) ? void 0 : s.generateRequest;
                if (a) try {
                    const r = a.call(this.hls, t, n, e);
                    if (!r) throw new Error("Invalid response from configured generateRequest filter");
                    t = r.initDataType, n = e.decryptdata.pssh = r.initData ? new Uint8Array(r.initData) : null
                } catch (e) {
                    var o;
                    if (this.warn(e.message), null != (o = this.hls) && o.config.debug) throw e
                }
                if (null === n) return this.log(`Skipping key-session request for "${r}" (no initData)`), Promise.resolve(e);
                const l = this.getKeyIdString(e.decryptdata);
                this.log(`Generating key-session request for "${r}": ${l} (init data type: ${t} length: ${n ? n.byteLength : null})`);
                const c = new Ag;
                e.mediaKeysSession.onmessage = t => {
                    const n = e.mediaKeysSession;
                    if (!n) return void c.emit("error", new Error("invalid state"));
                    const {messageType: r, message: i} = t;
                    this.log(`"${r}" message event for session "${n.sessionId}" message size: ${i.byteLength}`), "license-request" === r || "license-renewal" === r ? this.renewLicense(e, i).catch((e => {
                        this.handleError(e), c.emit("error", e)
                    })) : "license-release" === r ? e.keySystem === Ph.FAIRPLAY && (this.updateKeySession(e, _h("acknowledged")), this.removeSession(e)) : this.warn(`unhandled media key message type "${r}"`)
                }, e.mediaKeysSession.onkeystatuseschange = t => {
                    if (!e.mediaKeysSession) return void c.emit("error", new Error("invalid state"));
                    this.onKeyStatusChange(e);
                    const n = e.keyStatus;
                    c.emit("keyStatus", n), "expired" === n && (this.warn(`${e.keySystem} expired for key ${l}`), this.renewKeySession(e))
                };
                const u = new Promise(((e, t) => {
                    c.on("error", t), c.on("keyStatus", (n => {
                        n.startsWith("usable") ? e() : "output-restricted" === n ? t(new My({
                            type: uh.KEY_SYSTEM_ERROR,
                            details: dh.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                            fatal: !1
                        }, "HDCP level output restricted")) : "internal-error" === n ? t(new My({
                            type: uh.KEY_SYSTEM_ERROR,
                            details: dh.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                            fatal: !0
                        }, `key status changed to "${n}"`)) : "expired" === n ? t(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${n}"`)
                    }))
                }));
                return e.mediaKeysSession.generateRequest(t, n).then((() => {
                    var t;
                    this.log(`Request generated for key-session "${null == (t = e.mediaKeysSession) ? void 0 : t.sessionId}" keyId: ${l}`)
                })).catch((e => {
                    throw new My({
                        type: uh.KEY_SYSTEM_ERROR,
                        details: dh.KEY_SYSTEM_NO_SESSION,
                        error: e,
                        fatal: !1
                    }, `Error generating key-session request: ${e}`)
                })).then((() => u)).catch((t => {
                    throw c.removeAllListeners(), this.removeSession(e), t
                })).then((() => (c.removeAllListeners(), e)))
            }

            onKeyStatusChange(e) {
                e.mediaKeysSession.keyStatuses.forEach(((t, n) => {
                    this.log(`key status change "${t}" for keyStatuses keyId: ${sf("buffer" in n ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n))} session keyId: ${sf(new Uint8Array(e.decryptdata.keyId || []))} uri: ${e.decryptdata.uri}`), e.keyStatus = t
                }))
            }

            fetchServerCertificate(e) {
                const t = this.config, n = new (0, t.loader)(t), r = this.getServerCertificateUrl(e);
                return r ? (this.log(`Fetching serverCertificate for "${e}"`), new Promise(((i, s) => {
                    const a = {responseType: "arraybuffer", url: r}, o = t.certLoadPolicy.default,
                        l = {loadPolicy: o, timeout: o.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0},
                        c = {
                            onSuccess: (e, t, n, r) => {
                                i(e.data)
                            }, onError: (t, n, i, o) => {
                                s(new My({
                                    type: uh.KEY_SYSTEM_ERROR,
                                    details: dh.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                                    fatal: !0,
                                    networkDetails: i,
                                    response: sh({url: a.url, data: void 0}, t)
                                }, `"${e}" certificate request failed (${r}). Status: ${t.code} (${t.text})`))
                            }, onTimeout: (t, n, i) => {
                                s(new My({
                                    type: uh.KEY_SYSTEM_ERROR,
                                    details: dh.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                                    fatal: !0,
                                    networkDetails: i,
                                    response: {url: a.url, data: void 0}
                                }, `"${e}" certificate request timed out (${r})`))
                            }, onAbort: (e, t, n) => {
                                s(new Error("aborted"))
                            }
                        };
                    n.load(a, l, c)
                }))) : Promise.resolve()
            }

            setMediaKeysServerCertificate(e, t, n) {
                return new Promise(((r, i) => {
                    e.setServerCertificate(n).then((i => {
                        this.log(`setServerCertificate ${i ? "success" : "not supported by CDM"} (${null == n ? void 0 : n.byteLength}) on "${t}"`), r(e)
                    })).catch((e => {
                        i(new My({
                            type: uh.KEY_SYSTEM_ERROR,
                            details: dh.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                            error: e,
                            fatal: !0
                        }, e.message))
                    }))
                }))
            }

            renewLicense(e, t) {
                return this.requestLicense(e, new Uint8Array(t)).then((t => this.updateKeySession(e, new Uint8Array(t)).catch((e => {
                    throw new My({
                        type: uh.KEY_SYSTEM_ERROR,
                        details: dh.KEY_SYSTEM_SESSION_UPDATE_FAILED,
                        error: e,
                        fatal: !0
                    }, e.message)
                }))))
            }

            setupLicenseXHR(e, t, n, r) {
                const i = this.config.licenseXhrSetup;
                return i ? Promise.resolve().then((() => {
                    if (!n.decryptdata) throw new Error("Key removed");
                    return i.call(this.hls, e, t, n, r)
                })).catch((s => {
                    if (!n.decryptdata) throw s;
                    return e.open("POST", t, !0), i.call(this.hls, e, t, n, r)
                })).then((n => (e.readyState || e.open("POST", t, !0), {
                    xhr: e,
                    licenseChallenge: n || r
                }))) : (e.open("POST", t, !0), Promise.resolve({xhr: e, licenseChallenge: r}))
            }

            requestLicense(e, t) {
                const n = this.config.keyLoadPolicy.default;
                return new Promise(((r, i) => {
                    const s = this.getLicenseServerUrl(e.keySystem);
                    this.log(`Sending license request to URL: ${s}`);
                    const a = new XMLHttpRequest;
                    a.responseType = "arraybuffer", a.onreadystatechange = () => {
                        if (!this.hls || !e.mediaKeysSession) return i(new Error("invalid state"));
                        if (4 === a.readyState) if (200 === a.status) {
                            this._requestLicenseFailureCount = 0;
                            let t = a.response;
                            this.log(`License received ${t instanceof ArrayBuffer ? t.byteLength : t}`);
                            const n = this.config.licenseResponseCallback;
                            if (n) try {
                                t = n.call(this.hls, a, s, e)
                            } catch (e) {
                                this.error(e)
                            }
                            r(t)
                        } else {
                            const o = n.errorRetry, l = o ? o.maxNumRetry : 0;
                            if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > l || a.status >= 400 && a.status < 500) i(new My({
                                type: uh.KEY_SYSTEM_ERROR,
                                details: dh.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                fatal: !0,
                                networkDetails: a,
                                response: {url: s, data: void 0, code: a.status, text: a.statusText}
                            }, `License Request XHR failed (${s}). Status: ${a.status} (${a.statusText})`)); else {
                                const n = l - this._requestLicenseFailureCount + 1;
                                this.warn(`Retrying license request, ${n} attempts left`), this.requestLicense(e, t).then(r, i)
                            }
                        }
                    }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = a, this.setupLicenseXHR(a, s, e, t).then((({
                                                                                                                                                                              xhr: e,
                                                                                                                                                                              licenseChallenge: t
                                                                                                                                                                          }) => {
                        e.send(t)
                    }))
                }))
            }

            onMediaAttached(e, t) {
                if (!this.config.emeEnabled) return;
                const n = t.media;
                this.media = n, n.addEventListener("encrypted", this.onMediaEncrypted), n.addEventListener("waitingforkey", this.onWaitingForKey)
            }

            onMediaDetached() {
                const e = this.media, t = this.mediaKeySessions;
                e && (e.removeEventListener("encrypted", this.onMediaEncrypted), e.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, Af.clearKeyUriToKeyIdMap();
                const n = t.length;
                Iy.CDMCleanupPromise = Promise.all(t.map((e => this.removeSession(e))).concat(null == e ? void 0 : e.setMediaKeys(null).catch((t => {
                    this.log(`Could not clear media keys: ${t}. media.src: ${null == e ? void 0 : e.src}`)
                })))).then((() => {
                    n && (this.log("finished closing key sessions and clearing media keys"), t.length = 0)
                })).catch((t => {
                    this.log(`Could not close sessions and clear media keys: ${t}. media.src: ${null == e ? void 0 : e.src}`)
                }))
            }

            onManifestLoading() {
                this.keyFormatPromise = null
            }

            onManifestLoaded(e, {sessionKeys: t}) {
                if (t && this.config.emeEnabled && !this.keyFormatPromise) {
                    const e = t.reduce(((e, t) => (-1 === e.indexOf(t.keyFormat) && e.push(t.keyFormat), e)), []);
                    this.log(`Selecting key-system from session-keys ${e.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(e)
                }
            }

            removeSession(e) {
                const {mediaKeysSession: t, licenseXhr: n} = e;
                if (t) {
                    this.log(`Remove licenses and keys and close session ${t.sessionId}`), t.onmessage = null, t.onkeystatuseschange = null, n && n.readyState !== XMLHttpRequest.DONE && n.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
                    const r = this.mediaKeySessions.indexOf(e);
                    return r > -1 && this.mediaKeySessions.splice(r, 1), t.remove().catch((e => {
                        this.log(`Could not remove session: ${e}`)
                    })).then((() => t.close())).catch((e => {
                        this.log(`Could not close session: ${e}`)
                    }))
                }
            }
        }

        Iy.CDMCleanupPromise = void 0;

        class My extends Error {
            constructor(e, t) {
                super(t), this.data = void 0, e.error || (e.error = new Error(t)), this.data = e, e.err = e.error
            }
        }

        var Dy = "a", Oy = "av";

        class By {
            constructor(e) {
                this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
                    this.initialized && (this.starved = !0), this.buffering = !0
                }, this.onPlaying = () => {
                    this.initialized || (this.initialized = !0), this.buffering = !1
                }, this.applyPlaylistData = e => {
                    try {
                        this.apply(e, {ot: "m", su: !this.initialized})
                    } catch (e) {
                        mh.warn("Could not generate manifest CMCD data.", e)
                    }
                }, this.applyFragmentData = e => {
                    try {
                        const t = e.frag, n = this.hls.levels[t.level], r = this.getObjectType(t),
                            i = {d: 1e3 * t.duration, ot: r};
                        "v" !== r && r !== Dy && r != Oy || (i.br = n.bitrate / 1e3, i.tb = this.getTopBandwidth(r) / 1e3, i.bl = this.getBufferLength(r)), this.apply(e, i)
                    } catch (e) {
                        mh.warn("Could not generate segment CMCD data.", e)
                    }
                }, this.hls = e;
                const t = this.config = e.config, {cmcd: n} = t;
                null != n && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = n.sessionId || By.uuid(), this.cid = n.contentId, this.useHeaders = !0 === n.useHeaders, this.registerListeners())
            }

            registerListeners() {
                const e = this.hls;
                e.on(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(ch.MEDIA_DETACHED, this.onMediaDetached, this), e.on(ch.BUFFER_CREATED, this.onBufferCreated, this)
            }

            unregisterListeners() {
                const e = this.hls;
                e.off(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(ch.MEDIA_DETACHED, this.onMediaDetached, this), e.off(ch.BUFFER_CREATED, this.onBufferCreated, this)
            }

            destroy() {
                this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null
            }

            onMediaAttached(e, t) {
                this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying)
            }

            onMediaDetached() {
                this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null)
            }

            onBufferCreated(e, t) {
                var n, r;
                this.audioBuffer = null == (n = t.tracks.audio) ? void 0 : n.buffer, this.videoBuffer = null == (r = t.tracks.video) ? void 0 : r.buffer
            }

            createData() {
                var e;
                return {
                    v: 1,
                    sf: "h",
                    sid: this.sid,
                    cid: this.cid,
                    pr: null == (e = this.media) ? void 0 : e.playbackRate,
                    mtp: this.hls.bandwidthEstimate / 1e3
                }
            }

            apply(e, t = {}) {
                oh(t, this.createData());
                const n = "i" === t.ot || "v" === t.ot || t.ot === Oy;
                if (this.starved && n && (t.bs = !0, t.su = !0, this.starved = !1), null == t.su && (t.su = this.buffering), this.useHeaders) {
                    const n = By.toHeaders(t);
                    if (!Object.keys(n).length) return;
                    e.headers || (e.headers = {}), oh(e.headers, n)
                } else {
                    const n = By.toQuery(t);
                    if (!n) return;
                    e.url = By.appendQueryToUri(e.url, n)
                }
            }

            getObjectType(e) {
                const {type: t} = e;
                return "subtitle" === t ? "tt" : "initSegment" === e.sn ? "i" : "audio" === t ? Dy : "main" === t ? this.hls.audioTracks.length ? "v" : Oy : void 0
            }

            getTopBandwidth(e) {
                let t, n = 0;
                const r = this.hls;
                if (e === Dy) t = r.audioTracks; else {
                    const e = r.maxAutoLevel, n = e > -1 ? e + 1 : r.levels.length;
                    t = r.levels.slice(0, n)
                }
                for (const e of t) e.bitrate > n && (n = e.bitrate);
                return n > 0 ? n : NaN
            }

            getBufferLength(e) {
                const t = this.hls.media, n = e === Dy ? this.audioBuffer : this.videoBuffer;
                return n && t ? 1e3 * tm.bufferInfo(n, t.currentTime, this.config.maxBufferHole).len : NaN
            }

            createPlaylistLoader() {
                const {pLoader: e} = this.config, t = this.applyPlaylistData, n = e || this.config.loader;
                return class {
                    constructor(e) {
                        this.loader = void 0, this.loader = new n(e)
                    }

                    get stats() {
                        return this.loader.stats
                    }

                    get context() {
                        return this.loader.context
                    }

                    destroy() {
                        this.loader.destroy()
                    }

                    abort() {
                        this.loader.abort()
                    }

                    load(e, n, r) {
                        t(e), this.loader.load(e, n, r)
                    }
                }
            }

            createFragmentLoader() {
                const {fLoader: e} = this.config, t = this.applyFragmentData, n = e || this.config.loader;
                return class {
                    constructor(e) {
                        this.loader = void 0, this.loader = new n(e)
                    }

                    get stats() {
                        return this.loader.stats
                    }

                    get context() {
                        return this.loader.context
                    }

                    destroy() {
                        this.loader.destroy()
                    }

                    abort() {
                        this.loader.abort()
                    }

                    load(e, n, r) {
                        t(e), this.loader.load(e, n, r)
                    }
                }
            }

            static uuid() {
                const e = URL.createObjectURL(new Blob), t = e.toString();
                return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1)
            }

            static serialize(e) {
                const t = [], n = e => !Number.isNaN(e) && null != e && "" !== e && !1 !== e, r = e => Math.round(e),
                    i = e => 100 * r(e / 100),
                    s = {br: r, d: r, bl: i, dl: i, mtp: i, nor: e => encodeURIComponent(e), rtp: i, tb: r},
                    a = Object.keys(e || {}).sort();
                for (const r of a) {
                    let i = e[r];
                    if (!n(i)) continue;
                    if ("v" === r && 1 === i) continue;
                    if ("pr" == r && 1 === i) continue;
                    const a = s[r];
                    a && (i = a(i));
                    const o = typeof i;
                    let l;
                    l = "ot" === r || "sf" === r || "st" === r ? `${r}=${i}` : "boolean" === o ? r : "number" === o ? `${r}=${i}` : `${r}=${JSON.stringify(i)}`, t.push(l)
                }
                return t.join(",")
            }

            static toHeaders(e) {
                const t = Object.keys(e), n = {}, r = ["Object", "Request", "Session", "Status"], i = [{}, {}, {}, {}],
                    s = {
                        br: 0,
                        d: 0,
                        ot: 0,
                        tb: 0,
                        bl: 1,
                        dl: 1,
                        mtp: 1,
                        nor: 1,
                        nrr: 1,
                        su: 1,
                        cid: 2,
                        pr: 2,
                        sf: 2,
                        sid: 2,
                        st: 2,
                        v: 2,
                        bs: 3,
                        rtp: 3
                    };
                for (const n of t) i[null != s[n] ? s[n] : 1][n] = e[n];
                for (let e = 0; e < i.length; e++) {
                    const t = By.serialize(i[e]);
                    t && (n[`CMCD-${r[e]}`] = t)
                }
                return n
            }

            static toQuery(e) {
                return `CMCD=${encodeURIComponent(By.serialize(e))}`
            }

            static appendQueryToUri(e, t) {
                if (!t) return e;
                const n = e.includes("?") ? "&" : "?";
                return `${e}${n}${t}`
            }
        }

        function Fy(e, t, n, r) {
            e && Object.keys(t).forEach((i => {
                const s = e.filter((e => e.groupId === i)).map((e => {
                    const s = oh({}, e);
                    return s.details = void 0, s.attrs = new vh(s.attrs), s.url = s.attrs.URI = Uy(e.url, e.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", n), s.groupId = s.attrs["GROUP-ID"] = t[i], s.attrs["PATHWAY-ID"] = r, s
                }));
                e.push(...s)
            }))
        }

        function Uy(e, t, n, r) {
            const {HOST: i, PARAMS: s, [n]: a} = r;
            let o;
            t && (o = null == a ? void 0 : a[t], o && (e = o));
            const l = new self.URL(e);
            return i && !o && (l.host = i), s && Object.keys(s).sort().forEach((e => {
                e && l.searchParams.set(e, s[e])
            })), l.href
        }

        const Hy = /^age:\s*[\d.]+\s*$/im;

        class $y {
            constructor(e) {
                this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new xh, this.retryDelay = 0
            }

            destroy() {
                this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null
            }

            abortInternal() {
                const e = this.loader;
                self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, 4 !== e.readyState && (this.stats.aborted = !0, e.abort()))
            }

            abort() {
                var e;
                this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
            }

            load(e, t, n) {
                if (this.stats.loading.start) throw new Error("Loader can only be used once.");
                this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = n, this.loadInternal()
            }

            loadInternal() {
                const {config: e, context: t} = this;
                if (!e) return;
                const n = this.loader = new self.XMLHttpRequest, r = this.stats;
                r.loading.first = 0, r.loaded = 0;
                const i = this.xhrSetup;
                i ? Promise.resolve().then((() => {
                    if (!this.stats.aborted) return i(n, t.url)
                })).catch((e => (n.open("GET", t.url, !0), i(n, t.url)))).then((() => {
                    this.stats.aborted || this.openAndSendXhr(n, t, e)
                })).catch((e => {
                    this.callbacks.onError({code: n.status, text: e.message}, t, n, r)
                })) : this.openAndSendXhr(n, t, e)
            }

            openAndSendXhr(e, t, n) {
                e.readyState || e.open("GET", t.url, !0);
                const r = this.context.headers, {maxTimeToFirstByteMs: i, maxLoadTimeMs: s} = n.loadPolicy;
                if (r) for (const t in r) e.setRequestHeader(t, r[t]);
                t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), n.timeout = i && lh(i) ? i : s, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), n.timeout), e.send()
            }

            readystatechange() {
                const {context: e, loader: t, stats: n} = this;
                if (!e || !t) return;
                const r = t.readyState, i = this.config;
                if (!n.aborted && r >= 2 && (0 === n.loading.first && (n.loading.first = Math.max(self.performance.now(), n.loading.start), i.timeout !== i.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), i.timeout = i.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.loadPolicy.maxLoadTimeMs - (n.loading.first - n.loading.start)))), 4 === r)) {
                    self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null;
                    const r = t.status, s = "text" !== t.responseType;
                    if (r >= 200 && r < 300 && (s && t.response || null !== t.responseText)) {
                        n.loading.end = Math.max(self.performance.now(), n.loading.first);
                        const i = s ? t.response : t.responseText,
                            a = "arraybuffer" === t.responseType ? i.byteLength : i.length;
                        if (n.loaded = n.total = a, n.bwEstimate = 8e3 * n.total / (n.loading.end - n.loading.first), !this.callbacks) return;
                        const o = this.callbacks.onProgress;
                        if (o && o(n, e, i, t), !this.callbacks) return;
                        const l = {url: t.responseURL, data: i, code: r};
                        this.callbacks.onSuccess(l, n, e, t)
                    } else {
                        const s = i.loadPolicy.errorRetry;
                        Lp(s, n.retry, !1, r) ? this.retry(s) : (mh.error(`${r} while loading ${e.url}`), this.callbacks.onError({
                            code: r,
                            text: t.statusText
                        }, e, t, n))
                    }
                }
            }

            loadtimeout() {
                var e;
                const t = null == (e = this.config) ? void 0 : e.loadPolicy.timeoutRetry;
                if (Lp(t, this.stats.retry, !0)) this.retry(t); else {
                    mh.warn(`timeout while loading ${this.context.url}`);
                    const e = this.callbacks;
                    e && (this.abortInternal(), e.onTimeout(this.stats, this.context, this.loader))
                }
            }

            retry(e) {
                const {context: t, stats: n} = this;
                this.retryDelay = Cp(e, n.retry), n.retry++, mh.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${t.url}, retrying ${n.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay)
            }

            loadprogress(e) {
                const t = this.stats;
                t.loaded = e.loaded, e.lengthComputable && (t.total = e.total)
            }

            getCacheAge() {
                let e = null;
                if (this.loader && Hy.test(this.loader.getAllResponseHeaders())) {
                    const t = this.loader.getResponseHeader("age");
                    e = t ? parseFloat(t) : null
                }
                return e
            }

            getResponseHeader(e) {
                return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null
            }
        }

        const Ky = /(\d+)-(\d+)\/(\d+)/;

        class zy {
            constructor(e) {
                this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || Gy, this.controller = new self.AbortController, this.stats = new xh
            }

            destroy() {
                this.loader = this.callbacks = null, this.abortInternal()
            }

            abortInternal() {
                const e = this.response;
                null != e && e.ok || (this.stats.aborted = !0, this.controller.abort())
            }

            abort() {
                var e;
                this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
            }

            load(e, t, n) {
                const r = this.stats;
                if (r.loading.start) throw new Error("Loader can only be used once.");
                r.loading.start = self.performance.now();
                const i = function (e, t) {
                        const n = {
                            method: "GET",
                            mode: "cors",
                            credentials: "same-origin",
                            signal: t,
                            headers: new self.Headers(oh({}, e.headers))
                        };
                        return e.rangeEnd && n.headers.set("Range", "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1)), n
                    }(e, this.controller.signal), s = n.onProgress, a = "arraybuffer" === e.responseType,
                    o = a ? "byteLength" : "length", {maxTimeToFirstByteMs: l, maxLoadTimeMs: c} = t.loadPolicy;
                this.context = e, this.config = t, this.callbacks = n, this.request = this.fetchSetup(e, i), self.clearTimeout(this.requestTimeout), t.timeout = l && lh(l) ? l : c, this.requestTimeout = self.setTimeout((() => {
                    this.abortInternal(), n.onTimeout(r, e, this.response)
                }), t.timeout), self.fetch(this.request).then((i => {
                    this.response = this.loader = i;
                    const o = Math.max(self.performance.now(), r.loading.start);
                    if (self.clearTimeout(this.requestTimeout), t.timeout = c, this.requestTimeout = self.setTimeout((() => {
                        this.abortInternal(), n.onTimeout(r, e, this.response)
                    }), c - (o - r.loading.start)), !i.ok) {
                        const {status: e, statusText: t} = i;
                        throw new qy(t || "fetch, bad network response", e, i)
                    }
                    return r.loading.first = o, r.total = function (e) {
                        const t = e.get("Content-Range");
                        if (t) {
                            const e = function (e) {
                                const t = Ky.exec(e);
                                if (t) return parseInt(t[2]) - parseInt(t[1]) + 1
                            }(t);
                            if (lh(e)) return e
                        }
                        const n = e.get("Content-Length");
                        if (n) return parseInt(n)
                    }(i.headers) || r.total, s && lh(t.highWaterMark) ? this.loadProgressively(i, r, e, t.highWaterMark, s) : a ? i.arrayBuffer() : "json" === e.responseType ? i.json() : i.text()
                })).then((i => {
                    const {response: a} = this;
                    self.clearTimeout(this.requestTimeout), r.loading.end = Math.max(self.performance.now(), r.loading.first);
                    const l = i[o];
                    l && (r.loaded = r.total = l);
                    const c = {url: a.url, data: i, code: a.status};
                    s && !lh(t.highWaterMark) && s(r, e, i, a), n.onSuccess(c, r, e, a)
                })).catch((t => {
                    if (self.clearTimeout(this.requestTimeout), r.aborted) return;
                    const i = t && t.code || 0, s = t ? t.message : null;
                    n.onError({code: i, text: s}, e, t ? t.details : null, r)
                }))
            }

            getCacheAge() {
                let e = null;
                if (this.response) {
                    const t = this.response.headers.get("age");
                    e = t ? parseFloat(t) : null
                }
                return e
            }

            getResponseHeader(e) {
                return this.response ? this.response.headers.get(e) : null
            }

            loadProgressively(e, t, n, r = 0, i) {
                const s = new Ng, a = e.body.getReader(), o = () => a.read().then((a => {
                    if (a.done) return s.dataLength && i(t, n, s.flush(), e), Promise.resolve(new ArrayBuffer(0));
                    const l = a.value, c = l.length;
                    return t.loaded += c, c < r || s.dataLength ? (s.push(l), s.dataLength >= r && i(t, n, s.flush(), e)) : i(t, n, l, e), o()
                })).catch((() => Promise.reject()));
                return o()
            }
        }

        function Gy(e, t) {
            return new self.Request(e.url, t)
        }

        class qy extends Error {
            constructor(e, t, n) {
                super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = n
            }
        }

        const Wy = /\s/, Vy = {
            newCue(e, t, n, r) {
                const i = [];
                let s, a, o, l, c;
                const u = self.VTTCue || self.TextTrackCue;
                for (let h = 0; h < r.rows.length; h++) if (s = r.rows[h], o = !0, l = 0, c = "", !s.isEmpty()) {
                    var d;
                    for (let e = 0; e < s.chars.length; e++) Wy.test(s.chars[e].uchar) && o ? l++ : (c += s.chars[e].uchar, o = !1);
                    s.cueStartTime = t, t === n && (n += 1e-4), l >= 16 ? l-- : l++;
                    const r = py(c.trim()), f = by(t, n, r);
                    null != e && null != (d = e.cues) && d.getCueById(f) || (a = new u(t, n, r), a.id = f, a.line = h + 1, a.align = "left", a.position = 10 + Math.min(80, 10 * Math.floor(8 * l / 32)), i.push(a))
                }
                return e && i.length && (i.sort(((e, t) => "auto" === e.line || "auto" === t.line ? 0 : e.line > 8 && t.line > 8 ? t.line - e.line : e.line - t.line)), i.forEach((t => ap(e, t)))), i
            }
        }, Yy = sh(sh({
            autoStartLoad: !0,
            startPosition: -1,
            defaultAudioCodec: void 0,
            debug: !1,
            capLevelOnFPSDrop: !1,
            capLevelToPlayerSize: !1,
            ignoreDevicePixelRatio: !1,
            initialLiveManifestSize: 1,
            maxBufferLength: 30,
            backBufferLength: 1 / 0,
            maxBufferSize: 6e7,
            maxBufferHole: .1,
            highBufferWatchdogPeriod: 2,
            nudgeOffset: .1,
            nudgeMaxRetry: 3,
            maxFragLookUpTolerance: .25,
            liveSyncDurationCount: 3,
            liveMaxLatencyDurationCount: 1 / 0,
            liveSyncDuration: void 0,
            liveMaxLatencyDuration: void 0,
            maxLiveSyncPlaybackRate: 1,
            liveDurationInfinity: !1,
            liveBackBufferLength: null,
            maxMaxBufferLength: 600,
            enableWorker: !0,
            workerPath: null,
            enableSoftwareAES: !0,
            startLevel: void 0,
            startFragPrefetch: !1,
            fpsDroppedMonitoringPeriod: 5e3,
            fpsDroppedMonitoringThreshold: .2,
            appendErrorMaxRetry: 3,
            loader: $y,
            fLoader: void 0,
            pLoader: void 0,
            xhrSetup: void 0,
            licenseXhrSetup: void 0,
            licenseResponseCallback: void 0,
            abrController: class {
                constructor(e) {
                    this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = -1, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this.hls = e;
                    const t = e.config;
                    this.bwEstimator = new Pg(t.abrEwmaSlowVoD, t.abrEwmaFastVoD, t.abrEwmaDefaultEstimate), this.registerListeners()
                }

                registerListeners() {
                    const {hls: e} = this;
                    e.on(ch.FRAG_LOADING, this.onFragLoading, this), e.on(ch.FRAG_LOADED, this.onFragLoaded, this), e.on(ch.FRAG_BUFFERED, this.onFragBuffered, this), e.on(ch.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(ch.LEVEL_LOADED, this.onLevelLoaded, this)
                }

                unregisterListeners() {
                    const {hls: e} = this;
                    e.off(ch.FRAG_LOADING, this.onFragLoading, this), e.off(ch.FRAG_LOADED, this.onFragLoaded, this), e.off(ch.FRAG_BUFFERED, this.onFragBuffered, this), e.off(ch.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(ch.LEVEL_LOADED, this.onLevelLoaded, this)
                }

                destroy() {
                    this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null
                }

                onFragLoading(e, t) {
                    var n;
                    const r = t.frag;
                    this.ignoreFragment(r) || (this.fragCurrent = r, this.partCurrent = null != (n = t.part) ? n : null, this.clearTimer(), this.timer = self.setInterval(this.onCheck, 100))
                }

                onLevelSwitching(e, t) {
                    this.clearTimer()
                }

                getTimeToLoadFrag(e, t, n, r) {
                    return e + n / t + (r ? this.lastLevelLoadSec : 0)
                }

                onLevelLoaded(e, t) {
                    const n = this.hls.config, {total: r, bwEstimate: i} = t.stats;
                    lh(r) && lh(i) && (this.lastLevelLoadSec = 8 * r / i), t.details.live ? this.bwEstimator.update(n.abrEwmaSlowLive, n.abrEwmaFastLive) : this.bwEstimator.update(n.abrEwmaSlowVoD, n.abrEwmaFastVoD)
                }

                _abandonRulesCheck() {
                    const {fragCurrent: e, partCurrent: t, hls: n} = this, {autoLevelEnabled: r, media: i} = n;
                    if (!e || !i) return;
                    const s = performance.now(), a = t ? t.stats : e.stats, o = t ? t.duration : e.duration,
                        l = s - a.loading.start;
                    if (a.aborted || a.loaded && a.loaded === a.total || 0 === e.level) return this.clearTimer(), void (this._nextAutoLevel = -1);
                    if (!r || i.paused || !i.playbackRate || !i.readyState) return;
                    const c = n.mainForwardBufferInfo;
                    if (null === c) return;
                    const u = this.bwEstimator.getEstimateTTFB(), d = Math.abs(i.playbackRate);
                    if (l <= Math.max(u, o / (2 * d) * 1e3)) return;
                    const h = c.len / d;
                    if (h >= 2 * o / d) return;
                    const f = a.loading.first ? a.loading.first - a.loading.start : -1, p = a.loaded && f > -1,
                        m = this.bwEstimator.getEstimate(), {levels: g, minAutoLevel: y} = n, v = g[e.level],
                        b = a.total || Math.max(a.loaded, Math.round(o * v.maxBitrate / 8));
                    let w = l - f;
                    w < 1 && p && (w = Math.min(l, 8 * a.loaded / m));
                    const x = p ? 1e3 * a.loaded / w : 0, E = x ? (b - a.loaded) / x : 8 * b / m + u / 1e3;
                    if (E <= h) return;
                    const S = x ? 8 * x : m;
                    let k, A = Number.POSITIVE_INFINITY;
                    for (k = e.level - 1; k > y; k--) {
                        const e = g[k].maxBitrate;
                        if (A = this.getTimeToLoadFrag(u / 1e3, S, o * e, !g[k].details), A < h) break
                    }
                    A >= E || A > 10 * o || (n.nextLoadLevel = k, p ? this.bwEstimator.sample(l - Math.min(u, f), a.loaded) : this.bwEstimator.sampleTTFB(l), this.clearTimer(), mh.warn(`[abr] Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} is loading too slowly;\n      Time to underbuffer: ${h.toFixed(3)} s\n      Estimated load time for current fragment: ${E.toFixed(3)} s\n      Estimated load time for down switch fragment: ${A.toFixed(3)} s\n      TTFB estimate: ${f}\n      Current BW estimate: ${lh(m) ? (m / 1024).toFixed(3) : "Unknown"} Kb/s\n      New BW estimate: ${(this.bwEstimator.getEstimate() / 1024).toFixed(3)} Kb/s\n      Aborting and switching to level ${k}`), e.loader && (this.fragCurrent = this.partCurrent = null, e.abortRequests()), n.trigger(ch.FRAG_LOAD_EMERGENCY_ABORTED, {
                        frag: e,
                        part: t,
                        stats: a
                    }))
                }

                onFragLoaded(e, {frag: t, part: n}) {
                    const r = n ? n.stats : t.stats;
                    if (t.type === Jf && this.bwEstimator.sampleTTFB(r.loading.first - r.loading.start), !this.ignoreFragment(t)) {
                        if (this.clearTimer(), this.lastLoadedFragLevel = t.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
                            const e = n ? n.duration : t.duration, i = this.hls.levels[t.level],
                                s = (i.loaded ? i.loaded.bytes : 0) + r.loaded,
                                a = (i.loaded ? i.loaded.duration : 0) + e;
                            i.loaded = {bytes: s, duration: a}, i.realBitrate = Math.round(8 * s / a)
                        }
                        if (t.bitrateTest) {
                            const e = {stats: r, frag: t, part: n, id: t.type};
                            this.onFragBuffered(ch.FRAG_BUFFERED, e), t.bitrateTest = !1
                        }
                    }
                }

                onFragBuffered(e, t) {
                    const {frag: n, part: r} = t, i = null != r && r.stats.loaded ? r.stats : n.stats;
                    if (i.aborted) return;
                    if (this.ignoreFragment(n)) return;
                    const s = i.parsing.end - i.loading.start - Math.min(i.loading.first - i.loading.start, this.bwEstimator.getEstimateTTFB());
                    this.bwEstimator.sample(s, i.loaded), i.bwEstimate = this.bwEstimator.getEstimate(), n.bitrateTest ? this.bitrateTestDelay = s / 1e3 : this.bitrateTestDelay = 0
                }

                ignoreFragment(e) {
                    return e.type !== Jf || "initSegment" === e.sn
                }

                clearTimer() {
                    self.clearInterval(this.timer)
                }

                get nextAutoLevel() {
                    const e = this._nextAutoLevel, t = this.bwEstimator;
                    if (-1 !== e && !t.canEstimate()) return e;
                    let n = this.getNextABRAutoLevel();
                    if (-1 !== e) {
                        const t = this.hls.levels;
                        if (t.length > Math.max(e, n) && t[e].loadError <= t[n].loadError) return e
                    }
                    return -1 !== e && (n = Math.min(e, n)), n
                }

                getNextABRAutoLevel() {
                    const {fragCurrent: e, partCurrent: t, hls: n} = this, {
                            maxAutoLevel: r,
                            config: i,
                            minAutoLevel: s,
                            media: a
                        } = n, o = t ? t.duration : e ? e.duration : 0,
                        l = a && 0 !== a.playbackRate ? Math.abs(a.playbackRate) : 1,
                        c = this.bwEstimator ? this.bwEstimator.getEstimate() : i.abrEwmaDefaultEstimate,
                        u = n.mainForwardBufferInfo, d = (u ? u.len : 0) / l;
                    let h = this.findBestLevel(c, s, r, d, i.abrBandWidthFactor, i.abrBandWidthUpFactor);
                    if (h >= 0) return h;
                    mh.trace(`[abr] ${d ? "rebuffering expected" : "buffer is empty"}, finding optimal quality level`);
                    let f = o ? Math.min(o, i.maxStarvationDelay) : i.maxStarvationDelay, p = i.abrBandWidthFactor,
                        m = i.abrBandWidthUpFactor;
                    if (!d) {
                        const e = this.bitrateTestDelay;
                        e && (f = (o ? Math.min(o, i.maxLoadingDelay) : i.maxLoadingDelay) - e, mh.trace(`[abr] bitrate test took ${Math.round(1e3 * e)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * f)} ms`), p = m = 1)
                    }
                    return h = this.findBestLevel(c, s, r, d + f, p, m), Math.max(h, 0)
                }

                findBestLevel(e, t, n, r, i, s) {
                    var a;
                    const {fragCurrent: o, partCurrent: l, lastLoadedFragLevel: c} = this, {levels: u} = this.hls,
                        d = u[c], h = !(null == d || null == (a = d.details) || !a.live),
                        f = null == d ? void 0 : d.codecSet, p = l ? l.duration : o ? o.duration : 0,
                        m = this.bwEstimator.getEstimateTTFB() / 1e3;
                    let g = t, y = -1;
                    for (let a = n; a >= t; a--) {
                        const t = u[a];
                        if (!t || f && t.codecSet !== f) {
                            t && (g = Math.min(a, g), y = Math.max(a, y));
                            continue
                        }
                        -1 !== y && mh.trace(`[abr] Skipped level(s) ${g}-${y} with CODECS:"${u[y].attrs.CODECS}"; not compatible with "${d.attrs.CODECS}"`);
                        const n = t.details,
                            o = (l ? null == n ? void 0 : n.partTarget : null == n ? void 0 : n.averagetargetduration) || p;
                        let v;
                        v = a <= c ? i * e : s * e;
                        const b = u[a].maxBitrate, w = this.getTimeToLoadFrag(m, v, b * o, void 0 === n);
                        if (mh.trace(`[abr] level:${a} adjustedbw-bitrate:${Math.round(v - b)} avgDuration:${o.toFixed(1)} maxFetchDuration:${r.toFixed(1)} fetchDuration:${w.toFixed(1)}`), v > b && (0 === w || !lh(w) || h && !this.bitrateTestDelay || w < r)) return a
                    }
                    return -1
                }

                set nextAutoLevel(e) {
                    this._nextAutoLevel = e
                }
            },
            bufferController: class {
                constructor(e) {
                    this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = () => {
                        const {media: e, mediaSource: t} = this;
                        mh.log("[buffer-controller]: Media source opened"), e && (e.removeEventListener("emptied", this._onMediaEmptied), this.updateMediaElementDuration(), this.hls.trigger(ch.MEDIA_ATTACHED, {media: e})), t && t.removeEventListener("sourceopen", this._onMediaSourceOpen), this.checkPendingTracks()
                    }, this._onMediaSourceClose = () => {
                        mh.log("[buffer-controller]: Media source closed")
                    }, this._onMediaSourceEnded = () => {
                        mh.log("[buffer-controller]: Media source ended")
                    }, this._onMediaEmptied = () => {
                        const {media: e, _objectUrl: t} = this;
                        e && e.src !== t && mh.error(`Media element src was set while attaching MediaSource (${t} > ${e.src})`)
                    }, this.hls = e, this._initSourceBuffer(), this.registerListeners()
                }

                hasSourceTypes() {
                    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
                }

                destroy() {
                    this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null
                }

                registerListeners() {
                    const {hls: e} = this;
                    e.on(ch.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.on(ch.BUFFER_RESET, this.onBufferReset, this), e.on(ch.BUFFER_APPENDING, this.onBufferAppending, this), e.on(ch.BUFFER_CODECS, this.onBufferCodecs, this), e.on(ch.BUFFER_EOS, this.onBufferEos, this), e.on(ch.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(ch.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(ch.FRAG_PARSED, this.onFragParsed, this), e.on(ch.FRAG_CHANGED, this.onFragChanged, this)
                }

                unregisterListeners() {
                    const {hls: e} = this;
                    e.off(ch.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.off(ch.BUFFER_RESET, this.onBufferReset, this), e.off(ch.BUFFER_APPENDING, this.onBufferAppending, this), e.off(ch.BUFFER_CODECS, this.onBufferCodecs, this), e.off(ch.BUFFER_EOS, this.onBufferEos, this), e.off(ch.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(ch.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(ch.FRAG_PARSED, this.onFragParsed, this), e.off(ch.FRAG_CHANGED, this.onFragChanged, this)
                }

                _initSourceBuffer() {
                    this.sourceBuffer = {}, this.operationQueue = new Og(this.sourceBuffer), this.listeners = {
                        audio: [],
                        video: [],
                        audiovideo: []
                    }, this.lastMpegAudioChunk = null
                }

                onManifestLoading() {
                    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0, this.details = null
                }

                onManifestParsed(e, t) {
                    let n = 2;
                    (t.audio && !t.video || !t.altAudio) && (n = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = n, mh.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`)
                }

                onMediaAttaching(e, t) {
                    const n = this.media = t.media;
                    if (n && Bg) {
                        const e = this.mediaSource = new Bg;
                        e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), n.src = self.URL.createObjectURL(e), this._objectUrl = n.src, n.addEventListener("emptied", this._onMediaEmptied)
                    }
                }

                onMediaDetaching() {
                    const {media: e, mediaSource: t, _objectUrl: n} = this;
                    if (t) {
                        if (mh.log("[buffer-controller]: media source detaching"), "open" === t.readyState) try {
                            t.endOfStream()
                        } catch (e) {
                            mh.warn(`[buffer-controller]: onMediaDetaching: ${e.message} while calling endOfStream`)
                        }
                        this.onBufferReset(), t.removeEventListener("sourceopen", this._onMediaSourceOpen), t.removeEventListener("sourceended", this._onMediaSourceEnded), t.removeEventListener("sourceclose", this._onMediaSourceClose), e && (e.removeEventListener("emptied", this._onMediaEmptied), n && self.URL.revokeObjectURL(n), e.src === n ? (e.removeAttribute("src"), e.load()) : mh.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}
                    }
                    this.hls.trigger(ch.MEDIA_DETACHED, void 0)
                }

                onBufferReset() {
                    this.getSourceBufferTypes().forEach((e => {
                        const t = this.sourceBuffer[e];
                        try {
                            t && (this.removeBufferListeners(e), this.mediaSource && this.mediaSource.removeSourceBuffer(t), this.sourceBuffer[e] = void 0)
                        } catch (t) {
                            mh.warn(`[buffer-controller]: Failed to reset the ${e} buffer`, t)
                        }
                    })), this._initSourceBuffer()
                }

                onBufferCodecs(e, t) {
                    const n = this.getSourceBufferTypes().length;
                    Object.keys(t).forEach((e => {
                        if (n) {
                            const n = this.tracks[e];
                            if (n && "function" == typeof n.buffer.changeType) {
                                const {id: r, codec: i, levelCodec: s, container: a, metadata: o} = t[e],
                                    l = (n.levelCodec || n.codec).replace(Fg, "$1"), c = (s || i).replace(Fg, "$1");
                                if (l !== c) {
                                    const t = `${a};codecs=${s || i}`;
                                    this.appendChangeType(e, t), mh.log(`[buffer-controller]: switching codec ${l} to ${c}`), this.tracks[e] = {
                                        buffer: n.buffer,
                                        codec: i,
                                        container: a,
                                        levelCodec: s,
                                        metadata: o,
                                        id: r
                                    }
                                }
                            }
                        } else this.pendingTracks[e] = t[e]
                    })), n || (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks())
                }

                appendChangeType(e, t) {
                    const {operationQueue: n} = this, r = {
                        execute: () => {
                            const r = this.sourceBuffer[e];
                            r && (mh.log(`[buffer-controller]: changing ${e} sourceBuffer type to ${t}`), r.changeType(t)), n.shiftAndExecuteNext(e)
                        }, onStart: () => {
                        }, onComplete: () => {
                        }, onError: t => {
                            mh.warn(`[buffer-controller]: Failed to change ${e} SourceBuffer type`, t)
                        }
                    };
                    n.append(r, e)
                }

                onBufferAppending(e, t) {
                    const {hls: n, operationQueue: r, tracks: i} = this, {
                        data: s,
                        type: a,
                        frag: o,
                        part: l,
                        chunkMeta: c
                    } = t, u = c.buffering[a], d = self.performance.now();
                    u.start = d;
                    const h = o.stats.buffering, f = l ? l.stats.buffering : null;
                    0 === h.start && (h.start = d), f && 0 === f.start && (f.start = d);
                    const p = i.audio;
                    let m = !1;
                    "audio" === a && "audio/mpeg" === (null == p ? void 0 : p.container) && (m = !this.lastMpegAudioChunk || 1 === c.id || this.lastMpegAudioChunk.sn !== c.sn, this.lastMpegAudioChunk = c);
                    const g = o.start, y = {
                        execute: () => {
                            if (u.executeStart = self.performance.now(), m) {
                                const e = this.sourceBuffer[a];
                                if (e) {
                                    const t = g - e.timestampOffset;
                                    Math.abs(t) >= .1 && (mh.log(`[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${g} (delta: ${t}) sn: ${o.sn})`), e.timestampOffset = g)
                                }
                            }
                            this.appendExecutor(s, a)
                        }, onStart: () => {
                        }, onComplete: () => {
                            const e = self.performance.now();
                            u.executeEnd = u.end = e, 0 === h.first && (h.first = e), f && 0 === f.first && (f.first = e);
                            const {sourceBuffer: t} = this, n = {};
                            for (const e in t) n[e] = tm.getBuffered(t[e]);
                            this.appendError = 0, this.hls.trigger(ch.BUFFER_APPENDED, {
                                type: a,
                                frag: o,
                                part: l,
                                chunkMeta: c,
                                parent: o.type,
                                timeRanges: n
                            })
                        }, onError: e => {
                            mh.error(`[buffer-controller]: Error encountered while trying to append to the ${a} SourceBuffer`, e);
                            const t = {
                                type: uh.MEDIA_ERROR,
                                parent: o.type,
                                details: dh.BUFFER_APPEND_ERROR,
                                frag: o,
                                part: l,
                                chunkMeta: c,
                                error: e,
                                err: e,
                                fatal: !1
                            };
                            e.code === DOMException.QUOTA_EXCEEDED_ERR ? t.details = dh.BUFFER_FULL_ERROR : (this.appendError++, t.details = dh.BUFFER_APPEND_ERROR, this.appendError > n.config.appendErrorMaxRetry && (mh.error(`[buffer-controller]: Failed ${n.config.appendErrorMaxRetry} times to append segment in sourceBuffer`), t.fatal = !0)), n.trigger(ch.ERROR, t)
                        }
                    };
                    r.append(y, a)
                }

                onBufferFlushing(e, t) {
                    const {operationQueue: n} = this, r = e => ({
                        execute: this.removeExecutor.bind(this, e, t.startOffset, t.endOffset),
                        onStart: () => {
                        },
                        onComplete: () => {
                            this.hls.trigger(ch.BUFFER_FLUSHED, {type: e})
                        },
                        onError: t => {
                            mh.warn(`[buffer-controller]: Failed to remove from ${e} SourceBuffer`, t)
                        }
                    });
                    t.type ? n.append(r(t.type), t.type) : this.getSourceBufferTypes().forEach((e => {
                        n.append(r(e), e)
                    }))
                }

                onFragParsed(e, t) {
                    const {frag: n, part: r} = t, i = [], s = r ? r.elementaryStreams : n.elementaryStreams;
                    s[kh] ? i.push("audiovideo") : (s[Eh] && i.push("audio"), s[Sh] && i.push("video")), 0 === i.length && mh.warn(`Fragments must have at least one ElementaryStreamType set. type: ${n.type} level: ${n.level} sn: ${n.sn}`), this.blockBuffers((() => {
                        const e = self.performance.now();
                        n.stats.buffering.end = e, r && (r.stats.buffering.end = e);
                        const t = r ? r.stats : n.stats;
                        this.hls.trigger(ch.FRAG_BUFFERED, {frag: n, part: r, stats: t, id: n.type})
                    }), i)
                }

                onFragChanged(e, t) {
                    this.flushBackBuffer()
                }

                onBufferEos(e, t) {
                    this.getSourceBufferTypes().reduce(((e, n) => {
                        const r = this.sourceBuffer[n];
                        return !r || t.type && t.type !== n || (r.ending = !0, r.ended || (r.ended = !0, mh.log(`[buffer-controller]: ${n} sourceBuffer now EOS`))), e && !(r && !r.ended)
                    }), !0) && (mh.log("[buffer-controller]: Queueing mediaSource.endOfStream()"), this.blockBuffers((() => {
                        this.getSourceBufferTypes().forEach((e => {
                            const t = this.sourceBuffer[e];
                            t && (t.ending = !1)
                        }));
                        const {mediaSource: e} = this;
                        e && "open" === e.readyState ? (mh.log("[buffer-controller]: Calling mediaSource.endOfStream()"), e.endOfStream()) : e && mh.info(`[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: ${e.readyState}`)
                    })))
                }

                onLevelUpdated(e, {details: t}) {
                    t.fragments.length && (this.details = t, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
                }

                flushBackBuffer() {
                    const {hls: e, details: t, media: n, sourceBuffer: r} = this;
                    if (!n || null === t) return;
                    const i = this.getSourceBufferTypes();
                    if (!i.length) return;
                    const s = t.live && null !== e.config.liveBackBufferLength ? e.config.liveBackBufferLength : e.config.backBufferLength;
                    if (!lh(s) || s < 0) return;
                    const a = n.currentTime, o = t.levelTargetDuration, l = Math.max(s, o),
                        c = Math.floor(a / o) * o - l;
                    i.forEach((n => {
                        const i = r[n];
                        if (i) {
                            const r = tm.getBuffered(i);
                            if (r.length > 0 && c > r.start(0)) {
                                if (e.trigger(ch.BACK_BUFFER_REACHED, {bufferEnd: c}), t.live) e.trigger(ch.LIVE_BACK_BUFFER_REACHED, {bufferEnd: c}); else if (i.ended && r.end(r.length - 1) - a < 2 * o) return void mh.info(`[buffer-controller]: Cannot flush ${n} back buffer while SourceBuffer is in ended state`);
                                e.trigger(ch.BUFFER_FLUSHING, {startOffset: 0, endOffset: c, type: n})
                            }
                        }
                    }))
                }

                updateMediaElementDuration() {
                    if (!this.details || !this.media || !this.mediaSource || "open" !== this.mediaSource.readyState) return;
                    const {details: e, hls: t, media: n, mediaSource: r} = this,
                        i = e.fragments[0].start + e.totalduration, s = n.duration, a = lh(r.duration) ? r.duration : 0;
                    e.live && t.config.liveDurationInfinity ? (mh.log("[buffer-controller]: Media Source duration is set to Infinity"), r.duration = 1 / 0, this.updateSeekableRange(e)) : (i > a && i > s || !lh(s)) && (mh.log(`[buffer-controller]: Updating Media Source duration to ${i.toFixed(3)}`), r.duration = i)
                }

                updateSeekableRange(e) {
                    const t = this.mediaSource, n = e.fragments;
                    if (n.length && e.live && null != t && t.setLiveSeekableRange) {
                        const r = Math.max(0, n[0].start), i = Math.max(r, r + e.totalduration);
                        t.setLiveSeekableRange(r, i)
                    }
                }

                checkPendingTracks() {
                    const {bufferCodecEventsExpected: e, operationQueue: t, pendingTracks: n} = this,
                        r = Object.keys(n).length;
                    if (r && !e || 2 === r) {
                        this.createSourceBuffers(n), this.pendingTracks = {};
                        const e = this.getSourceBufferTypes();
                        if (e.length) this.hls.trigger(ch.BUFFER_CREATED, {tracks: this.tracks}), e.forEach((e => {
                            t.executeNext(e)
                        })); else {
                            const e = new Error("could not create source buffer for media codec(s)");
                            this.hls.trigger(ch.ERROR, {
                                type: uh.MEDIA_ERROR,
                                details: dh.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                                fatal: !0,
                                error: e,
                                reason: e.message
                            })
                        }
                    }
                }

                createSourceBuffers(e) {
                    const {sourceBuffer: t, mediaSource: n} = this;
                    if (!n) throw Error("createSourceBuffers called when mediaSource was null");
                    for (const r in e) if (!t[r]) {
                        const i = e[r];
                        if (!i) throw Error(`source buffer exists for track ${r}, however track does not`);
                        const s = i.levelCodec || i.codec, a = `${i.container};codecs=${s}`;
                        mh.log(`[buffer-controller]: creating sourceBuffer(${a})`);
                        try {
                            const e = t[r] = n.addSourceBuffer(a), o = r;
                            this.addBufferListener(o, "updatestart", this._onSBUpdateStart), this.addBufferListener(o, "updateend", this._onSBUpdateEnd), this.addBufferListener(o, "error", this._onSBUpdateError), this.tracks[r] = {
                                buffer: e,
                                codec: s,
                                container: i.container,
                                levelCodec: i.levelCodec,
                                metadata: i.metadata,
                                id: i.id
                            }
                        } catch (e) {
                            mh.error(`[buffer-controller]: error while trying to add sourceBuffer: ${e.message}`), this.hls.trigger(ch.ERROR, {
                                type: uh.MEDIA_ERROR,
                                details: dh.BUFFER_ADD_CODEC_ERROR,
                                fatal: !1,
                                error: e,
                                mimeType: a
                            })
                        }
                    }
                }

                _onSBUpdateStart(e) {
                    const {operationQueue: t} = this;
                    t.current(e).onStart()
                }

                _onSBUpdateEnd(e) {
                    const {operationQueue: t} = this;
                    t.current(e).onComplete(), t.shiftAndExecuteNext(e)
                }

                _onSBUpdateError(e, t) {
                    const n = new Error(`${e} SourceBuffer error`);
                    mh.error(`[buffer-controller]: ${n}`, t), this.hls.trigger(ch.ERROR, {
                        type: uh.MEDIA_ERROR,
                        details: dh.BUFFER_APPENDING_ERROR,
                        error: n,
                        fatal: !1
                    });
                    const r = this.operationQueue.current(e);
                    r && r.onError(t)
                }

                removeExecutor(e, t, n) {
                    const {media: r, mediaSource: i, operationQueue: s, sourceBuffer: a} = this, o = a[e];
                    if (!r || !i || !o) return mh.warn(`[buffer-controller]: Attempting to remove from the ${e} SourceBuffer, but it does not exist`), void s.shiftAndExecuteNext(e);
                    const l = lh(r.duration) ? r.duration : 1 / 0, c = lh(i.duration) ? i.duration : 1 / 0,
                        u = Math.max(0, t), d = Math.min(n, l, c);
                    d > u && !o.ending ? (o.ended = !1, mh.log(`[buffer-controller]: Removing [${u},${d}] from the ${e} SourceBuffer`), o.remove(u, d)) : s.shiftAndExecuteNext(e)
                }

                appendExecutor(e, t) {
                    const {operationQueue: n, sourceBuffer: r} = this, i = r[t];
                    if (!i) return mh.warn(`[buffer-controller]: Attempting to append to the ${t} SourceBuffer, but it does not exist`), void n.shiftAndExecuteNext(t);
                    i.ended = !1, i.appendBuffer(e)
                }

                blockBuffers(e, t = this.getSourceBufferTypes()) {
                    if (!t.length) return mh.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"), void Promise.resolve().then(e);
                    const {operationQueue: n} = this, r = t.map((e => n.appendBlocker(e)));
                    Promise.all(r).then((() => {
                        e(), t.forEach((e => {
                            const t = this.sourceBuffer[e];
                            null != t && t.updating || n.shiftAndExecuteNext(e)
                        }))
                    }))
                }

                getSourceBufferTypes() {
                    return Object.keys(this.sourceBuffer)
                }

                addBufferListener(e, t, n) {
                    const r = this.sourceBuffer[e];
                    if (!r) return;
                    const i = n.bind(this, e);
                    this.listeners[e].push({event: t, listener: i}), r.addEventListener(t, i)
                }

                removeBufferListeners(e) {
                    const t = this.sourceBuffer[e];
                    t && this.listeners[e].forEach((e => {
                        t.removeEventListener(e.event, e.listener)
                    }))
                }
            },
            capLevelController: Ny,
            errorController: class {
                constructor(e) {
                    this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = e, this.log = mh.log.bind(mh, "[info]:"), this.warn = mh.warn.bind(mh, "[warning]:"), this.error = mh.error.bind(mh, "[error]:"), this.registerListeners()
                }

                registerListeners() {
                    const e = this.hls;
                    e.on(ch.ERROR, this.onError, this), e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.LEVEL_UPDATED, this.onLevelUpdated, this)
                }

                unregisterListeners() {
                    const e = this.hls;
                    e && (e.off(ch.ERROR, this.onError, this), e.off(ch.ERROR, this.onErrorOut, this), e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.LEVEL_UPDATED, this.onLevelUpdated, this))
                }

                destroy() {
                    this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {}
                }

                startLoad(e) {
                    this.playlistError = 0
                }

                stopLoad() {
                }

                getVariantLevelIndex(e) {
                    return (null == e ? void 0 : e.type) === Jf ? e.level : this.hls.loadLevel
                }

                onManifestLoading() {
                    this.playlistError = 0, this.penalizedRenditions = {}
                }

                onLevelUpdated() {
                    this.playlistError = 0
                }

                onError(e, t) {
                    var n;
                    if (t.fatal) return;
                    const r = this.hls, i = t.context;
                    switch (t.details) {
                        case dh.FRAG_LOAD_ERROR:
                        case dh.FRAG_LOAD_TIMEOUT:
                        case dh.KEY_LOAD_ERROR:
                        case dh.KEY_LOAD_TIMEOUT:
                            return void (t.errorAction = this.getFragRetryOrSwitchAction(t));
                        case dh.FRAG_GAP:
                        case dh.FRAG_PARSING_ERROR:
                        case dh.FRAG_DECRYPT_ERROR:
                            return t.errorAction = this.getFragRetryOrSwitchAction(t), void (t.errorAction.action = 2);
                        case dh.LEVEL_EMPTY_ERROR:
                        case dh.LEVEL_PARSING_ERROR: {
                            var s, a;
                            const e = t.parent === Jf ? t.level : r.loadLevel;
                            t.details === dh.LEVEL_EMPTY_ERROR && null != (s = t.context) && null != (a = s.levelDetails) && a.live ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, e) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, e))
                        }
                            return;
                        case dh.LEVEL_LOAD_ERROR:
                        case dh.LEVEL_LOAD_TIMEOUT:
                            return void ("number" == typeof (null == i ? void 0 : i.level) && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, i.level)));
                        case dh.AUDIO_TRACK_LOAD_ERROR:
                        case dh.AUDIO_TRACK_LOAD_TIMEOUT:
                        case dh.SUBTITLE_LOAD_ERROR:
                        case dh.SUBTITLE_TRACK_LOAD_TIMEOUT:
                            if (i) {
                                const e = r.levels[r.loadLevel];
                                if (e && (i.type === Xf && i.groupId === e.audioGroupId || i.type === Qf && i.groupId === e.textGroupId)) return t.errorAction = this.getPlaylistRetryOrSwitchAction(t, r.loadLevel), t.errorAction.action = 2, void (t.errorAction.flags = 1)
                            }
                            return;
                        case dh.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED: {
                            const e = r.levels[r.loadLevel], n = null == e ? void 0 : e.attrs["HDCP-LEVEL"];
                            n && (t.errorAction = {action: 2, flags: 2, hdcpLevel: n})
                        }
                            return;
                        case dh.BUFFER_ADD_CODEC_ERROR:
                        case dh.REMUX_ALLOC_ERROR:
                            return void (t.errorAction = this.getLevelSwitchAction(t, null != (n = t.level) ? n : r.loadLevel));
                        case dh.INTERNAL_EXCEPTION:
                        case dh.BUFFER_APPENDING_ERROR:
                        case dh.BUFFER_APPEND_ERROR:
                        case dh.BUFFER_FULL_ERROR:
                        case dh.LEVEL_SWITCH_ERROR:
                        case dh.BUFFER_STALLED_ERROR:
                        case dh.BUFFER_SEEK_OVER_HOLE:
                        case dh.BUFFER_NUDGE_ON_STALL:
                            return void (t.errorAction = {action: 0, flags: 0})
                    }
                    if (t.type === uh.KEY_SYSTEM_ERROR) {
                        const e = this.getVariantLevelIndex(t.frag);
                        return t.levelRetry = !1, void (t.errorAction = this.getLevelSwitchAction(t, e))
                    }
                }

                getPlaylistRetryOrSwitchAction(e, t) {
                    var n;
                    const r = Tp(this.hls.config.playlistLoadPolicy, e), i = this.playlistError++,
                        s = null == (n = e.response) ? void 0 : n.code;
                    if (Lp(r, i, Ap(e), s)) return {action: 5, flags: 0, retryConfig: r, retryCount: i};
                    const a = this.getLevelSwitchAction(e, t);
                    return r && (a.retryConfig = r, a.retryCount = i), a
                }

                getFragRetryOrSwitchAction(e) {
                    const t = this.hls, n = this.getVariantLevelIndex(e.frag), r = t.levels[n], {
                            fragLoadPolicy: i,
                            keyLoadPolicy: s
                        } = t.config, a = Tp(e.details.startsWith("key") ? s : i, e),
                        o = t.levels.reduce(((e, t) => e + t.fragmentError), 0);
                    if (r) {
                        var l;
                        e.details !== dh.FRAG_GAP && r.fragmentError++;
                        const t = null == (l = e.response) ? void 0 : l.code;
                        if (Lp(a, o, Ap(e), t)) return {action: 5, flags: 0, retryConfig: a, retryCount: o}
                    }
                    const c = this.getLevelSwitchAction(e, n);
                    return a && (c.retryConfig = a, c.retryCount = o), c
                }

                getLevelSwitchAction(e, t) {
                    const n = this.hls;
                    null == t && (t = n.loadLevel);
                    const r = this.hls.levels[t];
                    if (r && (r.loadError++, n.autoLevelEnabled)) {
                        var i, s;
                        let t = -1;
                        const {levels: a, loadLevel: o, minAutoLevel: l, maxAutoLevel: c} = n,
                            u = null == (i = e.frag) ? void 0 : i.type, {
                                type: d,
                                groupId: h
                            } = null != (s = e.context) ? s : {};
                        for (let n = a.length; n--;) {
                            const i = (n + o) % a.length;
                            if (i !== o && i >= l && i <= c && 0 === a[i].loadError) {
                                const n = a[i];
                                if (e.details === dh.FRAG_GAP && e.frag) {
                                    const t = a[i].details;
                                    if (t) {
                                        const n = Pp(e.frag, t.fragments, e.frag.start);
                                        if (null != n && n.gap) continue
                                    }
                                } else {
                                    if (d === Xf && h === n.audioGroupId || d === Qf && h === n.textGroupId) continue;
                                    if (u === ep && r.audioGroupId === n.audioGroupId || u === tp && r.textGroupId === n.textGroupId) continue
                                }
                                t = i;
                                break
                            }
                        }
                        if (t > -1 && n.loadLevel !== t) return e.levelRetry = !0, this.playlistError = 0, {
                            action: 2,
                            flags: 0,
                            nextAutoLevel: t
                        }
                    }
                    return {action: 2, flags: 1}
                }

                onErrorOut(e, t) {
                    var n;
                    switch (null == (n = t.errorAction) ? void 0 : n.action) {
                        case 0:
                            break;
                        case 2:
                            this.sendAlternateToPenaltyBox(t), t.errorAction.resolved || t.details === dh.FRAG_GAP || (t.fatal = !0)
                    }
                    t.fatal && this.hls.stopLoad()
                }

                sendAlternateToPenaltyBox(e) {
                    const t = this.hls, n = e.errorAction;
                    if (!n) return;
                    const {flags: r, hdcpLevel: i, nextAutoLevel: s} = n;
                    switch (r) {
                        case 0:
                            this.switchLevel(e, s);
                            break;
                        case 1:
                            n.resolved || (n.resolved = this.redundantFailover(e));
                            break;
                        case 2:
                            i && (t.maxHdcpLevel = gp[gp.indexOf(i) - 1], n.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`)
                    }
                    n.resolved || this.switchLevel(e, s)
                }

                switchLevel(e, t) {
                    void 0 !== t && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel)
                }

                redundantFailover(e) {
                    const {hls: t, penalizedRenditions: n} = this, r = e.parent === Jf ? e.level : t.loadLevel,
                        i = t.levels[r], s = i.url.length, a = e.frag ? e.frag.urlId : i.urlId;
                    i.urlId !== a || e.frag && !i.details || this.penalizeRendition(i, e);
                    for (let o = 1; o < s; o++) {
                        const l = (a + o) % s, c = n[l];
                        if (!c || Ip(c, e, n[a])) return this.warn(`Switching to Redundant Stream ${l + 1}/${s}: "${i.url[l]}" after ${e.details}`), this.playlistError = 0, t.levels.forEach((e => {
                            e.urlId = l
                        })), t.nextLoadLevel = r, !0
                    }
                    return !1
                }

                penalizeRendition(e, t) {
                    const {penalizedRenditions: n} = this,
                        r = n[e.urlId] || {lastErrorPerfMs: 0, errors: [], details: void 0};
                    r.lastErrorPerfMs = performance.now(), r.errors.push(t), r.details = e.details, n[e.urlId] = r
                }
            },
            fpsController: class {
                constructor(e) {
                    this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners()
                }

                setStreamController(e) {
                    this.streamController = e
                }

                registerListeners() {
                    this.hls.on(ch.MEDIA_ATTACHING, this.onMediaAttaching, this)
                }

                unregisterListeners() {
                    this.hls.off(ch.MEDIA_ATTACHING, this.onMediaAttaching, this)
                }

                destroy() {
                    this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
                }

                onMediaAttaching(e, t) {
                    const n = this.hls.config;
                    if (n.capLevelOnFPSDrop) {
                        const e = t.media instanceof self.HTMLVideoElement ? t.media : null;
                        this.media = e, e && "function" == typeof e.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), n.fpsDroppedMonitoringPeriod)
                    }
                }

                checkFPS(e, t, n) {
                    const r = performance.now();
                    if (t) {
                        if (this.lastTime) {
                            const e = r - this.lastTime, i = n - this.lastDroppedFrames, s = t - this.lastDecodedFrames,
                                a = 1e3 * i / e, o = this.hls;
                            if (o.trigger(ch.FPS_DROP, {
                                currentDropped: i,
                                currentDecoded: s,
                                totalDroppedFrames: n
                            }), a > 0 && i > o.config.fpsDroppedMonitoringThreshold * s) {
                                let e = o.currentLevel;
                                mh.warn("drop FPS ratio greater than max allowed value for currentLevel: " + e), e > 0 && (-1 === o.autoLevelCapping || o.autoLevelCapping >= e) && (e -= 1, o.trigger(ch.FPS_DROP_LEVEL_CAPPING, {
                                    level: e,
                                    droppedLevel: o.currentLevel
                                }), o.autoLevelCapping = e, this.streamController.nextLevelSwitch())
                            }
                        }
                        this.lastTime = r, this.lastDroppedFrames = n, this.lastDecodedFrames = t
                    }
                }

                checkFPSInterval() {
                    const e = this.media;
                    if (e) if (this.isVideoPlaybackQualityAvailable) {
                        const t = e.getVideoPlaybackQuality();
                        this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)
                    } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
                }
            },
            stretchShortVideoTrack: !1,
            maxAudioFramesDrift: 1,
            forceKeyFrameOnDiscontinuity: !0,
            abrEwmaFastLive: 3,
            abrEwmaSlowLive: 9,
            abrEwmaFastVoD: 3,
            abrEwmaSlowVoD: 9,
            abrEwmaDefaultEstimate: 5e5,
            abrBandWidthFactor: .95,
            abrBandWidthUpFactor: .7,
            abrMaxWithRealBitrate: !1,
            maxStarvationDelay: 4,
            maxLoadingDelay: 4,
            minAutoBitrate: 0,
            emeEnabled: !1,
            widevineLicenseUrl: void 0,
            drmSystems: {},
            drmSystemOptions: {},
            requestMediaKeySystemAccessFunc: Uh,
            testBandwidth: !0,
            progressive: !1,
            lowLatencyMode: !0,
            cmcd: void 0,
            enableDateRangeMetadataCues: !0,
            enableEmsgMetadataCues: !0,
            enableID3MetadataCues: !0,
            certLoadPolicy: {
                default: {
                    maxTimeToFirstByteMs: 8e3,
                    maxLoadTimeMs: 2e4,
                    timeoutRetry: null,
                    errorRetry: null
                }
            },
            keyLoadPolicy: {
                default: {
                    maxTimeToFirstByteMs: 8e3,
                    maxLoadTimeMs: 2e4,
                    timeoutRetry: {maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear"},
                    errorRetry: {maxNumRetry: 8, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear"}
                }
            },
            manifestLoadPolicy: {
                default: {
                    maxTimeToFirstByteMs: 1 / 0,
                    maxLoadTimeMs: 2e4,
                    timeoutRetry: {maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0},
                    errorRetry: {maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3}
                }
            },
            playlistLoadPolicy: {
                default: {
                    maxTimeToFirstByteMs: 1e4,
                    maxLoadTimeMs: 2e4,
                    timeoutRetry: {maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0},
                    errorRetry: {maxNumRetry: 2, retryDelayMs: 1e3, maxRetryDelayMs: 8e3}
                }
            },
            fragLoadPolicy: {
                default: {
                    maxTimeToFirstByteMs: 1e4,
                    maxLoadTimeMs: 12e4,
                    timeoutRetry: {maxNumRetry: 4, retryDelayMs: 0, maxRetryDelayMs: 0},
                    errorRetry: {maxNumRetry: 6, retryDelayMs: 1e3, maxRetryDelayMs: 8e3}
                }
            },
            steeringManifestLoadPolicy: {
                default: {
                    maxTimeToFirstByteMs: 1e4,
                    maxLoadTimeMs: 2e4,
                    timeoutRetry: {maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0},
                    errorRetry: {maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3}
                }
            },
            manifestLoadingTimeOut: 1e4,
            manifestLoadingMaxRetry: 1,
            manifestLoadingRetryDelay: 1e3,
            manifestLoadingMaxRetryTimeout: 64e3,
            levelLoadingTimeOut: 1e4,
            levelLoadingMaxRetry: 4,
            levelLoadingRetryDelay: 1e3,
            levelLoadingMaxRetryTimeout: 64e3,
            fragLoadingTimeOut: 2e4,
            fragLoadingMaxRetry: 6,
            fragLoadingRetryDelay: 1e3,
            fragLoadingMaxRetryTimeout: 64e3
        }, {
            cueHandler: Vy,
            enableWebVTT: !0,
            enableIMSC1: !0,
            enableCEA708Captions: !0,
            captionsTextTrack1Label: "English",
            captionsTextTrack1LanguageCode: "en",
            captionsTextTrack2Label: "Spanish",
            captionsTextTrack2LanguageCode: "es",
            captionsTextTrack3Label: "Unknown CC",
            captionsTextTrack3LanguageCode: "",
            captionsTextTrack4Label: "Unknown CC",
            captionsTextTrack4LanguageCode: "",
            renderTextTracksNatively: !0
        }), {}, {
            subtitleStreamController: class extends Sm {
                constructor(e, t, n) {
                    super(e, t, n, "[subtitle-stream-controller]", tp), this.levels = [], this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this._registerListeners()
                }

                onHandlerDestroying() {
                    this._unregisterListeners(), this.mainDetails = null
                }

                _registerListeners() {
                    const {hls: e} = this;
                    e.on(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.LEVEL_LOADED, this.onLevelLoaded, this), e.on(ch.ERROR, this.onError, this), e.on(ch.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(ch.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(ch.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(ch.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(ch.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(ch.FRAG_BUFFERED, this.onFragBuffered, this)
                }

                _unregisterListeners() {
                    const {hls: e} = this;
                    e.off(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.LEVEL_LOADED, this.onLevelLoaded, this), e.off(ch.ERROR, this.onError, this), e.off(ch.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(ch.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(ch.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(ch.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(ch.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(ch.FRAG_BUFFERED, this.onFragBuffered, this)
                }

                startLoad(e) {
                    this.stopLoad(), this.state = hm, this.setInterval(500), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
                }

                onManifestLoading() {
                    this.mainDetails = null, this.fragmentTracker.removeAllFragments()
                }

                onMediaDetaching() {
                    this.tracksBuffered = [], super.onMediaDetaching()
                }

                onLevelLoaded(e, t) {
                    this.mainDetails = t.details
                }

                onSubtitleFragProcessed(e, t) {
                    const {frag: n, success: r} = t;
                    if (this.fragPrevious = n, this.state = hm, !r) return;
                    const i = this.tracksBuffered[this.currentTrackId];
                    if (!i) return;
                    let s;
                    const a = n.start;
                    for (let e = 0; e < i.length; e++) if (a >= i[e].start && a <= i[e].end) {
                        s = i[e];
                        break
                    }
                    const o = n.start + n.duration;
                    s ? s.end = o : (s = {start: a, end: o}, i.push(s)), this.fragmentTracker.fragBuffered(n)
                }

                onBufferFlushing(e, t) {
                    const {startOffset: n, endOffset: r} = t;
                    if (0 === n && r !== Number.POSITIVE_INFINITY) {
                        const {currentTrackId: e, levels: i} = this;
                        if (!i.length || !i[e] || !i[e].details) return;
                        const s = r - i[e].details.targetduration;
                        if (s <= 0) return;
                        t.endOffsetSubtitles = Math.max(0, s), this.tracksBuffered.forEach((e => {
                            for (let t = 0; t < e.length;) if (e[t].end <= s) e.shift(); else {
                                if (!(e[t].start < s)) break;
                                e[t].start = s, t++
                            }
                        })), this.fragmentTracker.removeFragmentsInRange(n, s, tp)
                    }
                }

                onFragBuffered(e, t) {
                    var n;
                    this.loadedmetadata || t.frag.type !== Jf || null != (n = this.media) && n.buffered.length && (this.loadedmetadata = !0)
                }

                onError(e, t) {
                    const n = t.frag;
                    (null == n ? void 0 : n.type) === tp && (this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== dm && (this.state = hm))
                }

                onSubtitleTracksUpdated(e, {subtitleTracks: t}) {
                    jg(this.levels, t) ? this.levels = t.map((e => new vp(e))) : (this.tracksBuffered = [], this.levels = t.map((e => {
                        const t = new vp(e);
                        return this.tracksBuffered[t.id] = [], t
                    })), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, tp), this.fragPrevious = null, this.mediaBuffer = null)
                }

                onSubtitleTrackSwitch(e, t) {
                    if (this.currentTrackId = t.id, !this.levels.length || -1 === this.currentTrackId) return void this.clearInterval();
                    const n = this.levels[this.currentTrackId];
                    null != n && n.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, n && this.setInterval(500)
                }

                onSubtitleTrackLoaded(e, t) {
                    var n;
                    const {details: r, id: i} = t, {currentTrackId: s, levels: a} = this;
                    if (!a.length) return;
                    const o = a[s];
                    if (i >= a.length || i !== s || !o) return;
                    this.mediaBuffer = this.mediaBufferTimeRanges;
                    let l = 0;
                    if (r.live || null != (n = o.details) && n.live) {
                        const e = this.mainDetails;
                        if (r.deltaUpdateFailed || !e) return;
                        const t = e.fragments[0];
                        o.details ? (l = this.alignPlaylists(r, o.details), 0 === l && t && (l = t.start, Ep(r, l))) : r.hasProgramDateTime && e.hasProgramDateTime ? (am(r, e), l = r.fragments[0].start) : t && (l = t.start, Ep(r, l))
                    }
                    o.details = r, this.levelLastLoaded = i, this.startFragRequested || !this.mainDetails && r.live || this.setStartPosition(o.details, l), this.tick(), r.live && !this.fragCurrent && this.media && this.state === hm && (Pp(null, r.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), o.details = void 0))
                }

                _handleFragmentLoadComplete(e) {
                    const {frag: t, payload: n} = e, r = t.decryptdata, i = this.hls;
                    if (!this.fragContextChanged(t) && n && n.byteLength > 0 && r && r.key && r.iv && "AES-128" === r.method) {
                        const e = performance.now();
                        this.decrypter.decrypt(new Uint8Array(n), r.key.buffer, r.iv.buffer).catch((e => {
                            throw i.trigger(ch.ERROR, {
                                type: uh.MEDIA_ERROR,
                                details: dh.FRAG_DECRYPT_ERROR,
                                fatal: !1,
                                error: e,
                                reason: e.message,
                                frag: t
                            }), e
                        })).then((n => {
                            const r = performance.now();
                            i.trigger(ch.FRAG_DECRYPTED, {frag: t, payload: n, stats: {tstart: e, tdecrypt: r}})
                        })).catch((e => {
                            this.warn(`${e.name}: ${e.message}`), this.state = hm
                        }))
                    }
                }

                doTick() {
                    if (this.media) {
                        if (this.state === hm) {
                            const {currentTrackId: e, levels: t} = this, n = t[e];
                            if (!t.length || !n || !n.details) return;
                            const r = n.details, i = r.targetduration, {config: s} = this, a = this.getLoadPosition(),
                                o = tm.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], a - i, s.maxBufferHole), {
                                    end: l,
                                    len: c
                                } = o, u = this.getFwdBufferInfo(this.media, Jf);
                            if (c > this.getMaxBufferLength(null == u ? void 0 : u.len) + i) return;
                            const d = r.fragments, h = d.length, f = r.edge;
                            let p = null;
                            const m = this.fragPrevious;
                            if (l < f) {
                                const {maxFragLookUpTolerance: e} = s;
                                p = Pp(m, d, Math.max(d[0].start, l), e), !p && m && m.start < d[0].start && (p = d[0])
                            } else p = d[h - 1];
                            if (!p) return;
                            p = this.mapToInitFragWhenRequired(p), this.fragmentTracker.getState(p) === Up && this.loadFragment(p, n, l)
                        }
                    } else this.state = hm
                }

                getMaxBufferLength(e) {
                    const t = super.getMaxBufferLength();
                    return e ? Math.max(t, e) : t
                }

                loadFragment(e, t, n) {
                    this.fragCurrent = e, "initSegment" === e.sn ? this._loadInitSegment(e, t) : (this.startFragRequested = !0, super.loadFragment(e, t, n))
                }

                get mediaBufferTimeRanges() {
                    return new Mg(this.tracksBuffered[this.currentTrackId] || [])
                }
            }, subtitleTrackController: class extends Mp {
                constructor(e) {
                    super(e, "[subtitle-track-controller]"), this.media = null, this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.trackChangeListener = () => this.onTextTracksChanged(), this.asyncPollTrackChange = () => this.pollTrackChange(0), this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.registerListeners()
                }

                destroy() {
                    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.trackChangeListener = this.asyncPollTrackChange = null, super.destroy()
                }

                get subtitleDisplay() {
                    return this._subtitleDisplay
                }

                set subtitleDisplay(e) {
                    this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes(this.trackId)
                }

                registerListeners() {
                    const {hls: e} = this;
                    e.on(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.on(ch.LEVEL_LOADING, this.onLevelLoading, this), e.on(ch.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(ch.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(ch.ERROR, this.onError, this)
                }

                unregisterListeners() {
                    const {hls: e} = this;
                    e.off(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.off(ch.LEVEL_LOADING, this.onLevelLoading, this), e.off(ch.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(ch.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(ch.ERROR, this.onError, this)
                }

                onMediaAttached(e, t) {
                    this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
                }

                pollTrackChange(e) {
                    self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, e)
                }

                onMediaDetaching() {
                    this.media && (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), Dg(this.media.textTracks).forEach((e => {
                        op(e)
                    })), this.subtitleTrack = -1, this.media = null)
                }

                onManifestLoading() {
                    this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0
                }

                onManifestParsed(e, t) {
                    this.tracks = t.subtitleTracks
                }

                onSubtitleTrackLoaded(e, t) {
                    const {id: n, details: r} = t, {trackId: i} = this, s = this.tracksInGroup[i];
                    if (!s) return void this.warn(`Invalid subtitle track id ${n}`);
                    const a = s.details;
                    s.details = t.details, this.log(`subtitle track ${n} loaded [${r.startSN}-${r.endSN}]`), n === this.trackId && this.playlistLoaded(n, t, a)
                }

                onLevelLoading(e, t) {
                    this.switchLevel(t.level)
                }

                onLevelSwitching(e, t) {
                    this.switchLevel(t.level)
                }

                switchLevel(e) {
                    const t = this.hls.levels[e];
                    if (null == t || !t.textGroupIds) return;
                    const n = t.textGroupIds[t.urlId],
                        r = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
                    if (this.groupId !== n) {
                        const e = this.tracks.filter((e => !n || e.groupId === n));
                        this.tracksInGroup = e;
                        const t = this.findTrackId(null == r ? void 0 : r.name) || this.findTrackId();
                        this.groupId = n || null;
                        const i = {subtitleTracks: e};
                        this.log(`Updating subtitle tracks, ${e.length} track(s) found in "${n}" group-id`), this.hls.trigger(ch.SUBTITLE_TRACKS_UPDATED, i), -1 !== t && this.setSubtitleTrack(t, r)
                    } else this.shouldReloadPlaylist(r) && this.setSubtitleTrack(this.trackId, r)
                }

                findTrackId(e) {
                    const t = this.tracksInGroup;
                    for (let n = 0; n < t.length; n++) {
                        const r = t[n];
                        if ((!this.selectDefaultTrack || r.default) && (!e || e === r.name)) return r.id
                    }
                    return -1
                }

                onError(e, t) {
                    !t.fatal && t.context && t.context.type === Qf && t.context.id === this.trackId && t.context.groupId === this.groupId && this.checkRetry(t)
                }

                get subtitleTracks() {
                    return this.tracksInGroup
                }

                get subtitleTrack() {
                    return this.trackId
                }

                set subtitleTrack(e) {
                    this.selectDefaultTrack = !1;
                    const t = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
                    this.setSubtitleTrack(e, t)
                }

                loadPlaylist(e) {
                    super.loadPlaylist();
                    const t = this.tracksInGroup[this.trackId];
                    if (this.shouldLoadPlaylist(t)) {
                        const n = t.id, r = t.groupId;
                        let i = t.url;
                        if (e) try {
                            i = e.addDirectives(i)
                        } catch (e) {
                            this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`)
                        }
                        this.log(`Loading subtitle playlist for id ${n}`), this.hls.trigger(ch.SUBTITLE_TRACK_LOADING, {
                            url: i,
                            id: n,
                            groupId: r,
                            deliveryDirectives: e || null
                        })
                    }
                }

                toggleTrackModes(e) {
                    const {media: t, trackId: n} = this;
                    if (!t) return;
                    const r = Dg(t.textTracks), i = r.filter((e => e.groupId === this.groupId));
                    if (-1 === e) [].slice.call(r).forEach((e => {
                        e.mode = "disabled"
                    })); else {
                        const e = i[n];
                        e && (e.mode = "disabled")
                    }
                    const s = i[e];
                    s && (s.mode = this.subtitleDisplay ? "showing" : "hidden")
                }

                setSubtitleTrack(e, t) {
                    var n;
                    const r = this.tracksInGroup;
                    if (!this.media) return void (this.queuedDefaultTrack = e);
                    if (this.trackId !== e && this.toggleTrackModes(e), this.trackId === e && (-1 === e || null != (n = r[e]) && n.details) || e < -1 || e >= r.length) return;
                    this.clearTimer();
                    const i = r[e];
                    if (this.log(`Switching to subtitle-track ${e}` + (i ? ` "${i.name}" lang:${i.lang} group:${i.groupId}` : "")), this.trackId = e, i) {
                        const {id: e, groupId: n = "", name: r, type: s, url: a} = i;
                        this.hls.trigger(ch.SUBTITLE_TRACK_SWITCH, {id: e, groupId: n, name: r, type: s, url: a});
                        const o = this.switchParams(i.url, null == t ? void 0 : t.details);
                        this.loadPlaylist(o)
                    } else this.hls.trigger(ch.SUBTITLE_TRACK_SWITCH, {id: e})
                }

                onTextTracksChanged() {
                    if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return;
                    let e = -1;
                    const t = Dg(this.media.textTracks);
                    for (let n = 0; n < t.length; n++) if ("hidden" === t[n].mode) e = n; else if ("showing" === t[n].mode) {
                        e = n;
                        break
                    }
                    this.subtitleTrack !== e && (this.subtitleTrack = e)
                }
            }, timelineController: class {
                constructor(e) {
                    if (this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
                        ccOffset: 0,
                        presentationOffset: 0,
                        0: {start: 0, prevCC: -1, new: !0}
                    }, this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
                        textTrack1: {
                            label: this.config.captionsTextTrack1Label,
                            languageCode: this.config.captionsTextTrack1LanguageCode
                        },
                        textTrack2: {
                            label: this.config.captionsTextTrack2Label,
                            languageCode: this.config.captionsTextTrack2LanguageCode
                        },
                        textTrack3: {
                            label: this.config.captionsTextTrack3Label,
                            languageCode: this.config.captionsTextTrack3LanguageCode
                        },
                        textTrack4: {
                            label: this.config.captionsTextTrack4Label,
                            languageCode: this.config.captionsTextTrack4LanguageCode
                        }
                    }, this.config.enableCEA708Captions) {
                        const e = new sy(this, "textTrack1"), t = new sy(this, "textTrack2"),
                            n = new sy(this, "textTrack3"), r = new sy(this, "textTrack4");
                        this.cea608Parser1 = new ny(1, e, t), this.cea608Parser2 = new ny(3, n, r)
                    }
                    e.on(ch.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(ch.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(ch.FRAG_LOADING, this.onFragLoading, this), e.on(ch.FRAG_LOADED, this.onFragLoaded, this), e.on(ch.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(ch.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(ch.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(ch.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(ch.BUFFER_FLUSHING, this.onBufferFlushing, this)
                }

                destroy() {
                    const {hls: e} = this;
                    e.off(ch.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(ch.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(ch.FRAG_LOADING, this.onFragLoading, this), e.off(ch.FRAG_LOADED, this.onFragLoaded, this), e.off(ch.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(ch.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(ch.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(ch.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(ch.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null
                }

                addCues(e, t, n, r, i) {
                    let s = !1;
                    for (let e = i.length; e--;) {
                        const r = i[e], u = (a = r[0], o = r[1], l = t, c = n, Math.min(o, c) - Math.max(a, l));
                        if (u >= 0 && (r[0] = Math.min(r[0], t), r[1] = Math.max(r[1], n), s = !0, u / (n - t) > .5)) return
                    }
                    var a, o, l, c;
                    if (s || i.push([t, n]), this.config.renderTextTracksNatively) {
                        const i = this.captionsTracks[e];
                        this.Cues.newCue(i, t, n, r)
                    } else {
                        const i = this.Cues.newCue(null, t, n, r);
                        this.hls.trigger(ch.CUES_PARSED, {type: "captions", cues: i, track: e})
                    }
                }

                onInitPtsFound(e, {frag: t, id: n, initPTS: r, timescale: i}) {
                    const {unparsedVttFrags: s} = this;
                    "main" === n && (this.initPTS[t.cc] = {
                        baseTime: r,
                        timescale: i
                    }), s.length && (this.unparsedVttFrags = [], s.forEach((e => {
                        this.onFragLoaded(ch.FRAG_LOADED, e)
                    })))
                }

                getExistingTrack(e) {
                    const {media: t} = this;
                    if (t) for (let n = 0; n < t.textTracks.length; n++) {
                        const r = t.textTracks[n];
                        if (r[e]) return r
                    }
                    return null
                }

                createCaptionsTrack(e) {
                    this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e)
                }

                createNativeTrack(e) {
                    if (this.captionsTracks[e]) return;
                    const {captionsProperties: t, captionsTracks: n, media: r} = this, {
                        label: i,
                        languageCode: s
                    } = t[e], a = this.getExistingTrack(e);
                    if (a) n[e] = a, op(n[e]), sp(n[e], r); else {
                        const t = this.createTextTrack("captions", i, s);
                        t && (t[e] = !0, n[e] = t)
                    }
                }

                createNonNativeTrack(e) {
                    if (this.nonNativeCaptionsTracks[e]) return;
                    const t = this.captionsProperties[e];
                    if (!t) return;
                    const n = {
                        _id: e,
                        label: t.label,
                        kind: "captions",
                        default: !!t.media && !!t.media.default,
                        closedCaptions: t.media
                    };
                    this.nonNativeCaptionsTracks[e] = n, this.hls.trigger(ch.NON_NATIVE_TEXT_TRACKS_FOUND, {tracks: [n]})
                }

                createTextTrack(e, t, n) {
                    const r = this.media;
                    if (r) return r.addTextTrack(e, t, n)
                }

                onMediaAttaching(e, t) {
                    this.media = t.media, this._cleanTracks()
                }

                onMediaDetaching() {
                    const {captionsTracks: e} = this;
                    Object.keys(e).forEach((t => {
                        op(e[t]), delete e[t]
                    })), this.nonNativeCaptionsTracks = {}
                }

                onManifestLoading() {
                    this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
                        ccOffset: 0,
                        presentationOffset: 0,
                        0: {start: 0, prevCC: -1, new: !0}
                    }, this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset())
                }

                _cleanTracks() {
                    const {media: e} = this;
                    if (!e) return;
                    const t = e.textTracks;
                    if (t) for (let e = 0; e < t.length; e++) op(t[e])
                }

                onSubtitleTracksUpdated(e, t) {
                    const n = t.subtitleTracks || [], r = n.some((e => e.textCodec === wy));
                    if (this.config.enableWebVTT || r && this.config.enableIMSC1) {
                        if (jg(this.tracks, n)) return void (this.tracks = n);
                        if (this.textTracks = [], this.tracks = n, this.config.renderTextTracksNatively) {
                            const e = this.media ? this.media.textTracks : null;
                            this.tracks.forEach(((t, n) => {
                                let r;
                                if (e && n < e.length) {
                                    let n = null;
                                    for (let r = 0; r < e.length; r++) if (Py(e[r], t)) {
                                        n = e[r];
                                        break
                                    }
                                    n && (r = n)
                                }
                                if (r) op(r); else {
                                    const e = this._captionsOrSubtitlesFromCharacteristics(t);
                                    r = this.createTextTrack(e, t.name, t.lang), r && (r.mode = "disabled")
                                }
                                r && (r.groupId = t.groupId, this.textTracks.push(r))
                            }))
                        } else if (this.tracks.length) {
                            const e = this.tracks.map((e => ({
                                label: e.name,
                                kind: e.type.toLowerCase(),
                                default: e.default,
                                subtitleTrack: e
                            })));
                            this.hls.trigger(ch.NON_NATIVE_TEXT_TRACKS_FOUND, {tracks: e})
                        }
                    }
                }

                _captionsOrSubtitlesFromCharacteristics(e) {
                    if (e.attrs.CHARACTERISTICS) {
                        const t = /transcribes-spoken-dialog/gi.test(e.attrs.CHARACTERISTICS),
                            n = /describes-music-and-sound/gi.test(e.attrs.CHARACTERISTICS);
                        if (t && n) return "captions"
                    }
                    return "subtitles"
                }

                onManifestLoaded(e, t) {
                    this.config.enableCEA708Captions && t.captions && t.captions.forEach((e => {
                        const t = /(?:CC|SERVICE)([1-4])/.exec(e.instreamId);
                        if (!t) return;
                        const n = `textTrack${t[1]}`, r = this.captionsProperties[n];
                        r && (r.label = e.name, e.lang && (r.languageCode = e.lang), r.media = e)
                    }))
                }

                closedCaptionsForLevel(e) {
                    const t = this.hls.levels[e.level];
                    return null == t ? void 0 : t.attrs["CLOSED-CAPTIONS"]
                }

                onFragLoading(e, t) {
                    const {cea608Parser1: n, cea608Parser2: r, lastSn: i, lastPartIndex: s} = this;
                    if (this.enabled && n && r && t.frag.type === Jf) {
                        var a, o;
                        const e = t.frag.sn,
                            l = null != (a = null == t || null == (o = t.part) ? void 0 : o.index) ? a : -1;
                        e === i + 1 || e === i && l === s + 1 || (n.reset(), r.reset()), this.lastSn = e, this.lastPartIndex = l
                    }
                }

                onFragLoaded(e, t) {
                    const {frag: n, payload: r} = t, {initPTS: i, unparsedVttFrags: s} = this;
                    if (n.type === tp) if (r.byteLength) {
                        if (!i[n.cc]) return s.push(t), void (i.length && this.hls.trigger(ch.SUBTITLE_FRAG_PROCESSED, {
                            success: !1,
                            frag: n,
                            error: new Error("Missing initial subtitle PTS")
                        }));
                        const e = n.decryptdata, a = "stats" in t;
                        if (null == e || !e.encrypted || a) {
                            const e = this.tracks[n.level], t = this.vttCCs;
                            t[n.cc] || (t[n.cc] = {
                                start: n.start,
                                prevCC: this.prevCC,
                                new: !0
                            }, this.prevCC = n.cc), e && e.textCodec === wy ? this._parseIMSC1(n, r) : this._parseVTTs(n, r, t)
                        }
                    } else this.hls.trigger(ch.SUBTITLE_FRAG_PROCESSED, {
                        success: !1,
                        frag: n,
                        error: new Error("Empty subtitle payload")
                    })
                }

                _parseIMSC1(e, t) {
                    const n = this.hls;
                    ky(t, this.initPTS[e.cc], (t => {
                        this._appendCues(t, e.level), n.trigger(ch.SUBTITLE_FRAG_PROCESSED, {success: !0, frag: e})
                    }), (t => {
                        mh.log(`Failed to parse IMSC1: ${t}`), n.trigger(ch.SUBTITLE_FRAG_PROCESSED, {
                            success: !1,
                            frag: e,
                            error: t
                        })
                    }))
                }

                _parseVTTs(e, t, n) {
                    var r;
                    const i = this.hls;
                    !function (e, t, n, r, i, s, a) {
                        const o = new my, l = tf(new Uint8Array(e)).trim().replace(gy, "\n").split("\n"), c = [],
                            u = function (e, t = 1) {
                                return ag(e, 9e4, 1 / t)
                            }(t.baseTime, t.timescale);
                        let d, h = "00:00.000", f = 0, p = 0, m = !0;
                        o.oncue = function (e) {
                            const t = n[r];
                            let s = n.ccOffset;
                            const a = (f - u) / 9e4;
                            null != t && t.new && (void 0 !== p ? s = n.ccOffset = t.start : function (e, t, n) {
                                let r = e[t], i = e[r.prevCC];
                                if (!i || !i.new && r.new) return e.ccOffset = e.presentationOffset = r.start, void (r.new = !1);
                                for (; null != (s = i) && s.new;) {
                                    var s;
                                    e.ccOffset += r.start - i.start, r.new = !1, r = i, i = e[r.prevCC]
                                }
                                e.presentationOffset = n
                            }(n, r, a)), a && (s = a - n.presentationOffset);
                            const o = e.endTime - e.startTime, l = hg(9e4 * (e.startTime + s - p), 9e4 * i) / 9e4;
                            e.startTime = Math.max(l, 0), e.endTime = Math.max(l + o, 0);
                            const d = e.text.trim();
                            e.text = decodeURIComponent(encodeURIComponent(d)), e.id || (e.id = by(e.startTime, e.endTime, d)), e.endTime > 0 && c.push(e)
                        }, o.onparsingerror = function (e) {
                            d = e
                        }, o.onflush = function () {
                            d ? a(d) : s(c)
                        }, l.forEach((e => {
                            if (m) {
                                if (yy(e, "X-TIMESTAMP-MAP=")) {
                                    m = !1, e.slice(16).split(",").forEach((e => {
                                        yy(e, "LOCAL:") ? h = e.slice(6) : yy(e, "MPEGTS:") && (f = parseInt(e.slice(7)))
                                    }));
                                    try {
                                        p = function (e) {
                                            let t = parseInt(e.slice(-3));
                                            const n = parseInt(e.slice(-6, -4)), r = parseInt(e.slice(-9, -7)),
                                                i = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
                                            if (!(lh(t) && lh(n) && lh(r) && lh(i))) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
                                            return t += 1e3 * n, t += 6e4 * r, t += 36e5 * i, t
                                        }(h) / 1e3
                                    } catch (e) {
                                        d = e
                                    }
                                    return
                                }
                                "" === e && (m = !1)
                            }
                            o.parse(e + "\n")
                        })), o.flush()
                    }(null != (r = e.initSegment) && r.data ? bf(e.initSegment.data, new Uint8Array(t)) : t, this.initPTS[e.cc], n, e.cc, e.start, (t => {
                        this._appendCues(t, e.level), i.trigger(ch.SUBTITLE_FRAG_PROCESSED, {success: !0, frag: e})
                    }), (n => {
                        this._fallbackToIMSC1(e, t), mh.log(`Failed to parse VTT cue: ${n}`), i.trigger(ch.SUBTITLE_FRAG_PROCESSED, {
                            success: !1,
                            frag: e,
                            error: n
                        })
                    }))
                }

                _fallbackToIMSC1(e, t) {
                    const n = this.tracks[e.level];
                    n.textCodec || ky(t, this.initPTS[e.cc], (() => {
                        n.textCodec = wy, this._parseIMSC1(e, t)
                    }), (() => {
                        n.textCodec = "wvtt"
                    }))
                }

                _appendCues(e, t) {
                    const n = this.hls;
                    if (this.config.renderTextTracksNatively) {
                        const n = this.textTracks[t];
                        if (!n || "disabled" === n.mode) return;
                        e.forEach((e => ap(n, e)))
                    } else {
                        const r = this.tracks[t];
                        if (!r) return;
                        const i = r.default ? "default" : "subtitles" + t;
                        n.trigger(ch.CUES_PARSED, {type: "subtitles", cues: e, track: i})
                    }
                }

                onFragDecrypted(e, t) {
                    const {frag: n} = t;
                    if (n.type === tp) {
                        if (!this.initPTS[n.cc]) return void this.unparsedVttFrags.push(t);
                        this.onFragLoaded(ch.FRAG_LOADED, t)
                    }
                }

                onSubtitleTracksCleared() {
                    this.tracks = [], this.captionsTracks = {}
                }

                onFragParsingUserdata(e, t) {
                    const {cea608Parser1: n, cea608Parser2: r} = this;
                    if (!this.enabled || !n || !r) return;
                    const {frag: i, samples: s} = t;
                    if (i.type !== Jf || "NONE" !== this.closedCaptionsForLevel(i)) for (let e = 0; e < s.length; e++) {
                        const t = s[e].bytes;
                        if (t) {
                            const i = this.extractCea608Data(t);
                            n.addData(s[e].pts, i[0]), r.addData(s[e].pts, i[1])
                        }
                    }
                }

                onBufferFlushing(e, {startOffset: t, endOffset: n, endOffsetSubtitles: r, type: i}) {
                    const {media: s} = this;
                    if (s && !(s.currentTime < n)) {
                        if (!i || "video" === i) {
                            const {captionsTracks: e} = this;
                            Object.keys(e).forEach((r => lp(e[r], t, n)))
                        }
                        if (this.config.renderTextTracksNatively && 0 === t && void 0 !== r) {
                            const {textTracks: e} = this;
                            Object.keys(e).forEach((n => lp(e[n], t, r)))
                        }
                    }
                }

                extractCea608Data(e) {
                    const t = [[], []], n = 31 & e[0];
                    let r = 2;
                    for (let i = 0; i < n; i++) {
                        const n = e[r++], i = 127 & e[r++], s = 127 & e[r++];
                        if ((0 !== i || 0 !== s) && 0 != (4 & n)) {
                            const e = 3 & n;
                            0 !== e && 1 !== e || (t[e].push(i), t[e].push(s))
                        }
                    }
                    return t
                }
            }, audioStreamController: class extends Sm {
                constructor(e, t, n) {
                    super(e, t, n, "[audio-stream-controller]", ep), this.videoBuffer = null, this.videoTrackCC = -1, this.waitingVideoCC = -1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this._registerListeners()
                }

                onHandlerDestroying() {
                    this._unregisterListeners(), this.mainDetails = null, this.bufferedTrack = null, this.switchingTrack = null
                }

                _registerListeners() {
                    const {hls: e} = this;
                    e.on(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.LEVEL_LOADED, this.onLevelLoaded, this), e.on(ch.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(ch.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(ch.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(ch.ERROR, this.onError, this), e.on(ch.BUFFER_RESET, this.onBufferReset, this), e.on(ch.BUFFER_CREATED, this.onBufferCreated, this), e.on(ch.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(ch.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(ch.FRAG_BUFFERED, this.onFragBuffered, this)
                }

                _unregisterListeners() {
                    const {hls: e} = this;
                    e.off(ch.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(ch.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.LEVEL_LOADED, this.onLevelLoaded, this), e.off(ch.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(ch.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(ch.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(ch.ERROR, this.onError, this), e.off(ch.BUFFER_RESET, this.onBufferReset, this), e.off(ch.BUFFER_CREATED, this.onBufferCreated, this), e.off(ch.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(ch.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(ch.FRAG_BUFFERED, this.onFragBuffered, this)
                }

                onInitPtsFound(e, {frag: t, id: n, initPTS: r, timescale: i}) {
                    if ("main" === n) {
                        const e = t.cc;
                        this.initPTS[t.cc] = {
                            baseTime: r,
                            timescale: i
                        }, this.log(`InitPTS for cc: ${e} found from main: ${r}`), this.videoTrackCC = e, this.state === xm && this.tick()
                    }
                }

                startLoad(e) {
                    if (!this.levels) return this.startPosition = e, void (this.state = dm);
                    const t = this.lastCurrentTime;
                    this.stopLoad(), this.setInterval(100), t > 0 && -1 === e ? (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t, this.state = hm) : (this.loadedmetadata = !1, this.state = gm), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
                }

                doTick() {
                    switch (this.state) {
                        case hm:
                            this.doTickIdle();
                            break;
                        case gm: {
                            var e;
                            const {levels: t, trackId: n} = this,
                                r = null == t || null == (e = t[n]) ? void 0 : e.details;
                            if (r) {
                                if (this.waitForCdnTuneIn(r)) break;
                                this.state = xm
                            }
                            break
                        }
                        case mm: {
                            var t;
                            const e = performance.now(), n = this.retryDate;
                            (!n || e >= n || null != (t = this.media) && t.seeking) && (this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.trackId), this.state = hm);
                            break
                        }
                        case xm: {
                            const e = this.waitingData;
                            if (e) {
                                const {frag: t, part: n, cache: r, complete: i} = e;
                                if (void 0 !== this.initPTS[t.cc]) {
                                    this.waitingData = null, this.waitingVideoCC = -1, this.state = pm;
                                    const e = {frag: t, part: n, payload: r.flush(), networkDetails: null};
                                    this._handleFragmentLoadProgress(e), i && super._handleFragmentLoadComplete(e)
                                } else if (this.videoTrackCC !== this.waitingVideoCC) this.log(`Waiting fragment cc (${t.cc}) cancelled because video is at cc ${this.videoTrackCC}`), this.clearWaitingFragment(); else {
                                    const e = this.getLoadPosition(),
                                        n = tm.bufferInfo(this.mediaBuffer, e, this.config.maxBufferHole);
                                    Np(n.end, this.config.maxFragLookUpTolerance, t) < 0 && (this.log(`Waiting fragment cc (${t.cc}) @ ${t.start} cancelled because another fragment at ${n.end} is needed`), this.clearWaitingFragment())
                                }
                            } else this.state = hm
                        }
                    }
                    this.onTickEnd()
                }

                clearWaitingFragment() {
                    const e = this.waitingData;
                    e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = hm)
                }

                resetLoadingState() {
                    this.clearWaitingFragment(), super.resetLoadingState()
                }

                onTickEnd() {
                    const {media: e} = this;
                    null != e && e.readyState && (this.lastCurrentTime = e.currentTime)
                }

                doTickIdle() {
                    const {hls: e, levels: t, media: n, trackId: r} = this, i = e.config;
                    if (null == t || !t[r]) return;
                    if (!n && (this.startFragRequested || !i.startFragPrefetch)) return;
                    const s = t[r], a = s.details;
                    if (!a || a.live && this.levelLastLoaded !== r || this.waitForCdnTuneIn(a)) return void (this.state = gm);
                    const o = this.mediaBuffer ? this.mediaBuffer : this.media;
                    this.bufferFlushed && o && (this.bufferFlushed = !1, this.afterBufferFlushed(o, Eh, ep));
                    const l = this.getFwdBufferInfo(o, ep);
                    if (null === l) return;
                    const {bufferedTrack: c, switchingTrack: u} = this;
                    if (!u && this._streamEnded(l, a)) return e.trigger(ch.BUFFER_EOS, {type: "audio"}), void (this.state = bm);
                    const d = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, Jf), h = l.len,
                        f = this.getMaxBufferLength(null == d ? void 0 : d.len);
                    if (h >= f && !u) return;
                    const p = a.fragments[0].start;
                    let m = l.end;
                    if (u && n) {
                        const e = this.getLoadPosition();
                        c && u.attrs !== c.attrs && (m = e), a.PTSKnown && e < p && (l.end > p || l.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), n.currentTime = p + .05)
                    }
                    let g = this.getNextFragment(m, a), y = !1;
                    if (g && this.isLoopLoading(g, m) && (y = !!g.gap, g = this.getNextFragmentLoopLoading(g, a, l, Jf, f)), !g) return void (this.bufferFlushed = !0);
                    const v = d && g.start > d.end + a.targetduration;
                    if (v || (null == d || !d.len) && l.len) {
                        const e = this.getAppendedFrag(g.start, Jf);
                        if (null === e) return;
                        if (y || (y = !!e.gap || !!v && 0 === d.len), v && !y || y && l.nextStart && l.nextStart < e.end) return
                    }
                    this.loadFragment(g, s, m)
                }

                getMaxBufferLength(e) {
                    const t = super.getMaxBufferLength();
                    return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t
                }

                onMediaDetaching() {
                    this.videoBuffer = null, super.onMediaDetaching()
                }

                onAudioTracksUpdated(e, {audioTracks: t}) {
                    this.resetTransmuxer(), this.levels = t.map((e => new vp(e)))
                }

                onAudioTrackSwitching(e, t) {
                    const n = !!t.url;
                    this.trackId = t.id;
                    const {fragCurrent: r} = this;
                    r && (r.abortRequests(), this.removeUnbufferedFrags(r.start)), this.resetLoadingState(), n ? this.setInterval(100) : this.resetTransmuxer(), n ? (this.switchingTrack = t, this.state = hm) : (this.switchingTrack = null, this.bufferedTrack = t, this.state = dm), this.tick()
                }

                onManifestLoading() {
                    this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = !1, this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null, this.startFragRequested = !1, this.trackId = this.videoTrackCC = this.waitingVideoCC = -1
                }

                onLevelLoaded(e, t) {
                    this.mainDetails = t.details, null !== this.cachedTrackLoadedData && (this.hls.trigger(ch.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null)
                }

                onAudioTrackLoaded(e, t) {
                    var n;
                    if (null == this.mainDetails) return void (this.cachedTrackLoadedData = t);
                    const {levels: r} = this, {details: i, id: s} = t;
                    if (!r) return void this.warn(`Audio tracks were reset while loading level ${s}`);
                    this.log(`Track ${s} loaded [${i.startSN},${i.endSN}]${i.lastPartSn ? `[part-${i.lastPartSn}-${i.lastPartIndex}]` : ""},duration:${i.totalduration}`);
                    const a = r[s];
                    let o = 0;
                    if (i.live || null != (n = a.details) && n.live) {
                        const e = this.mainDetails;
                        if (i.fragments[0] || (i.deltaUpdateFailed = !0), i.deltaUpdateFailed || !e) return;
                        !a.details && i.hasProgramDateTime && e.hasProgramDateTime ? (am(i, e), o = i.fragments[0].start) : o = this.alignPlaylists(i, a.details)
                    }
                    a.details = i, this.levelLastLoaded = s, this.startFragRequested || !this.mainDetails && i.live || this.setStartPosition(a.details, o), this.state !== gm || this.waitForCdnTuneIn(i) || (this.state = hm), this.tick()
                }

                _handleFragmentLoadProgress(e) {
                    var t;
                    const {frag: n, part: r, payload: i} = e, {config: s, trackId: a, levels: o} = this;
                    if (!o) return void this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
                    const l = o[a];
                    if (!l) return void this.warn("Audio track is undefined on fragment load progress");
                    const c = l.details;
                    if (!c) return this.warn("Audio track details undefined on fragment load progress"), void this.removeUnbufferedFrags(n.start);
                    const u = s.defaultAudioCodec || l.audioCodec || "mp4a.40.2";
                    let d = this.transmuxer;
                    d || (d = this.transmuxer = new Cg(this.hls, ep, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
                    const h = this.initPTS[n.cc], f = null == (t = n.initSegment) ? void 0 : t.data;
                    if (void 0 !== h) {
                        const e = !1, t = r ? r.index : -1, s = -1 !== t,
                            a = new nm(n.level, n.sn, n.stats.chunkCount, i.byteLength, t, s);
                        d.push(i, f, u, "", n, r, c.totalduration, e, a, h)
                    } else {
                        this.log(`Unknown video PTS for cc ${n.cc}, waiting for video PTS before demuxing audio frag ${n.sn} of [${c.startSN} ,${c.endSN}],track ${a}`);
                        const {cache: e} = this.waitingData = this.waitingData || {
                            frag: n,
                            part: r,
                            cache: new Ng,
                            complete: !1
                        };
                        e.push(new Uint8Array(i)), this.waitingVideoCC = this.videoTrackCC, this.state = xm
                    }
                }

                _handleFragmentLoadComplete(e) {
                    this.waitingData ? this.waitingData.complete = !0 : super._handleFragmentLoadComplete(e)
                }

                onBufferReset() {
                    this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1
                }

                onBufferCreated(e, t) {
                    const n = t.tracks.audio;
                    n && (this.mediaBuffer = n.buffer || null), t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null)
                }

                onFragBuffered(e, t) {
                    const {frag: n, part: r} = t;
                    if (n.type === ep) if (this.fragContextChanged(n)) this.warn(`Fragment ${n.sn}${r ? " p: " + r.index : ""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`); else {
                        if ("initSegment" !== n.sn) {
                            this.fragPrevious = n;
                            const e = this.switchingTrack;
                            e && (this.bufferedTrack = e, this.switchingTrack = null, this.hls.trigger(ch.AUDIO_TRACK_SWITCHED, sh({}, e)))
                        }
                        this.fragBufferedComplete(n, r)
                    } else if (!this.loadedmetadata && n.type === Jf) {
                        const e = this.videoBuffer || this.media;
                        e && tm.getBuffered(e).length && (this.loadedmetadata = !0)
                    }
                }

                onError(e, t) {
                    var n;
                    if (t.fatal) this.state = wm; else switch (t.details) {
                        case dh.FRAG_GAP:
                        case dh.FRAG_PARSING_ERROR:
                        case dh.FRAG_DECRYPT_ERROR:
                        case dh.FRAG_LOAD_ERROR:
                        case dh.FRAG_LOAD_TIMEOUT:
                        case dh.KEY_LOAD_ERROR:
                        case dh.KEY_LOAD_TIMEOUT:
                            this.onFragmentOrKeyLoadError(ep, t);
                            break;
                        case dh.AUDIO_TRACK_LOAD_ERROR:
                        case dh.AUDIO_TRACK_LOAD_TIMEOUT:
                        case dh.LEVEL_PARSING_ERROR:
                            t.levelRetry || this.state !== gm || (null == (n = t.context) ? void 0 : n.type) !== Xf || (this.state = hm);
                            break;
                        case dh.BUFFER_FULL_ERROR:
                            if (!t.parent || "audio" !== t.parent) return;
                            this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
                            break;
                        case dh.INTERNAL_EXCEPTION:
                            this.recoverWorkerError(t)
                    }
                }

                onBufferFlushed(e, {type: t}) {
                    t === Eh && (this.bufferFlushed = !0, this.state === bm && (this.state = hm))
                }

                _handleTransmuxComplete(e) {
                    var t;
                    const n = "audio", {hls: r} = this, {remuxResult: i, chunkMeta: s} = e,
                        a = this.getCurrentContext(s);
                    if (!a) return void this.resetWhenMissingContext(s);
                    const {frag: o, part: l, level: c} = a, {details: u} = c, {
                        audio: d,
                        text: h,
                        id3: f,
                        initSegment: p
                    } = i;
                    if (!this.fragContextChanged(o) && u) {
                        if (this.state = ym, this.switchingTrack && d && this.completeAudioSwitch(this.switchingTrack), null != p && p.tracks) {
                            const e = o.initSegment || o;
                            this._bufferInitSegment(p.tracks, e, s), r.trigger(ch.FRAG_PARSING_INIT_SEGMENT, {
                                frag: e,
                                id: n,
                                tracks: p.tracks
                            })
                        }
                        if (d) {
                            const {startPTS: e, endPTS: t, startDTS: n, endDTS: r} = d;
                            l && (l.elementaryStreams[Eh] = {
                                startPTS: e,
                                endPTS: t,
                                startDTS: n,
                                endDTS: r
                            }), o.setElementaryStreamInfo(Eh, e, t, n, r), this.bufferFragmentData(d, o, l, s)
                        }
                        if (null != f && null != (t = f.samples) && t.length) {
                            const e = oh({id: n, frag: o, details: u}, f);
                            r.trigger(ch.FRAG_PARSING_METADATA, e)
                        }
                        if (h) {
                            const e = oh({id: n, frag: o, details: u}, h);
                            r.trigger(ch.FRAG_PARSING_USERDATA, e)
                        }
                    } else this.fragmentTracker.removeFragment(o)
                }

                _bufferInitSegment(e, t, n) {
                    if (this.state !== ym) return;
                    e.video && delete e.video;
                    const r = e.audio;
                    if (!r) return;
                    r.levelCodec = r.codec, r.id = "audio", this.log(`Init audio buffer, container:${r.container}, codecs[parsed]=[${r.codec}]`), this.hls.trigger(ch.BUFFER_CODECS, e);
                    const i = r.initSegment;
                    if (null != i && i.byteLength) {
                        const e = {type: "audio", frag: t, part: null, chunkMeta: n, parent: t.type, data: i};
                        this.hls.trigger(ch.BUFFER_APPENDING, e)
                    }
                    this.tick()
                }

                loadFragment(e, t, n) {
                    const r = this.fragmentTracker.getState(e);
                    var i;
                    this.fragCurrent = e, this.switchingTrack || r === Up || r === $p ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : null != (i = t.details) && i.live && !this.initPTS[e.cc] ? (this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = xm) : (this.startFragRequested = !0, super.loadFragment(e, t, n)) : this.clearTrackerIfNeeded(e)
                }

                completeAudioSwitch(e) {
                    const {hls: t, media: n, bufferedTrack: r} = this, i = null == r ? void 0 : r.attrs, s = e.attrs;
                    n && i && (i.CHANNELS !== s.CHANNELS || i.NAME !== s.NAME || i.LANGUAGE !== s.LANGUAGE) && (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio")), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(ch.AUDIO_TRACK_SWITCHED, sh({}, e))
                }
            }, audioTrackController: class extends Mp {
                constructor(e) {
                    super(e, "[audio-track-controller]"), this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners()
                }

                registerListeners() {
                    const {hls: e} = this;
                    e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.on(ch.LEVEL_LOADING, this.onLevelLoading, this), e.on(ch.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(ch.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(ch.ERROR, this.onError, this)
                }

                unregisterListeners() {
                    const {hls: e} = this;
                    e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.off(ch.LEVEL_LOADING, this.onLevelLoading, this), e.off(ch.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(ch.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(ch.ERROR, this.onError, this)
                }

                destroy() {
                    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy()
                }

                onManifestLoading() {
                    this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0
                }

                onManifestParsed(e, t) {
                    this.tracks = t.audioTracks || []
                }

                onAudioTrackLoaded(e, t) {
                    const {id: n, groupId: r, details: i} = t, s = this.tracksInGroup[n];
                    if (!s || s.groupId !== r) return void this.warn(`Track with id:${n} and group:${r} not found in active group ${s.groupId}`);
                    const a = s.details;
                    s.details = t.details, this.log(`audio-track ${n} "${s.name}" lang:${s.lang} group:${r} loaded [${i.startSN}-${i.endSN}]`), n === this.trackId && this.playlistLoaded(n, t, a)
                }

                onLevelLoading(e, t) {
                    this.switchLevel(t.level)
                }

                onLevelSwitching(e, t) {
                    this.switchLevel(t.level)
                }

                switchLevel(e) {
                    const t = this.hls.levels[e];
                    if (null == t || !t.audioGroupIds) return;
                    const n = t.audioGroupIds[t.urlId];
                    if (this.groupId !== n) {
                        this.groupId = n || null;
                        const e = this.tracks.filter((e => !n || e.groupId === n));
                        this.selectDefaultTrack && !e.some((e => e.default)) && (this.selectDefaultTrack = !1), this.tracksInGroup = e;
                        const t = {audioTracks: e};
                        this.log(`Updating audio tracks, ${e.length} track(s) found in group:${n}`), this.hls.trigger(ch.AUDIO_TRACKS_UPDATED, t), this.selectInitialTrack()
                    } else this.shouldReloadPlaylist(this.currentTrack) && this.setAudioTrack(this.trackId)
                }

                onError(e, t) {
                    !t.fatal && t.context && t.context.type === Xf && t.context.id === this.trackId && t.context.groupId === this.groupId && (this.requestScheduled = -1, this.checkRetry(t))
                }

                get audioTracks() {
                    return this.tracksInGroup
                }

                get audioTrack() {
                    return this.trackId
                }

                set audioTrack(e) {
                    this.selectDefaultTrack = !1, this.setAudioTrack(e)
                }

                setAudioTrack(e) {
                    const t = this.tracksInGroup;
                    if (e < 0 || e >= t.length) return void this.warn("Invalid id passed to audio-track controller");
                    this.clearTimer();
                    const n = this.currentTrack;
                    t[this.trackId];
                    const r = t[e], {groupId: i, name: s} = r;
                    if (this.log(`Switching to audio-track ${e} "${s}" lang:${r.lang} group:${i}`), this.trackId = e, this.currentTrack = r, this.selectDefaultTrack = !1, this.hls.trigger(ch.AUDIO_TRACK_SWITCHING, sh({}, r)), r.details && !r.details.live) return;
                    const a = this.switchParams(r.url, null == n ? void 0 : n.details);
                    this.loadPlaylist(a)
                }

                selectInitialTrack() {
                    const e = this.tracksInGroup, t = this.findTrackId(this.currentTrack) | this.findTrackId(null);
                    if (-1 !== t) this.setAudioTrack(t); else {
                        const t = new Error(`No track found for running audio group-ID: ${this.groupId} track count: ${e.length}`);
                        this.warn(t.message), this.hls.trigger(ch.ERROR, {
                            type: uh.MEDIA_ERROR,
                            details: dh.AUDIO_TRACK_LOAD_ERROR,
                            fatal: !0,
                            error: t
                        })
                    }
                }

                findTrackId(e) {
                    const t = this.tracksInGroup;
                    for (let n = 0; n < t.length; n++) {
                        const r = t[n];
                        if (!this.selectDefaultTrack || r.default) {
                            if (!e || void 0 !== e.attrs["STABLE-RENDITION-ID"] && e.attrs["STABLE-RENDITION-ID"] === r.attrs["STABLE-RENDITION-ID"]) return r.id;
                            if (e.name === r.name && e.lang === r.lang) return r.id
                        }
                    }
                    return -1
                }

                loadPlaylist(e) {
                    super.loadPlaylist();
                    const t = this.tracksInGroup[this.trackId];
                    if (this.shouldLoadPlaylist(t)) {
                        const n = t.id, r = t.groupId;
                        let i = t.url;
                        if (e) try {
                            i = e.addDirectives(i)
                        } catch (e) {
                            this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`)
                        }
                        this.log(`loading audio-track playlist ${n} "${t.name}" lang:${t.lang} group:${r}`), this.clearTimer(), this.hls.trigger(ch.AUDIO_TRACK_LOADING, {
                            url: i,
                            id: n,
                            groupId: r,
                            deliveryDirectives: e || null
                        })
                    }
                }
            }, emeController: Iy, cmcdController: By, contentSteeringController: class {
                constructor(e) {
                    this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.log = mh.log.bind(mh, "[content-steering]:"), this.registerListeners()
                }

                registerListeners() {
                    const e = this.hls;
                    e.on(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.on(ch.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.on(ch.ERROR, this.onError, this)
                }

                unregisterListeners() {
                    const e = this.hls;
                    e && (e.off(ch.MANIFEST_LOADING, this.onManifestLoading, this), e.off(ch.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(ch.MANIFEST_PARSED, this.onManifestParsed, this), e.off(ch.ERROR, this.onError, this))
                }

                startLoad() {
                    if (this.started = !0, self.clearTimeout(this.reloadTimer), this.enabled && this.uri) if (this.updated) {
                        const e = Math.max(1e3 * this.timeToLoad - (performance.now() - this.updated), 0);
                        this.scheduleRefresh(this.uri, e)
                    } else this.loadSteeringManifest(this.uri)
                }

                stopLoad() {
                    this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), self.clearTimeout(this.reloadTimer)
                }

                destroy() {
                    this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null
                }

                removeLevel(e) {
                    const t = this.levels;
                    t && (this.levels = t.filter((t => t !== e)))
                }

                onManifestLoading() {
                    this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null
                }

                onManifestLoaded(e, t) {
                    const {contentSteering: n} = t;
                    null !== n && (this.pathwayId = n.pathwayId, this.uri = n.uri, this.started && this.startLoad())
                }

                onManifestParsed(e, t) {
                    this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks
                }

                onError(e, t) {
                    const {errorAction: n} = t;
                    if (2 === (null == n ? void 0 : n.action) && 1 === n.flags) {
                        let e = this.pathwayPriority;
                        const t = this.pathwayId;
                        this.penalizedPathways[t] || (this.penalizedPathways[t] = performance.now()), !e && this.levels && (e = this.levels.reduce(((e, t) => (-1 === e.indexOf(t.pathwayId) && e.push(t.pathwayId), e)), [])), e && e.length > 1 && (this.updatePathwayPriority(e), n.resolved = this.pathwayId !== t)
                    }
                }

                filterParsedLevels(e) {
                    this.levels = e;
                    let t = this.getLevelsForPathway(this.pathwayId);
                    if (0 === t.length) {
                        const n = e[0].pathwayId;
                        this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${n}"`), t = this.getLevelsForPathway(n), this.pathwayId = n
                    }
                    return t.length !== e.length ? (this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t) : e
                }

                getLevelsForPathway(e) {
                    return null === this.levels ? [] : this.levels.filter((t => e === t.pathwayId))
                }

                updatePathwayPriority(e) {
                    let t;
                    this.pathwayPriority = e;
                    const n = this.penalizedPathways, r = performance.now();
                    Object.keys(n).forEach((e => {
                        r - n[e] > 3e5 && delete n[e]
                    }));
                    for (let r = 0; r < e.length; r++) {
                        const i = e[r];
                        if (n[i]) continue;
                        if (i === this.pathwayId) return;
                        const s = this.hls.nextLoadLevel, a = this.hls.levels[s];
                        if (t = this.getLevelsForPathway(i), t.length > 0) {
                            this.log(`Setting Pathway to "${i}"`), this.pathwayId = i, this.hls.trigger(ch.LEVELS_UPDATED, {levels: t});
                            const e = this.hls.levels[s];
                            a && e && this.levels && (e.attrs["STABLE-VARIANT-ID"] !== a.attrs["STABLE-VARIANT-ID"] && e.bitrate !== a.bitrate && this.log(`Unstable Pathways change from bitrate ${a.bitrate} to ${e.bitrate}`), this.hls.nextLoadLevel = s);
                            break
                        }
                    }
                }

                clonePathways(e) {
                    const t = this.levels;
                    if (!t) return;
                    const n = {}, r = {};
                    e.forEach((e => {
                        const {ID: i, "BASE-ID": s, "URI-REPLACEMENT": a} = e;
                        if (t.some((e => e.pathwayId === i))) return;
                        const o = this.getLevelsForPathway(s).map((e => {
                            const t = oh({}, e);
                            t.details = void 0, t.url = Uy(e.uri, e.attrs["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", a);
                            const s = new vh(e.attrs);
                            s["PATHWAY-ID"] = i;
                            const o = s.AUDIO && `${s.AUDIO}_clone_${i}`,
                                l = s.SUBTITLES && `${s.SUBTITLES}_clone_${i}`;
                            o && (n[s.AUDIO] = o, s.AUDIO = o), l && (r[s.SUBTITLES] = l, s.SUBTITLES = l), t.attrs = s;
                            const c = new vp(t);
                            return Bp(c, "audio", o), Bp(c, "text", l), c
                        }));
                        t.push(...o), Fy(this.audioTracks, n, a, i), Fy(this.subtitleTracks, r, a, i)
                    }))
                }

                loadSteeringManifest(e) {
                    const t = this.hls.config, n = t.loader;
                    let r;
                    this.loader && this.loader.destroy(), this.loader = new n(t);
                    try {
                        r = new self.URL(e)
                    } catch (t) {
                        return this.enabled = !1, void this.log(`Failed to parse Steering Manifest URI: ${e}`)
                    }
                    if ("data:" !== r.protocol) {
                        const e = 0 | (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate);
                        r.searchParams.set("_HLS_pathway", this.pathwayId), r.searchParams.set("_HLS_throughput", "" + e)
                    }
                    const i = {responseType: "json", url: r.href}, s = t.steeringManifestLoadPolicy.default,
                        a = s.errorRetry || s.timeoutRetry || {}, o = {
                            loadPolicy: s,
                            timeout: s.maxLoadTimeMs,
                            maxRetry: a.maxNumRetry || 0,
                            retryDelay: a.retryDelayMs || 0,
                            maxRetryDelay: a.maxRetryDelayMs || 0
                        }, l = {
                            onSuccess: (e, t, n, i) => {
                                this.log(`Loaded steering manifest: "${r}"`);
                                const s = e.data;
                                if (1 !== s.VERSION) return void this.log(`Steering VERSION ${s.VERSION} not supported!`);
                                this.updated = performance.now(), this.timeToLoad = s.TTL;
                                const {"RELOAD-URI": a, "PATHWAY-CLONES": o, "PATHWAY-PRIORITY": l} = s;
                                if (a) try {
                                    this.uri = new self.URL(a, r).href
                                } catch (e) {
                                    return this.enabled = !1, void this.log(`Failed to parse Steering Manifest RELOAD-URI: ${a}`)
                                }
                                this.scheduleRefresh(this.uri || n.url), o && this.clonePathways(o), l && this.updatePathwayPriority(l)
                            }, onError: (e, t, n, r) => {
                                if (this.log(`Error loading steering manifest: ${e.code} ${e.text} (${t.url})`), this.stopLoad(), 410 === e.code) return this.enabled = !1, void this.log(`Steering manifest ${t.url} no longer available`);
                                let i = 1e3 * this.timeToLoad;
                                if (429 !== e.code) this.scheduleRefresh(this.uri || t.url, i); else {
                                    const e = this.loader;
                                    if ("function" == typeof (null == e ? void 0 : e.getResponseHeader)) {
                                        const t = e.getResponseHeader("Retry-After");
                                        t && (i = 1e3 * parseFloat(t))
                                    }
                                    this.log(`Steering manifest ${t.url} rate limited`)
                                }
                            }, onTimeout: (e, t, n) => {
                                this.log(`Timeout loading steering manifest (${t.url})`), this.scheduleRefresh(this.uri || t.url)
                            }
                        };
                    this.log(`Requesting steering manifest: ${r}`), this.loader.load(i, o, l)
                }

                scheduleRefresh(e, t = 1e3 * this.timeToLoad) {
                    self.clearTimeout(this.reloadTimer), this.reloadTimer = self.setTimeout((() => {
                        this.loadSteeringManifest(e)
                    }), t)
                }
            }
        });

        function Zy(e) {
            return e && "object" == typeof e ? Array.isArray(e) ? e.map(Zy) : Object.keys(e).reduce(((t, n) => (t[n] = Zy(e[n]), t)), {}) : e
        }

        class Xy {
            static get version() {
                return "1.4.6"
            }

            static isSupported() {
                return function () {
                    const e = Nf();
                    if (!e) return !1;
                    const t = km(),
                        n = e && "function" == typeof e.isTypeSupported && e.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
                        r = !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove;
                    return !!n && !!r
                }()
            }

            static get Events() {
                return ch
            }

            static get ErrorTypes() {
                return uh
            }

            static get ErrorDetails() {
                return dh
            }

            static get DefaultConfig() {
                return Xy.defaultConfig ? Xy.defaultConfig : Yy
            }

            static set DefaultConfig(e) {
                Xy.defaultConfig = e
            }

            constructor(e = {}) {
                this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Ag, this._autoLevelCapping = void 0, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null, function (e, t) {
                    if (self.console && !0 === e || "object" == typeof e) {
                        !function (e, ...t) {
                            t.forEach((function (t) {
                                ph[t] = e[t] ? e[t].bind(e) : function (e) {
                                    const t = self.console[e];
                                    return t ? t.bind(self.console, `[${e}] >`) : hh
                                }(t)
                            }))
                        }(e, "debug", "log", "info", "warn", "error");
                        try {
                            ph.log('Debug logs enabled for "Hls instance" in hls.js version 1.4.6')
                        } catch (e) {
                            ph = fh
                        }
                    } else ph = fh
                }(e.debug || !1);
                const t = this.config = function (e, t) {
                    if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                    if (void 0 !== t.liveMaxLatencyDurationCount && (void 0 === t.liveSyncDurationCount || t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
                    if (void 0 !== t.liveMaxLatencyDuration && (void 0 === t.liveSyncDuration || t.liveMaxLatencyDuration <= t.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
                    const n = Zy(e), r = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
                    return ["manifest", "level", "frag"].forEach((e => {
                        const i = `${"level" === e ? "playlist" : e}LoadPolicy`, s = void 0 === t[i], a = [];
                        r.forEach((r => {
                            const o = `${e}Loading${r}`, l = t[o];
                            if (void 0 !== l && s) {
                                a.push(o);
                                const e = n[i].default;
                                switch (t[i] = {default: e}, r) {
                                    case"TimeOut":
                                        e.maxLoadTimeMs = l, e.maxTimeToFirstByteMs = l;
                                        break;
                                    case"MaxRetry":
                                        e.errorRetry.maxNumRetry = l, e.timeoutRetry.maxNumRetry = l;
                                        break;
                                    case"RetryDelay":
                                        e.errorRetry.retryDelayMs = l, e.timeoutRetry.retryDelayMs = l;
                                        break;
                                    case"MaxRetryTimeout":
                                        e.errorRetry.maxRetryDelayMs = l, e.timeoutRetry.maxRetryDelayMs = l
                                }
                            }
                        })), a.length && mh.warn(`hls.js config: "${a.join('", "')}" setting(s) are deprecated, use "${i}": ${JSON.stringify(t[i])}`)
                    })), sh(sh({}, n), t)
                }(Xy.DefaultConfig, e);
                this.userConfig = e, this._autoLevelCapping = -1, t.progressive && function (e) {
                    const t = e.loader;
                    t !== zy && t !== $y ? (mh.log("[config]: Custom loader detected, cannot enable progressive streaming"), e.progressive = !1) : function () {
                        if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
                            return new self.ReadableStream({}), !0
                        } catch (e) {
                        }
                        return !1
                    }() && (e.loader = zy, e.progressive = !0, e.enableSoftwareAES = !0, mh.log("[config]: Progressive streaming enabled, using FetchLoader"))
                }(t);
                const {
                        abrController: n,
                        bufferController: r,
                        capLevelController: i,
                        errorController: s,
                        fpsController: a
                    } = t, o = new s(this), l = this.abrController = new n(this), c = this.bufferController = new r(this),
                    u = this.capLevelController = new i(this), d = new a(this), h = new ip(this), f = new pp(this),
                    p = t.contentSteeringController, m = p ? new p(this) : null,
                    g = this.levelController = new Op(this, m), y = new zp(this), v = new Qp(this.config),
                    b = this.streamController = new Lg(this, y, v);
                u.setStreamController(b), d.setStreamController(b);
                const w = [h, g, b];
                m && w.splice(1, 0, m), this.networkControllers = w;
                const x = [l, c, u, d, f, y];
                this.audioTrackController = this.createController(t.audioTrackController, w);
                const E = t.audioStreamController;
                E && w.push(new E(this, y, v)), this.subtitleTrackController = this.createController(t.subtitleTrackController, w);
                const S = t.subtitleStreamController;
                S && w.push(new S(this, y, v)), this.createController(t.timelineController, x), v.emeController = this.emeController = this.createController(t.emeController, x), this.cmcdController = this.createController(t.cmcdController, x), this.latencyController = this.createController(mp, x), this.coreComponents = x, w.push(o);
                const k = o.onErrorOut;
                "function" == typeof k && this.on(ch.ERROR, k, o)
            }

            createController(e, t) {
                if (e) {
                    const n = new e(this);
                    return t && t.push(n), n
                }
                return null
            }

            on(e, t, n = this) {
                this._emitter.on(e, t, n)
            }

            once(e, t, n = this) {
                this._emitter.once(e, t, n)
            }

            removeAllListeners(e) {
                this._emitter.removeAllListeners(e)
            }

            off(e, t, n = this, r) {
                this._emitter.off(e, t, n, r)
            }

            listeners(e) {
                return this._emitter.listeners(e)
            }

            emit(e, t, n) {
                return this._emitter.emit(e, t, n)
            }

            trigger(e, t) {
                if (this.config.debug) return this.emit(e, e, t);
                try {
                    return this.emit(e, e, t)
                } catch (t) {
                    mh.error("An internal error happened while handling event " + e + '. Error message: "' + t.message + '". Here is a stacktrace:', t), this.trigger(ch.ERROR, {
                        type: uh.OTHER_ERROR,
                        details: dh.INTERNAL_EXCEPTION,
                        fatal: !1,
                        event: e,
                        error: t
                    })
                }
                return !1
            }

            listenerCount(e) {
                return this._emitter.listenerCount(e)
            }

            destroy() {
                mh.log("destroy"), this.trigger(ch.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach((e => e.destroy())), this.networkControllers.length = 0, this.coreComponents.forEach((e => e.destroy())), this.coreComponents.length = 0;
                const e = this.config;
                e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null
            }

            attachMedia(e) {
                mh.log("attachMedia"), this._media = e, this.trigger(ch.MEDIA_ATTACHING, {media: e})
            }

            detachMedia() {
                mh.log("detachMedia"), this.trigger(ch.MEDIA_DETACHING, void 0), this._media = null
            }

            loadSource(e) {
                this.stopLoad();
                const t = this.media, n = this.url,
                    r = this.url = rh.buildAbsoluteURL(self.location.href, e, {alwaysNormalize: !0});
                mh.log(`loadSource:${r}`), t && n && (n !== r || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(ch.MANIFEST_LOADING, {url: e})
            }

            startLoad(e = -1) {
                mh.log(`startLoad(${e})`), this.networkControllers.forEach((t => {
                    t.startLoad(e)
                }))
            }

            stopLoad() {
                mh.log("stopLoad"), this.networkControllers.forEach((e => {
                    e.stopLoad()
                }))
            }

            swapAudioCodec() {
                mh.log("swapAudioCodec"), this.streamController.swapAudioCodec()
            }

            recoverMediaError() {
                mh.log("recoverMediaError");
                const e = this._media;
                this.detachMedia(), e && this.attachMedia(e)
            }

            removeLevel(e, t = 0) {
                this.levelController.removeLevel(e, t)
            }

            get levels() {
                return this.levelController.levels || []
            }

            get currentLevel() {
                return this.streamController.currentLevel
            }

            set currentLevel(e) {
                mh.log(`set currentLevel:${e}`), this.loadLevel = e, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch()
            }

            get nextLevel() {
                return this.streamController.nextLevel
            }

            set nextLevel(e) {
                mh.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch()
            }

            get loadLevel() {
                return this.levelController.level
            }

            set loadLevel(e) {
                mh.log(`set loadLevel:${e}`), this.levelController.manualLevel = e
            }

            get nextLoadLevel() {
                return this.levelController.nextLoadLevel
            }

            set nextLoadLevel(e) {
                this.levelController.nextLoadLevel = e
            }

            get firstLevel() {
                return Math.max(this.levelController.firstLevel, this.minAutoLevel)
            }

            set firstLevel(e) {
                mh.log(`set firstLevel:${e}`), this.levelController.firstLevel = e
            }

            get startLevel() {
                return this.levelController.startLevel
            }

            set startLevel(e) {
                mh.log(`set startLevel:${e}`), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e
            }

            get capLevelToPlayerSize() {
                return this.config.capLevelToPlayerSize
            }

            set capLevelToPlayerSize(e) {
                const t = !!e;
                t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t)
            }

            get autoLevelCapping() {
                return this._autoLevelCapping
            }

            get bandwidthEstimate() {
                const {bwEstimator: e} = this.abrController;
                return e ? e.getEstimate() : NaN
            }

            get ttfbEstimate() {
                const {bwEstimator: e} = this.abrController;
                return e ? e.getEstimateTTFB() : NaN
            }

            set autoLevelCapping(e) {
                this._autoLevelCapping !== e && (mh.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e)
            }

            get maxHdcpLevel() {
                return this._maxHdcpLevel
            }

            set maxHdcpLevel(e) {
                gp.indexOf(e) > -1 && (this._maxHdcpLevel = e)
            }

            get autoLevelEnabled() {
                return -1 === this.levelController.manualLevel
            }

            get manualLevel() {
                return this.levelController.manualLevel
            }

            get minAutoLevel() {
                const {levels: e, config: {minAutoBitrate: t}} = this;
                if (!e) return 0;
                const n = e.length;
                for (let r = 0; r < n; r++) if (e[r].maxBitrate >= t) return r;
                return 0
            }

            get maxAutoLevel() {
                const {levels: e, autoLevelCapping: t, maxHdcpLevel: n} = this;
                let r;
                if (r = -1 === t && e && e.length ? e.length - 1 : t, n) for (let t = r; t--;) {
                    const r = e[t].attrs["HDCP-LEVEL"];
                    if (r && r <= n) return t
                }
                return r
            }

            get nextAutoLevel() {
                return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
            }

            set nextAutoLevel(e) {
                this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e)
            }

            get playingDate() {
                return this.streamController.currentProgramDateTime
            }

            get mainForwardBufferInfo() {
                return this.streamController.getMainFwdBufferInfo()
            }

            get audioTracks() {
                const e = this.audioTrackController;
                return e ? e.audioTracks : []
            }

            get audioTrack() {
                const e = this.audioTrackController;
                return e ? e.audioTrack : -1
            }

            set audioTrack(e) {
                const t = this.audioTrackController;
                t && (t.audioTrack = e)
            }

            get subtitleTracks() {
                const e = this.subtitleTrackController;
                return e ? e.subtitleTracks : []
            }

            get subtitleTrack() {
                const e = this.subtitleTrackController;
                return e ? e.subtitleTrack : -1
            }

            get media() {
                return this._media
            }

            set subtitleTrack(e) {
                const t = this.subtitleTrackController;
                t && (t.subtitleTrack = e)
            }

            get subtitleDisplay() {
                const e = this.subtitleTrackController;
                return !!e && e.subtitleDisplay
            }

            set subtitleDisplay(e) {
                const t = this.subtitleTrackController;
                t && (t.subtitleDisplay = e)
            }

            get lowLatencyMode() {
                return this.config.lowLatencyMode
            }

            set lowLatencyMode(e) {
                this.config.lowLatencyMode = e
            }

            get liveSyncPosition() {
                return this.latencyController.liveSyncPosition
            }

            get latency() {
                return this.latencyController.latency
            }

            get maxLatency() {
                return this.latencyController.maxLatency
            }

            get targetLatency() {
                return this.latencyController.targetLatency
            }

            get drift() {
                return this.latencyController.drift
            }

            get forceStartLoad() {
                return this.streamController.forceStartLoad
            }
        }

        function Qy(n) {
            const r = (0, t.useRef)(null);
            return (0, t.useEffect)((() => {
                if (n.stream && r.current && !r.current.src && Xy.isSupported()) {
                    const e = new Xy;
                    return e.loadSource(n.stream), e.attachMedia(r.current), () => e.destroy()
                }
            }), [r, n]), (0, e.jsx)("div", {children: (0, e.jsx)("video", {ref: r, ...n, controls: !0})})
        }

        function Jy(n) {
            const [r, i] = (0, t.useState)(), [s, a] = (0, t.useState)(), [o, l] = (0, t.useState)(), [c, u] = (0, t.useState)(""), [d, h] = (0, t.useState)(n.url), [f, p] = (0, t.useState)(!1),
                m = (0, Wu.Os)();

            async function g() {
                const e = await cc.get(n.url);
                if (e) return void l(e);
                const t = new Request(n.url, {method: "OPTIONS", headers: {accept: "L402"}}), r = await fetch(t);
                if (402 === r.status) {
                    const e = r.headers.get("www-authenticate");
                    if (null != e && e.startsWith("L402")) {
                        const t = (0, Ks.aS)(e.substring(5));
                        if (console.debug(t), a(t), t.invoice) {
                            const e = (0, ai.decodeInvoice)(t.invoice);
                            i(e)
                        }
                    }
                }
            }

            return (0, t.useEffect)((() => {
                o && async function () {
                    if (!o) return;
                    p(!0);
                    const e = new Request(n.url, {headers: {Authorization: `L402 ${o.macaroon}:${o.preimage}`}}),
                        t = await fetch(e);
                    if (t.ok) {
                        const e = await t.blob();
                        h(URL.createObjectURL(e))
                    }
                    p(!1)
                }().catch(console.error)
            }), [o]), o && f ? (0, e.jsx)(Yd, {}) : r ? (0, e.jsxs)("div", {
                className: "note-invoice",
                children: [(0, e.jsx)("h3", {
                    children: (0, e.jsx)(cl, {
                        id: "9qtLJC",
                        defaultMessage: "Payment Required"
                    })
                }), (0, e.jsxs)("div", {
                    className: "flex f-row",
                    children: [(0, e.jsx)("div", {
                        className: "f-grow",
                        children: (0, e.jsx)(cl, {
                            id: "DqLx9k",
                            defaultMessage: "You must pay {n} sats to access this file.",
                            values: {n: (0, e.jsx)(yl, {value: (null !== (y = r.amount) && void 0 !== y ? y : 0) / 1e3})}
                        })
                    }), (0, e.jsx)("div", {
                        children: m.wallet && (0, e.jsx)(Vd, {
                            onClick: () => async function () {
                                if (m.wallet && s) try {
                                    const e = await m.wallet.payInvoice(s.invoice);
                                    if (console.debug(e), e.preimage) {
                                        const t = {
                                            pr: s.invoice,
                                            url: n.url,
                                            macaroon: s.macaroon,
                                            preimage: e.preimage
                                        };
                                        await cc.set(t), l(t)
                                    }
                                } catch (e) {
                                    e instanceof Error && u(e.message)
                                }
                            }(), children: (0, e.jsx)(cl, {id: "Ss0sWu", defaultMessage: "Pay Now"})
                        })
                    })]
                }), !m.wallet && (0, e.jsx)("b", {
                    children: (0, e.jsx)(cl, {
                        id: "0ehN4t",
                        defaultMessage: "Please connect a wallet {here} to be able to pay this invoice",
                        values: {
                            here: (0, e.jsx)(Rt, {
                                to: "/settings/wallet",
                                onClick: e => e.stopPropagation(),
                                children: (0, e.jsx)(cl, {id: "380eol", defaultMessage: "here"})
                            })
                        }
                    })
                }), c && (0, e.jsx)("b", {className: "error", children: c})]
            }) : n.mime.startsWith("image/") ? (0, e.jsx)(ev, {
                children: (0, e.jsx)(Wd, {
                    src: d,
                    onError: () => g()
                }, n.url)
            }) : n.mime.startsWith("audio/") ? (0, e.jsx)("audio", {
                src: d,
                controls: !0,
                onError: () => g()
            }, n.url) : n.mime.startsWith("video/") ? n.url.endsWith(".m3u8") ? (0, e.jsx)(Qy, {stream: n.url}) : (0, e.jsx)("video", {
                src: d,
                controls: !0,
                onError: () => g()
            }, n.url) : (0, e.jsx)("a", {
                href: n.url,
                onClick: e => e.stopPropagation(),
                target: "_blank",
                rel: "noreferrer",
                className: "ext",
                children: n.url
            }, n.url);
            var y
        }

        function ev(n) {
            let {children: r} = n;
            const [i, s] = (0, t.useState)(!1);

            function a(e) {
                e.stopPropagation(), e.preventDefault(), s(!1)
            }

            return (0, e.jsxs)(e.Fragment, {
                children: [i && (0, e.jsxs)(Cu, {
                    onClose: a,
                    className: "spotlight",
                    children: [(0, e.jsx)("div", {
                        className: "close",
                        onClick: a,
                        children: (0, e.jsx)(Gl, {name: "close"})
                    }), r]
                }), (0, e.jsx)("div", {
                    onClick: function (e) {
                        e.stopPropagation(), e.preventDefault(), s((e => !e))
                    }, children: r
                })]
            })
        }

        Xy.defaultConfig = void 0;
        const tv = n => {
            let {url: r} = n;
            const [i, s] = (0, t.useState)(), {proxy: a} = Wl();
            return (0, t.useEffect)((() => {
                (async () => {
                    const e = await async function (e) {
                        const t = new qd;
                        try {
                            return await t.linkPreview(e)
                        } catch (t) {
                            console.warn("Failed to load link preview", e)
                        }
                    }(r);
                    if (e) {
                        var t;
                        const n = null === (t = e.og_tags) || void 0 === t ? void 0 : t.find((e => "og:type" === e[0].toLowerCase()));
                        if ((null == n ? void 0 : n[1].startsWith("image")) || (null == n ? void 0 : n[1].startsWith("video")) || e.image) return void s(e)
                    }
                    s(null)
                })()
            }), [r]), null === i ? (0, e.jsx)("a", {
                href: r,
                onClick: e => e.stopPropagation(),
                target: "_blank",
                rel: "noreferrer",
                className: "ext",
                children: r
            }) : (0, e.jsxs)("div", {
                className: "link-preview-container", children: [i && (0, e.jsxs)("a", {
                    href: r,
                    onClick: e => e.stopPropagation(),
                    target: "_blank",
                    rel: "noreferrer",
                    className: "ext",
                    children: [function () {
                        var t, n;
                        const r = null == i || null === (t = i.og_tags) || void 0 === t || null === (n = t.find((e => "og:type" === e[0].toLowerCase()))) || void 0 === n ? void 0 : n[1];
                        if (null != r && r.startsWith("video")) {
                            var s, o, l, c, u;
                            const t = ["og:video:secure_url", "og:video:url", "og:video"],
                                n = null == i || null === (s = i.og_tags) || void 0 === s || null === (o = s.find((e => t.includes(e[0].toLowerCase())))) || void 0 === o ? void 0 : o[1],
                                r = null !== (l = null == i || null === (c = i.og_tags) || void 0 === c || null === (u = c.find((e => "og:video:type" === e[0].toLowerCase()))) || void 0 === u ? void 0 : u[1]) && void 0 !== l ? l : "video/mp4";
                            if (n) return (0, e.jsx)(Jy, {url: n, mime: r})
                        }
                        if (null != r && r.startsWith("image")) {
                            var d, h, f, p, m;
                            const t = ["og:image:secure_url", "og:image:url", "og:image"],
                                n = null == i || null === (d = i.og_tags) || void 0 === d || null === (h = d.find((e => t.includes(e[0].toLowerCase())))) || void 0 === h ? void 0 : h[1],
                                r = null !== (f = null == i || null === (p = i.og_tags) || void 0 === p || null === (m = p.find((e => "og:image:type" === e[0].toLowerCase()))) || void 0 === m ? void 0 : m[1]) && void 0 !== f ? f : "image/png";
                            if (n) return (0, e.jsx)(Jy, {url: n, mime: r})
                        }
                        if (null != i && i.image) {
                            const t = {"--img-url": null != i && i.image ? `url(${a(null == i ? void 0 : i.image)})` : ""};
                            return (0, e.jsx)("div", {className: "link-preview-image", style: t})
                        }
                        return null
                    }(), (0, e.jsxs)("p", {
                        className: "link-preview-title",
                        children: [null == i ? void 0 : i.title, (null == i ? void 0 : i.description) && (0, e.jsxs)(e.Fragment, {children: [(0, e.jsx)("br", {}), (0, e.jsx)("small", {children: i.description.slice(0, 160)})]})]
                    })]
                }), !i && (0, e.jsx)(Dd, {className: "f-center"})]
            })
        };

        function nv(e) {
            const n = (0, t.useMemo)((() => {
                const t = new Pt.RequestBuilder(`event:${e.id.slice(0, 12)}`);
                if (e.type === Pt.NostrPrefix.Address) {
                    const n = t.withFilter().tag("d", [e.id]);
                    e.author && n.authors([(0, Ks.Wg)(e.author)]), e.kind && n.kinds([(0, Ks.Wg)(e.kind)])
                } else {
                    const n = t.withFilter().ids([e.id]);
                    e.relays && e.relays.slice(0, 2).forEach((e => n.relay(e))), e.author && n.authors([e.author])
                }
                return t
            }), [e]);
            return (0, hl.useRequestBuilder)(DS, Pt.ReplaceableNoteStore, n)
        }

        function rv(t) {
            let {link: n, depth: r} = t;
            const i = nv(n);
            return i.data ? (0, e.jsx)(Pb, {
                data: i.data,
                related: [],
                className: "note-quote",
                depth: (null != r ? r : 0) + 1,
                options: {showFooter: !1}
            }) : (0, e.jsx)(Yd, {})
        }

        function iv(t) {
            let {link: n, depth: r} = t;
            const i = (0, Pt.tryParseNostrLink)(n);
            if ((null == i ? void 0 : i.type) === Pt.NostrPrefix.PublicKey || (null == i ? void 0 : i.type) === Pt.NostrPrefix.Profile) return (0, e.jsx)(Ad, {
                pubkey: i.id,
                relays: i.relays
            });
            if ((null == i ? void 0 : i.type) === Pt.NostrPrefix.Note || (null == i ? void 0 : i.type) === Pt.NostrPrefix.Event || (null == i ? void 0 : i.type) === Pt.NostrPrefix.Address) {
                if ((null != r ? r : 0) > 0) {
                    const t = i.encode();
                    return (0, e.jsxs)(Rt, {
                        to: `/e/${t}`,
                        onClick: e => e.stopPropagation(),
                        state: {from: location.pathname},
                        children: ["#", t.substring(0, 12)]
                    })
                }
                return (0, e.jsx)(rv, {link: i, depth: r})
            }
            return (0, e.jsx)("a", {
                href: n,
                onClick: e => e.stopPropagation(),
                target: "_blank",
                rel: "noreferrer",
                className: "ext",
                children: n
            })
        }

        function sv(n) {
            const [r, i] = (0, t.useState)(!1);
            return r ? (0, e.jsx)(e.Fragment, {children: n.children}) : (0, e.jsx)("div", {
                onClick: e => {
                    e.stopPropagation(), i(!0)
                }, className: "note-invoice", children: n.message
            })
        }

        function av(t) {
            const n = Qs(), {preferences: r, follows: i, publicKey: s} = n,
                a = "follows-only" === r.autoLoadMedia && !i.item.includes(t.creator), o = t.creator === s,
                l = "none" === r.autoLoadMedia || !o && a, c = new URL(t.link).hostname, u = new URL(t.link),
                d = bi.test(u.pathname.toLowerCase()) && RegExp.$1, h = (() => {
                    switch (d) {
                        case"gif":
                        case"jpg":
                        case"jpeg":
                        case"jfif":
                        case"png":
                        case"bmp":
                        case"webp":
                            return "image";
                        case"wav":
                        case"mp3":
                        case"ogg":
                            return "audio";
                        case"mp4":
                        case"mov":
                        case"mkv":
                        case"avi":
                        case"m4v":
                        case"webm":
                        case"m3u8":
                            return "video";
                        default:
                            return "unknown"
                    }
                })();
            return l ? (0, e.jsx)(sv, {
                message: (0, e.jsx)(cl, {
                    id: "lsNFM1",
                    defaultMessage: "Click to load content from {link}",
                    values: {link: c}
                }), children: (0, e.jsx)(Jy, {mime: `${h}/${d}`, url: u.toString()})
            }) : (0, e.jsx)(Jy, {mime: `${h}/${d}`, url: u.toString()})
        }

        const ov = t => {
            var n;
            let {magnet: r} = t;
            return (0, e.jsxs)("div", {
                className: "note-invoice",
                children: [(0, e.jsx)("h4", {
                    children: (0, e.jsx)(cl, {
                        id: "Gcn9NQ",
                        defaultMessage: "Magnet Link"
                    })
                }), (0, e.jsx)("a", {
                    href: r.raw,
                    rel: "noreferrer",
                    children: null !== (n = r.dn) && void 0 !== n ? n : r.infoHash
                })]
            })
        };

        function lv(t) {
            let {link: n, creator: r, depth: i} = t;
            const s = n;
            try {
                const t = new URL(s), n = Ei.test(s) && RegExp.$1, a = Si.test(s) && RegExp.$2,
                    o = Ai.test(s) && RegExp.$1, l = Ti.test(s) && RegExp.$1, c = Ci.test(s) && RegExp.$1,
                    u = Ri.test(s), d = Li.test(s), h = _i.test(s), f = Pi.test(s), p = Ni.test(s);
                if (bi.test(t.pathname.toLowerCase()) && RegExp.$1 && !h) return (0, e.jsx)(av, {link: s, creator: r});
                if (a) return (0, e.jsx)("div", {className: "tweet", children: (0, e.jsx)(Cd, {tweetId: a})}, a);
                if (n) return (0, e.jsx)("iframe", {
                    className: "w-max",
                    src: `https://www.youtube.com/embed/${n}`,
                    title: "YouTube video player",
                    frameBorder: "0",
                    allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",
                    allowFullScreen: !0
                }, n);
                if (o) return (0, e.jsx)(Nd, {link: s});
                if (l) return (0, e.jsx)(Rd, {link: s});
                if (c) return (0, e.jsx)(Ld, {link: s});
                if (u) return (0, e.jsx)(_d, {link: s});
                if (d) return (0, e.jsx)(jd, {link: s});
                if (h) return (0, e.jsx)(Id, {link: s});
                if (f) return (0, e.jsx)(e.Fragment, {
                    children: (0, e.jsx)("a", {
                        href: s,
                        onClick: e => e.stopPropagation(),
                        target: "_blank",
                        rel: "noreferrer",
                        className: "ext",
                        children: s
                    })
                });
                if (p) return (0, e.jsx)(Md, {link: s});
                if ("nostr:" === t.protocol || "web+nostr:" === t.protocol) return (0, e.jsx)(iv, {link: s, depth: i});
                if ("magnet:" !== t.protocol) return (0, e.jsx)(tv, {url: s});
                {
                    const t = (0, Ks.jC)(s);
                    if (t) return (0, e.jsx)(ov, {magnet: t})
                }
            } catch {
            }
            return (0, e.jsx)("a", {
                href: s,
                onClick: e => e.stopPropagation(),
                target: "_blank",
                rel: "noreferrer",
                className: "ext",
                children: s
            })
        }

        function cv(n) {
            let {token: r} = n;
            const i = Qs(), s = (0, hl.useUserProfile)(DS, i.publicKey), [o, l] = (0, t.useState)();
            return (0, t.useEffect)((() => {
                try {
                    if (!r.startsWith("cashuA") || r.length < 10) return;
                    Promise.all([a.e(983), a.e(922)]).then(a.bind(a, 6983)).then((e => {
                        let {getDecodedToken: t} = e;
                        const n = t(r);
                        l(n)
                    }))
                } catch {
                }
            }), [r]), o ? (0, e.jsx)("div", {
                className: "note-invoice",
                children: (0, e.jsxs)("div", {
                    className: "flex f-between",
                    children: [(0, e.jsxs)("div", {
                        children: [(0, e.jsx)("h4", {
                            children: (0, e.jsx)(cl, {
                                id: "TMfYfY",
                                defaultMessage: "Cashu token"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "ULotH9",
                                defaultMessage: "Amount: {amount} sats",
                                values: {amount: o.token[0].proofs.reduce(((e, t) => e + t.amount), 0)}
                            })
                        }), (0, e.jsx)("small", {
                            className: "xs",
                            children: (0, e.jsx)(cl, {
                                id: "iUsU2x",
                                defaultMessage: "Mint: {url}",
                                values: {url: o.token[0].mint}
                            })
                        })]
                    }), (0, e.jsxs)("div", {
                        children: [(0, e.jsx)("button", {
                            onClick: e => async function (e, t) {
                                e.stopPropagation(), await navigator.clipboard.writeText(t)
                            }(e, r), className: "mr5", children: (0, e.jsx)(cl, {id: "SX58hM", defaultMessage: "Copy"})
                        }), (0, e.jsx)("button", {
                            onClick: e => async function (e, t) {
                                var n;
                                e.stopPropagation();
                                const r = null !== (n = null == s ? void 0 : s.lud16) && void 0 !== n ? n : "",
                                    i = `https://redeem.cashu.me?token=${encodeURIComponent(t)}&lightning=${encodeURIComponent(r)}&autopay=yes`;
                                window.open(i, "_blank")
                            }(e, r), children: (0, e.jsx)(cl, {id: "XrSk2j", defaultMessage: "Redeem"})
                        })]
                    })]
                })
            }) : (0, e.jsx)(e.Fragment, {children: r})
        }

        function uv(n) {
            let {content: r, tags: i, creator: s, disableMedia: a, depth: o} = n;
            const l = it();

            function c(t) {
                let n = function (t) {
                    return t.body.map((n => "string" == typeof n ? n.split(wi).map((n => {
                        const r = n.match(/#\[(\d+)\]/);
                        if (r && 2 === r.length) {
                            var i;
                            const n = parseInt(r[1]), o = null === (i = t.tags) || void 0 === i ? void 0 : i[n];
                            if (o) switch (o[0]) {
                                case"p":
                                    var s;
                                    return (0, e.jsx)(Ad, {
                                        pubkey: null !== (s = o[1]) && void 0 !== s ? s : "",
                                        relays: o[2]
                                    });
                                case"e": {
                                    const t = (0, Ks.jm)(Pt.NostrPrefix.Event, o[1]).substring(0, 12);
                                    return o[1] && (0, e.jsxs)(Rt, {
                                        to: (0, Ks.sC)(o[1], o[2]),
                                        onClick: e => e.stopPropagation(),
                                        state: {from: l.pathname},
                                        children: ["#", t]
                                    })
                                }
                                case"t":
                                    var a;
                                    return (0, e.jsx)(kd, {tag: null !== (a = o[1]) && void 0 !== a ? a : ""})
                            }
                            return (0, e.jsxs)("b", {style: {color: "var(--error)"}, children: [r[0], "?"]})
                        }
                        return n
                    })) : n)).flat()
                }(t);
                return n = function (t) {
                    return t.map((t => "string" == typeof t ? (0, Ks.v1)(t).map((t => (() => {
                        const e = t.toLowerCase();
                        return e.startsWith("web+nostr:") || e.startsWith("nostr:") ? (0, Pt.validateNostrLink)(e) : e.startsWith("http:") || e.startsWith("https:") || e.startsWith("magnet:")
                    })() ? null != a && a && !t.startsWith("nostr:") ? (0, e.jsx)("a", {
                        href: t,
                        onClick: e => e.stopPropagation(),
                        target: "_blank",
                        rel: "noreferrer",
                        className: "ext",
                        children: t
                    }) : (0, e.jsx)(lv, {link: t, creator: s, depth: o}) : t)) : t)).flat()
                }(n), n = function (t) {
                    return t.map((t => "string" == typeof t ? t.split(xi).map((t => t.toLowerCase().startsWith("lnbc") ? (0, e.jsx)(Sd, {invoice: t}) : t)) : t)).flat()
                }(n), n = function (t) {
                    return t.map((t => "string" == typeof t ? t.split(ki).map((t => t.toLowerCase().startsWith("#") ? (0, e.jsx)(kd, {tag: t.substring(1)}) : t)) : t)).flat()
                }(n), n = function (t) {
                    return t.map((t => "string" == typeof t && t.includes("cashuA") ? t.split(ji).map((t => (0, e.jsx)(cv, {token: t}))) : t)).flat()
                }(n), n = function (t) {
                    return t.map((t => "string" == typeof t ? t.split(/:(\w+):/g).map((t => {
                        const n = i.find((e => "emoji" === e[0] && e[1] === t));
                        return n ? (0, e.jsx)(Wd, {src: n[2], size: 15, className: "custom-emoji"}) : t
                    })) : t)).flat()
                }(n), n
            }

            const u = (0, t.useMemo)((() => (0, e.jsx)("div", {
                className: "text",
                children: c({body: [r], tags: i})
            })), [r]);
            return (0, e.jsx)("div", {dir: "auto", children: u})
        }

        function dv() {
            return dv = Object.assign ? Object.assign.bind() : function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }, dv.apply(this, arguments)
        }

        function hv(e, t) {
            if (null == e) return {};
            var n, r, i = {}, s = Object.keys(e);
            for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
            return i
        }

        var fv = "szh-menu", pv = (0, t.createContext)(), mv = (0, t.createContext)({}), gv = (0, t.createContext)({}),
            yv = (0, t.createContext)({}), vv = (0, t.createContext)({}), bv = (0, t.createContext)({}),
            wv = (0, t.createContext)({}), xv = Object.freeze({
                ENTER: "Enter",
                ESC: "Escape",
                SPACE: " ",
                HOME: "Home",
                END: "End",
                LEFT: "ArrowLeft",
                RIGHT: "ArrowRight",
                UP: "ArrowUp",
                DOWN: "ArrowDown"
            }), Ev = Object.freeze({RESET: 0, SET: 1, UNSET: 2, INCREASE: 3, DECREASE: 4, FIRST: 5, LAST: 6, SET_INDEX: 7}),
            Sv = Object.freeze({CLICK: "click", CANCEL: "cancel", BLUR: "blur", SCROLL: "scroll"}),
            kv = Object.freeze({FIRST: "first", LAST: "last"}),
            Av = Object.freeze({entering: "opening", entered: "open", exiting: "closing", exited: "closed"}),
            Tv = "absolute", Cv = "menuitem", Rv = {"aria-hidden": !0, role: Cv}, Lv = function (n, r) {
                var i = (0, t.memo)(r), s = (0, t.forwardRef)((function (n, r) {
                    var s = (0, t.useRef)(null);
                    return (0, e.jsx)(i, dv({}, n, {
                        itemRef: s,
                        externalRef: r,
                        isHovering: (0, t.useContext)(pv) === s.current
                    }))
                }));
                return s.displayName = "WithHovering(" + n + ")", s
            },
            _v = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement ? t.useLayoutEffect : t.useEffect;

        function Pv(e, t) {
            "function" == typeof e ? e(t) : e.current = t
        }

        var Nv = function (e, n) {
            return (0, t.useMemo)((function () {
                return e ? n ? function (t) {
                    Pv(e, t), Pv(n, t)
                } : e : n
            }), [e, n])
        }, jv = function (e) {
            var n = e.block, r = e.element, i = e.modifiers, s = e.className;
            return (0, t.useMemo)((function () {
                var e = r ? n + "__" + r : n, t = e;
                i && Object.keys(i).forEach((function (n) {
                    var r = i[n];
                    r && (t += " " + e + "--" + (!0 === r ? n : n + "-" + r))
                }));
                var a = "function" == typeof s ? s(i) : s;
                return "string" == typeof a && (a = a.trim()) && (t += " " + a), t
            }), [n, r, i, s])
        }, Iv = function (e) {
            return !!e && "o" === e[0]
        }, Mv = l.unstable_batchedUpdates || function (e) {
            return e()
        }, Dv = (Object.values, function (e, t, n) {
            return void 0 === n && (n = 1e-4), Math.abs(e - t) < n
        }), Ov = function (e, t) {
            return !0 === e || !(!e || !e[t])
        }, Bv = function (e, t) {
            return "function" == typeof e ? e(t) : e
        }, Fv = function (e, t) {
            return t && Object.keys(t).forEach((function (n) {
                var r = e[n], i = t[n];
                e[n] = "function" == typeof i && r ? function () {
                    i.apply(void 0, arguments), r.apply(void 0, arguments)
                } : i
            })), e
        }, Uv = function (e) {
            for (; e;) {
                if (!(e = e.parentNode) || e === document.body) return;
                var t = getComputedStyle(e), n = t.overflow, r = t.overflowX, i = t.overflowY;
                if (/auto|scroll|overlay|hidden/.test(n + i + r)) return e
            }
        };

        function Hv(e, t) {
            return {"aria-disabled": e || void 0, tabIndex: t ? 0 : -1}
        }

        function $v(e, t) {
            for (var n = 0; n < e.length; n++) if (e[n] === t) return n;
            return -1
        }

        var Kv, zv,
            Gv = ["className", "value", "href", "type", "checked", "disabled", "children", "onClick", "isHovering", "itemRef", "externalRef"],
            qv = ["setHover"], Wv = Lv("MenuItem", (function (n) {
                var r = n.className, i = n.value, s = n.href, a = n.type, o = n.checked, l = n.disabled, c = n.children,
                    u = n.onClick, d = n.isHovering, h = n.itemRef, f = n.externalRef, p = hv(n, Gv), m = !!l,
                    g = function (e, n, r, i) {
                        var s = (0, t.useContext)(wv).submenuCloseDelay, a = (0, t.useContext)(mv), o = a.isParentOpen,
                            l = a.isSubmenuOpen, c = a.dispatch, u = a.updateItems, d = (0, t.useRef)(0), h = function () {
                                !r && !i && c(Ev.SET, e.current)
                            }, f = function () {
                                !i && c(Ev.UNSET, e.current)
                            };
                        return function (e, t, n) {
                            _v((function () {
                                if (!e) {
                                    var r = t.current;
                                    return n(r, !0), function () {
                                        n(r)
                                    }
                                }
                            }), [e, t, n])
                        }(i, e, u), (0, t.useEffect)((function () {
                            return function () {
                                return clearTimeout(d.current)
                            }
                        }), []), (0, t.useEffect)((function () {
                            r && o && n.current && n.current.focus()
                        }), [n, r, o]), {
                            setHover: h, onBlur: function (e) {
                                r && !e.currentTarget.contains(e.relatedTarget) && f()
                            }, onPointerMove: function () {
                                l ? d.current || (d.current = setTimeout((function () {
                                    d.current = 0, h()
                                }), s)) : h()
                            }, onPointerLeave: function (e, t) {
                                d.current && (clearTimeout(d.current), d.current = 0), !t && f()
                            }
                        }
                    }(h, h, d, m), y = g.setHover, v = hv(g, qv), b = (0, t.useContext)(yv), w = (0, t.useContext)(vv),
                    x = "radio" === a, E = "checkbox" === a, S = !(!s || m || x || E), k = x ? w.value === i : !!E && !!o,
                    A = function (e) {
                        if (m) return e.stopPropagation(), void e.preventDefault();
                        var t = {value: i, syntheticEvent: e};
                        void 0 !== e.key && (t.key = e.key), E && (t.checked = !k), x && (t.name = w.name), Bv(u, t), x && Bv(w.onRadioChange, t), b.handleClick(t, E || x)
                    }, T = (0, t.useMemo)((function () {
                        return {type: a, disabled: m, hover: d, checked: k, anchor: S}
                    }), [a, m, d, k, S]), C = Fv(dv({}, v, {
                        onPointerDown: y, onKeyDown: function (e) {
                            if (d) switch (e.key) {
                                case xv.ENTER:
                                case xv.SPACE:
                                    S ? e.key === xv.SPACE && h.current.click() : A(e)
                            }
                        }, onClick: A
                    }), p), R = dv({
                        role: x ? "menuitemradio" : E ? "menuitemcheckbox" : Cv,
                        "aria-checked": x || E ? k : void 0
                    }, Hv(m, d), C, {
                        ref: Nv(f, h),
                        className: jv({block: fv, element: "item", modifiers: T, className: r}),
                        children: (0, t.useMemo)((function () {
                            return Bv(c, T)
                        }), [c, T])
                    });
                return S ? (0, e.jsx)("li", {
                    role: "presentation",
                    children: (0, e.jsx)("a", dv({href: s}, R))
                }) : (0, e.jsx)("li", dv({}, R))
            })), Vv = function (n) {
                var r = n.className, i = n.containerRef, s = n.containerProps, a = n.children, o = n.isOpen, l = n.skipOpen,
                    c = n.theming, u = n.transition, d = n.onClose, h = Ov(u, "item");
                return (0, e.jsx)("div", dv({}, Fv({
                    onKeyDown: function (e) {
                        var t = e.key;
                        t === xv.ESC && Bv(d, {key: t, reason: Sv.CANCEL})
                    }, onBlur: function (e) {
                        o && !e.currentTarget.contains(e.relatedTarget || document.activeElement) && (Bv(d, {reason: Sv.BLUR}), l && (l.current = !0, setTimeout((function () {
                            return l.current = !1
                        }), 300)))
                    }
                }, s), {
                    className: jv({
                        block: "szh-menu-container", modifiers: (0, t.useMemo)((function () {
                            return {theme: c, itemTransition: h}
                        }), [c, h]), className: r
                    }), style: dv({position: "absolute"}, null == s ? void 0 : s.style), ref: i, children: a
                }))
            },
            Yv = ["ariaLabel", "menuClassName", "menuStyle", "arrowClassName", "arrowStyle", "anchorPoint", "anchorRef", "containerRef", "containerProps", "focusProps", "externalRef", "parentScrollingRef", "arrow", "align", "direction", "position", "overflow", "setDownOverflow", "repositionFlag", "captureFocus", "state", "endTransition", "isDisabled", "menuItemFocus", "offsetX", "offsetY", "children", "onClose"],
            Zv = function (n) {
                var r = n.ariaLabel, i = n.menuClassName, s = n.menuStyle, a = n.arrowClassName, o = n.arrowStyle,
                    c = n.anchorPoint, u = n.anchorRef, d = n.containerRef, h = n.containerProps, f = n.focusProps,
                    p = n.externalRef, m = n.parentScrollingRef, g = n.arrow, y = n.align,
                    v = void 0 === y ? "start" : y, b = n.direction, w = void 0 === b ? "bottom" : b, x = n.position,
                    E = void 0 === x ? "auto" : x, S = n.overflow, k = void 0 === S ? "visible" : S,
                    A = n.setDownOverflow, T = n.repositionFlag, C = n.captureFocus, R = void 0 === C || C, L = n.state,
                    _ = n.endTransition, P = n.isDisabled, N = n.menuItemFocus, j = n.offsetX, I = void 0 === j ? 0 : j,
                    M = n.offsetY, D = void 0 === M ? 0 : M, O = n.children, B = n.onClose, F = hv(n, Yv),
                    U = (0, t.useState)({x: 0, y: 0}), H = U[0], $ = U[1], K = (0, t.useState)({}), z = K[0], G = K[1],
                    q = (0, t.useState)(), W = q[0], V = q[1], Y = (0, t.useState)(w), Z = Y[0], X = Y[1],
                    Q = (0, t.useState)(0), J = Q[0], ee = Q[1], te = (0, t.useReducer)((function (e) {
                        return e + 1
                    }), 1), ne = te[0], re = te[1], ie = (0, t.useContext)(bv), se = ie.transition, ae = ie.boundingBoxRef,
                    oe = ie.boundingBoxPadding, le = ie.rootMenuRef, ce = ie.rootAnchorRef, ue = ie.scrollNodesRef,
                    de = ie.reposition, he = ie.viewScroll, fe = (0, t.useContext)(gv).reposSubmenu || T,
                    pe = (0, t.useRef)(null), me = (0, t.useRef)(), ge = (0, t.useRef)(), ye = (0, t.useRef)(!1),
                    ve = (0, t.useRef)({width: 0, height: 0}), be = (0, t.useRef)((function () {
                    })), we = function (e, n) {
                        var r = (0, t.useState)(), i = r[0], s = r[1],
                            a = (0, t.useRef)({items: [], hoverIndex: -1, sorted: !1}).current,
                            o = (0, t.useCallback)((function (e, t) {
                                var r = a.items;
                                if (e) if (t) r.push(e); else {
                                    var i = r.indexOf(e);
                                    i > -1 && (r.splice(i, 1), e.contains(document.activeElement) && (n.current.focus(), s()))
                                } else a.items = [];
                                a.hoverIndex = -1, a.sorted = !1
                            }), [a, n]), l = (0, t.useCallback)((function (t, n, r) {
                                var i = a.items, o = a.hoverIndex, l = function () {
                                    if (!a.sorted) {
                                        var t = e.current.querySelectorAll(".szh-menu__item");
                                        i.sort((function (e, n) {
                                            return $v(t, e) - $v(t, n)
                                        })), a.sorted = !0
                                    }
                                }, c = -1, u = void 0;
                                switch (t) {
                                    case Ev.RESET:
                                        break;
                                    case Ev.SET:
                                        u = n;
                                        break;
                                    case Ev.UNSET:
                                        u = function (e) {
                                            return e === n ? void 0 : e
                                        };
                                        break;
                                    case Ev.FIRST:
                                        l(), u = i[c = 0];
                                        break;
                                    case Ev.LAST:
                                        l(), c = i.length - 1, u = i[c];
                                        break;
                                    case Ev.SET_INDEX:
                                        l(), u = i[c = r];
                                        break;
                                    case Ev.INCREASE:
                                        l(), (c = o) < 0 && (c = i.indexOf(n)), ++c >= i.length && (c = 0), u = i[c];
                                        break;
                                    case Ev.DECREASE:
                                        l(), (c = o) < 0 && (c = i.indexOf(n)), --c < 0 && (c = i.length - 1), u = i[c]
                                }
                                u || (c = -1), s(u), a.hoverIndex = c
                            }), [e, a]);
                        return {hoverItem: i, dispatch: l, updateItems: o}
                    }(pe, me), xe = we.hoverItem, Ee = we.dispatch, Se = we.updateItems, ke = Iv(L), Ae = Ov(se, "open"),
                    Te = Ov(se, "close"), Ce = ue.current, Re = (0, t.useCallback)((function (e) {
                        var t, n = u ? null == (t = u.current) ? void 0 : t.getBoundingClientRect() : c ? {
                            left: c.x,
                            right: c.x,
                            top: c.y,
                            bottom: c.y,
                            width: 0,
                            height: 0
                        } : null;
                        if (n) {
                            Ce.menu || (Ce.menu = (ae ? ae.current : Uv(le.current)) || window);
                            var r = function (e, t, n, r) {
                                    var i = t.current.getBoundingClientRect(), s = e.current.getBoundingClientRect(),
                                        a = n === window ? {
                                            left: 0,
                                            top: 0,
                                            right: document.documentElement.clientWidth,
                                            bottom: window.innerHeight
                                        } : n.getBoundingClientRect(), o = function (e) {
                                            if ("string" != typeof e) return {top: 0, right: 0, bottom: 0, left: 0};
                                            var t = e.trim().split(/\s+/, 4).map(parseFloat), n = isNaN(t[0]) ? 0 : t[0],
                                                r = isNaN(t[1]) ? n : t[1];
                                            return {top: n, right: r, bottom: isNaN(t[2]) ? n : t[2], left: isNaN(t[3]) ? r : t[3]}
                                        }(r), l = function (e) {
                                            return e + s.left - a.left - o.left
                                        }, c = function (e) {
                                            return e + s.left + i.width - a.right + o.right
                                        }, u = function (e) {
                                            return e + s.top - a.top - o.top
                                        }, d = function (e) {
                                            return e + s.top + i.height - a.bottom + o.bottom
                                        };
                                    return {
                                        menuRect: i,
                                        containerRect: s,
                                        getLeftOverflow: l,
                                        getRightOverflow: c,
                                        getTopOverflow: u,
                                        getBottomOverflow: d,
                                        confineHorizontally: function (e) {
                                            var t = l(e);
                                            if (t < 0) e -= t; else {
                                                var n = c(e);
                                                n > 0 && (t = l(e -= n)) < 0 && (e -= t)
                                            }
                                            return e
                                        },
                                        confineVertically: function (e) {
                                            var t = u(e);
                                            if (t < 0) e -= t; else {
                                                var n = d(e);
                                                n > 0 && (t = u(e -= n)) < 0 && (e -= t)
                                            }
                                            return e
                                        }
                                    }
                                }(d, pe, Ce.menu, oe), i = function (e) {
                                    var t = e.arrow, n = e.align, r = e.direction, i = e.offsetX, s = e.offsetY, a = e.position,
                                        o = e.anchorRect, l = e.arrowRef, c = e.positionHelpers, u = c.menuRect,
                                        d = c.containerRect, h = i, f = s;
                                    t && ("left" === r || "right" === r ? h += l.current.offsetWidth : f += l.current.offsetHeight);
                                    var p, m, g = o.left - d.left - u.width - h, y = o.right - d.left + h,
                                        v = o.top - d.top - u.height - f, b = o.bottom - d.top + f;
                                    "end" === n ? (p = o.right - d.left - u.width, m = o.bottom - d.top - u.height) : "center" === n ? (p = o.left - d.left - (u.width - o.width) / 2, m = o.top - d.top - (u.height - o.height) / 2) : (p = o.left - d.left, m = o.top - d.top);
                                    var w = dv({}, c, {
                                        anchorRect: o,
                                        placeLeftX: g,
                                        placeRightX: y,
                                        placeLeftorRightY: m += f,
                                        placeTopY: v,
                                        placeBottomY: b,
                                        placeToporBottomX: p += h,
                                        arrowRef: l,
                                        arrow: t,
                                        direction: r,
                                        position: a
                                    });
                                    switch (r) {
                                        case"left":
                                        case"right":
                                            return function (e) {
                                                var t, n, r, i = e.anchorRect, s = e.containerRect, a = e.menuRect,
                                                    o = e.placeLeftorRightY, l = e.placeLeftX, c = e.placeRightX,
                                                    u = e.getLeftOverflow, d = e.getRightOverflow, h = e.confineHorizontally,
                                                    f = e.confineVertically, p = e.arrowRef, m = e.arrow, g = e.direction,
                                                    y = e.position, v = g, b = o;
                                                "initial" !== y && (b = f(b), "anchor" === y && (b = Math.min(b, i.bottom - s.top), b = Math.max(b, i.top - s.top - a.height))), "left" === v ? (t = l, "initial" !== y && (n = u(t)) < 0 && ((r = d(c)) <= 0 || -n > r) && (t = c, v = "right")) : (t = c, "initial" !== y && (r = d(t)) > 0 && ((n = u(l)) >= 0 || -n < r) && (t = l, v = "left")), "auto" === y && (t = h(t));
                                                var w = m ? function (e) {
                                                    var t = e.arrowRef, n = e.menuY, r = e.anchorRect, i = e.containerRect,
                                                        s = e.menuRect, a = r.top - i.top - n + r.height / 2,
                                                        o = 1.25 * t.current.offsetHeight;
                                                    return a = Math.max(o, a), Math.min(a, s.height - o)
                                                }({
                                                    menuY: b,
                                                    arrowRef: p,
                                                    anchorRect: i,
                                                    containerRect: s,
                                                    menuRect: a
                                                }) : void 0;
                                                return {arrowY: w, x: t, y: b, computedDirection: v}
                                            }(w);
                                        default:
                                            return function (e) {
                                                var t, n, r, i = e.anchorRect, s = e.containerRect, a = e.menuRect,
                                                    o = e.placeToporBottomX, l = e.placeTopY, c = e.placeBottomY,
                                                    u = e.getTopOverflow, d = e.getBottomOverflow, h = e.confineHorizontally,
                                                    f = e.confineVertically, p = e.arrowRef, m = e.arrow, g = e.direction,
                                                    y = e.position, v = "top" === g ? "top" : "bottom", b = o;
                                                "initial" !== y && (b = h(b), "anchor" === y && (b = Math.min(b, i.right - s.left), b = Math.max(b, i.left - s.left - a.width))), "top" === v ? (t = l, "initial" !== y && (n = u(t)) < 0 && ((r = d(c)) <= 0 || -n > r) && (t = c, v = "bottom")) : (t = c, "initial" !== y && (r = d(t)) > 0 && ((n = u(l)) >= 0 || -n < r) && (t = l, v = "top")), "auto" === y && (t = f(t));
                                                var w = m ? function (e) {
                                                    var t = e.arrowRef, n = e.menuX, r = e.anchorRect, i = e.containerRect,
                                                        s = e.menuRect, a = r.left - i.left - n + r.width / 2,
                                                        o = 1.25 * t.current.offsetWidth;
                                                    return a = Math.max(o, a), Math.min(a, s.width - o)
                                                }({
                                                    menuX: b,
                                                    arrowRef: p,
                                                    anchorRect: i,
                                                    containerRect: s,
                                                    menuRect: a
                                                }) : void 0;
                                                return {arrowX: w, x: b, y: t, computedDirection: v}
                                            }(w)
                                    }
                                }({
                                    arrow: g,
                                    align: v,
                                    direction: w,
                                    offsetX: I,
                                    offsetY: D,
                                    position: E,
                                    anchorRect: n,
                                    arrowRef: ge,
                                    positionHelpers: r
                                }), s = i.arrowX, a = i.arrowY, o = i.x, l = i.y, h = i.computedDirection, f = r.menuRect,
                                p = f.height;
                            if (!e && "visible" !== k) {
                                var m, y, b = r.getTopOverflow, x = r.getBottomOverflow, S = ve.current.height, A = x(l);
                                if (A > 0 || Dv(A, 0) && Dv(p, S)) m = p - A, y = A; else {
                                    var T = b(l);
                                    (T < 0 || Dv(T, 0) && Dv(p, S)) && (y = 0 - T, (m = p + T) >= 0 && (l -= T))
                                }
                                m >= 0 ? (p = m, V({height: m, overflowAmt: y})) : V()
                            }
                            g && G({x: s, y: a}), $({x: o, y: l}), X(h), ve.current = {width: f.width, height: p}
                        }
                    }), [g, v, oe, w, I, D, E, k, c, u, d, ae, le, Ce]);
                _v((function () {
                    ke && (Re(), ye.current && re()), ye.current = ke, be.current = Re
                }), [ke, Re, fe]), _v((function () {
                    W && !A && (pe.current.scrollTop = 0)
                }), [W, A]), _v((function () {
                    return Se
                }), [Se]), (0, t.useEffect)((function () {
                    var e = Ce.menu;
                    if (ke && e) {
                        if (e = e.addEventListener ? e : window, !Ce.anchors) {
                            Ce.anchors = [];
                            for (var t = Uv(ce && ce.current); t && t !== e;) Ce.anchors.push(t), t = Uv(t)
                        }
                        var n = he;
                        if (Ce.anchors.length && "initial" === n && (n = "auto"), "initial" !== n) {
                            var r = function () {
                                "auto" === n ? Mv((function () {
                                    return Re(!0)
                                })) : Bv(B, {reason: Sv.SCROLL})
                            }, i = Ce.anchors.concat("initial" !== he ? e : []);
                            return i.forEach((function (e) {
                                return e.addEventListener("scroll", r)
                            })), function () {
                                return i.forEach((function (e) {
                                    return e.removeEventListener("scroll", r)
                                }))
                            }
                        }
                    }
                }), [ce, Ce, ke, B, he, Re]);
                var Le = !!W && W.overflowAmt > 0;
                (0, t.useEffect)((function () {
                    if (!Le && ke && m) {
                        var e = function () {
                            return Mv(Re)
                        }, t = m.current;
                        return t.addEventListener("scroll", e), function () {
                            return t.removeEventListener("scroll", e)
                        }
                    }
                }), [ke, Le, m, Re]), (0, t.useEffect)((function () {
                    if ("function" == typeof ResizeObserver && "initial" !== de) {
                        var e = new ResizeObserver((function (e) {
                            var t, n, r = e[0], i = r.borderBoxSize, s = r.target;
                            if (i) {
                                var a = i[0] || i;
                                t = a.inlineSize, n = a.blockSize
                            } else {
                                var o = s.getBoundingClientRect();
                                t = o.width, n = o.height
                            }
                            0 !== t && 0 !== n && (Dv(t, ve.current.width, 1) && Dv(n, ve.current.height, 1) || (0, l.flushSync)((function () {
                                be.current(), re()
                            })))
                        })), t = pe.current;
                        return e.observe(t, {box: "border-box"}), function () {
                            return e.unobserve(t)
                        }
                    }
                }), [de]), (0, t.useEffect)((function () {
                    if (!ke) return Ee(Ev.RESET), void (Te || V());
                    var e = N || {}, t = e.position, n = e.alwaysUpdate, r = function () {
                        t === kv.FIRST ? Ee(Ev.FIRST) : t === kv.LAST ? Ee(Ev.LAST) : t >= -1 && Ee(Ev.SET_INDEX, void 0, t)
                    };
                    if (n) r(); else if (R) {
                        var i = setTimeout((function () {
                            pe.current.contains(document.activeElement) || (me.current.focus(), r())
                        }), Ae ? 170 : 100);
                        return function () {
                            return clearTimeout(i)
                        }
                    }
                }), [ke, Ae, Te, R, N, Ee]);
                var _e, Pe, Ne = J > 0, je = (0, t.useMemo)((function () {
                    return {isParentOpen: ke, isSubmenuOpen: Ne, setOpenSubmenuCount: ee, dispatch: Ee, updateItems: Se}
                }), [ke, Ne, Ee, Se]);
                W && (A ? Pe = W.overflowAmt : _e = W.height);
                var Ie = (0, t.useMemo)((function () {
                        return {reposSubmenu: ne, overflow: k, overflowAmt: Pe, parentMenuRef: pe, parentDir: Z}
                    }), [ne, k, Pe, Z]), Me = _e >= 0 ? {maxHeight: _e, overflow: k} : void 0,
                    De = (0, t.useMemo)((function () {
                        return {state: L, dir: Z}
                    }), [L, Z]), Oe = (0, t.useMemo)((function () {
                        return {dir: Z}
                    }), [Z]), Be = jv({block: fv, element: "arrow", modifiers: Oe, className: a}),
                    Fe = (0, e.jsxs)("ul", dv({role: "menu", "aria-label": r}, Hv(P), Fv({
                        onKeyDown: function (e) {
                            switch (e.key) {
                                case xv.HOME:
                                    Ee(Ev.FIRST);
                                    break;
                                case xv.END:
                                    Ee(Ev.LAST);
                                    break;
                                case xv.UP:
                                    Ee(Ev.DECREASE, xe);
                                    break;
                                case xv.DOWN:
                                    Ee(Ev.INCREASE, xe);
                                    break;
                                case xv.SPACE:
                                    return void (e.target && -1 !== e.target.className.indexOf(fv) && e.preventDefault());
                                default:
                                    return
                            }
                            e.preventDefault(), e.stopPropagation()
                        }, onAnimationEnd: function () {
                            "closing" === L && V(), Bv(_)
                        }
                    }, F), {
                        ref: Nv(p, pe),
                        className: jv({block: fv, modifiers: De, className: i}),
                        style: dv({}, s, Me, {
                            margin: 0,
                            display: "closed" === L ? "none" : void 0,
                            position: Tv,
                            left: H.x,
                            top: H.y
                        }),
                        children: [(0, e.jsx)("li", dv({
                            tabIndex: -1,
                            style: {position: Tv, left: 0, top: 0, display: "block", outline: "none"},
                            ref: me
                        }, Rv, f)), g && (0, e.jsx)("li", dv({
                            className: Be,
                            style: dv({display: "block", position: Tv, left: z.x, top: z.y}, o),
                            ref: ge
                        }, Rv)), (0, e.jsx)(gv.Provider, {
                            value: Ie,
                            children: (0, e.jsx)(mv.Provider, {
                                value: je,
                                children: (0, e.jsx)(pv.Provider, {value: xe, children: Bv(O, De)})
                            })
                        })]
                    }));
                return h ? (0, e.jsx)(Vv, dv({}, h, {isOpen: ke, children: Fe})) : Fe
            },
            Xv = ["aria-label", "className", "containerProps", "initialMounted", "unmountOnClose", "transition", "transitionTimeout", "boundingBoxRef", "boundingBoxPadding", "reposition", "submenuOpenDelay", "submenuCloseDelay", "skipOpen", "viewScroll", "portal", "theming", "onItemClick"],
            Qv = (0, t.forwardRef)((function (n, r) {
                var i = n["aria-label"], s = n.className, a = n.containerProps, o = n.initialMounted,
                    c = n.unmountOnClose, u = n.transition, d = n.transitionTimeout, h = n.boundingBoxRef,
                    f = n.boundingBoxPadding, p = n.reposition, m = void 0 === p ? "auto" : p, g = n.submenuOpenDelay,
                    y = void 0 === g ? 300 : g, v = n.submenuCloseDelay, b = void 0 === v ? 150 : v, w = n.skipOpen,
                    x = n.viewScroll, E = void 0 === x ? "initial" : x, S = n.portal, k = n.theming, A = n.onItemClick,
                    T = hv(n, Xv), C = (0, t.useRef)(null), R = (0, t.useRef)({}), L = T.anchorRef, _ = T.state,
                    P = T.onClose, N = (0, t.useMemo)((function () {
                        return {
                            initialMounted: o,
                            unmountOnClose: c,
                            transition: u,
                            transitionTimeout: d,
                            boundingBoxRef: h,
                            boundingBoxPadding: f,
                            rootMenuRef: C,
                            rootAnchorRef: L,
                            scrollNodesRef: R,
                            reposition: m,
                            viewScroll: E
                        }
                    }), [o, c, u, d, L, h, f, m, E]), j = (0, t.useMemo)((function () {
                        return {submenuOpenDelay: y, submenuCloseDelay: b}
                    }), [y, b]), I = (0, t.useMemo)((function () {
                        return {
                            handleClick: function (e, t) {
                                e.stopPropagation || Bv(A, e);
                                var n = e.keepOpen;
                                void 0 === n && (n = t && e.key === xv.SPACE), n || Bv(P, {
                                    value: e.value,
                                    key: e.key,
                                    reason: Sv.CLICK
                                })
                            }, handleClose: function (e) {
                                Bv(P, {key: e, reason: Sv.CLICK})
                            }
                        }
                    }), [A, P]);
                if (!_) return null;
                var M = (0, e.jsx)(bv.Provider, {
                    value: N,
                    children: (0, e.jsx)(wv.Provider, {
                        value: j,
                        children: (0, e.jsx)(yv.Provider, {
                            value: I,
                            children: (0, e.jsx)(Zv, dv({}, T, {
                                ariaLabel: i || "Menu",
                                externalRef: r,
                                containerRef: C,
                                containerProps: {
                                    className: s,
                                    containerRef: C,
                                    containerProps: a,
                                    skipOpen: w,
                                    theming: k,
                                    transition: u,
                                    onClose: P
                                }
                            }))
                        })
                    })
                });
                return !0 === S && "undefined" != typeof document ? (0, l.createPortal)(M, document.body) : S ? S.target ? (0, l.createPortal)(M, S.target) : S.stablePosition ? null : M : M
            })), Jv = ["preEnter", "entering", "entered", "preExit", "exiting", "exited", "unmounted"],
            eb = function (e) {
                return e ? 6 : 5
            }, tb = function (e, t, n, r, i) {
                clearTimeout(r.current), t(e), n.current = e, i && i({state: Jv[e]})
            }, nb = ["aria-label", "captureFocus", "initialOpen", "menuButton", "instanceRef", "onMenuChange"],
            rb = (0, t.forwardRef)((function (n, r) {
                var i = n["aria-label"], s = n.menuButton, a = n.instanceRef, o = n.onMenuChange, l = hv(n, nb),
                    c = function (e) {
                        var n = function (e) {
                            var n = void 0 === e ? {} : e, r = n.initialOpen, i = n.initialMounted,
                                s = n.unmountOnClose, a = n.transition, o = n.transitionTimeout, l = function (e) {
                                    var n, r, i = void 0 === e ? {} : e, s = i.enter, a = void 0 === s || s, o = i.exit,
                                        l = void 0 === o || o, c = i.preEnter, u = i.preExit, d = i.timeout,
                                        h = i.initialEntered, f = i.mountOnEnter, p = i.unmountOnExit, m = i.onChange,
                                        g = (0, t.useState)(h ? 2 : eb(f)), y = g[0], v = g[1], b = (0, t.useRef)(y),
                                        w = (0, t.useRef)();
                                    "object" == typeof d ? (n = d.enter, r = d.exit) : n = r = d;
                                    var x = (0, t.useCallback)((function () {
                                        var e;
                                        switch (b.current) {
                                            case 1:
                                            case 0:
                                                e = 2;
                                                break;
                                            case 4:
                                            case 3:
                                                e = eb(p)
                                        }
                                        void 0 !== e && tb(e, v, b, w, m)
                                    }), [m, p]), E = (0, t.useCallback)((function (e) {
                                        var t = function e(t) {
                                            switch (tb(t, v, b, w, m), t) {
                                                case 1:
                                                    n >= 0 && (w.current = setTimeout(x, n));
                                                    break;
                                                case 4:
                                                    r >= 0 && (w.current = setTimeout(x, r));
                                                    break;
                                                case 0:
                                                case 3:
                                                    w.current = setTimeout((function () {
                                                        return e(t + 1)
                                                    }), 0)
                                            }
                                        }, i = b.current <= 2;
                                        "boolean" != typeof e && (e = !i), e ? i || t(a ? c ? 0 : 1 : 2) : i && t(l ? u ? 3 : 4 : eb(p))
                                    }), [x, m, a, l, c, u, n, r, p]);
                                    return (0, t.useEffect)((function () {
                                        return function () {
                                            return clearTimeout(w.current)
                                        }
                                    }), []), [Jv[y], E, x]
                                }({
                                    initialEntered: r,
                                    mountOnEnter: !i,
                                    unmountOnExit: s,
                                    timeout: void 0 === o ? 500 : o,
                                    enter: Ov(a, "open"),
                                    exit: Ov(a, "close")
                                }), c = l[0], u = l[1], d = l[2];
                            return [{state: Av[c], endTransition: d}, u]
                        }(e), r = n[0], i = n[1], s = (0, t.useState)(), a = s[0], o = s[1];
                        return [dv({menuItemFocus: a}, r), i, function (e, t) {
                            o({position: e, alwaysUpdate: t}), i(!0)
                        }]
                    }(l), u = c[0], d = c[1], h = c[2], f = u.state, p = Iv(f), m = (0, t.useRef)(null),
                    g = function (e, n) {
                        var r = (0, t.useState)({})[0];
                        return {
                            onMouseDown: function () {
                                r.v = e && "closed" !== e
                            }, onClick: function (e) {
                                return r.v ? r.v = !1 : function (e, t) {
                                    return h(t.detail ? void 0 : kv.FIRST)
                                }(0, e)
                            }
                        }
                    }(f), y = (0, t.useCallback)((function (e) {
                        d(!1), e.key && setTimeout((function () {
                            var e;
                            return null == (e = m.current) ? void 0 : e.focus()
                        }), 0)
                    }), [d]), v = Bv(s, {open: p});
                if (!v || !v.type) throw new Error("Menu requires a menuButton prop.");
                var b = dv({ref: Nv(v.ref, m)}, Fv(dv({
                    onKeyDown: function (e) {
                        switch (e.key) {
                            case xv.UP:
                                h(kv.LAST);
                                break;
                            case xv.DOWN:
                                h(kv.FIRST);
                                break;
                            default:
                                return
                        }
                        e.preventDefault()
                    }
                }, g), v.props));
                "MenuButton" === v.type._szhsinMenu && (b.isOpen = p);
                var w = (0, t.cloneElement)(v, b);
                return function (e, n) {
                    var r = (0, t.useRef)(n);
                    (0, t.useEffect)((function () {
                        r.current !== n && Bv(e, {open: n}), r.current = n
                    }), [e, n])
                }(o, p), (0, t.useImperativeHandle)(a, (function () {
                    return {
                        openMenu: h, closeMenu: function () {
                            return d(!1)
                        }
                    }
                })), (0, e.jsxs)(t.Fragment, {
                    children: [w, (0, e.jsx)(Qv, dv({}, l, u, {
                        "aria-label": i || ("string" == typeof v.props.children ? v.props.children : "Menu"),
                        anchorRef: m,
                        ref: r,
                        onClose: y
                    }))]
                })
            }));

        function ib() {
            return (ib = Object.assign || function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }).apply(this, arguments)
        }

        function sb(e) {
            var t = e.nativeEvent;
            return window.TouchEvent ? t instanceof TouchEvent : "touches" in t
        }

        function ab(e) {
            return e.nativeEvent instanceof MouseEvent
        }

        function ob(e) {
            return sb(e) ? {x: e.touches[0].pageX, y: e.touches[0].pageY} : ab(e) ? {x: e.pageX, y: e.pageY} : null
        }

        function lb() {
            const t = hc(), {note: n, show: r, selectedCustomRelays: i} = g((e => e.reBroadcast)), s = S(),
                a = Qs().relays;
            return (0, e.jsx)(e.Fragment, {
                children: r && (0, e.jsxs)(Cu, {
                    className: "note-creator-modal",
                    onClose: () => s(el(!1)),
                    children: [(0, e.jsx)("div", {
                        children: Object.keys(a.item || {}).filter((e => a.item[e].write)).map(((t, n, r) => (0, e.jsxs)("div", {
                            className: "card flex",
                            children: [(0, e.jsx)("div", {
                                className: "flex f-col f-grow",
                                children: (0, e.jsx)("div", {children: t})
                            }), (0, e.jsx)("div", {
                                children: (0, e.jsx)("input", {
                                    type: "checkbox",
                                    checked: !i || i.includes(t),
                                    onChange: e => s(nl((!e.target.checked || !i || i.length != r.length - 1) && r.filter((n => n === t ? e.target.checked : !i || i.includes(n)))))
                                })
                            })]
                        })))
                    }), (0, e.jsxs)("div", {
                        className: "note-creator-actions",
                        children: [(0, e.jsx)("button", {
                            className: "secondary", onClick: function () {
                                s(rl())
                            }, children: (0, e.jsx)(cl, {...Su.Cancel})
                        }), (0, e.jsx)("button", {
                            onClick: function (e) {
                                e.stopPropagation(), async function () {
                                    n && t && (i ? i.forEach((e => DS.WriteOnceToRelay(e, n))) : DS.BroadcastEvent(n), s(rl()))
                                }().catch(console.warn)
                            }, children: (0, e.jsx)(cl, {...Su.ReBroadcast})
                        })]
                    })]
                })
            })
        }

        !function (e) {
            e.CANCELED_BY_MOVEMENT = "canceled-by-movement", e.CANCELED_BY_TIMEOUT = "canceled-by-timeout"
        }(Kv || (Kv = {})), function (e) {
            e.BOTH = "both", e.MOUSE = "mouse", e.TOUCH = "touch"
        }(zv || (zv = {}));
        const cb = function () {
            const e = (0, t.useRef)();
            return (0, t.useEffect)((() => {
                const t = e.current;
                if (t) {
                    const e = e => {
                        0 != e.deltaY && (e.preventDefault(), t.scrollTo({
                            left: t.scrollLeft + e.deltaY,
                            behavior: "smooth"
                        }))
                    };
                    return t.addEventListener("wheel", e), () => t.removeEventListener("wheel", e)
                }
            }), []), e
        }, ub = t => {
            let {t: n, tab: r, setTab: i} = t;
            return (0, e.jsx)("div", {
                className: `tab ${r.value === n.value ? "active" : ""} ${n.disabled ? "disabled" : ""}`,
                onClick: () => !n.disabled && i(n),
                children: n.text
            })
        }, db = t => {
            let {tabs: n, tab: r, setTab: i} = t;
            const s = cb();
            return (0, e.jsx)("div", {
                className: "tabs",
                ref: s,
                children: n.map((t => (0, e.jsx)(ub, {tab: r, setTab: i, t}, t.value)))
            })
        }, hb = n => {
            let {show: r, setShow: i, positive: s, negative: a, reposts: o, zaps: l} = n;
            const {formatMessage: c} = al(), u = () => i(!1), d = (0, t.useMemo)((() => {
                    const e = [...s];
                    return e.sort(((e, t) => t.created_at - e.created_at)), e
                }), [s]), h = (0, t.useMemo)((() => {
                    const e = [...a];
                    return e.sort(((e, t) => t.created_at - e.created_at)), e
                }), [a]), f = s.length + a.length + l.length + o.length,
                p = [{text: c(Su.Likes, {n: d.length}), value: 0}, {
                    text: c(Su.Zaps, {n: l.length}),
                    value: 1,
                    disabled: 0 === l.length
                }, {
                    text: c(Su.Reposts, {n: o.length}),
                    value: 2,
                    disabled: 0 === o.length
                }].concat(0 !== h.length ? [{
                    text: c(Su.Dislikes, {n: h.length}),
                    value: 3
                }] : []), [m, g] = (0, t.useState)(p[0]);
            return (0, t.useEffect)((() => {
                r || g(p[0])
            }), [r]), r ? (0, e.jsxs)(Cu, {
                className: "reactions-modal",
                onClose: u,
                children: [(0, e.jsx)("div", {
                    className: "close",
                    onClick: u,
                    children: (0, e.jsx)(Gl, {name: "close"})
                }), (0, e.jsx)("div", {
                    className: "reactions-header",
                    children: (0, e.jsx)("h2", {children: (0, e.jsx)(cl, {...Su.ReactionsCount, values: {n: f}})})
                }), (0, e.jsx)(db, {tabs: p, tab: m, setTab: g}), (0, e.jsxs)("div", {
                    className: "reactions-body",
                    children: [0 === m.value && d.map((t => (0, e.jsxs)("div", {
                        className: "reactions-item",
                        children: [(0, e.jsx)("div", {
                            className: "reaction-icon",
                            children: "+" === t.content ? (0, e.jsx)(Gl, {name: "heart"}) : t.content
                        }), (0, e.jsx)(Zl, {pubkey: t.pubkey})]
                    }, t.id))), 1 === m.value && l.map((t => t.sender && (0, e.jsxs)("div", {
                        className: "reactions-item",
                        children: [(0, e.jsxs)("div", {
                            className: "zap-reaction-icon",
                            children: [(0, e.jsx)(Gl, {
                                name: "zap",
                                size: 20
                            }), (0, e.jsx)("span", {className: "zap-amount", children: Hu(t.amount)})]
                        }), (0, e.jsx)(Zl, {
                            pubkey: t.anonZap ? "" : t.sender,
                            subHeader: (0, e.jsx)("div", {title: t.content, children: t.content}),
                            link: t.anonZap ? "" : void 0,
                            overrideUsername: t.anonZap ? c({id: "LXxsbk", defaultMessage: "Anonymous"}) : void 0
                        })]
                    }, t.id))), 2 === m.value && o.map((t => (0, e.jsxs)("div", {
                        className: "reactions-item",
                        children: [(0, e.jsx)("div", {
                            className: "reaction-icon",
                            children: (0, e.jsx)(Gl, {name: "repost", size: 16})
                        }), (0, e.jsx)(Zl, {pubkey: t.pubkey})]
                    }, t.id))), 3 === m.value && h.map((t => (0, e.jsxs)("div", {
                        className: "reactions-item f-ellipsis",
                        children: [(0, e.jsx)("div", {
                            className: "reaction-icon",
                            children: (0, e.jsx)(Gl, {name: "dislike"})
                        }), (0, e.jsx)(Zl, {pubkey: t.pubkey})]
                    }, t.id)))]
                }, m.value)]
            }) : null
        }, fb = n => {
            let {zaps: r} = n;
            const {formatMessage: i} = al(), s = (0, t.useMemo)((() => {
                const e = [...r.filter((e => e.sender && e.valid))], t = [...r.filter((e => !e.sender && e.valid))];
                return e.sort(((e, t) => t.amount - e.amount)), e.concat(t)
            }), [r]);
            if (0 === r.length) return null;
            const [a, ...o] = s, {sender: l, amount: c, anonZap: u} = a;
            return (0, e.jsx)("div", {
                className: "zaps-summary",
                children: c && (0, e.jsx)("div", {
                    className: "top-zap",
                    children: (0, e.jsxs)("div", {
                        className: "summary",
                        children: [l && (0, e.jsx)(Zl, {
                            pubkey: u ? "" : l,
                            overrideUsername: u ? i({id: "LXxsbk", defaultMessage: "Anonymous"}) : void 0
                        }), o.length > 0 ? (0, e.jsx)(cl, {
                            ...Su.Others,
                            values: {n: o.length}
                        }) : (0, e.jsx)(cl, {...Su.Zapped}), " ", (0, e.jsx)(cl, {
                            ...Su.OthersZapped,
                            values: {n: o.length}
                        })]
                    })
                })
            })
        }, pb = t => {
            var n;
            let {zap: r, showZapped: i = !0} = t;
            const {amount: s, content: a, sender: o, valid: l, receiver: c} = r, u = Qs().publicKey;
            return l && o ? (0, e.jsxs)("div", {
                className: "zap note card",
                children: [(0, e.jsxs)("div", {
                    className: "header",
                    children: [(0, e.jsx)(Zl, {pubkey: o}), c !== u && i && (0, e.jsx)(Zl, {pubkey: (0, Ks.Wg)(c)}), (0, e.jsx)("div", {
                        className: "amount",
                        children: (0, e.jsx)("span", {
                            className: "amount-number",
                            children: (0, e.jsx)(cl, {...Su.Sats, values: {n: Hu(null != s ? s : 0)}})
                        })
                    })]
                }), (null !== (n = null == a ? void 0 : a.length) && void 0 !== n ? n : 0) > 0 && o && (0, e.jsx)("div", {
                    className: "body",
                    children: (0, e.jsx)(uv, {creator: o, content: (0, Ks.Wg)(a), tags: []})
                })]
            }) : null
        };
        let mb = !1;
        const gb = async e => {
            for (; mb;) await (0, Ks.gw)(100);
            mb = !0;
            try {
                return await e()
            } finally {
                mb = !1
            }
        };

        function yb(n) {
            const {ev: r, showReactions: i, setShowReactions: s, positive: a, negative: o, reposts: l, zaps: c} = n,
                u = S(), {formatMessage: d} = al(), h = Qs(), {
                    pinned: f,
                    bookmarked: p,
                    publicKey: m,
                    preferences: y,
                    relays: v
                } = h, {mute: b, block: w} = pc(), x = (0, hl.useUserProfile)(DS, r.pubkey), E = function (e, n) {
                    const r = n && e ? (0, Ks.JQ)(n + e) : void 0, i = {id: r, event: n, by: e},
                        s = (0, t.useSyncExternalStore)((e => uc.hook(e, r)), (() => uc.snapshot().find((e => e.id === r)))) || i;
                    return {
                        data: s,
                        react: () => uc.set({...s, event: (0, Ks.Wg)(n), by: (0, Ks.Wg)(e), reacted: !0}),
                        zap: () => uc.set({...s, event: (0, Ks.Wg)(n), by: (0, Ks.Wg)(e), zapped: !0}),
                        repost: () => uc.set({...s, event: (0, Ks.Wg)(n), by: (0, Ks.Wg)(e), reposted: !0})
                    }
                }(m, r.id), k = hc(), A = g((e => e.noteCreator.show)), T = g((e => e.reBroadcast.show)),
                C = g((e => e.reBroadcast.note)), R = g((e => e.noteCreator.replyTo)),
                L = A && (null == R ? void 0 : R.id) === r.id,
                _ = T && C && (null == C ? void 0 : C.id) === r.id, [P, N] = (0, t.useState)(!1), [j, I] = (0, t.useState)(!1),
                M = (0, Wu.Os)().wallet, D = r.pubkey === m, O = window.navigator.language,
                B = new Intl.DisplayNames([...window.navigator.languages], {type: "language"}),
                F = c.reduce(((e, t) => e + t.amount), 0), U = E.data.zapped || c.some((e => e.sender === m)),
                H = function (e, n) {
                    var r = void 0 === n ? {} : n, i = r.threshold, s = void 0 === i ? 400 : i, a = r.captureEvent,
                        o = void 0 !== a && a, l = r.detect, c = void 0 === l ? zv.BOTH : l, u = r.cancelOnMovement,
                        d = void 0 !== u && u, h = r.filterEvents, f = r.onStart, p = r.onMove, m = r.onFinish,
                        g = r.onCancel, y = (0, t.useRef)(!1), v = (0, t.useRef)(!1), b = (0, t.useRef)(),
                        w = (0, t.useRef)(e), x = (0, t.useRef)(null), E = (0, t.useCallback)((function (e) {
                            return function (t) {
                                if (!v.current && (ab(t) || sb(t)) && (void 0 === h || h(t))) {
                                    x.current = ob(t), o && t.persist();
                                    var n = void 0 === e ? {} : {context: e};
                                    null == f || f(t, n), v.current = !0, b.current = setTimeout((function () {
                                        w.current && (w.current(t, n), y.current = !0)
                                    }), s)
                                }
                            }
                        }), [o, h, f, s]), S = (0, t.useCallback)((function (e, t) {
                            return function (n) {
                                if (ab(n) || sb(n)) {
                                    x.current = null, o && n.persist();
                                    var r = void 0 === e ? {} : {context: e};
                                    y.current ? null == m || m(n, r) : v.current && (null == g || g(n, ib({}, r, {reason: null != t ? t : Kv.CANCELED_BY_TIMEOUT}))), y.current = !1, v.current = !1, void 0 !== b.current && clearTimeout(b.current)
                                }
                            }
                        }), [o, m, g]), k = (0, t.useCallback)((function (e) {
                            return function (t) {
                                if (null == p || p(t, {context: e}), d && x.current) {
                                    var n = ob(t);
                                    if (n) {
                                        var r = !0 === d ? 25 : d,
                                            i = {x: Math.abs(n.x - x.current.x), y: Math.abs(n.y - x.current.y)};
                                        (i.x > r || i.y > r) && S(e, Kv.CANCELED_BY_MOVEMENT)(t)
                                    }
                                }
                            }
                        }), [S, d, p]);
                    return (0, t.useEffect)((function () {
                        return function () {
                            void 0 !== b.current && clearTimeout(b.current)
                        }
                    }), []), (0, t.useEffect)((function () {
                        w.current = e
                    }), [e]), (0, t.useMemo)((function () {
                        return function (t) {
                            var n = {onMouseDown: E(t), onMouseMove: k(t), onMouseUp: S(t), onMouseLeave: S(t)},
                                r = {onTouchStart: E(t), onTouchMove: k(t), onTouchEnd: S(t)};
                            return null === e ? {} : c === zv.MOUSE ? n : c === zv.TOUCH ? r : ib({}, n, r)
                        }
                    }), [e, S, c, k, E])
                }((e => {
                    e.stopPropagation(), N(!0)
                }), {captureEvent: !0});

            function $(e) {
                return E.data.reacted || (null == a ? void 0 : a.some((t => {
                    let {pubkey: n, content: r} = t;
                    return (0, Ks.N2)(r) === e && n === m
                })))
            }

            function K() {
                return E.data.reposted || l.some((e => e.pubkey === m))
            }

            async function z(e) {
                if (!$(e) && k) {
                    const t = await k.react(r, e);
                    DS.BroadcastEvent(t), await E.react()
                }
            }

            function G() {
                var e;
                return (null === (e = r.tags.find((e => "zap" === e[0]))) || void 0 === e ? void 0 : e[1]) || (null == x ? void 0 : x.lud16) || (null == x ? void 0 : x.lud06)
            }

            async function q(e, t, n, r) {
                await gb((async () => {
                    const i = new ai.LNURL(e);
                    await i.load();
                    const s = Object.keys(v.item), a = i.canZap && k ? await k.zap(1e3 * t, n, s, r) : void 0,
                        o = await i.getInvoice(t, void 0, a);
                    await (null == M ? void 0 : M.payInvoice((0, Ks.Wg)(o.pr))), wd.allocate(t), await E.zap()
                }))
            }

            (0, t.useEffect)((() => {
                if (y.autoZap && !U && !D && !j) {
                    const e = G();
                    null != M && M.isReady() && e && (I(!0), queueMicrotask((async () => {
                        try {
                            await q(e, y.defaultZapAmount, r.pubkey, r.id)
                        } catch {
                        } finally {
                            I(!1)
                        }
                    })))
                }
            }), [y.autoZap, x, j]);
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsxs)("div", {
                    className: "footer", children: [(0, e.jsxs)("div", {
                        className: "footer-reactions",
                        children: [G() ? (0, e.jsx)(e.Fragment, {
                            children: (0, e.jsxs)("div", {
                                className: "reaction-pill " + (U ? "reacted" : ""), ...H(),
                                onClick: e => async function (e) {
                                    if (j || null != e && e.isPropagationStopped()) return;
                                    const t = G();
                                    if (null != M && M.isReady() && t) {
                                        I(!0);
                                        try {
                                            await q(t, y.defaultZapAmount, r.pubkey, r.id)
                                        } catch (e) {
                                            console.warn("Fast zap failed", e), e instanceof Error && "User rejected" === e.message || N(!0)
                                        } finally {
                                            I(!1)
                                        }
                                    } else N(!0)
                                }(e),
                                children: [j ? (0, e.jsx)(Dd, {}) : null != M && M.isReady() ? (0, e.jsx)(Gl, {name: "zapFast"}) : (0, e.jsx)(Gl, {name: "zap"}), F > 0 && (0, e.jsx)("div", {
                                    className: "reaction-pill-number",
                                    children: Hu(F)
                                })]
                            })
                        }) : null, y.enableReactions ? (0, e.jsx)(e.Fragment, {
                            children: (0, e.jsxs)("div", {
                                className: `reaction-pill ${$("+") ? "reacted" : ""} `,
                                onClick: () => z(y.reactionEmoji),
                                children: [(0, e.jsx)(Gl, {name: "heart"}), (0, e.jsx)("div", {
                                    className: "reaction-pill-number",
                                    children: Hu(a.length)
                                })]
                            })
                        }) : null, (0, e.jsxs)("div", {
                            className: "reaction-pill " + (K() ? "reacted" : ""),
                            onClick: () => async function () {
                                if (!K() && k && (!y.confirmReposts || window.confirm(d(Su.ConfirmRepost, {id: r.id})))) {
                                    const e = await k.repost(r);
                                    DS.BroadcastEvent(e), await E.repost()
                                }
                            }(),
                            children: [(0, e.jsx)(Gl, {
                                name: "repost",
                                size: 17
                            }), l.length > 0 && (0, e.jsx)("div", {
                                className: "reaction-pill-number",
                                children: Hu(l.length)
                            })]
                        }), (0, e.jsx)("div", {
                            className: "reaction-pill " + (A ? "reacted" : ""), onClick: () => {
                                (null == R ? void 0 : R.id) !== r.id && u(Zo()), u(Ko(r)), u(Bo(!A))
                            }, children: (0, e.jsx)(Gl, {name: "reply", size: 17})
                        }), (0, e.jsx)(rb, {
                            menuButton: (0, e.jsx)("div", {
                                className: "reaction-pill",
                                children: (0, e.jsx)(Gl, {name: "dots", size: 15})
                            }), menuClassName: "ctx-menu", children: (0, e.jsxs)(e.Fragment, {
                                children: [(0, e.jsx)("div", {
                                    className: "close-menu-container",
                                    children: (0, e.jsx)(Wv, {children: (0, e.jsx)("div", {className: "close-menu"})})
                                }), (0, e.jsxs)(Wv, {
                                    onClick: () => s(!0),
                                    children: [(0, e.jsx)(Gl, {name: "heart"}), (0, e.jsx)(cl, {...Su.Reactions})]
                                }), (0, e.jsxs)(Wv, {
                                    onClick: () => async function () {
                                        const e = (0, Pt.encodeTLV)(Pt.NostrPrefix.Event, r.id, r.relays),
                                            t = `${window.location.protocol}//${window.location.host}/e/${e}`;
                                        "share" in window.navigator ? await window.navigator.share({
                                            title: "Snort",
                                            url: t
                                        }) : await navigator.clipboard.writeText(t)
                                    }(), children: [(0, e.jsx)(Gl, {name: "share"}), (0, e.jsx)(cl, {...Su.Share})]
                                }), !f.item.includes(r.id) && (0, e.jsxs)(Wv, {
                                    onClick: () => async function (e) {
                                        if (k) {
                                            const t = [...f.item, e], n = await k.noteList(t, Pt.Lists.Pinned);
                                            DS.BroadcastEvent(n), Ys(h, t, 1e3 * n.created_at)
                                        }
                                    }(r.id), children: [(0, e.jsx)(Gl, {name: "pin"}), (0, e.jsx)(cl, {...Su.Pin})]
                                }), !p.item.includes(r.id) && (0, e.jsxs)(Wv, {
                                    onClick: () => async function (e) {
                                        if (k) {
                                            const t = [...p.item, e], n = await k.noteList(t, Pt.Lists.Bookmarked);
                                            DS.BroadcastEvent(n), Zs(h, t, 1e3 * n.created_at)
                                        }
                                    }(r.id),
                                    children: [(0, e.jsx)(Gl, {name: "bookmark"}), (0, e.jsx)(cl, {...Su.Bookmark})]
                                }), (0, e.jsxs)(Wv, {
                                    onClick: () => async function () {
                                        const e = (0, Pt.encodeTLV)(Pt.NostrPrefix.Event, r.id, r.relays);
                                        await navigator.clipboard.writeText(e)
                                    }(), children: [(0, e.jsx)(Gl, {name: "copy"}), (0, e.jsx)(cl, {...Su.CopyID})]
                                }), (0, e.jsxs)(Wv, {
                                    onClick: () => b(r.pubkey),
                                    children: [(0, e.jsx)(Gl, {name: "mute"}), (0, e.jsx)(cl, {...Su.Mute})]
                                }), y.enableReactions && (0, e.jsxs)(Wv, {
                                    onClick: () => z("-"),
                                    children: [(0, e.jsx)(Gl, {name: "dislike"}), (0, e.jsx)(cl, {...Su.DislikeAction})]
                                }), r.pubkey === m && (0, e.jsxs)(Wv, {
                                    onClick: () => {
                                        (null == C ? void 0 : C.id) !== r.id && u(rl()), u(tl(r)), u(el(!T))
                                    }, children: [(0, e.jsx)(Gl, {name: "relay"}), (0, e.jsx)(cl, {...Su.ReBroadcast})]
                                }), r.pubkey !== m && (0, e.jsxs)(Wv, {
                                    onClick: () => w(r.pubkey),
                                    children: [(0, e.jsx)(Gl, {name: "block"}), (0, e.jsx)(cl, {...Su.Block})]
                                }), (0, e.jsxs)(Wv, {
                                    onClick: () => async function () {
                                        const e = await fetch(`${li}/translate`, {
                                            method: "POST",
                                            body: JSON.stringify({
                                                q: r.content,
                                                source: "auto",
                                                target: O.split("-")[0]
                                            }),
                                            headers: {"Content-Type": "application/json"}
                                        });
                                        if (e.ok) {
                                            const t = await e.json();
                                            "function" == typeof n.onTranslated && t && n.onTranslated({
                                                text: t.translatedText,
                                                fromLanguage: B.of(t.detectedLanguage.language),
                                                confidence: t.detectedLanguage.confidence
                                            })
                                        }
                                    }(),
                                    children: [(0, e.jsx)(Gl, {name: "translate"}), (0, e.jsx)(cl, {
                                        ...Su.TranslateTo,
                                        values: {lang: B.of(O.split("-")[0])}
                                    })]
                                }), y.showDebugMenus && (0, e.jsxs)(Wv, {
                                    onClick: () => async function () {
                                        await navigator.clipboard.writeText(JSON.stringify(r, void 0, "  "))
                                    }(), children: [(0, e.jsx)(Gl, {name: "json"}), (0, e.jsx)(cl, {...Su.CopyJSON})]
                                }), D && (0, e.jsxs)(Wv, {
                                    onClick: () => async function () {
                                        if (window.confirm(d(Su.ConfirmDeletion, {id: r.id.substring(0, 8)})) && k) {
                                            const e = await k.delete(r.id);
                                            DS.BroadcastEvent(e)
                                        }
                                    }(),
                                    children: [(0, e.jsx)(Gl, {
                                        name: "trash",
                                        className: "red"
                                    }), (0, e.jsx)(cl, {...Su.Delete})]
                                })]
                            })
                        })]
                    }), L && (0, e.jsx)(Bb, {}), _ && (0, e.jsx)(lb, {}), (0, e.jsx)(hb, {
                        show: i,
                        setShow: s,
                        positive: a,
                        negative: o,
                        reposts: l,
                        zaps: c
                    }), (0, e.jsx)(Ed, {
                        lnurl: G(),
                        onClose: () => N(!1),
                        show: P,
                        author: null == x ? void 0 : x.pubkey,
                        target: function () {
                            var e;
                            const t = null === (e = r.tags.find((e => "zap" === e[0]))) || void 0 === e ? void 0 : e[1];
                            return t ? new ai.LNURL(t).name : (null == x ? void 0 : x.display_name) || (null == x ? void 0 : x.name)
                        }(),
                        note: r.id,
                        allocatePool: !0
                    })]
                }), (0, e.jsx)("div", {className: "zaps-container", children: (0, e.jsx)(fb, {zaps: c})})]
            })
        }

        const vb = 6e4, bb = 60 * vb, wb = 24 * bb;

        function xb(n) {
            const [r, i] = (0, t.useState)(), {from: s, fallback: a} = n,
                o = new Intl.DateTimeFormat(void 0, {dateStyle: "medium", timeStyle: "long"}).format(s),
                l = new Date(s).toISOString();

            function c() {
                const e = new Date(s), t = (new Date).getTime() - s, n = Math.abs(t);
                if (n > wb) return e.toLocaleDateString(void 0, {year: "2-digit", month: "short", day: "2-digit"});
                if (n > bb) return `${e.getHours().toString().padStart(2, "0")}:${e.getMinutes().toString().padStart(2, "0")}`;
                if (n < vb) return a;
                {
                    const e = Math.floor(n / vb);
                    return t < 0 ? `in ${e}m` : `${e}m`
                }
            }

            return (0, t.useEffect)((() => {
                i(c());
                const e = setInterval((() => {
                    i((e => {
                        const t = c();
                        return t !== e ? t : e
                    }))
                }), vb);
                return () => clearInterval(e)
            }), [s]), (0, e.jsx)("time", {dateTime: l, title: o, children: r})
        }

        function Eb(n) {
            const {formatMessage: r} = al(), i = hc(), {wallet: s} = (0, Wu.Os)(), {
                    preferences: a,
                    publicKey: o,
                    relays: l
                } = Qs(),
                c = (0, hl.useUserProfile)(DS, n.ev.pubkey), [u, d] = (0, t.useState)(""), [h, f] = (0, t.useState)(""), [p, m] = (0, t.useState)(),
                g = n.zaps.some((e => e.sender === o)), y = n.ev.pubkey === o, v = g || y,
                b = n.ev.tags.filter((e => "poll_option" === e[0])).sort(((e, t) => Number(e[1]) - Number(t[1]))),
                w = n.zaps.filter((e => void 0 !== e.pollOption)).reduce(((e, t) => e + t.amount), 0);
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)("small", {
                    children: (0, e.jsx)(cl, {
                        id: "3qnJlS",
                        defaultMessage: "You are voting with {amount} sats",
                        values: {amount: Hu(a.defaultZapAmount)}
                    })
                }), (0, e.jsxs)("div", {
                    className: "poll-body", children: [b.map((t => {
                        const o = Number(t[1]), u = t[2], h = n.zaps.filter((e => e.pollOption === o)),
                            g = h.reduce(((e, t) => e + t.amount), 0), y = 0 === w ? 0 : g / w;
                        return (0, e.jsxs)("div", {
                            className: "flex",
                            onClick: e => async function (e, t) {
                                if (e.stopPropagation(), p || !i) return;
                                const o = a.defaultZapAmount;
                                try {
                                    var u;
                                    if (o <= 0) throw new Error(r({
                                        id: "NepkXH",
                                        defaultMessage: "Can't vote with {amount} sats, please set a different default zap amount"
                                    }, {amount: o}));
                                    m(t);
                                    const e = Object.keys(l.item),
                                        a = await i.zap(1e3 * o, n.ev.pubkey, e, n.ev.id, void 0, (e => e.tag(["poll_option", t.toString()]))),
                                        d = (null === (u = n.ev.tags.find((e => "zap" === e[0]))) || void 0 === u ? void 0 : u[1]) || (null == c ? void 0 : c.lud16) || (null == c ? void 0 : c.lud06);
                                    if (!d) return;
                                    const h = new ai.LNURL(d);
                                    if (await h.load(), !h.canZap) throw new Error(r({
                                        id: "fOksnD",
                                        defaultMessage: "Can't vote because LNURL service does not support zaps"
                                    }));
                                    const p = await h.getInvoice(o, void 0, a);
                                    null != s && s.isReady() ? await (null == s ? void 0 : s.payInvoice((0, Ks.Wg)(p.pr))) : f((0, Ks.Wg)(p.pr))
                                } catch (e) {
                                    e instanceof Error ? d(e.message) : d(r({
                                        id: "g985Wp",
                                        defaultMessage: "Failed to send vote"
                                    }))
                                } finally {
                                    m(void 0)
                                }
                            }(e, o),
                            children: [(0, e.jsx)("div", {
                                className: "f-grow",
                                children: o === p ? (0, e.jsx)(Dd, {}) : (0, e.jsx)(uv, {
                                    content: u,
                                    tags: n.ev.tags,
                                    creator: n.ev.pubkey
                                })
                            }), v && (0, e.jsxs)(e.Fragment, {
                                children: [(0, e.jsxs)("div", {
                                    className: "flex",
                                    children: [(0, e.jsx)(yl, {
                                        value: 100 * y,
                                        maximumFractionDigits: 0
                                    }), "% ", (0, e.jsxs)("small", {children: ["(", Hu(g), ")"]})]
                                }), (0, e.jsx)("div", {style: {width: 100 * y + "%"}, className: "progress"})]
                            })]
                        }, t[1])
                    })), u && (0, e.jsx)("b", {className: "error", children: u})]
                }), (0, e.jsx)(Ed, {show: "" !== h, onClose: () => f(""), invoice: h})]
            })
        }

        function Sb(t) {
            let {ev: n} = t;
            const r = (0, Ks.MV)(n, "url"), i = (0, Ks.MV)(n, "x"), s = (0, Ks.MV)(n, "m"),
                a = (0, Ks.MV)(n, "blurhash"), o = (0, Ks.MV)(n, "magnet");
            return r && s ? (0, e.jsx)(sv, {
                message: (0, e.jsx)(cl, {
                    id: "lsNFM1",
                    defaultMessage: "Click to load content from {link}",
                    values: {link: r}
                }), children: (0, e.jsx)(Jy, {mime: s, url: r, sha256: i, magnet: o, blurHash: a})
            }) : (0, e.jsx)("b", {
                className: "error",
                children: (0, e.jsx)(cl, {
                    id: "PamNxw",
                    defaultMessage: "Unknown file header: {name}",
                    values: {name: n.content}
                })
            })
        }

        function kb(t) {
            var n, r, i, s, a;
            let {ev: o} = t;
            const l = o.tags.find((e => "media" === e[0])), c = o.tags.find((e => "cover" === e[0])),
                u = o.tags.find((e => "subject" === e[0])), d = o.tags.filter((e => "p" === e[0])),
                h = (0, Pt.encodeTLV)(Pt.NostrPrefix.Address, null !== (n = null === (r = o.tags.find((e => "d" === e[0]))) || void 0 === r ? void 0 : r[1]) && void 0 !== n ? n : "", void 0, o.kind, o.pubkey);
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsxs)("div", {
                    className: "flex zapstr mb10 card",
                    children: [(0, e.jsx)(Wd, {
                        src: null !== (i = null == c ? void 0 : c[1]) && void 0 !== i ? i : "",
                        size: 100
                    }), (0, e.jsxs)("div", {
                        className: "flex f-col",
                        children: [(0, e.jsx)("div", {children: (0, e.jsx)("h3", {children: null !== (s = null == u ? void 0 : u[1]) && void 0 !== s ? s : ""})}), (0, e.jsx)("audio", {
                            src: null !== (a = null == l ? void 0 : l[1]) && void 0 !== a ? a : "",
                            controls: !0
                        }), (0, e.jsx)("div", {
                            children: d.map((t => {
                                var n;
                                return (0, e.jsx)(Zl, {
                                    pubkey: t[1],
                                    subHeader: (0, e.jsx)(e.Fragment, {children: null !== (n = t[2]) && void 0 !== n ? n : ""}),
                                    className: "",
                                    defaultNip: " "
                                })
                            }))
                        })]
                    })]
                }), (0, e.jsx)(Rt, {
                    to: `https://zapstr.live/?track=${h}`,
                    target: "_blank",
                    children: (0, e.jsx)("button", {
                        children: (0, e.jsx)(cl, {
                            id: "Lu5/Bj",
                            defaultMessage: "Open on Zapstr"
                        })
                    })
                })]
            })
        }

        function Ab(t) {
            const n = (0, Ks.nm)(t.pubkey), r = hc(), {follows: i, relays: s} = Qs(), a = i.item.includes(n),
                o = `${t.className} follow-button`;
            return (0, e.jsx)(Vd, {
                className: a ? `${o} secondary` : o, onClick: () => a ? async function (e) {
                    if (r) {
                        const t = await r.contactList(i.item.filter((t => t !== e)), s.item);
                        DS.BroadcastEvent(t)
                    }
                }(n) : async function (e) {
                    if (r) {
                        const t = await r.contactList([e, ...i.item], s.item);
                        DS.BroadcastEvent(t)
                    }
                }(n), children: a ? (0, e.jsx)(cl, {...Su.Unfollow}) : (0, e.jsx)(cl, {...Su.Follow})
            })
        }

        function Tb(t) {
            var n;
            const r = t.pubkey, {ref: i, inView: s} = Fu({triggerOnce: !0}),
                a = (0, hl.useUserProfile)(DS, s ? r : void 0), o = {about: !0, ...t.options};
            return (0, e.jsx)(e.Fragment, {
                children: (0, e.jsx)("div", {
                    className: "profile-preview" + (t.className ? ` ${t.className}` : ""),
                    ref: i,
                    children: s && (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)(Zl, {
                            pubkey: r,
                            subHeader: o.about ? (0, e.jsx)("div", {
                                className: "about",
                                children: null == a ? void 0 : a.about
                            }) : void 0
                        }), null !== (n = t.actions) && void 0 !== n ? n : (0, e.jsx)("div", {
                            className: "follow-button-container",
                            children: (0, e.jsx)(Ab, {pubkey: r})
                        })]
                    })
                })
            })
        }

        function Cb(t) {
            let {pubkeys: n, title: r, showFollowAll: i, showAbout: s, className: a, actions: o} = t;
            const l = hc(), {follows: c, relays: u} = Qs();
            return (0, e.jsxs)("div", {
                className: a,
                children: [(null == i || i) && (0, e.jsxs)("div", {
                    className: "flex mt10 mb10",
                    children: [(0, e.jsx)("div", {
                        className: "f-grow bold",
                        children: r
                    }), o, (0, e.jsx)("button", {
                        className: "transparent",
                        type: "button",
                        onClick: () => async function () {
                            if (l) {
                                const e = await l.contactList([...n, ...c.item], u.item);
                                DS.BroadcastEvent(e)
                            }
                        }(),
                        children: (0, e.jsx)(cl, {...Su.FollowAll})
                    })]
                }), null == n ? void 0 : n.map((t => (0, e.jsx)(Tb, {pubkey: t, options: {about: s}}, t)))]
            })
        }

        function Rb(t) {
            var n;
            let {ev: r, className: i} = t;
            const s = (0, Wu.Os)(), a = Qs(), o = hc(),
                l = (0, Ks.D8)(r.tags.filter((e => "p" === e[0])).map((e => e[1])));
            return (0, e.jsx)(Cb, {
                pubkeys: l,
                showAbout: !0,
                className: i,
                title: null === (n = r.tags.find((e => "d" === e[0]))) || void 0 === n ? void 0 : n[1],
                actions: (0, e.jsx)(e.Fragment, {
                    children: (0, e.jsx)(Vd, {
                        className: "mr5 transparent",
                        onClick: () => async function () {
                            for (const n of l) try {
                                const i = await sc.get(n), l = a.preferences.defaultZapAmount,
                                    c = (null == i ? void 0 : i.lud16) || (null == i ? void 0 : i.lud06);
                                if (c) {
                                    const u = new ai.LNURL(c);
                                    await u.load();
                                    const d = await (null == o ? void 0 : o.zap(1e3 * l, n, Object.keys(a.relays.item), void 0, `Zap from ${(0, Ks.jm)("note", r.id)}`)),
                                        h = await u.getInvoice(l, void 0, d);
                                    if (h.pr) {
                                        var t;
                                        const r = await (null === (t = s.wallet) || void 0 === t ? void 0 : t.payInvoice(h.pr));
                                        (null == r ? void 0 : r.state) === Wu.kd.Paid && ad.push({
                                            element: (0, e.jsx)(cl, {
                                                id: "Ig9/a1",
                                                defaultMessage: "Sent {n} sats to {name}",
                                                values: {n: l, name: Xl(i, n)}
                                            }), icon: "zap"
                                        })
                                    }
                                }
                            } catch (e) {
                                console.debug("Failed to zap", n, e)
                            }
                        }(),
                        children: (0, e.jsx)(cl, {
                            id: "AGNz71",
                            defaultMessage: "Zap All {n} sats",
                            values: {n: (0, e.jsx)(yl, {value: a.preferences.defaultZapAmount * l.length})}
                        })
                    })
                })
            })
        }

        function Lb(t) {
            let {ev: n} = t;
            const r = (0, Ks.MV)(n, "title"), i = (0, Ks.Wg)((0, Ks.MV)(n, "d"));
            return (0, e.jsx)("div", {
                className: "text",
                children: (0, e.jsxs)("div", {
                    className: "flex card",
                    children: [(0, e.jsx)("div", {
                        className: "f-grow",
                        children: (0, e.jsx)("h3", {children: r})
                    }), (0, e.jsx)("div", {
                        children: (0, e.jsx)(Rt, {
                            to: `/live/${(0, Pt.encodeTLV)(Pt.NostrPrefix.Address, i, void 0, n.kind, n.pubkey)}`,
                            children: (0, e.jsx)("button", {
                                className: "primary",
                                type: "button",
                                children: (0, e.jsx)(cl, {id: "HF4YnO", defaultMessage: "Watch Live!"})
                            })
                        })
                    })]
                })
            })
        }

        const _b = n => {
            let {children: r} = n;
            const [i, s] = (0, t.useState)(!1);
            return i ? (0, e.jsx)(e.Fragment, {children: r}) : (0, e.jsx)("div", {
                className: "card note hidden-note",
                children: (0, e.jsxs)("div", {
                    className: "header",
                    children: [(0, e.jsx)("p", {children: (0, e.jsx)(cl, {...Su.MutedAuthor})}), (0, e.jsx)("button", {
                        onClick: () => s(!0),
                        children: (0, e.jsx)(cl, {...Su.Show})
                    })]
                })
            })
        };

        function Pb(n) {
            const {data: r, related: i, highlight: s, options: a, ignoreModeration: o = !1, className: l} = n;
            if (r.kind === Pt.EventKind.FileHeader) return (0, e.jsx)(Sb, {ev: r});
            if (r.kind === Pt.EventKind.ZapstrTrack) return (0, e.jsx)(kb, {ev: r});
            if (r.kind === Pt.EventKind.PubkeyLists) return (0, e.jsx)(Rb, {ev: r, className: l});
            if (r.kind === Pt.EventKind.LiveEvent) return (0, e.jsx)(Lb, {ev: r});
            const c = "note card" + (l ? ` ${l}` : ""), u = st(), [d, h] = (0, t.useState)(!1),
                f = (0, t.useMemo)((() => (0, Ks.Ym)(i, r.id, Pt.EventKind.Deletion)), [i]), {isMuted: p} = pc(),
                m = p(null == r ? void 0 : r.pubkey), {
                    ref: g,
                    inView: y,
                    entry: v
                } = Fu({triggerOnce: !0}), [b, w] = (0, t.useState)(!1), [x, E] = (0, t.useState)(!1), S = Qs(), {
                    pinned: k,
                    bookmarked: A
                } = S, T = hc(), [C, R] = (0, t.useState)(), {formatMessage: L} = al(),
                _ = (0, t.useMemo)((() => (0, Ks.Ym)(i, r.id, Pt.EventKind.Reaction)), [i, r]),
                P = (0, t.useMemo)((() => {
                    const e = null == _ ? void 0 : _.reduce(((e, t) => {
                        const n = (0, Ks.N2)(t.content), r = e[n] || [];
                        return {...e, [n]: [...r, t]}
                    }), {[Ks.le.Positive]: [], [Ks.le.Negative]: []});
                    return {
                        [Ks.le.Positive]: (0, Ks.iT)(e[Ks.le.Positive]),
                        [Ks.le.Negative]: (0, Ks.iT)(e[Ks.le.Negative])
                    }
                }), [_]), N = P[Ks.le.Positive], j = P[Ks.le.Negative],
                I = (0, t.useMemo)((() => (0, Ks.iT)([...(0, Ks.Ym)(i, r.id, Pt.EventKind.TextNote).filter((e => e.tags.some((0, Ks.JS)(e, r.id)))), ...(0, Ks.Ym)(i, r.id, Pt.EventKind.Repost)])), [i, r]),
                M = (0, t.useMemo)((() => {
                    const e = (0, Ks.Ym)(i, r.id, Pt.EventKind.ZapReceipt).map((e => (0, Pt.parseZap)(e, sc, r))).filter((e => e.valid));
                    return e.sort(((e, t) => t.amount - e.amount)), e
                }), [i]), D = N.length + j.length + I.length + M.length,
                O = {showHeader: !0, showTime: !0, showFooter: !0, canUnpin: !1, canUnbookmark: !1, ...a}, B = () => {
                    var t;
                    const i = null !== (t = null == r ? void 0 : r.content) && void 0 !== t ? t : "";
                    if ((null == f ? void 0 : f.length) > 0) return (0, e.jsx)("b", {
                        className: "error",
                        children: (0, e.jsx)(cl, {...Su.Deleted})
                    });
                    const s = r.tags.find((e => "content-warning" === e[0]));
                    return s ? (0, e.jsx)(sv, {
                        message: (0, e.jsxs)(e.Fragment, {
                            children: [(0, e.jsx)(cl, {
                                id: "x/q8d5",
                                defaultMessage: "This note has been marked as sensitive, click here to reveal"
                            }), s[1] && (0, e.jsxs)(e.Fragment, {
                                children: [(0, e.jsx)("br", {}), (0, e.jsx)(cl, {
                                    id: "KLo3SP",
                                    defaultMessage: "Reason: {reason}",
                                    values: {reason: s[1]}
                                })]
                            })]
                        }), children: (0, e.jsx)(uv, {content: i, tags: r.tags, creator: r.pubkey})
                    }) : (0, e.jsx)(uv, {content: i, tags: r.tags, creator: r.pubkey, depth: n.depth})
                };

            function F(e, t) {
                if (!(arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.target === e.currentTarget) || !1 === (null == a ? void 0 : a.canClick)) return;
                if (e.stopPropagation(), n.onClick) return void n.onClick(t);
                const i = (0, Ks.sC)(t.id, t.relays);
                e.metaKey ? window.open(i, "_blank") : u(i, {state: r})
            }

            function U() {
                var n, i, s, a, o, l, c, u;
                const d = Pt.EventExt.extractThread(r);
                if (void 0 === d) return;
                const h = null !== (n = null == d || null === (i = d.replyTo) || void 0 === i ? void 0 : i.value) && void 0 !== n ? n : null == d || null === (s = d.root) || void 0 === s ? void 0 : s.value,
                    f = null !== (a = null == d || null === (o = d.replyTo) || void 0 === o ? void 0 : o.relay) && void 0 !== a ? a : null === (l = d.root) || void 0 === l ? void 0 : l.relay,
                    p = [];
                for (const t of null !== (m = null == d ? void 0 : d.pubKeys) && void 0 !== m ? m : []) {
                    var m, g;
                    const n = sc.getFromCache(t), r = (0, Ks.jm)(Pt.NostrPrefix.PublicKey, t).substring(0, 12);
                    p.push({
                        pk: t,
                        name: null !== (g = null == n ? void 0 : n.name) && void 0 !== g ? g : r,
                        link: (0, e.jsx)(Rt, {to: (0, Ks._v)(t), children: null != n && n.name ? `@${n.name}` : r})
                    })
                }
                p.sort((e => e.name.startsWith(Pt.NostrPrefix.PublicKey) ? 1 : -1));
                const y = p.length - 2,
                    v = (n, r) => (0, e.jsxs)(t.Fragment, {children: [r > 0 && ", ", n.link]}, n.pk),
                    b = p.length > 2 ? null == p ? void 0 : p.slice(0, 2).map(v) : null == p ? void 0 : p.map(v),
                    w = p.length > 2 ? L(Su.Others, {n: y}) : "";
                return (0, e.jsxs)("div", {
                    className: "reply",
                    children: ["re:", (null !== (c = null == p ? void 0 : p.length) && void 0 !== c ? c : 0) > 0 ? (0, e.jsxs)(e.Fragment, {children: [b, " ", w]}) : h && (0, e.jsx)(Rt, {
                        to: (0, Ks.sC)(h, f),
                        children: null === (u = (0, Ks.jm)(Pt.NostrPrefix.Event, h)) || void 0 === u ? void 0 : u.substring(0, 12)
                    })]
                })
            }

            if ((0, t.useLayoutEffect)((() => {
                var e, t;
                v && y && !1 === b && ((null !== (e = null == v || null === (t = v.target) || void 0 === t ? void 0 : t.offsetHeight) && void 0 !== e ? e : 0) > 650 && w(!0))
            }), [y, v, b]), ![Pt.EventKind.TextNote, Pt.EventKind.Polls].includes(r.kind)) return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)("h4", {
                    children: (0, e.jsx)(cl, {
                        ...Su.UnknownEventKind,
                        values: {kind: r.kind}
                    })
                }), (0, e.jsx)("pre", {children: JSON.stringify(r, void 0, "  ")})]
            });

            function H() {
                if (r.kind === Pt.EventKind.Polls) return (0, e.jsx)(Eb, {ev: r, zaps: M})
            }

            const $ = (0, e.jsx)("div", {
                className: `${c}${s ? " active " : " "}${b && !x ? " note-expand" : ""}`,
                onClick: e => F(e, r),
                ref: g,
                children: function () {
                    var t;
                    if (y) return (0, e.jsxs)(e.Fragment, {
                        children: [O.showHeader && (0, e.jsxs)("div", {
                            className: "header flex",
                            children: [(0, e.jsx)(Zl, {
                                pubkey: r.pubkey,
                                subHeader: null !== (t = U()) && void 0 !== t ? t : void 0,
                                link: void 0 === (null == a ? void 0 : a.canClick) ? void 0 : ""
                            }), (O.showTime || O.showBookmarked) && (0, e.jsxs)("div", {
                                className: "info",
                                children: [O.showBookmarked && (0, e.jsxs)("div", {
                                    className: "saved " + (O.canUnbookmark ? "pointer" : ""),
                                    onClick: () => async function (e) {
                                        if (O.canUnbookmark && T && window.confirm(L(Su.ConfirmUnbookmark))) {
                                            const t = A.item.filter((t => t !== e)),
                                                n = await T.noteList(t, Pt.Lists.Bookmarked);
                                            DS.BroadcastEvent(n), Zs(S, t, 1e3 * n.created_at)
                                        }
                                    }(r.id),
                                    children: [(0, e.jsx)(Gl, {name: "bookmark"}), " ", (0, e.jsx)(cl, {...Su.Bookmarked})]
                                }), !O.showBookmarked && (0, e.jsx)(xb, {from: 1e3 * r.created_at})]
                            }), O.showPinned && (0, e.jsxs)("div", {
                                className: "pinned " + (O.canUnpin ? "pointer" : ""),
                                onClick: () => async function (e) {
                                    if (O.canUnpin && T && window.confirm(L(Su.ConfirmUnpin))) {
                                        const t = k.item.filter((t => t !== e)),
                                            n = await T.noteList(t, Pt.Lists.Pinned);
                                        DS.BroadcastEvent(n), Ys(S, t, 1e3 * n.created_at)
                                    }
                                }(r.id),
                                children: [(0, e.jsx)(Gl, {name: "pin"}), " ", (0, e.jsx)(cl, {...Su.Pinned})]
                            })]
                        }), (0, e.jsxs)("div", {
                            className: "body",
                            onClick: e => F(e, r, !0),
                            children: [B(), C && C.confidence > .5 ? (0, e.jsxs)(e.Fragment, {
                                children: [(0, e.jsx)("p", {
                                    className: "highlight",
                                    children: (0, e.jsx)(cl, {...Su.TranslatedFrom, values: {lang: C.fromLanguage}})
                                }), C.text]
                            }) : C ? (0, e.jsx)("p", {
                                className: "highlight",
                                children: (0, e.jsx)(cl, {...Su.TranslationFailed})
                            }) : void 0, H(), O.showReactionsLink && (0, e.jsx)("div", {
                                className: "reactions-link",
                                onClick: () => h(!0),
                                children: (0, e.jsx)(cl, {...Su.ReactionsLink, values: {n: D}})
                            })]
                        }), b && !x && (0, e.jsx)("span", {
                            className: "expand-note mt10 flex f-center",
                            onClick: () => E(!0),
                            children: (0, e.jsx)(cl, {...Su.ShowMore})
                        }), O.showFooter && (0, e.jsx)(yb, {
                            ev: r,
                            positive: N,
                            negative: j,
                            reposts: I,
                            zaps: M,
                            onTranslated: e => R(e),
                            showReactions: d,
                            setShowReactions: h
                        })]
                    })
                }()
            });
            return !o && m ? (0, e.jsx)(_b, {children: $}) : $
        }

        var Nb, jb;
        !function (e) {
            e[e.Supporter = 0] = "Supporter", e[e.Premium = 1] = "Premium"
        }(Nb || (Nb = {})), function (e) {
            e[e.MultiAccount = 1] = "MultiAccount", e[e.NostrAddress = 2] = "NostrAddress", e[e.Badge = 3] = "Badge", e[e.DeepL = 4] = "DeepL", e[e.RelayRetention = 5] = "RelayRetention", e[e.RelayBackup = 6] = "RelayBackup", e[e.RelayAccess = 7] = "RelayAccess", e[e.LNProxy = 8] = "LNProxy", e[e.EmailBridge = 9] = "EmailBridge"
        }(jb || (jb = {}));
        const Ib = [{
            id: Nb.Supporter,
            price: 5e3,
            disabled: !1,
            unlocks: [jb.MultiAccount, jb.NostrAddress, jb.Badge, jb.RelayAccess]
        }, {
            id: Nb.Premium,
            price: 2e4,
            disabled: !1,
            unlocks: [jb.DeepL, jb.RelayBackup, jb.RelayRetention, jb.LNProxy, jb.EmailBridge]
        }];

        function Mb(e) {
            const t = (0, Ks.oK)();
            return [...e].sort(((e, t) => t.type - e.type)).filter((e => e.start <= t && e.end > t))
        }

        function Db(e) {
            return Mb(e)[0]
        }

        function Ob(t) {
            let {note: n} = t;
            return (0, e.jsxs)("div", {
                className: "note-preview",
                children: [(0, e.jsx)(Zl, {pubkey: n.pubkey}), (0, e.jsxs)("div", {
                    className: "note-preview-body",
                    children: [n.content.slice(0, 136), n.content.length > 140 && "..."]
                })]
            })
        }

        function Bb() {
            const {formatMessage: n} = al(), r = hc(), i = Nu(), {
                    note: s,
                    zapForward: a,
                    sensitive: o,
                    pollOptions: l,
                    replyTo: c,
                    otherEvents: u,
                    preview: d,
                    active: h,
                    show: f,
                    showAdvanced: p,
                    selectedCustomRelays: m,
                    error: y
                } = g((e => e.noteCreator)), [v, b] = (0, t.useState)(!1), w = S(), x = Db(Xs.allSubscriptions()),
                E = Qs().relays;

            async function k() {
                if (s && r) {
                    let i;
                    if (a) try {
                        const e = new ai.LNURL(a);
                        await e.load(), i = [e.getZapTag()]
                    } catch {
                        return void w(Uo(n({id: "0jOEtS", defaultMessage: "Invalid LNURL"})))
                    }
                    var e;
                    o && (null !== (e = i) && void 0 !== e || (i = []), i.push(["content-warning", o]));
                    const d = l ? Pt.EventKind.Polls : Pt.EventKind.TextNote;
                    var t;
                    l && (null !== (t = i) && void 0 !== t || (i = []), i.push(...l.map(((e, t) => ["poll_option", t.toString(), e]))));
                    const h = e => {
                        var t;
                        return null === (t = i) || void 0 === t || t.forEach((t => e.tag(t))), e.kind(d), e
                    }, f = c ? await r.reply(c, s, h) : await r.note(s, h);
                    m ? m.forEach((e => DS.WriteOnceToRelay(e, f))) : DS.BroadcastEvent(f), w(Zo());
                    for (const e of u) m ? m.forEach((t => DS.WriteOnceToRelay(t, e))) : DS.BroadcastEvent(e);
                    w(Zo())
                }
            }

            async function A(e) {
                b(!0);
                try {
                    if (e) {
                        const t = await i.upload(e, e.name);
                        if (t.header) {
                            const e = `nostr:${(0, Pt.encodeTLV)(Pt.NostrPrefix.Event, t.header.id, void 0, t.header.kind)}`;
                            w(Fo(`${s ? `${s}\n` : ""}${e}`)), w(Yo([...u, t.header]))
                        } else t.url ? w(Fo(`${s ? `${s}\n` : ""}${t.url}`)) : null != t && t.error && w(Uo(t.error))
                    }
                } catch (e) {
                    e instanceof Error && w(Uo(null == e ? void 0 : e.message))
                } finally {
                    b(!1)
                }
            }

            return (0, e.jsx)(e.Fragment, {
                children: f && (0, e.jsxs)(Cu, {
                    className: "note-creator-modal",
                    onClose: () => w(Bo(!1)),
                    children: [c && (0, e.jsx)(Ob, {note: c}), d && function () {
                        if (d) return (0, e.jsx)(Pb, {data: d, related: [], options: {showFooter: !1, canClick: !1}})
                    }(), !d && (0, e.jsxs)("div", {
                        onPaste: e => {
                            if (e.clipboardData) {
                                const t = e.clipboardData.items, n = Array.from(t).filter((function (e) {
                                    return /^image\//.test(e.type)
                                }));
                                if (0 === n.length) return;
                                const r = n[0].getAsFile();
                                r && A(r)
                            }
                        },
                        className: `flex note-creator${c ? " note-reply" : ""}${l ? " poll" : ""}`,
                        children: [(0, e.jsxs)("div", {
                            className: "flex f-col f-grow",
                            children: [(0, e.jsx)(Tu, {
                                autoFocus: !0,
                                className: "textarea " + (h ? "textarea--focused" : ""),
                                onChange: function (e) {
                                    const {value: t} = e.target;
                                    w(Fo(t)), w(Ho(!!t))
                                },
                                value: s,
                                onFocus: () => w(Ho(!0)),
                                onKeyDown: e => {
                                    "Enter" === e.key && e.metaKey && k().catch(console.warn)
                                }
                            }), function () {
                                if (l) return (0, e.jsxs)(e.Fragment, {
                                    children: [(0, e.jsx)("h4", {
                                        children: (0, e.jsx)(cl, {
                                            id: "vhlWFg",
                                            defaultMessage: "Poll Options"
                                        })
                                    }), null == l ? void 0 : l.map(((t, n) => (0, e.jsxs)("div", {
                                        className: "form-group w-max",
                                        children: [(0, e.jsx)("div", {
                                            children: (0, e.jsx)(cl, {
                                                id: "mfe8RW",
                                                defaultMessage: "Option: {n}",
                                                values: {n: n + 1}
                                            })
                                        }), (0, e.jsxs)("div", {
                                            children: [(0, e.jsx)("input", {
                                                type: "text",
                                                value: t,
                                                onChange: e => function (e, t) {
                                                    if (l) {
                                                        const n = [...l];
                                                        n[e] = t, w(Vo(n))
                                                    }
                                                }(n, e.target.value)
                                            }), n > 1 && (0, e.jsx)("button", {
                                                onClick: () => function (e) {
                                                    if (l) {
                                                        const t = [...l];
                                                        t.splice(e, 1), w(Vo(t))
                                                    }
                                                }(n),
                                                className: "ml5",
                                                children: (0, e.jsx)(Gl, {name: "close", size: 14})
                                            })]
                                        })]
                                    }, `po-${n}`))), (0, e.jsx)("button", {
                                        onClick: () => w(Vo([...l, ""])),
                                        children: (0, e.jsx)(Gl, {name: "plus", size: 14})
                                    })]
                                })
                            }(), (0, e.jsxs)("div", {
                                className: "insert",
                                children: [x && (0, e.jsx)(rb, {
                                    menuButton: (0, e.jsx)("button", {children: (0, e.jsx)(Gl, {name: "code-circle"})}),
                                    menuClassName: "ctx-menu",
                                    children: Xs.getSessions().map((t => (0, e.jsx)(Wv, {
                                        onClick: e => {
                                            e.stopPropagation = !0, Xs.switchAccount(t)
                                        }, children: (0, e.jsx)(Zl, {pubkey: t, link: ""})
                                    })))
                                }), void 0 === l && !c && (0, e.jsx)("button", {
                                    onClick: () => w(Vo(["A", "B"])),
                                    children: (0, e.jsx)(Gl, {name: "pie-chart"})
                                }), (0, e.jsx)("button", {
                                    onClick: async function () {
                                        try {
                                            const e = await (0, Ks.ZB)();
                                            e && A(e)
                                        } catch (e) {
                                            e instanceof Error && w(Uo(null == e ? void 0 : e.message))
                                        }
                                    }, children: (0, e.jsx)(Gl, {name: "attachment"})
                                })]
                            })]
                        }), y && (0, e.jsx)("span", {className: "error", children: y})]
                    }), (0, e.jsxs)("div", {
                        className: "note-creator-actions",
                        children: [v && (0, e.jsx)(Dd, {}), (0, e.jsx)("button", {
                            className: "secondary",
                            onClick: () => w(zo(!p)),
                            children: (0, e.jsx)(cl, {id: "3Rx6Qo", defaultMessage: "Advanced"})
                        }), (0, e.jsx)("button", {
                            className: "secondary", onClick: function () {
                                w(Zo())
                            }, children: (0, e.jsx)(cl, {...Su.Cancel})
                        }), (0, e.jsx)("button", {
                            onClick: function (e) {
                                e.stopPropagation(), k().catch(console.warn)
                            }, children: c ? (0, e.jsx)(cl, {...Su.Reply}) : (0, e.jsx)(cl, {...Su.Send})
                        })]
                    }), p && (0, e.jsxs)("div", {
                        children: [(0, e.jsx)("button", {
                            className: "secondary", onClick: async function () {
                                if (d) w($o(void 0)); else if (r) {
                                    const e = await r.note(s);
                                    e && w($o(e))
                                }
                            }, children: (0, e.jsx)(cl, {id: "1iQ8GN", defaultMessage: "Toggle Preview"})
                        }), (0, e.jsx)("h4", {
                            children: (0, e.jsx)(cl, {
                                id: "EcZF24",
                                defaultMessage: "Custom Relays"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "th5lxp",
                                defaultMessage: "Send note to a subset of your write relays"
                            })
                        }), (0, e.jsx)("div", {
                            children: Object.keys(E.item || {}).filter((e => E.item[e].write)).map(((t, n, r) => (0, e.jsxs)("div", {
                                className: "card flex",
                                children: [(0, e.jsx)("div", {
                                    className: "flex f-col f-grow",
                                    children: (0, e.jsx)("div", {children: t})
                                }), (0, e.jsx)("div", {
                                    children: (0, e.jsx)("input", {
                                        type: "checkbox",
                                        checked: !m || m.includes(t),
                                        onChange: e => w(Go((!e.target.checked || !m || m.length != r.length - 1) && r.filter((n => n === t ? e.target.checked : !m || m.includes(n)))))
                                    })
                                })]
                            })))
                        }), (0, e.jsx)("h4", {
                            children: (0, e.jsx)(cl, {
                                id: "R1fEdZ",
                                defaultMessage: "Forward Zaps"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "P04gQm",
                                defaultMessage: "All zaps sent to this note will be received by the following LNURL"
                            })
                        }), (0, e.jsx)("b", {
                            className: "warning",
                            children: (0, e.jsx)(cl, {id: "gXgY3+", defaultMessage: "Not all clients support this yet"})
                        }), (0, e.jsx)("input", {
                            type: "text",
                            className: "w-max",
                            placeholder: n({id: "FP+D3H", defaultMessage: "LNURL to forward zaps to"}),
                            value: a,
                            onChange: e => w(qo(e.target.value))
                        }), (0, e.jsx)("h4", {
                            children: (0, e.jsx)(cl, {
                                id: "bQdA2k",
                                defaultMessage: "Sensitive Content"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "UUPFlt",
                                defaultMessage: "Users must accept the content warning to show the content of your note."
                            })
                        }), (0, e.jsx)("b", {
                            className: "warning",
                            children: (0, e.jsx)(cl, {id: "gXgY3+", defaultMessage: "Not all clients support this yet"})
                        }), (0, e.jsx)("div", {
                            className: "flex",
                            children: (0, e.jsx)("input", {
                                className: "w-max",
                                type: "text",
                                value: o,
                                onChange: e => w(Wo(e.target.value)),
                                maxLength: 50,
                                minLength: 1,
                                placeholder: n({id: "AkCxS/", defaultMessage: "Reason"})
                            })
                        })]
                    })]
                })
            })
        }

        class Fb {
            constructor(e) {
                this.url = e
            }

            async GetConfig() {
                return await this.getJson("/config.json")
            }

            async CheckAvailable(e, t) {
                return await this.getJson("/registration/availability", "POST", {name: e, domain: t})
            }

            async RegisterHandle(e, t, n) {
                return await this.getJson("/registration/register", "PUT", {name: e, domain: t, pk: n, ref: "snort"})
            }

            async CheckRegistration(e) {
                return await this.getJson("/registration/register/check", "POST", void 0, {authorization: e})
            }

            async getJson(e, t, n, r) {
                try {
                    const i = await fetch(`${this.url}${e}`, {
                        method: t,
                        body: n ? JSON.stringify(n) : void 0,
                        headers: {accept: "application/json", ...n ? {"content-type": "application/json"} : {}, ...r}
                    });
                    return await i.json()
                } catch (e) {
                    console.warn(e)
                }
                return {error: "UNKNOWN_ERROR", errors: []}
            }
        }

        var Ub, Hb;
        !function (e) {
            e[e.Redirect = 0] = "Redirect", e[e.ProxyDirect = 1] = "ProxyDirect", e[e.ProxyTrusted = 2] = "ProxyTrusted"
        }(Hb || (Hb = {}));

        class $b extends Fb {
            constructor(e, t) {
                super(t), Ub.set(this, void 0), function (e, t, n, r, i) {
                    if ("m" === r) throw new TypeError("Private method is not writable");
                    if ("a" === r && !i) throw new TypeError("Private accessor was defined without a setter");
                    if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                    "a" === r ? i.call(e, n) : i ? i.value = n : t.set(e, n)
                }(this, Ub, e, "f")
            }

            async list() {
                return this.getJsonAuthd("/list", "GET")
            }

            async transfer(e, t) {
                return this.getJsonAuthd(`/${e}/transfer?to=${t}`, "PATCH")
            }

            async patch(e, t) {
                return this.getJsonAuthd(`/${e}`, "PATCH", t)
            }

            async registerForSubscription(e, t, n) {
                return this.getJsonAuthd(`/registration/register/${n}`, "PUT", {
                    name: e,
                    domain: t,
                    pk: "",
                    ref: "snort"
                })
            }

            async getJsonAuthd(e, t, n, r) {
                const i = await function (e, t, n, r) {
                    if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                    if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                    return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
                }(this, Ub, "f").generic((n => (n.kind(Pt.EventKind.HttpAuthentication), n.tag(["url", `${this.url}${e}`]), n.tag(["method", null != t ? t : "GET"]), n)));
                return i ? this.getJson(e, t, n, {
                    ...r,
                    authorization: `Nostr ${window.btoa(JSON.stringify(i))}`
                }) : {error: "INVALID_TOKEN"}
            }
        }

        function Kb(n) {
            var r, i;
            const s = st(), {helpText: a = !0} = n, {formatMessage: o} = al(), l = Qs().publicKey,
                c = (0, hl.useUserProfile)(DS, l), u = hc(),
                d = (0, t.useMemo)((() => new Fb(n.service)), [n.service]), [h, f] = (0, t.useState)(), [p, m] = (0, t.useState)(), [g, y] = (0, t.useState)(""), [v, b] = (0, t.useState)(""), [w, x] = (0, t.useState)(!1), [E, S] = (0, t.useState)(), [k, A] = (0, t.useState)(), [T, C] = (0, t.useState)(!1), [R, L] = (0, t.useState)(),
                _ = (0, t.useMemo)((() => null == h ? void 0 : h.domains.find((e => e.name === v))), [v, h]);
            return (0, t.useEffect)((() => {
                d.GetConfig().then((e => {
                    if ("error" in e) m(e); else {
                        var t;
                        const n = e;
                        f(n);
                        const r = (null === (t = n.domains.find((e => e.default))) || void 0 === t ? void 0 : t.name) || n.domains[0].name;
                        b(r)
                    }
                })).catch(console.error)
            }), [n, d]), (0, t.useEffect)((() => {
                var e, t, n, r;
                if (m(void 0), S(void 0), g && v) return g.length < (null !== (e = null == _ ? void 0 : _.length[0]) && void 0 !== e ? e : 2) ? void S({
                    available: !1,
                    why: "TOO_SHORT"
                }) : g.length > (null !== (t = null == _ ? void 0 : _.length[1]) && void 0 !== t ? t : 20) ? void S({
                    available: !1,
                    why: "TOO_LONG"
                }) : new RegExp(null !== (n = null == _ ? void 0 : _.regex[0]) && void 0 !== n ? n : "", null !== (r = null == _ ? void 0 : _.regex[1]) && void 0 !== r ? r : "").test(g) ? (0, Ks.Ds)(500, (() => {
                    d.CheckAvailable(g, v).then((e => {
                        "error" in e ? m(e) : S(e)
                    })).catch(console.error)
                })) : void S({available: !1, why: "REGEX"})
            }), [g, v, _, d]), (0, t.useEffect)((() => {
                if (k && T && !w) {
                    const e = setInterval((() => {
                        w || (x(!0), async function (e) {
                            const t = await d.CheckRegistration(e.token);
                            if ("error" in t) m(t), A(void 0), C(!1); else {
                                const e = t;
                                e.paid && (e.available ? m(void 0) : m({error: "REGISTERED"}), C(!1), L(t), A(void 0))
                            }
                        }(k).then((() => x(!1))).catch((e => {
                            console.error(e), x(!1)
                        })))
                    }), 2e3);
                    return () => clearInterval(e)
                }
            }), [k, T, d, w]), (0, e.jsxs)(e.Fragment, {
                children: [a && (0, e.jsx)("h3", {children: n.name}), a && n.about, a && (0, e.jsx)("p", {
                    children: (0, e.jsx)(cl, {
                        ...Su.FindMore,
                        values: {
                            service: n.name,
                            link: (0, e.jsx)("a", {href: n.link, target: "_blank", rel: "noreferrer", children: n.link})
                        }
                    })
                }), p && (0, e.jsx)("b", {
                    className: "error",
                    children: p.error
                }), !R && (0, e.jsxs)("div", {
                    className: "flex mb10",
                    children: [(0, e.jsx)("input", {
                        type: "text",
                        className: "nip-handle",
                        placeholder: o(Su.Handle),
                        value: g,
                        onChange: e => {
                            const t = e.target.value.toLowerCase();
                            y(t), n.onChange && n.onChange(`${t}@${v}`)
                        }
                    }), "@", (0, e.jsx)("select", {
                        value: v,
                        onChange: e => {
                            const t = e.target.value;
                            b(t), n.onChange && n.onChange(`${g}@${t}`)
                        },
                        children: null == h ? void 0 : h.domains.map((t => (0, e.jsx)("option", {children: t.name}, t.name)))
                    })]
                }), (null == E ? void 0 : E.available) && !R && (0, e.jsxs)("div", {
                    className: "flex",
                    children: [!n.forSubscription && (0, e.jsxs)("div", {
                        className: "mr10",
                        children: [(0, e.jsx)(cl, {
                            ...Su.Sats,
                            values: {n: Hu((0, Ks.Wg)(null === (r = E.quote) || void 0 === r ? void 0 : r.price))}
                        }), (0, e.jsx)("br", {}), (0, e.jsx)("small", {children: null === (i = E.quote) || void 0 === i ? void 0 : i.data.type})]
                    }), (0, e.jsx)(Vd, {
                        onClick: () => n.forSubscription ? async function (e, t, r) {
                            if (!l || !u) return;
                            const i = new $b(u, n.service), s = await i.registerForSubscription(e, t, r);
                            if ("error" in s) m(s); else if (n.onSuccess) {
                                const r = `${e}@${t}`;
                                n.onSuccess(r)
                            }
                        }(g, v, n.forSubscription) : async function (e, t) {
                            if (!l) return;
                            const n = await d.RegisterHandle(e, t, l);
                            "error" in n ? m(n) : (A(n), C(!0))
                        }(g, v),
                        children: n.forSubscription ? (0, e.jsx)(cl, {
                            id: "FdhSU2",
                            defaultMessage: "Claim Now"
                        }) : (0, e.jsx)(cl, {...Su.BuyNow})
                    })]
                }), !1 === (null == E ? void 0 : E.available) && !R && (0, e.jsx)("div", {
                    className: "flex",
                    children: (0, e.jsxs)("b", {
                        className: "error",
                        children: [(0, e.jsx)(cl, {...Su.NotAvailable}), " ", function (e, t) {
                            if (void 0 !== e) return new Map([["TOO_SHORT", o(Su.TooShort)], ["TOO_LONG", o(Su.TooLong)], ["REGEX", o(Su.Regex)], ["REGISTERED", o(Su.Registered)], ["DISALLOWED_null", o(Su.Disallowed)], ["DISALLOWED_later", o(Su.DisalledLater)]]).get("DISALLOWED" === e ? `${e}_${t}` : e)
                        }(E.why, E.reasonTag || null)]
                    })
                }), (0, e.jsx)(Ed, {
                    invoice: null == k ? void 0 : k.invoice,
                    show: T,
                    onClose: () => C(!1),
                    title: o(Su.Buying, {item: `${g}@${v}`})
                }), (null == R ? void 0 : R.paid) && (0, e.jsxs)("div", {
                    className: "flex f-col",
                    children: [(0, e.jsx)("h4", {children: (0, e.jsx)(cl, {...Su.OrderPaid})}), (0, e.jsxs)("p", {children: [(0, e.jsx)(cl, {...Su.NewNip}), " ", (0, e.jsxs)("code", {children: [g, "@", v]})]}), (0, e.jsx)("h3", {children: (0, e.jsx)(cl, {...Su.AccountSupport})}), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...Su.SavePassword})}), (0, e.jsx)(qu, {text: R.password}), (0, e.jsxs)("p", {
                        children: [(0, e.jsx)(cl, {...Su.GoTo}), " ", (0, e.jsx)("a", {
                            href: n.supportLink,
                            target: "_blank",
                            rel: "noreferrer",
                            children: (0, e.jsx)(cl, {...Su.AccountPage})
                        })]
                    }), (0, e.jsx)("h4", {children: (0, e.jsx)(cl, {...Su.ActivateNow})}), (0, e.jsx)(Vd, {
                        onClick: () => async function (e, t) {
                            if (c && u) {
                                const r = `${e}@${t}`, i = {...c, nip05: r}, o = await u.metadata(i);
                                DS.BroadcastEvent(o), n.onSuccess && n.onSuccess(r);
                                const l = (0, Pt.mapEventToProfile)(o);
                                l && sc.set(l), a && s("/settings")
                            }
                        }(g, v), children: (0, e.jsx)(cl, {...Su.AddToProfile})
                    })]
                })]
            })
        }

        Ub = new WeakMap;
        const zb = {
            name: "Snort",
            service: `${oi}/api/v1/n5sp`,
            link: "https://snort.social/",
            supportLink: "https://snort.social/help",
            about: (0, e.jsx)(cl, {...Ul})
        }, Gb = [zb, {
            name: "Nostr Plebs",
            service: "https://nostrplebs.com/api/v1",
            link: "https://nostrplebs.com/",
            supportLink: "https://nostrplebs.com/manage",
            about: (0, e.jsx)(cl, {...Hl})
        }];

        function qb(n) {
            let {sub: r} = n;
            const i = hc(), {formatMessage: s} = al(), a = new Date(1e3 * r.created), o = new Date(1e3 * r.expires),
                l = new Date, c = Math.floor((o.getTime() - l.getTime()) / 864e5),
                u = Math.floor((o.getTime() - l.getTime()) / 36e5), d = "expired" === r.state, h = "new" === r.state,
                f = "paid" === r.state, [p, m] = (0, t.useState)(""), [g, y] = (0, t.useState)();
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsxs)("div", {
                    className: "card",
                    children: [(0, e.jsxs)("div", {
                        className: "flex card-title",
                        children: [(0, e.jsx)(Gl, {name: "badge", className: "mr5", size: 25}), Wb(r.type)]
                    }), (0, e.jsxs)("div", {
                        className: "flex",
                        children: [(0, e.jsxs)("p", {
                            className: "f-1",
                            children: [(0, e.jsx)(cl, {
                                id: "ORGv1Q",
                                defaultMessage: "Created"
                            }), ":", (0, e.jsx)("time", {
                                dateTime: a.toISOString(),
                                children: (0, e.jsx)(gl, {value: a, dateStyle: "full"})
                            })]
                        }), c >= 1 && (0, e.jsxs)("p", {
                            className: "f-1",
                            children: [(0, e.jsx)(cl, {
                                id: "xhQMeQ",
                                defaultMessage: "Expires"
                            }), ":", (0, e.jsx)("time", {
                                dateTime: o.toISOString(),
                                children: (0, e.jsx)(cl, {
                                    id: "rmdsT4",
                                    defaultMessage: "{n} days",
                                    values: {n: (0, e.jsx)(yl, {value: c, maximumFractionDigits: 0})}
                                })
                            })]
                        }), c >= 0 && c < 1 && (0, e.jsxs)("p", {
                            className: "f-1",
                            children: [(0, e.jsx)(cl, {
                                id: "xhQMeQ",
                                defaultMessage: "Expires"
                            }), ":", (0, e.jsx)("time", {
                                dateTime: o.toISOString(),
                                children: (0, e.jsx)(cl, {
                                    id: "2ukA4d",
                                    defaultMessage: "{n} hours",
                                    values: {n: (0, e.jsx)(yl, {value: u, maximumFractionDigits: 0})}
                                })
                            })]
                        }), d && (0, e.jsx)("p", {
                            className: "f-1 error",
                            children: (0, e.jsx)(cl, {id: "RahCRH", defaultMessage: "Expired"})
                        }), h && (0, e.jsx)("p", {
                            className: "f-1",
                            children: (0, e.jsx)(cl, {id: "6uMqL1", defaultMessage: "Unpaid"})
                        })]
                    }), (d || h) && (0, e.jsx)("div", {
                        className: "flex",
                        children: (0, e.jsx)(Vd, {
                            onClick: () => async function (e) {
                                const t = new qd(void 0, i);
                                try {
                                    const n = await t.renewSubscription(e);
                                    m(n.pr)
                                } catch (e) {
                                    e instanceof Gd && y(e)
                                }
                            }(r.id),
                            children: d ? (0, e.jsx)(cl, {
                                id: "nWQFic",
                                defaultMessage: "Renew"
                            }) : (0, e.jsx)(cl, {id: "Ss0sWu", defaultMessage: "Pay Now"})
                        })
                    }), f && (0, e.jsxs)(e.Fragment, {
                        children: [!r.handle && (0, e.jsxs)(e.Fragment, {
                            children: [(0, e.jsx)("h3", {
                                children: (0, e.jsx)(cl, {
                                    id: "GUlSVG",
                                    defaultMessage: "Claim your included Snort nostr address"
                                })
                            }), (0, e.jsx)(Kb, {
                                ...zb,
                                helpText: !1,
                                forSubscription: r.id,
                                onSuccess: e => r.handle = e
                            })]
                        }), r.handle && (0, e.jsx)(Yl, {nip05: r.handle, pubkey: "", verifyNip: !1})]
                    })]
                }), (0, e.jsx)(Ed, {
                    invoice: p,
                    show: "" !== p,
                    onClose: () => m(""),
                    title: s({id: "Mrpkot", defaultMessage: "Pay for subscription"})
                }), g && (0, e.jsx)("b", {className: "error", children: Yb(g)})]
            })
        }

        function Wb(t) {
            switch (t) {
                case Nb.Supporter:
                    return (0, e.jsx)(cl, {id: "DcL8P+", defaultMessage: "Supporter"});
                case Nb.Premium:
                    return (0, e.jsx)(cl, {id: "C5xzTC", defaultMessage: "Premium"})
            }
        }

        function Vb(t) {
            switch (t) {
                case jb.MultiAccount:
                    return (0, e.jsx)(cl, {id: "cuP16y", defaultMessage: "Multi account support"});
                case jb.NostrAddress:
                    return (0, e.jsx)(cl, {id: "lPWASz", defaultMessage: "Snort nostr address"});
                case jb.Badge:
                    return (0, e.jsx)(cl, {id: "ttxS0b", defaultMessage: "Supporter Badge"});
                case jb.DeepL:
                    return (0, e.jsx)(cl, {id: "iEoXYx", defaultMessage: "DeepL translations"});
                case jb.RelayRetention:
                    return (0, e.jsx)(cl, {id: "Ai8VHU", defaultMessage: "Unlimited note retention on Snort relay"});
                case jb.RelayBackup:
                    return (0, e.jsx)(cl, {id: "pI+77w", defaultMessage: "Downloadable backups from Snort relay"});
                case jb.RelayAccess:
                    return (0, e.jsx)(cl, {
                        id: "BGCM48",
                        defaultMessage: "Write access to Snort relay, with 1 year of event retention"
                    });
                case jb.LNProxy:
                    return (0, e.jsx)(cl, {id: "SYQtZ7", defaultMessage: "LN Address Proxy"});
                case jb.EmailBridge:
                    return (0, e.jsx)(cl, {
                        id: "qD9EUF",
                        defaultMessage: "Email <> DM bridge for your Snort nostr address"
                    })
            }
        }

        function Yb(t) {
            switch (t.code) {
                case $d.InternalError:
                    return (0, e.jsx)(cl, {
                        id: "jMzO1S",
                        defaultMessage: "Internal error: {msg}",
                        values: {msg: t.message}
                    });
                case $d.SubscriptionActive:
                    return (0, e.jsx)(cl, {
                        id: "OQXnew",
                        defaultMessage: "You subscription is still active, you can't renew yet"
                    });
                case $d.Duplicate:
                    return (0, e.jsx)(cl, {
                        id: "NAuFNH",
                        defaultMessage: "You already have a subscription of this type, please renew or pay"
                    });
                default:
                    return t.message
            }
        }

        const Zb = [{
            path: "/subscribe", element: (0, e.jsx)((function () {
                const n = hc(), r = new qd(void 0, n), [i, s] = (0, t.useState)(""), [a, o] = (0, t.useState)();
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("div", {
                        className: "flex subscribe-page", children: Ib.map((t => {
                            const n = Ib.filter((e => e.id < t.id));
                            return (0, e.jsxs)("div", {
                                className: "card flex f-col" + (t.disabled ? " disabled" : ""),
                                children: [(0, e.jsxs)("div", {
                                    className: "f-grow",
                                    children: [(0, e.jsx)("h2", {children: Wb(t.id)}), (0, e.jsxs)("p", {
                                        children: [(0, e.jsx)(cl, {
                                            id: "Z0FDj+",
                                            defaultMessage: "Subscribe to Snort {plan} for {price} and receive the following rewards",
                                            values: {
                                                plan: Wb(t.id),
                                                price: (0, e.jsxs)("b", {children: [Hu(t.price), " sats/mo"]})
                                            }
                                        }), ":"]
                                    }), (0, e.jsxs)("ul", {
                                        children: [t.unlocks.map((t => (0, e.jsxs)("li", {children: [Vb(t), " "]}))), n.map((t => (0, e.jsx)("li", {
                                            children: (0, e.jsx)(cl, {
                                                id: "l+ikU1",
                                                defaultMessage: "Everything in {plan}",
                                                values: {plan: Wb(t.id)}
                                            })
                                        })))]
                                    })]
                                }), (0, e.jsx)("div", {
                                    className: "flex f-center w-max mb10",
                                    children: (0, e.jsx)(Vd, {
                                        className: "button",
                                        disabled: t.disabled,
                                        onClick: () => async function (e) {
                                            o(void 0);
                                            try {
                                                const t = await r.createSubscription(e);
                                                s(t.pr)
                                            } catch (e) {
                                                e instanceof Gd && o(e)
                                            }
                                        }(t.id),
                                        children: t.disabled ? (0, e.jsx)(cl, {
                                            id: "e61Jf3",
                                            defaultMessage: "Coming soon"
                                        }) : (0, e.jsx)(cl, {id: "gczcC5", defaultMessage: "Subscribe"})
                                    })
                                })]
                            })
                        }))
                    }), a && (0, e.jsx)("b", {className: "error", children: Yb(a)}), (0, e.jsx)(Ed, {
                        invoice: i,
                        show: "" !== i,
                        onClose: () => s("")
                    })]
                })
            }), {})
        }, {
            path: "/subscribe/manage", element: (0, e.jsx)((function () {
                const n = hc(), r = new qd(void 0, n), i = st(), [s, a] = (0, t.useState)(), [o, l] = (0, t.useState)();
                return (0, t.useEffect)((() => {
                    (async () => {
                        try {
                            const e = await r.listSubscriptions();
                            a(e)
                        } catch (e) {
                            e instanceof Gd && l(e)
                        }
                    })()
                }), []), void 0 === s ? (0, e.jsx)(Yd, {}) : (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("h2", {
                        children: (0, e.jsx)(cl, {
                            id: "J+dIsA",
                            defaultMessage: "Subscriptions"
                        })
                    }), s.map((t => (0, e.jsx)(qb, {sub: t}, t.id))), 0 !== s.length && (0, e.jsx)("button", {
                        onClick: () => i("/subscribe"),
                        children: (0, e.jsx)(cl, {id: "SP0+yi", defaultMessage: "Buy Subscription"})
                    }), 0 === s.length && (0, e.jsx)("p", {
                        children: (0, e.jsx)(cl, {
                            id: "W1yoZY",
                            defaultMessage: "It looks like you dont have any subscriptions, you can get one {link}",
                            values: {
                                link: (0, e.jsx)(Rt, {
                                    to: "/subscribe",
                                    children: (0, e.jsx)(cl, {id: "hniz8Z", defaultMessage: "here"})
                                })
                            }
                        })
                    }), o && (0, e.jsx)("b", {className: "error", children: Yb(o)})]
                })
            }), {})
        }], Xb = () => {
            const n = st(), {publicKey: r, latestNotification: i, readNotifications: s} = Qs(),
                a = (0, hl.useUserProfile)(DS, r), o = (0, t.useMemo)((() => i > s), [i, s]),
                l = (0, t.useMemo)((() => 0), [r]);
            return (0, e.jsxs)("div", {
                className: "header-actions",
                children: [(0, e.jsx)("div", {
                    className: "btn btn-rnd",
                    onClick: () => n("/wallet"),
                    children: (0, e.jsx)(Gl, {name: "wallet"})
                }), (0, e.jsx)("div", {
                    className: "btn btn-rnd",
                    onClick: () => n("/search"),
                    children: (0, e.jsx)(Gl, {name: "search"})
                }), (0, e.jsxs)("div", {
                    className: "btn btn-rnd",
                    onClick: () => n("/messages"),
                    children: [(0, e.jsx)(Gl, {name: "envelope"}), l > 0 && (0, e.jsx)("span", {className: "has-unread"})]
                }), (0, e.jsxs)("div", {
                    className: "btn btn-rnd", onClick: async function (e) {
                        if (e.stopPropagation(), "Notification" in window) try {
                            if ("granted" !== Notification.permission) {
                                const e = await Notification.requestPermission();
                                console.debug(e)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                        n("/notifications")
                    }, children: [(0, e.jsx)(Gl, {name: "bell"}), o && (0, e.jsx)("span", {className: "has-unread"})]
                }), (0, e.jsx)(Vl, {
                    user: a, onClick: () => {
                        a && n((0, Ks._v)(a.pubkey))
                    }
                })]
            })
        }, Qb = n => {
            let {pubkey: r, lnurl: i, children: s} = n;
            const a = (0, hl.useUserProfile)(DS, r), [o, l] = (0, t.useState)(!1),
                c = null != i ? i : (null == a ? void 0 : a.lud16) || (null == a ? void 0 : a.lud06);
            return c ? (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsxs)("div", {
                    className: "zap-button flex",
                    onClick: () => l(!0),
                    children: [(0, e.jsx)(Gl, {name: "zap", className: s ? "mr5" : "", size: 15}), s]
                }), (0, e.jsx)(Ed, {
                    target: (null == a ? void 0 : a.display_name) || (null == a ? void 0 : a.name),
                    lnurl: c,
                    show: o,
                    onClose: () => l(!1),
                    author: r
                })]
            }) : null
        };

        function Jb() {
            const {formatMessage: e} = al(), t = void 0 !== window.crypto.subtle;
            return {
                doLogin: async function (n) {
                    var r;
                    const i = e({
                        id: "iXPL0Z",
                        defaultMessage: "Can't login with private key on an insecure connection, please use a Nostr key manager extension instead"
                    });
                    if (n.startsWith("nsec")) {
                        if (!t) throw new Error(i);
                        const e = (0, Ks.FX)(n);
                        if (64 !== e.length) throw new Error("INVALID PRIVATE KEY");
                        Xs.loginWithPrivateKey(e)
                    } else if (n.startsWith("npub")) {
                        const e = (0, Ks.FX)(n);
                        Xs.loginWithPubkey(e)
                    } else if (n.match(yi)) {
                        const e = await nw(n);
                        Xs.loginWithPubkey(e)
                    } else if (24 === (null === (r = n.match(vi)) || void 0 === r ? void 0 : r.length)) {
                        if (!t) throw new Error(i);
                        const e = $s(Us(n));
                        Xs.loginWithPrivateKey(e)
                    } else {
                        if (64 !== n.length) throw new Error("INVALID PRIVATE KEY");
                        if (!t) throw new Error(i);
                        Xs.loginWithPrivateKey(n)
                    }
                }
            }
        }

        const ew = (0, Ks.FX)("npub1r0rs5q2gk0e3dk3nlc7gnu378ec6cnlenqp8a3cjhyzu6f8k5sgs4sq9ac"),
            tw = [{name: "", pubkey: ew, link: "https://void.cat/d/VKhPayp9ekeXYZGzAL9CxP"}, {
                name: "",
                pubkey: ew,
                link: "https://void.cat/d/3H2h8xxc3aEN6EVeobd8tw"
            }, {name: "", pubkey: ew, link: "https://void.cat/d/7i9W9PXn3TV86C4RUefNC9"}, {
                name: "",
                pubkey: ew,
                link: "https://void.cat/d/KtoX4ei6RYHY7HESg3Ve3k"
            }];

        async function nw(e) {
            const [t, n] = e.split("@"),
                r = await fetch(`https://${n}/.well-known/nostr.json?name=${encodeURIComponent(t.toLocaleLowerCase())}`);
            if (r.ok) {
                const e = (await r.json()).names[t.toLowerCase()];
                if (e) return e
            }
            throw new Error("User key not found")
        }

        const rw = n => {
            let {pubkey: r, bookmarks: i, related: s} = n;
            const [a, o] = (0, t.useState)("all"), l = Qs().publicKey,
                c = (0, t.useMemo)((() => [...new Set(i.map((e => e.pubkey)))]), [i]);
            return (0, e.jsxs)("div", {
                className: "main-content",
                children: [(0, e.jsx)("div", {
                    className: "mb10 flex-end",
                    children: (0, e.jsxs)("select", {
                        disabled: c.length <= 1,
                        value: a,
                        onChange: e => o(e.target.value),
                        children: [(0, e.jsx)("option", {
                            value: "all",
                            children: (0, e.jsx)(cl, {...Su.All})
                        }), c.map((function (t) {
                            const n = sc.getFromCache(t);
                            return n ? (0, e.jsx)("option", {
                                value: t,
                                children: (null == n ? void 0 : n.display_name) || (null == n ? void 0 : n.name)
                            }) : null
                        }))]
                    })
                }), i.filter((e => "all" === a || e.pubkey === a)).map((t => (0, e.jsx)(Pb, {
                    data: t,
                    related: s,
                    options: {showTime: !1, showBookmarked: !0, canUnbookmark: l === r}
                }, t.id)))]
            })
        }, iw = n => {
            let {url: r} = n;
            const i = r.replace(/^wss:\/\//, "https://").replace(/^ws:\/\//, "http://").replace(/\/$/, ""), [s, a] = (0, t.useState)(`${i}/favicon.ico`);
            return (0, e.jsx)("img", {className: "favicon", src: s, onError: () => a(ql), alt: `favicon for ${r}`})
        }, sw = t => {
            let {relays: n} = t;
            return (0, e.jsx)("div", {
                className: "main-content", children: null == n ? void 0 : n.map((t => {
                    let {url: n, settings: r} = t;
                    return (0, e.jsxs)("div", {
                        className: "card relay-card",
                        children: [(0, e.jsx)(iw, {url: n}), (0, e.jsx)("code", {
                            className: "relay-url f-ellipsis",
                            children: n
                        }), (0, e.jsxs)("div", {
                            className: "relay-settings",
                            children: [(0, e.jsx)(Gl, {
                                name: "read",
                                className: r.read ? "enabled" : "disabled"
                            }), (0, e.jsx)(Gl, {name: "write", className: r.write ? "enabled" : "disabled"})]
                        })]
                    }, n)
                }))
            })
        };

        function aw(e, n, r) {
            var i;
            const {preferences: s, publicKey: a} = Qs(), o = a === e, l = (0, t.useMemo)((() => {
                    if (o || !e) return null;
                    const t = new Pt.RequestBuilder(`note-list-${n}:${e.slice(0, 12)}`);
                    return t.withFilter().kinds([Pt.EventKind.NoteLists]).authors([e]).tag("d", [n]).limit(1), t
                }), [e]), c = (0, hl.useRequestBuilder)(DS, Pt.ParameterizedReplaceableNoteStore, l),
                u = (0, t.useMemo)((() => o ? r : c.data && c.data.length > 0 ? c.data[0].tags.filter((e => "e" === e[0])).map((e => e[1])) : []), [c.data, o, r]),
                d = (0, t.useMemo)((() => {
                    if (!e || 0 === u.length) return null;
                    const t = new Pt.RequestBuilder(`${n}-notes:${e.slice(0, 12)}`);
                    return t.withFilter().kinds([Pt.EventKind.TextNote]).ids(u), u.length > 0 && s.enableReactions && t.withFilter().kinds([Pt.EventKind.Reaction, Pt.EventKind.Repost, Pt.EventKind.Deletion, Pt.EventKind.ZapReceipt]).tag("e", u), t
                }), [u, e, s]);
            return null !== (i = (0, hl.useRequestBuilder)(DS, Pt.FlatNoteStore, d).data) && void 0 !== i ? i : []
        }

        function ow(e) {
            const {publicKey: n, follows: r} = Qs(), i = n === e, s = (0, t.useMemo)((() => {
                if (i || !e) return null;
                const t = new Pt.RequestBuilder(`follows:${e.slice(0, 12)}`);
                return t.withFilter().kinds([Pt.EventKind.ContactList]).authors([e]), t
            }), [i, e]), a = (0, hl.useRequestBuilder)(DS, Pt.PubkeyReplaceableNoteStore, s);
            return (0, t.useMemo)((() => {
                var t;
                return i ? r.item : function (e, t) {
                    const n = e.filter((e => e.kind === Pt.EventKind.ContactList && e.pubkey === t)),
                        r = null == n ? void 0 : n.map((e => e.tags.filter((e => "p" === e[0])).map((e => e[1]))));
                    return [...new Set(null == r ? void 0 : r.flat())]
                }(null !== (t = a.data) && void 0 !== t ? t : [], e)
            }), [a, r, e])
        }

        function lw(n) {
            let {onLoadMore: r, shouldLoadMore: i, children: s} = n;
            const {ref: a, inView: o} = Fu(), [l, c] = (0, t.useState)(0);
            return (0, t.useEffect)((() => {
                !0 === o && !0 === i && r()
            }), [o, i, l]), (0, t.useEffect)((() => {
                const e = setInterval((() => {
                    c((e => e + 1))
                }), 500);
                return () => clearInterval(e)
            }), []), (0, e.jsx)("div", {
                ref: a,
                className: "mb10",
                children: null != s ? s : (0, e.jsx)(cl, {...Su.Loading})
            })
        }

        function cw(n) {
            var r;
            const {data: i} = n, {isMuted: s} = pc(), a = (0, t.useMemo)((() => {
                if (i) {
                    const e = i.tags.filter((e => "e" === e[0]));
                    if (e.length > 0) return e[0]
                }
                return null
            }), [i]);
            if (i.kind !== Pt.EventKind.Reaction && i.kind !== Pt.EventKind.Repost && (i.kind !== Pt.EventKind.TextNote || i.tags.every(((e, t) => e[1] !== (null == a ? void 0 : a[1]) || "mention" !== e[3] || i.content !== `#[${t}]`)))) return null;
            const o = function () {
                if ((null == i ? void 0 : i.kind) === Pt.EventKind.Repost && i.content.length > 0 && "#[0]" !== i.content) try {
                    return JSON.parse(i.content)
                } catch (e) {
                    console.error("Could not load reposted content", e)
                }
                return n.root
            }(), l = o && s(o.pubkey) || (null == o ? void 0 : o.kind) !== Pt.EventKind.TextNote, c = {
                showHeader: (null == i ? void 0 : i.kind) === Pt.EventKind.Repost || (null == i ? void 0 : i.kind) === Pt.EventKind.TextNote,
                showFooter: !1
            };
            return l ? null : (0, e.jsxs)("div", {
                className: "reaction",
                children: [(0, e.jsxs)("div", {
                    className: "header flex",
                    children: [(0, e.jsx)(Zl, {pubkey: Pt.EventExt.getRootPubKey(i)}), (0, e.jsx)("div", {
                        className: "info",
                        children: (0, e.jsx)(xb, {from: 1e3 * i.created_at})
                    })]
                }), o ? (0, e.jsx)(Pb, {
                    data: o,
                    options: c,
                    related: []
                }) : null, !o && a ? (0, e.jsx)("p", {
                    children: (0, e.jsxs)(Rt, {
                        to: (0, Ks.sC)(null !== (r = a[1]) && void 0 !== r ? r : "", a[2]),
                        children: ["#", (0, Ks.jm)(Pt.NostrPrefix.Event, a[1]).substring(0, 12)]
                    })
                }) : null]
            })
        }

        function uw(t) {
            let {children: n, width: r, height: i, margin: s, loading: a = !0} = t;
            return a ? (0, e.jsx)("div", {
                className: "skeleton",
                style: {width: r, height: i, margin: s},
                children: n
            }) : (0, e.jsx)(e.Fragment, {children: n})
        }

        const dw = n => {
            const r = (0, t.useMemo)((() => ({method: n.method, window: n.window, now: n.now})), [n]),
                i = function (e, n) {
                    var r;
                    const {now: i, since: s, until: a, older: o, setUntil: l} = function (e) {
                            var n;
                            const [r] = (0, t.useState)(null !== (n = e.window) && void 0 !== n ? n : 7200), [i, s] = (0, t.useState)(e.now), [a, o] = (0, t.useState)(e.now - r);
                            return {
                                now: e.now, since: a, until: i, setUntil: s, older: () => {
                                    s((e => e - r)), o((e => e - r))
                                }
                            }
                        }({window: n.window, now: null !== (r = n.now) && void 0 !== r ? r : (0, Ks.oK)()}),
                        c = Qs().preferences, u = (0, t.useCallback)((() => {
                            if ("global" !== e.type && 0 === e.items.length) return null;
                            const t = new Pt.RequestBuilder(`timeline:${e.type}:${e.discriminator}`),
                                n = t.withFilter().kinds("profile_keyword" === e.type ? [Pt.EventKind.SetMetadata] : [Pt.EventKind.TextNote, Pt.EventKind.Repost, Pt.EventKind.Polls]);
                            switch (e.relay && n.relay(e.relay), e.type) {
                                case"pubkey":
                                    n.authors(e.items);
                                    break;
                                case"hashtag":
                                    n.tag("t", e.items);
                                    break;
                                case"ptag":
                                    n.tag("p", e.items);
                                    break;
                                case"profile_keyword":
                                    n.search(e.items[0] + " sort:popular"), fi.forEach((e => n.relay(e)));
                                    break;
                                case"post_keyword":
                                    n.search(e.items[0]), fi.forEach((e => n.relay(e)))
                            }
                            return {builder: t, filter: n}
                        }), [e.type, e.items, e.discriminator]), d = (0, t.useMemo)((() => {
                            var e;
                            const t = u();
                            return t && ("LIMIT_UNTIL" === n.method ? t.filter.until(a).limit(200) : (t.filter.since(s).until(a), void 0 === s && t.filter.limit(50)), c.autoShowLatest && t.builder.withOptions({leaveOpen: !0}).withFilter().authors(t.filter.filter.authors).kinds(t.filter.filter.kinds).tag("p", t.filter.filter["#p"]).tag("t", t.filter.filter["#t"]).search(t.filter.filter.search).limit(1).since(i)), null !== (e = null == t ? void 0 : t.builder) && void 0 !== e ? e : null
                        }), [a, s, n.method, c, u]), h = (0, hl.useRequestBuilder)(DS, Pt.FlatNoteStore, d),
                        f = (0, t.useMemo)((() => {
                            var e;
                            const t = u();
                            return t && !c.autoShowLatest && "LIMIT_UNTIL" !== n.method && (t.builder.withOptions({leaveOpen: !0}), t.builder.id = `${t.builder.id}:latest`, t.filter.limit(1).since(i)), null !== (e = null == t ? void 0 : t.builder) && void 0 !== e ? e : null
                        }), [c.autoShowLatest, u]), p = (0, hl.useRequestBuilder)(DS, Pt.FlatNoteStore, f);
                    (0, t.useEffect)((() => {
                        h.clear(), p.clear()
                    }), [e.relay]);
                    const m = (0, t.useMemo)((() => {
                        var t, n;
                        const r = new Pt.RequestBuilder(`timeline-related:${e.type}:${e.discriminator}`),
                            i = null !== (t = null === (n = h.data) || void 0 === n ? void 0 : n.map((e => e.id))) && void 0 !== t ? t : [];
                        i.length > 0 && r.withFilter().kinds(c.enableReactions ? [Pt.EventKind.Reaction, Pt.EventKind.Repost, Pt.EventKind.ZapReceipt] : [Pt.EventKind.ZapReceipt, Pt.EventKind.Repost]).tag("e", i);
                        const s = function () {
                            if (h.data) {
                                const e = h.data.filter((e => e.kind === Pt.EventKind.Repost && "" === e.content)).map((e => e.tags.find((e => "e" === e[0])))).filter((e => e)).map((e => (0, Ks.Wg)(e)[1])),
                                    t = h.data.filter((e => (e.kind === Pt.EventKind.Repost || e.kind === Pt.EventKind.TextNote) && e.tags.some((0, Ks.JS)(e)))).map((e => e.tags.find((0, Ks.JS)(e)))).filter((e => e)).map((e => (0, Ks.Wg)(e)[1]));
                                return [...e, ...t]
                            }
                            return []
                        }();
                        return s.length > 0 && r.withFilter().ids(s), r.numFilters > 0 ? r : null
                    }), [h.data, c, e.type]), g = (0, hl.useRequestBuilder)(DS, Pt.FlatNoteStore, m);
                    return {
                        main: h.data, related: g.data, latest: p.data, loading: h.loading(), loadMore: () => {
                            if (h.data) if (console.debug("Timeline load more!"), "LIMIT_UNTIL" === n.method) {
                                const e = h.data.reduce(((e, t) => t.created_at < e ? t.created_at : e), (0, Ks.oK)());
                                l(e)
                            } else o()
                        }, showLatest: () => {
                            p.data && (h.add(p.data), p.clear())
                        }
                    }
                }(n.subject, r), {muted: s, isMuted: a} = pc(), {ref: o, inView: l} = Fu(),
                c = (0, t.useCallback)((e => {
                    const t = [...e];
                    return n.noSort || t.sort(((e, t) => t.created_at - e.created_at)), null == t ? void 0 : t.filter((e => !n.postsOnly || !e.tags.some((e => "e" === e[0])))).filter((e => n.ignoreModeration || !a(e.pubkey)))
                }), [n.postsOnly, s, n.ignoreModeration]), u = (0, t.useMemo)((() => {
                    var e;
                    return c(null !== (e = i.main) && void 0 !== e ? e : [])
                }), [i, c]), d = (0, t.useMemo)((() => {
                    var e;
                    return c(null !== (e = i.latest) && void 0 !== e ? e : []).filter((e => !u.some((t => t.id === e.id))))
                }), [i, c]), h = (0, t.useCallback)((e => {
                    var t;
                    return (null !== (t = i.related) && void 0 !== t ? t : []).filter((t => (0, Ks.MV)(t, "e") === e))
                }), [i.related]), f = (0, t.useCallback)((e => {
                    var t;
                    if (e) return (null !== (t = i.related) && void 0 !== t ? t : []).find((t => t.id === e))
                }), [i.related]), p = (0, t.useMemo)((() => (0, Ks.iT)(d).map((e => e.pubkey))), [d]);

            function m() {
                let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                i.showLatest(), e && window.scrollTo(0, 0)
            }

            return (0, e.jsxs)(e.Fragment, {
                children: [d.length > 0 && (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsxs)("div", {
                        className: "card latest-notes pointer",
                        onClick: () => m(),
                        ref: o,
                        children: [p.slice(0, 3).map((t => (0, e.jsx)(Zl, {
                            pubkey: t,
                            showUsername: !1,
                            link: ""
                        }))), (0, e.jsx)(cl, {
                            id: "3t3kok",
                            defaultMessage: "{n} new {n, plural, =1 {note} other {notes}}",
                            values: {n: d.length}
                        }), (0, e.jsx)(Gl, {name: "arrowUp"})]
                    }), !l && (0, e.jsxs)("div", {
                        className: "card latest-notes latest-notes-fixed pointer fade-in",
                        onClick: () => m(!0),
                        children: [p.slice(0, 3).map((t => (0, e.jsx)(Zl, {
                            pubkey: t,
                            showUsername: !1,
                            link: ""
                        }))), (0, e.jsx)(cl, {
                            id: "3t3kok",
                            defaultMessage: "{n} new {n, plural, =1 {note} other {notes}}",
                            values: {n: d.length}
                        }), (0, e.jsx)(Gl, {name: "arrowUp"})]
                    })]
                }), u.map((function (t) {
                    switch (t.kind) {
                        case Pt.EventKind.SetMetadata:
                            return (0, e.jsx)(Tb, {
                                actions: (0, e.jsx)(e.Fragment, {}),
                                pubkey: t.pubkey,
                                className: "card"
                            });
                        case Pt.EventKind.Polls:
                        case Pt.EventKind.TextNote: {
                            var r;
                            const i = null === (r = t.tags.find((0, Ks.JS)(t))) || void 0 === r ? void 0 : r.at(1);
                            return i ? (0, e.jsx)(cw, {data: t, root: f(i)}, t.id) : (0, e.jsx)(Pb, {
                                data: t,
                                related: h(t.id),
                                ignoreModeration: n.ignoreModeration,
                                depth: 0
                            }, t.id)
                        }
                        case Pt.EventKind.ZapReceipt: {
                            const n = (0, Pt.parseZap)(t, sc);
                            return n.event ? null : (0, e.jsx)(pb, {zap: n}, t.id)
                        }
                        case Pt.EventKind.Reaction:
                        case Pt.EventKind.Repost: {
                            const n = (0, Ks.MV)(t, "e");
                            return (0, e.jsx)(cw, {data: t, root: f(n)}, t.id)
                        }
                    }
                })), (void 0 === n.loadMore || !0 === n.loadMore) && (0, e.jsxs)(lw, {
                    onLoadMore: () => i.loadMore(),
                    shouldLoadMore: !i.loading,
                    children: [(0, e.jsx)(uw, {
                        width: "100%",
                        height: "120px",
                        margin: "0 0 16px 0"
                    }), (0, e.jsx)(uw, {
                        width: "100%",
                        height: "120px",
                        margin: "0 0 16px 0"
                    }), (0, e.jsx)(uw, {width: "100%", height: "120px", margin: "0 0 16px 0"})]
                })]
            })
        }, hw = t => {
            let {pubkey: n} = t;
            const {block: r, unblock: i, isBlocked: s} = pc();
            return s(n) ? (0, e.jsx)("button", {
                className: "secondary",
                type: "button",
                onClick: () => i(n),
                children: (0, e.jsx)(cl, {...Su.Unblock})
            }) : (0, e.jsx)("button", {
                className: "secondary",
                type: "button",
                onClick: () => r(n),
                children: (0, e.jsx)(cl, {...Su.Block})
            })
        };

        function fw() {
            const {blocked: t} = pc();
            return (0, e.jsx)("div", {
                className: "main-content",
                children: t.map((t => (0, e.jsx)(Tb, {
                    actions: (0, e.jsx)(hw, {pubkey: t}),
                    pubkey: t,
                    options: {about: !1}
                }, t)))
            })
        }

        const pw = t => {
            let {pubkey: n} = t;
            const {mute: r, unmute: i, isMuted: s} = pc();
            return s(n) ? (0, e.jsx)("button", {
                className: "secondary",
                type: "button",
                onClick: () => i(n),
                children: (0, e.jsx)(cl, {...Su.Unmute})
            }) : (0, e.jsx)("button", {type: "button", onClick: () => r(n), children: (0, e.jsx)(cl, {...Su.Mute})})
        };

        function mw(t) {
            let {pubkeys: n} = t;
            const {isMuted: r, muteAll: i} = pc(), s = n.every(r);
            return (0, e.jsxs)("div", {
                className: "main-content",
                children: [(0, e.jsxs)("div", {
                    className: "flex mt10",
                    children: [(0, e.jsx)("div", {
                        className: "f-grow bold",
                        children: (0, e.jsx)(cl, {...Su.MuteCount, values: {n: null == n ? void 0 : n.length}})
                    }), (0, e.jsx)("button", {
                        disabled: s || 0 === n.length,
                        className: "transparent",
                        type: "button",
                        onClick: () => i(n),
                        children: (0, e.jsx)(cl, {...Su.MuteAll})
                    })]
                }), null == n ? void 0 : n.map((t => (0, e.jsx)(Tb, {
                    actions: (0, e.jsx)(pw, {pubkey: t}),
                    pubkey: t,
                    options: {about: !1}
                }, t)))]
            })
        }

        const gw = t => {
            let {onClick: n, children: r} = t;
            return (0, e.jsx)("button", {
                className: "icon",
                type: "button",
                onClick: n,
                children: (0, e.jsx)("div", {className: "icon-wrapper", children: r})
            })
        };

        function yw(t) {
            let {followsMe: n} = t;
            const {formatMessage: r} = al();
            return n ? (0, e.jsx)("span", {className: "follows-you", children: r(Su.FollowsYou)}) : null
        }

        function vw(t) {
            let {pubkey: n, onLinkVisit: r} = t;
            const i = (0, hl.useUserProfile)(DS, n), s = st();
            return i ? (0, e.jsx)(Rt, {
                to: (0, Ks._v)(n), onClick: function (e) {
                    e.preventDefault(), r(), s((0, Ks._v)(n))
                }, children: i.name || n.slice(0, 12)
            }) : null
        }

        function bw(n) {
            let {badges: r} = n;
            const [i, s] = (0, t.useState)(!1), a = r.map((e => {
                var t;
                const n = (0, Ks.MV)(e, "thumb"), r = (0, Ks.MV)(e, "image"), i = (0, Ks.MV)(e, "name"),
                    s = (0, Ks.MV)(e, "description");
                return {
                    id: e.id,
                    pubkey: e.pubkey,
                    name: i,
                    description: s,
                    thumb: null !== (t = null == n ? void 0 : n.length) && void 0 !== t && t ? n : r,
                    image: r
                }
            }));
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)("div", {
                    className: "badge-list",
                    onClick: () => s(!i),
                    children: a.slice(0, 8).map((t => {
                        let {id: n, name: r, thumb: i} = t;
                        return (0, e.jsx)(Wd, {alt: r, className: "badge-item", size: 64, src: i}, n)
                    }))
                }), i && (0, e.jsx)(Cu, {
                    className: "reactions-modal",
                    onClose: () => s(!1),
                    children: (0, e.jsxs)("div", {
                        className: "reactions-view",
                        children: [(0, e.jsx)("div", {
                            className: "close",
                            onClick: () => s(!1),
                            children: (0, e.jsx)(Gl, {name: "close"})
                        }), (0, e.jsx)("div", {
                            className: "reactions-header",
                            children: (0, e.jsx)("h2", {
                                children: (0, e.jsx)(cl, {
                                    id: "h8XMJL",
                                    defaultMessage: "Badges"
                                })
                            })
                        }), (0, e.jsx)("div", {
                            className: "body", children: a.map((t => {
                                let {id: n, name: r, pubkey: i, description: a, image: o} = t;
                                return (0, e.jsxs)("div", {
                                    className: "reactions-item badges-item",
                                    children: [(0, e.jsx)(Wd, {
                                        className: "reaction-icon",
                                        src: o,
                                        size: 64,
                                        alt: r
                                    }), (0, e.jsxs)("div", {
                                        className: "badge-info",
                                        children: [(0, e.jsx)("h3", {children: r}), (0, e.jsx)("p", {children: a}), (0, e.jsx)("p", {
                                            children: (0, e.jsx)(cl, {
                                                id: "RfhLwC",
                                                defaultMessage: "By: {author}",
                                                values: {author: (0, e.jsx)(vw, {pubkey: i, onLinkVisit: () => s(!1)})}
                                            })
                                        })]
                                    })]
                                }, n)
                            }))
                        })]
                    })
                })]
            })
        }

        function ww(n) {
            let {id: r} = n;
            const i = function (e) {
                const n = (0, t.useMemo)((() => {
                    if (!e) return null;
                    const t = new Pt.RequestBuilder(`zaps:${e.slice(0, 12)}`);
                    return t.withFilter().tag("p", [e]).kinds([Pt.EventKind.ZapReceipt]), t
                }), [e]), r = (0, hl.useRequestBuilder)(DS, Pt.FlatNoteStore, n), i = (0, t.useMemo)((() => {
                    if (r.data) {
                        const t = r.data.map((e => (0, Pt.parseZap)(e, sc))).filter((t => t.valid && t.receiver === e && t.sender !== e && !t.event));
                        return t.sort(((e, t) => t.amount - e.amount)), t
                    }
                    return []
                }), [r]);
                return i
            }(r), s = i.reduce(((e, t) => e + t.amount), 0);
            return (0, e.jsxs)("div", {
                className: "main-content",
                children: [(0, e.jsx)("div", {
                    className: "zaps-total",
                    children: (0, e.jsx)(cl, {..._l, values: {n: Hu(s)}})
                }), i.map((t => (0, e.jsx)(pb, {showZapped: !1, zap: t})))]
            })
        }

        function xw(n) {
            let {id: r} = n;
            const i = function (e) {
                const n = (0, t.useMemo)((() => {
                        if (!e) return null;
                        const t = new Pt.RequestBuilder(`followers:${e.slice(0, 12)}`);
                        return t.withFilter().kinds([Pt.EventKind.ContactList]).tag("p", [e]), t
                    }), [e]), r = (0, hl.useRequestBuilder)(DS, Pt.PubkeyReplaceableNoteStore, n),
                    i = (0, t.useMemo)((() => {
                        var t;
                        const n = null === (t = r.data) || void 0 === t ? void 0 : t.filter((t => t.kind === Pt.EventKind.ContactList && t.tags.some((t => "p" === t[0] && t[1] === e))));
                        return [...new Set(null == n ? void 0 : n.map((e => e.pubkey)))]
                    }), [r, e]);
                return i
            }(r);
            return (0, e.jsx)(Cb, {pubkeys: i, showAbout: !0})
        }

        function Ew(t) {
            let {id: n} = t;
            const r = ow(n);
            return (0, e.jsx)(Cb, {pubkeys: r, showAbout: !0})
        }

        function Sw(n) {
            let {id: r} = n;
            const i = function (e) {
                var n;
                const r = (0, t.useMemo)((() => {
                    if (!e) return null;
                    const t = new Pt.RequestBuilder(`relays:${e.slice(0, 12)}`);
                    return t.withFilter().authors([e]).kinds([Pt.EventKind.ContactList]), t
                }), [e]), i = (0, hl.useRequestBuilder)(DS, Pt.ReplaceableNoteStore, r);
                if (null === (n = i.data) || void 0 === n || !n.content) return [];
                try {
                    return Object.entries(JSON.parse(i.data.content)).map((e => {
                        let [t, n] = e;
                        return {url: t, settings: n}
                    }))
                } catch (e) {
                    return console.error(e), []
                }
            }(r);
            return (0, e.jsx)(sw, {relays: i})
        }

        function kw(t) {
            let {id: n} = t;
            const r = function (e) {
                const {bookmarked: t} = Qs();
                return aw(e, Pt.Lists.Bookmarked, t.item)
            }(n);
            return (0, e.jsx)(rw, {
                pubkey: n,
                bookmarks: r.filter((e => e.kind === Pt.EventKind.TextNote)),
                related: r.filter((e => e.kind !== Pt.EventKind.TextNote))
            })
        }

        var Aw, Tw, Cw, Rw = function (e, t, n, r) {
            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
        };

        class Lw extends Error {
            constructor(e, t, n) {
                super(e), this.body = t, this.statusCode = n
            }
        }

        class _w {
            constructor() {
                Aw.add(this), Tw.set(this, "https://api.nostr.band")
            }

            async trendingProfiles() {
                return await Rw(this, Aw, "m", Cw).call(this, "GET", "/v0/trending/profiles")
            }

            async trendingNotes() {
                return await Rw(this, Aw, "m", Cw).call(this, "GET", "/v0/trending/notes")
            }

            async sugguestedFollows(e) {
                return await Rw(this, Aw, "m", Cw).call(this, "GET", `/v0/suggested/profiles/${e}`)
            }
        }

        Tw = new WeakMap, Aw = new WeakSet, Cw = async function (e, t) {
            const n = await fetch(`${Rw(this, Tw, "f")}${t}`, {method: null != e ? e : "GET"});
            if (n.ok) return await n.json();
            throw new Lw("Failed to load content from nostr.band", await n.text(), n.status)
        };
        var Pw, Nw, jw, Iw, Mw, Dw = function (e, t, n, r) {
            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
        };

        class Ow extends Error {
            constructor(e, t, n) {
                super(e), this.body = t, this.statusCode = n
            }
        }

        class Bw {
            constructor() {
                Pw.add(this), Nw.set(this, "https://api.semisol.dev")
            }

            async sugguestedFollows(e, t) {
                return await Dw(this, Pw, "m", jw).call(this, "POST", "/nosgraph/v1/recommend", {
                    pubkey: e,
                    exclude: [],
                    following: t
                })
            }
        }

        function Fw() {
            const n = Qs(), [r, i] = (0, t.useState)(), [s, a] = (0, t.useState)(Iw.NostrBand), [o, l] = (0, t.useState)("");
            return (0, t.useEffect)((() => {
                (async function () {
                    if (n.publicKey) {
                        i(void 0), l("");
                        try {
                            switch (s) {
                                case Iw.NostrBand: {
                                    const e = new _w,
                                        t = (await e.sugguestedFollows((0, Ks.jm)(Pt.NostrPrefix.PublicKey, n.publicKey))).profiles.map((e => e.pubkey));
                                    i(t);
                                    break
                                }
                                case Iw.SemisolDev: {
                                    const e = new Bw,
                                        t = (await e.sugguestedFollows(n.publicKey, n.follows.item)).recommendations.sort((e => e[1])).map((e => e[0]));
                                    i(t);
                                    break
                                }
                            }
                        } catch (e) {
                            e instanceof Error && l(e.message)
                        }
                    }
                })().catch(console.error)
            }), [n, s]), (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)("h3", {
                    children: (0, e.jsx)(cl, {
                        id: "C8HhVE",
                        defaultMessage: "Suggested Follows"
                    })
                }), (0, e.jsxs)("div", {
                    className: "card flex f-space",
                    children: [(0, e.jsx)(cl, {
                        id: "xaj9Ba",
                        defaultMessage: "Provider"
                    }), (0, e.jsxs)("select", {
                        onChange: e => a(Number(e.target.value)),
                        children: [(0, e.jsx)("option", {
                            value: Iw.NostrBand,
                            children: "nostr.band"
                        }), (0, e.jsx)("option", {value: Iw.SemisolDev, children: "semisol.dev"})]
                    })]
                }), o && (0, e.jsx)("b", {className: "error", children: o}), r ? (0, e.jsx)(Cb, {
                    pubkeys: r,
                    showAbout: !0
                }) : (0, e.jsx)(Yd, {})]
            })
        }

        function Uw() {
            const [n, r] = (0, t.useState)();
            return (0, t.useEffect)((() => {
                (async function () {
                    const e = new _w, t = await e.trendingNotes();
                    r(t.notes.map((e => e.event)))
                })().catch(console.error)
            }), []), n ? (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)("h3", {
                    children: (0, e.jsx)(cl, {
                        id: "Ix8l+B",
                        defaultMessage: "Trending Notes"
                    })
                }), n.map((t => (0, e.jsx)(Pb, {data: t, related: [], depth: 0}, t.id)))]
            }) : (0, e.jsx)(Yd, {})
        }

        function Hw() {
            const [n, r] = (0, t.useState)();
            return (0, t.useEffect)((() => {
                (async function () {
                    const e = new _w, t = (await e.trendingProfiles()).profiles.map((e => e.pubkey));
                    r(t)
                })().catch(console.error)
            }), []), n ? (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)("h3", {
                    children: (0, e.jsx)(cl, {
                        id: "CVWeJ6",
                        defaultMessage: "Trending People"
                    })
                }), (0, e.jsx)(Cb, {pubkeys: n, showAbout: !0})]
            }) : (0, e.jsx)(Yd, {})
        }

        Nw = new WeakMap, Pw = new WeakSet, jw = async function (e, t, n) {
            const r = `${Dw(this, Nw, "f")}${t}`, i = await fetch(r, {
                method: null != e ? e : "GET",
                body: n ? JSON.stringify(n) : void 0,
                headers: {...n ? {"content-type": "application/json"} : {}}
            });
            if (i.ok) return await i.json();
            throw new Ow(`Failed to load content from ${r}`, await i.text(), i.status)
        }, (Mw = Iw || (Iw = {}))[Mw.NostrBand = 1] = "NostrBand", Mw[Mw.SemisolDev = 2] = "SemisolDev";
        const $w = () => {
            var t;
            const {publicKey: n, follows: r} = Qs();
            return 0 === (null === (t = r.item) || void 0 === t ? void 0 : t.length) && n ? (0, e.jsx)(cl, {
                ...El,
                values: {newUsersPage: (0, e.jsx)(Rt, {to: "/new/discover", children: (0, e.jsx)(cl, {...xl})})}
            }) : null
        }, Kw = [{
            path: "/", element: (0, e.jsx)((function () {
                const {formatMessage: n} = al(), r = st(), i = it(), {publicKey: s, tags: a, preferences: o} = Qs(),
                    l = {
                        Notes: {text: n(Sl), value: 0, data: "/notes"},
                        Conversations: {text: n(bl), value: 1, data: "/conversations"},
                        Global: {text: n(wl), value: 2, data: "/global"},
                        Discover: {text: n({id: "cE4Hfw", defaultMessage: "Discover"}), value: 3, data: "/discover"}
                    }, c = a.item.map(((e, t) => ({text: `#${e}`, value: t + 3, data: `/tag/${e}`}))),
                    u = [l.Notes, l.Conversations, l.Global, l.Discover, ...c], d = (0, t.useMemo)((() => {
                        const e = i.pathname.split("/").slice(-1)[0];
                        if (i.pathname.startsWith("/tag")) {
                            const t = c.find((t => t.text.slice(1) === e));
                            if (t) return t
                        }
                        switch (e) {
                            case"conversations":
                                return l.Conversations;
                            case"global":
                                return l.Global;
                            case"discover":
                                return l.Discover;
                            default:
                                return l.Notes
                        }
                    }), [i]);
                return (0, t.useEffect)((() => {
                    if ("/" === i.pathname) {
                        var e;
                        const t = s ? null !== (e = o.defaultRootTab) && void 0 !== e ? e : d.data : "/global";
                        r(t, {replace: !0})
                    }
                }), [i]), (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("div", {
                        className: "main-content",
                        children: s && (0, e.jsx)(db, {tabs: u, tab: d, setTab: e => r((0, Ks.Wg)(e.data))})
                    }), (0, e.jsx)("div", {className: "main-content", children: (0, e.jsx)(yt, {})})]
                })
            }), {}), children: [{
                path: "global", element: (0, e.jsx)((() => {
                    var n;
                    const {relays: r} = Qs(), [i, s] = (0, t.useState)(), [a, o] = (0, t.useState)(), [l] = (0, t.useState)((0, Ks.oK)()),
                        c = {
                            type: "global",
                            items: [],
                            relay: null == i ? void 0 : i.url,
                            discriminator: `all-${(0, Ks.JQ)(null !== (n = null == i ? void 0 : i.url) && void 0 !== n ? n : "").slice(0, 12)}`
                        };
                    return (0, t.useEffect)((() => (0, Ks.Ds)(500, (() => {
                        const e = [];
                        DS.Sockets.forEach((t => {
                            var n, r, i;
                            e.push({
                                url: t.address,
                                paid: null !== (n = null === (r = t.info) || void 0 === r || null === (i = r.limitation) || void 0 === i ? void 0 : i.payment_required) && void 0 !== n && n
                            })
                        })), e.sort((e => e.paid ? -1 : 1)), e.length > 0 && !i && s(e[0]), o(e)
                    }))), [r, i]), (0, e.jsxs)(e.Fragment, {
                        children: [function () {
                            if (!a || 0 === a.length) return null;
                            const t = a.filter((e => e.paid)), n = a.filter((e => !e.paid));
                            return (0, e.jsxs)("div", {
                                className: "flex mb10 f-end nowrap",
                                children: [(0, e.jsx)(cl, {
                                    id: "yCmnnm",
                                    defaultMessage: "Read global from"
                                }), "", (0, e.jsxs)("select", {
                                    className: "f-ellipsis",
                                    onChange: e => s(a.find((t => t.url === e.target.value))),
                                    value: null == i ? void 0 : i.url,
                                    children: [t.length > 0 && (0, e.jsx)("optgroup", {
                                        label: "Paid Relays",
                                        children: t.map((t => (0, e.jsx)("option", {
                                            value: t.url,
                                            children: (0, Ks.Os)(t.url)
                                        }, t.url)))
                                    }), (0, e.jsx)("optgroup", {
                                        label: "Public Relays",
                                        children: n.map((t => (0, e.jsx)("option", {
                                            value: t.url,
                                            children: (0, Ks.Os)(t.url)
                                        }, t.url)))
                                    })]
                                })]
                            })
                        }(), i && (0, e.jsx)(dw, {
                            subject: c,
                            postsOnly: !1,
                            method: "TIME_RANGE",
                            window: 600,
                            now: l
                        })]
                    })
                }), {})
            }, {
                path: "notes", element: (0, e.jsx)((() => {
                    const {follows: t, publicKey: n} = Qs(), r = {
                        type: "pubkey",
                        items: t.item,
                        discriminator: `follows:${null == n ? void 0 : n.slice(0, 12)}`
                    };
                    return (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)($w, {}), (0, e.jsx)(dw, {
                            subject: r,
                            postsOnly: !0,
                            method: "TIME_RANGE"
                        })]
                    })
                }), {})
            }, {
                path: "conversations", element: (0, e.jsx)((() => {
                    const {follows: t, publicKey: n} = Qs(), r = {
                        type: "pubkey",
                        items: t.item,
                        discriminator: `follows:${null == n ? void 0 : n.slice(0, 12)}`
                    };
                    return (0, e.jsx)(dw, {subject: r, postsOnly: !1, method: "TIME_RANGE"})
                }), {})
            }, {
                path: "discover", element: (0, e.jsx)((function () {
                    const {formatMessage: n} = al(), r = {
                        Follows: {text: n({id: "C8HhVE", defaultMessage: "Suggested Follows"}), value: 0},
                        Posts: {text: n({id: "Ix8l+B", defaultMessage: "Trending Notes"}), value: 1},
                        Profiles: {text: n({id: "CVWeJ6", defaultMessage: "Trending People"}), value: 2}
                    }, [i, s] = (0, t.useState)(r.Follows);
                    return (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("div", {
                            className: "tabs",
                            children: [r.Follows, r.Posts, r.Profiles].map((t => (0, e.jsx)(ub, {
                                tab: i,
                                setTab: s,
                                t
                            }, t.value)))
                        }), function () {
                            switch (i.value) {
                                case 0:
                                    return (0, e.jsx)(Fw, {});
                                case 1:
                                    return (0, e.jsx)(Uw, {});
                                case 2:
                                    return (0, e.jsx)(Hw, {})
                            }
                            return null
                        }()]
                    })
                }), {})
            }, {
                path: "tag/:tag", element: (0, e.jsx)((() => {
                    const {tag: t} = ot(),
                        n = {type: "hashtag", items: [null != t ? t : ""], discriminator: `tags-${t}`};
                    return (0, e.jsx)(dw, {subject: n, postsOnly: !1, method: "TIME_RANGE"})
                }), {})
            }]
        }];
        var zw, Gw;

        class qw {
            constructor() {
                zw.add(this), this.state = {}
            }

            mute() {
                this.state.muted = !0, function (e, t, n, r) {
                    if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
                    if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                    return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
                }(this, zw, "m", Gw).call(this)
            }

            load() {
                const e = window.localStorage.getItem(`task:${this.id}`);
                e && (this.state = JSON.parse(e))
            }
        }

        zw = new WeakSet, Gw = function () {
            window.localStorage.setItem(`task:${this.id}`, JSON.stringify(this.state))
        };
        const Ww = [new class extends qw {
            constructor() {
                super(...arguments), this.id = "buy-nip5"
            }

            check(e) {
                return !this.state.muted && !e.nip05
            }

            render() {
                return (0, e.jsx)("p", {
                    children: (0, e.jsx)(cl, {
                        id: "wvFw6Y",
                        defaultMessage: "Hey, it looks like you dont have a NIP-05 handle yet, you should get one! Check out {link}",
                        values: {
                            link: (0, e.jsx)(Rt, {
                                to: "/verification",
                                children: (0, e.jsx)(cl, {id: "Iwm6o2", defaultMessage: "NIP-05 Shop"})
                            })
                        }
                    })
                })
            }
        }, new class extends qw {
            constructor() {
                super(...arguments), this.id = "donate"
            }

            check() {
                return !this.state.muted
            }

            render() {
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("p", {
                        children: (0, e.jsx)(cl, {
                            id: "IDjHJ6",
                            defaultMessage: "Thanks for using Snort, please consider donating if you can."
                        })
                    }), (0, e.jsx)(Rt, {
                        to: "/donate",
                        children: (0, e.jsx)("button", {
                            children: (0, e.jsx)(cl, {
                                id: "2IFGap",
                                defaultMessage: "Donate"
                            })
                        })
                    })]
                })
            }
        }];
        Ww.forEach((e => e.load()));
        const Vw = () => {
                const n = Qs().publicKey, r = (0, hl.useUserProfile)(DS, n), [, i] = (0, t.useState)(0);
                return (0, e.jsx)(e.Fragment, {
                    children: Ww.filter((e => !!r && e.check(r))).map((t => (0, e.jsxs)("div", {
                        className: "card",
                        children: [(0, e.jsxs)("div", {
                            className: "header",
                            children: [(0, e.jsx)(Gl, {name: "lightbulb"}), (0, e.jsx)("div", {
                                className: "close",
                                onClick: () => function (e) {
                                    e.mute(), i((e => e + 1))
                                }(t),
                                children: (0, e.jsx)(Gl, {name: "close", size: 14})
                            })]
                        }), t.render()]
                    }, t.id)))
                })
            }, Yw = t => {
                let {text: n, onClick: r, className: i = ""} = t;
                const {formatMessage: s} = al(), a = s(Su.ShowMore), o = i ? `show-more ${i}` : "show-more";
                return (0, e.jsx)("div", {
                    className: "show-more-container",
                    children: (0, e.jsx)("button", {className: o, onClick: r, children: n || a})
                })
            }, Zw = t => {
                let {icon: n, collapsed: r} = t;
                return r ? (0, e.jsx)("div", {
                    className: "collapsed",
                    children: n
                }) : (0, e.jsx)("div", {className: "uncollapsed", children: n})
            }, Xw = n => {
                let {title: r, children: i, className: s} = n;
                const [a, o] = (0, t.useState)(!0), l = (0, e.jsx)("div", {
                    className: "collapse-icon " + (a ? "" : "flip"),
                    children: (0, e.jsx)(Gl, {name: "arrowFront"})
                });
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsxs)("div", {
                        className: "collapsable-section" + (s ? ` ${s}` : ""),
                        onClick: () => o(!a),
                        children: [r, (0, e.jsx)(Zw, {icon: l, collapsed: a})]
                    }), !a && i]
                })
            }, Qw = t => {
                let {text: n, children: r, collapsed: i, setCollapsed: s} = t;
                return i ? (0, e.jsx)("div", {
                    className: "collapsed",
                    children: (0, e.jsx)(Yw, {text: n, onClick: () => s(!1)})
                }) : (0, e.jsx)("div", {className: "uncollapsed", children: r})
            }, Jw = {id: "itPgxd", defaultMessage: "Profile"}, ex = {id: "RoOyAh", defaultMessage: "Relays"},
            tx = {id: "zINlao", defaultMessage: "Owner"}, nx = {id: "r3C4x/", defaultMessage: "Software"},
            rx = {id: "zFegDD", defaultMessage: "Contact"}, ix = {id: "hY4lzx", defaultMessage: "Supports"},
            sx = {id: "G/yZLu", defaultMessage: "Remove"}, ax = {id: "PCSt5T", defaultMessage: "Preferences"},
            ox = {id: "2IFGap", defaultMessage: "Donate"}, lx = {id: "H0JBH6", defaultMessage: "Log Out"},
            cx = {id: "Pe0ogR", defaultMessage: "Theme"}, ux = {id: "P7FD0F", defaultMessage: "System (Default)"},
            dx = {id: "3cc4Ct", defaultMessage: "Light"}, hx = {id: "tOdNiY", defaultMessage: "Dark"},
            fx = {id: "MWTx65", defaultMessage: "Default Page"}, px = {id: "1udzha", defaultMessage: "Conversations"},
            mx = {id: "EWyQH5", defaultMessage: "Global"},
            gx = {id: "xbVgIm", defaultMessage: "Automatically load media"}, yx = {
                id: "TDR5ge",
                defaultMessage: "Media in notes will automatically be shown for selected people, otherwise only the link will show"
            }, vx = {id: "450Fty", defaultMessage: "None"}, bx = {id: "odFwjL", defaultMessage: "Follows only"},
            wx = {id: "zQvVDJ", defaultMessage: "All"}, xx = {id: "ll3xBp", defaultMessage: "Image proxy service"},
            Ex = {id: "4Z3t5i", defaultMessage: "Use imgproxy to compress images"},
            Sx = {id: "YDURw6", defaultMessage: "Service URL"}, kx = {id: "EcglP9", defaultMessage: "Key"},
            Ax = {id: "GFOoEE", defaultMessage: "Salt"}, Tx = {id: "YXA3AH", defaultMessage: "Enable reactions"}, Cx = {
                id: "PrsIg7",
                defaultMessage: "Reactions will be shown on every page, if disabled no reactions will be shown"
            }, Rx = {id: "89q5wc", defaultMessage: "Confirm Reposts"},
            Lx = {id: "uSV4Ti", defaultMessage: "Reposts need to be manually confirmed"},
            _x = {id: "zvCDao", defaultMessage: "Automatically show latest notes"},
            Px = {id: "a7TDNm", defaultMessage: "Notes will stream in real time into global and notes tab"},
            Nx = {id: "mKh2HS", defaultMessage: "File upload service"},
            jx = {id: "VOjC1i", defaultMessage: "Pick which upload service you want to upload attachments to"},
            Ix = {id: "rfuMjE", defaultMessage: "(Default)"}, Mx = {id: "M3Oirc", defaultMessage: "Debug Menus"}, Dx = {
                id: "MBAYRO",
                defaultMessage: 'Shows "Copy ID" and "Copy Event JSON" in the context menu on each message'
            }, Ox = {id: "usAvMr", defaultMessage: "Edit Profile"}, Bx = {id: "g5pX+a", defaultMessage: "About"},
            Fx = {id: "d7d0/x", defaultMessage: "LN Address"}, Ux = {id: "VnXp8Z", defaultMessage: "Avatar"},
            Hx = {id: "25V4l1", defaultMessage: "Banner"}, $x = {id: "wEQDC6", defaultMessage: "Edit"},
            Kx = {id: "2/2yg+", defaultMessage: "Add"}, zx = {id: "rT14Ow", defaultMessage: "Add Relays"},
            Gx = {id: "HAlOn1", defaultMessage: "Name"}, qx = {id: "JkLHGw", defaultMessage: "Website"},
            Wx = {id: "jvo0vs", defaultMessage: "Save"}, Vx = {id: "dOQCL8", defaultMessage: "Display name"},
            Yx = {id: "EnCOBJ", defaultMessage: "Buy"}, Zx = {id: "7hp70g", defaultMessage: "NIP-05"},
            Xx = {id: "eHAneD", defaultMessage: "Reaction emoji"},
            Qx = {id: "gDzDRs", defaultMessage: "Emoji to send when reactiong to a note"};

        function Jx(n) {
            let {picture: r, onPictureChange: i} = n;
            const s = Nu(), [a, o] = (0, t.useState)("");
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)("div", {
                    className: "flex f-center",
                    children: (0, e.jsx)("div", {
                        style: {backgroundImage: `url(${r})`},
                        className: "avatar",
                        children: (0, e.jsx)("div", {
                            className: "edit" + (r ? "" : " new"),
                            onClick: () => async function () {
                                o("");
                                try {
                                    const e = await (0, Ks.ZB)();
                                    if (e) {
                                        const t = await s.upload(e, e.name);
                                        console.log(t), "string" == typeof (null == t ? void 0 : t.error) ? o(`Upload failed: ${t.error}`) : null == i || i((0, Ks.Wg)(t.url))
                                    }
                                } catch (e) {
                                    e instanceof Error ? o(`Upload failed: ${e.message}`) : o("Upload failed")
                                }
                            }().catch(console.error),
                            children: (0, e.jsx)(Gl, {name: r ? "edit" : "camera-plus"})
                        })
                    })
                }), a && (0, e.jsx)("b", {className: "error", children: a})]
            })
        }

        function eE(e) {
            const t = DS.Sockets.find((t => t.address === e));
            return t
        }

        function tE(n) {
            var r, i, s;
            const a = st(), o = Qs(),
                l = (0, Ks.Wg)(null !== (r = null !== (i = o.relays.item[n.addr]) && void 0 !== i ? i : null === (s = DS.Sockets.find((e => e.address === n.addr))) || void 0 === s ? void 0 : s.settings) && void 0 !== r ? r : {}),
                c = eE(n.addr), u = (0, t.useMemo)((() => (0, Ks.Os)(n.addr)), [n.addr]);

            function d(e) {
                zs(o, {...o.relays.item, [n.addr]: e}, (0, Ks.Fd)())
            }

            return (0, e.jsx)(e.Fragment, {
                children: (0, e.jsxs)("div", {
                    className: "relay w-max",
                    children: [(0, e.jsx)("div", {
                        className: "flex " + (null != c && c.connected ? "bg-success" : "bg-error"),
                        children: (0, e.jsx)(Gl, {name: "wifi"})
                    }), (0, e.jsxs)("div", {
                        className: "f-grow f-col",
                        children: [(0, e.jsxs)("div", {
                            className: "flex mb10",
                            children: [(0, e.jsx)("b", {
                                className: "f-2",
                                children: u
                            }), (0, e.jsxs)("div", {
                                className: "f-1",
                                children: [(0, e.jsx)(cl, {...Su.Write}), (0, e.jsx)("span", {
                                    className: "checkmark",
                                    onClick: () => d({write: !l.write, read: l.read}),
                                    children: (0, e.jsx)(Gl, {name: l.write ? "check" : "close", size: 12})
                                })]
                            }), (0, e.jsxs)("div", {
                                className: "f-1",
                                children: [(0, e.jsx)(cl, {...Su.Read}), (0, e.jsx)("span", {
                                    className: "checkmark",
                                    onClick: () => d({write: l.write, read: !l.read}),
                                    children: (0, e.jsx)(Gl, {name: l.read ? "check" : "close", size: 12})
                                })]
                            })]
                        }), (0, e.jsxs)("div", {
                            className: "flex",
                            children: [(0, e.jsx)("div", {className: "f-grow"}), (0, e.jsx)("div", {
                                children: (0, e.jsx)("span", {
                                    className: "icon-btn",
                                    onClick: () => {
                                        var e;
                                        return a(null !== (e = null == c ? void 0 : c.id) && void 0 !== e ? e : "")
                                    },
                                    children: (0, e.jsx)(Gl, {name: "gear", size: 12})
                                })
                            })]
                        })]
                    })]
                })
            })
        }

        const nE = ["en", "ja", "es", "hu", "zh-CN", "zh-TW", "fr", "ar", "it", "id", "de", "ru", "sv", "hr", "ta-IN", "fa-IR"],
            rE = t => (0, e.jsxs)("svg", {
                width: "58px",
                height: "58px",
                viewBox: "0 0 58 58",
                version: "1.1",
                xmlns: "http://www.w3.org/2000/svg", ...t,
                children: [(0, e.jsx)("title", {children: "logo-bluewallet"}), (0, e.jsxs)("defs", {
                    children: [(0, e.jsxs)("filter", {
                        x: "-14.0%",
                        y: "-13.8%",
                        width: "128.1%",
                        height: "127.6%",
                        filterUnits: "objectBoundingBox",
                        id: "filter-1",
                        children: [(0, e.jsx)("feOffset", {
                            dx: "0",
                            dy: "2",
                            in: "SourceAlpha",
                            result: "shadowOffsetOuter1"
                        }), (0, e.jsx)("feGaussianBlur", {
                            stdDeviation: "1",
                            in: "shadowOffsetOuter1",
                            result: "shadowBlurOuter1"
                        }), (0, e.jsx)("feColorMatrix", {
                            values: "0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.137729458 0",
                            type: "matrix",
                            in: "shadowBlurOuter1",
                            result: "shadowMatrixOuter1"
                        }), (0, e.jsxs)("feMerge", {children: [(0, e.jsx)("feMergeNode", {in: "shadowMatrixOuter1"}), (0, e.jsx)("feMergeNode", {in: "SourceGraphic"})]})]
                    }), (0, e.jsxs)("linearGradient", {
                        x1: "50%",
                        y1: "2.83824061%",
                        x2: "50%",
                        y2: "100%",
                        id: "linearGradient-2",
                        children: [(0, e.jsx)("stop", {
                            "stop-color": "#174697",
                            offset: "0%"
                        }), (0, e.jsx)("stop", {"stop-color": "#0C2550", offset: "100%"})]
                    }), (0, e.jsxs)("linearGradient", {
                        x1: "50%",
                        y1: "0%",
                        x2: "50%",
                        y2: "97.8843027%",
                        id: "linearGradient-3",
                        children: [(0, e.jsx)("stop", {
                            "stop-color": "#3F78DC",
                            offset: "0%"
                        }), (0, e.jsx)("stop", {"stop-color": "#2F5FB3", offset: "100%"})]
                    }), (0, e.jsxs)("linearGradient", {
                        x1: "50%",
                        y1: "2.72534321%",
                        x2: "50%",
                        y2: "100%",
                        id: "linearGradient-4",
                        children: [(0, e.jsx)("stop", {
                            "stop-color": "#8BD7F9",
                            offset: "0%"
                        }), (0, e.jsx)("stop", {"stop-color": "#68BBE1", offset: "100%"})]
                    })]
                }), (0, e.jsx)("g", {
                    id: "bluewallet",
                    stroke: "none",
                    strokeWidth: "1",
                    fill: "none",
                    fillRule: "evenodd",
                    children: (0, e.jsx)("g", {
                        id: "bluewallet-site-copy-2", children: (0, e.jsx)("g", {
                            id: "logo-bluewallet", children: (0, e.jsxs)("g", {
                                id: "Group-Copy",
                                filter: "url(#filter-1)",
                                children: [(0, e.jsx)("path", {
                                    d: "M16.6652538,-1.58013034e-15 L39.9523933,-2.33537939e-16 C45.7472651,1.35692268e-16 47.8486256,0.603366472 49.9671441,1.73636257 C52.0856627,2.86935868 53.7482884,4.53198441 54.8812845,6.65050293 C56.0142806,8.76902145 56.6176471,10.870382 56.6176471,16.6652538 L56.6176471,39.9523933 C56.6176471,45.7472651 56.0142806,47.8486256 54.8812845,49.9671441 C53.7482884,52.0856627 52.0856627,53.7482884 49.9671441,54.8812845 C47.8486256,56.0142806 45.7472651,56.6176471 39.9523933,56.6176471 L16.6652538,56.6176471 C10.870382,56.6176471 8.76902145,56.0142806 6.65050293,54.8812845 C4.53198441,53.7482884 2.86935868,52.0856627 1.73636257,49.9671441 C0.603366472,47.8486256 2.60802988e-16,45.7472651 -4.48864133e-16,39.9523933 L-4.57970006e-16,16.6652538 C2.66093762e-16,10.870382 0.603366472,8.76902145 1.73636257,6.65050293 C2.86935868,4.53198441 4.53198441,2.86935868 6.65050293,1.73636257 C8.76902145,0.603366472 10.870382,9.18101232e-16 16.6652538,-1.58013034e-15 Z",
                                    id: "Rectangle-Copy",
                                    fill: "url(#linearGradient-2)"
                                }), (0, e.jsx)("path", {
                                    d: "M16.6652538,13.2352941 L39.9523933,13.2352941 C45.7472651,13.2352941 47.8486256,13.8386606 49.9671441,14.9716567 C52.0856627,16.1046528 53.7482884,17.7672785 54.8812845,19.885797 C56.0142806,22.0043156 56.6176471,24.1056761 56.6176471,29.9005479 L56.6176471,39.2170991 C56.6176471,45.011971 56.0142806,47.1133315 54.8812845,49.23185 C53.7482884,51.3503685 52.0856627,53.0129943 49.9671441,54.1459904 C47.8486256,55.2789865 45.7472651,55.8823529 39.9523933,55.8823529 L16.6652538,55.8823529 C10.870382,55.8823529 8.76902145,55.2789865 6.65050293,54.1459904 C4.53198441,53.0129943 2.86935868,51.3503685 1.73636257,49.23185 C0.603366472,47.1133315 2.60802988e-16,45.011971 -4.48864133e-16,39.2170991 L-1.36480415e-15,29.9005479 C7.92990512e-16,24.1056761 0.603366472,22.0043156 1.73636257,19.885797 C2.86935868,17.7672785 4.53198441,16.1046528 6.65050293,14.9716567 C8.76902145,13.8386606 10.870382,13.2352941 16.6652538,13.2352941 Z",
                                    id: "Rectangle-Copy-2",
                                    fill: "url(#linearGradient-3)"
                                }), (0, e.jsx)("path", {
                                    d: "M13.2492834,27.2058824 L43.3683637,27.2058824 C47.2492145,27.2058824 49.1977058,27.7164232 50.9902984,28.6751122 C52.782891,29.6338012 54.1897282,31.0406384 55.1484172,32.833231 C56.1071062,34.6258236 56.6176471,36.5743149 56.6176471,40.4551657 L56.6176471,44.1036578 C56.6176471,47.9845086 56.1071062,49.933 55.1484172,51.7255925 C54.1897282,53.5181851 52.782891,54.9250223 50.9902984,55.8837113 C49.1977058,56.8424003 47.2492145,57.3529412 43.3683637,57.3529412 L13.2492834,57.3529412 C9.36843258,57.3529412 7.41994122,56.8424003 5.62734863,55.8837113 C3.83475604,54.9250223 2.42791888,53.5181851 1.46922987,51.7255925 C0.510540861,49.933 -2.77257755e-16,47.9845086 3.82228307e-16,44.1036578 L2.75457766e-16,40.4551657 C-1.99809382e-16,36.5743149 0.510540861,34.6258236 1.46922987,32.833231 C2.42791888,31.0406384 3.83475604,29.6338012 5.62734863,28.6751122 C7.41994122,27.7164232 9.36843258,27.2058824 13.2492834,27.2058824 Z",
                                    id: "Rectangle-Copy-3",
                                    fill: "url(#linearGradient-4)"
                                }), (0, e.jsx)("path", {
                                    d: "M30.8453034,44.2612592 C30.8453034,44.8309235 30.7830721,45.343135 30.6586077,45.797909 C30.5341432,46.252683 30.3546298,46.6404319 30.1200622,46.9611673 C29.8854945,47.2819026 29.5970764,47.5284343 29.2547991,47.7007698 C28.9125218,47.8731052 28.5235761,47.9592716 28.0879505,47.9592716 C27.8725312,47.9592716 27.6714762,47.9389268 27.4847795,47.8982364 C27.2980828,47.8575461 27.1197662,47.7917246 26.9498243,47.7007698 C26.7798825,47.609815 26.6123367,47.4949264 26.4471819,47.3561006 C26.2820271,47.2172749 26.1132845,47.0497291 25.9409491,46.8534582 L25.9409491,47.549977 C25.9409491,47.6026351 25.9277848,47.646915 25.9014558,47.6828182 C25.8751268,47.7187215 25.8320435,47.7486404 25.7722049,47.7725758 C25.7123662,47.7965113 25.6321835,47.8132659 25.5316545,47.8228401 C25.4311255,47.8324143 25.3090564,47.8372013 25.1654436,47.8372013 C25.0170437,47.8372013 24.8937778,47.8324143 24.7956424,47.8228401 C24.6975069,47.8132659 24.618521,47.7965113 24.5586823,47.7725758 C24.4988437,47.7486404 24.4569572,47.7187215 24.4330217,47.6828182 C24.4090862,47.646915 24.3971187,47.6026351 24.3971187,47.549977 L24.3971187,38.1074793 C24.3971187,38.0596084 24.4114798,38.0165252 24.4402023,37.9782284 C24.4689249,37.9399316 24.5179919,37.9076192 24.5874048,37.8812902 C24.6568176,37.8549612 24.7489678,37.8346163 24.8638581,37.8202551 C24.9787484,37.8058938 25.1247526,37.7987132 25.3018751,37.7987132 C25.4789976,37.7987132 25.6250018,37.8058938 25.7398921,37.8202551 C25.8547824,37.8346163 25.9469326,37.8549612 26.0163455,37.8812902 C26.0857584,37.9076192 26.1348253,37.9399316 26.1635479,37.9782284 C26.1922705,38.0165252 26.2066316,38.0596084 26.2066316,38.1074793 L26.2066316,41.6475184 C26.3693928,41.4847572 26.5321516,41.3459335 26.6949128,41.2310432 C26.857674,41.1161529 27.0204328,41.0216092 27.1831941,40.9474092 C27.3459553,40.8732093 27.5135011,40.8193553 27.6858365,40.7858456 C27.8581719,40.7523359 28.0400788,40.7355813 28.2315626,40.7355813 C28.705485,40.7355813 29.107595,40.8301251 29.4379045,41.0192153 C29.7682141,41.2083056 30.0374841,41.4632145 30.2457228,41.7839499 C30.4539614,42.1046853 30.6059494,42.4792698 30.7016913,42.9077148 C30.7974332,43.3361598 30.8453034,43.7873368 30.8453034,44.2612592 Z M28.9711651,44.3905101 C28.9711651,44.1176457 28.9508203,43.8543594 28.91013,43.6006434 C28.8694396,43.3469273 28.7988311,43.1219373 28.6983021,42.9256664 C28.5977731,42.7293955 28.4673267,42.5726205 28.306959,42.4553366 C28.1465913,42.3380528 27.9443396,42.2794118 27.7001977,42.2794118 C27.5805204,42.2794118 27.4632383,42.2961663 27.348348,42.329676 C27.2334577,42.3631857 27.1149789,42.42063 26.992908,42.5020106 C26.8708371,42.5833912 26.7451777,42.6887057 26.6159261,42.8179573 C26.4866746,42.9472088 26.3502444,43.1075741 26.2066316,43.2990579 L26.2066316,45.4245175 C26.4603476,45.7500399 26.703289,45.9977684 26.9354631,46.1677102 C27.1676372,46.3376521 27.4105787,46.4226218 27.6642947,46.4226218 C27.8988624,46.4226218 28.0975238,46.362784 28.2602851,46.2431066 C28.4230463,46.1234292 28.5582797,45.967851 28.6659893,45.7763672 C28.773699,45.5848834 28.8514881,45.3670738 28.899359,45.122932 C28.94723,44.8787901 28.9711651,44.634652 28.9711651,44.3905101 Z M34.0347841,47.549977 C34.0347841,47.597848 34.020423,47.6397344 33.9917004,47.6756376 C33.9629779,47.7115409 33.9139109,47.7414597 33.844498,47.7653952 C33.7750851,47.7893307 33.6829349,47.807282 33.5680446,47.8192498 C33.4531544,47.8312175 33.3071502,47.8372013 33.1300276,47.8372013 C32.9529051,47.8372013 32.8069009,47.8312175 32.6920106,47.8192498 C32.5771204,47.807282 32.4849702,47.7893307 32.4155573,47.7653952 C32.3461444,47.7414597 32.2970774,47.7115409 32.2683548,47.6756376 C32.2396323,47.6397344 32.2252712,47.597848 32.2252712,47.549977 L32.2252712,38.1074793 C32.2252712,38.0596084 32.2396323,38.0165252 32.2683548,37.9782284 C32.2970774,37.9399316 32.3461444,37.9076192 32.4155573,37.8812902 C32.4849702,37.8549612 32.5771204,37.8346163 32.6920106,37.8202551 C32.8069009,37.8058938 32.9529051,37.7987132 33.1300276,37.7987132 C33.3071502,37.7987132 33.4531544,37.8058938 33.5680446,37.8202551 C33.6829349,37.8346163 33.7750851,37.8549612 33.844498,37.8812902 C33.9139109,37.9076192 33.9629779,37.9399316 33.9917004,37.9782284 C34.020423,38.0165252 34.0347841,38.0596084 34.0347841,38.1074793 L34.0347841,47.549977 Z M41.8485754,47.549977 C41.8485754,47.597848 41.8366078,47.6397344 41.8126723,47.6756376 C41.7887369,47.7115409 41.7468504,47.7414597 41.6870117,47.7653952 C41.627173,47.7893307 41.5481871,47.807282 41.4500517,47.8192498 C41.3519163,47.8312175 41.2286504,47.8372013 41.0802505,47.8372013 C40.9222763,47.8372013 40.7942235,47.8312175 40.696088,47.8192498 C40.5979526,47.807282 40.5201634,47.7893307 40.4627183,47.7653952 C40.4052732,47.7414597 40.3645835,47.7115409 40.340648,47.6756376 C40.3167125,47.6397344 40.3047449,47.597848 40.3047449,47.549977 L40.3047449,46.8103745 C39.9504999,47.1933421 39.5902764,47.4805635 39.2240636,47.6720473 C38.8578509,47.8635311 38.4784793,47.9592716 38.0859375,47.9592716 C37.6455248,47.9592716 37.2757272,47.8874663 36.9765338,47.7438534 C36.6773403,47.6002406 36.4355957,47.4039726 36.2512925,47.1550437 C36.0669894,46.9061147 35.9353462,46.6176966 35.8563591,46.2897806 C35.7773721,45.9618646 35.7378791,45.5537708 35.7378791,45.0654871 L35.7378791,41.1448759 C35.7378791,41.097005 35.7510434,41.0551185 35.7773725,41.0192153 C35.8037015,40.9833121 35.8515717,40.9533932 35.9209846,40.9294577 C35.9903975,40.9055222 36.0837444,40.8875709 36.2010283,40.8756032 C36.3183121,40.8636354 36.4631195,40.8576517 36.635455,40.8576517 C36.8125775,40.8576517 36.9585817,40.8636354 37.073472,40.8756032 C37.1883622,40.8875709 37.2805124,40.9055222 37.3499253,40.9294577 C37.4193382,40.9533932 37.4684052,40.9833121 37.4971278,41.0192153 C37.5258503,41.0551185 37.5402114,41.097005 37.5402114,41.1448759 L37.5402114,44.7639017 C37.5402114,45.0989983 37.561753,45.355104 37.6048369,45.5322266 C37.6479207,45.7093491 37.7137423,45.8613371 37.8023035,45.9881951 C37.8908648,46.1150531 38.0033598,46.2131871 38.139792,46.2826 C38.2762243,46.3520128 38.4353928,46.3867188 38.6173024,46.3867188 C38.847083,46.3867188 39.0780568,46.3029458 39.3102309,46.1353975 C39.542405,45.9678492 39.7901335,45.723711 40.0534237,45.4029756 L40.0534237,41.1448759 C40.0534237,41.097005 40.066588,41.0551185 40.092917,41.0192153 C40.1192461,40.9833121 40.1671163,40.9533932 40.2365292,40.9294577 C40.3059421,40.9055222 40.3980923,40.8875709 40.5129825,40.8756032 C40.6278728,40.8636354 40.773877,40.8576517 40.9509995,40.8576517 C41.1281221,40.8576517 41.2741263,40.8636354 41.3890165,40.8756032 C41.5039068,40.8875709 41.5948603,40.9055222 41.6618796,40.9294577 C41.7288989,40.9533932 41.7767692,40.9833121 41.8054917,41.0192153 C41.8342143,41.0551185 41.8485754,41.097005 41.8485754,41.1448759 L41.8485754,47.549977 Z M49.5187545,44.1607307 C49.5187545,44.3809371 49.4696875,44.5436959 49.3715521,44.6490119 C49.2734166,44.754328 49.1381832,44.8069853 48.9658478,44.8069853 L45.0667784,44.8069853 C45.0667784,45.0798497 45.0990908,45.3275782 45.1637166,45.5501781 C45.2283424,45.772778 45.3312634,45.9618654 45.4724827,46.117446 C45.613702,46.2730266 45.7956089,46.3915054 46.0182088,46.472886 C46.2408087,46.5542666 46.5076853,46.5949563 46.8188464,46.5949563 C47.1347947,46.5949563 47.4124421,46.572218 47.6517968,46.5267406 C47.8911516,46.4812632 48.0981903,46.4309994 48.2729193,46.3759478 C48.4476483,46.3208962 48.5924557,46.2706325 48.707346,46.2251551 C48.8222363,46.1796777 48.9155832,46.1569393 48.9873896,46.1569393 C49.0304735,46.1569393 49.0663762,46.1653166 49.0950987,46.1820715 C49.1238213,46.1988263 49.1477564,46.2287452 49.1669048,46.271829 C49.1860532,46.3149129 49.1992175,46.3759474 49.2063981,46.4549345 C49.2135788,46.5339216 49.2171691,46.6332523 49.2171691,46.7529297 C49.2171691,46.8582458 49.2147755,46.9480025 49.2099884,47.0222024 C49.2052014,47.0964024 49.1980208,47.1598305 49.1884466,47.2124885 C49.1788724,47.2651466 49.1645114,47.3094265 49.145363,47.3453297 C49.1262146,47.3812329 49.1010827,47.4159389 49.0699666,47.4494485 C49.0388505,47.4829582 48.9538808,47.5284349 48.8150551,47.5858801 C48.6762293,47.6433252 48.4991095,47.6995727 48.2836902,47.7546243 C48.0682709,47.8096759 47.8217392,47.8575461 47.5440877,47.8982364 C47.2664362,47.9389268 46.9696408,47.9592716 46.6536925,47.9592716 C46.0840282,47.9592716 45.584981,47.8874663 45.156536,47.7438534 C44.728091,47.6002406 44.370261,47.382431 44.0830353,47.0904182 C43.7958096,46.7984054 43.5815903,46.4298046 43.440371,45.9846048 C43.2991517,45.5394049 43.2285431,45.0176194 43.2285431,44.4192325 C43.2285431,43.8495682 43.302742,43.33616 43.4511419,42.8789924 C43.5995419,42.4218248 43.8149579,42.034076 44.0973965,41.7157341 C44.3798351,41.3973923 44.7233041,41.1544509 45.1278136,40.9869026 C45.5323231,40.8193542 45.9882871,40.7355813 46.4957191,40.7355813 C47.0318738,40.7355813 47.4902313,40.8145672 47.8708053,40.9725414 C48.2513794,41.1305155 48.5637326,41.3495218 48.8078745,41.6295669 C49.0520163,41.9096119 49.2315297,42.2411133 49.34642,42.6240809 C49.4613103,43.0070485 49.5187545,43.4235195 49.5187545,43.8735064 L49.5187545,44.1607307 Z M47.7666865,43.643727 C47.7810478,43.136295 47.6793236,42.7377753 47.4615107,42.448156 C47.2436979,42.1585368 46.9074095,42.0137293 46.4526355,42.0137293 C46.2228549,42.0137293 46.0229967,42.0568125 45.8530549,42.1429802 C45.683113,42.2291479 45.5418958,42.3452333 45.4293991,42.4912397 C45.3169023,42.6372461 45.2307359,42.8095789 45.1708972,43.0082433 C45.1110585,43.2069078 45.0763526,43.4187336 45.0667784,43.643727 L47.7666865,43.643727 Z",
                                    id: "blue",
                                    fill: "#FFFFFF"
                                })]
                            })
                        })
                    })
                })]
            });
        var iE = a(4750);
        var sE = a(5287);

        function aE(t) {
            return (0, e.jsx)("svg", {
                xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 116.446 84.924", ...t, children: (0, e.jsx)("path", {
                    fill: "currentColor",
                    "clip-rule": "evenodd",
                    d: "m35.805 39.467c1.512-1.608 5.559-0.682 6.96-2.4-0.595-1.9-4.07-4.608-4.319-6.96-0.112-1.057 0.563-1.379 0.96-2.64 0.243-0.775 0.004-1.643 0.239-2.16 0.681-1.492 2.526-2.548 2.88-4.08-1.356-6.734 4.686-8.103 8.641-10.32 4.301 0.146 9.927-1.066 13.68 0.96 0.113 0.754-0.646 0.634-0.72 1.2 0.339 0.541 1.563 0.197 1.439 1.2-1.327 1.862-4.511-0.112-5.52 1.68 0.646 0.634 1.735 0.824 2.4 1.44v2.64c-0.708 0.172-1.486 0.274-1.921 0.72 1.552 3.67-5.669 2.291-3.359 6 1.339-0.021 4.954-0.144 6.72-1.2 2.784-1.665 2.711-6.367 5.521-8.159 0.691-0.029 1.57 0.131 1.92-0.24 1.151-2.775 3.98-5.438 8.88-5.76 2.746-0.182 8.349-1.87 10.8 0.239 1.465 1.262 0.81 3.268 2.16 4.561 0.988 0.451 2.105 0.774 2.16 2.16 0.267 1.202-1.834 1.31-0.48 2.159-0.962 1.039-1.811 2.19-3.12 2.881-0.113 1.153 1.554 0.526 1.44 1.68-0.802 1.122-1.209 3.907-2.641 3.6-0.806 0.247-0.373-0.746-0.479-1.199-0.89 0.295-1.405 0.67-2.16 0-0.26 0.78-0.709 1.371-1.2 1.92 1.643 1.478 4.003 2.237 5.521 3.84 3.235-1.359 7.077-5.149 10.8-1.92 0.188 0.988-0.368 1.231-0.24 2.16 0.896 0.774 0.978-0.801 1.92-0.721 1.06 0.062 1.265 0.976 2.16 1.2 0.185 0.904-0.293 1.147-0.24 1.92 0.473 0.889 2.352 0.368 2.881 1.2 0.555 2.155-1.012 2.188-0.961 3.84 1.031 0.388 1.998-1.142 3.601-0.96 0.884 1.517 0.381 4.419 2.16 5.04 0.628 3.104-2.561 3.75-4.32 2.4-0.444 0.436-0.312 1.448-0.72 1.92-1.188 0.147-1.536-0.545-2.4-0.721-0.799 1.563 1.617 1.889 0.72 3.601-1.775-0.463-2.337 1.205-3.359 2.16-1.136-0.064-1.352-1.049-2.16-1.44-0.217 0.423-0.884 0.396-0.96 0.96-0.752 0.804 1.801 1.3 0.72 2.4-1.513 2.06-3.329-1.013-5.76 0-0.55-0.57-1.208-1.032-1.44-1.92-2.051 0.131-3.084-0.756-4.319-1.44-3.303-0.538-4.311 1.677-7.44 0.96 0.216 2.23 3.326 2.419 5.28 2.16 2.783 2.896 3.368 7.992 6.72 10.32 0.458-3.125 4.479 6.161 9.12 10.319 3.707-0.149 6.219 0.33 8.16 1.44 0.042 1.242-2.057 0.343-2.64 0.96 1.246 2.751 4.993-0.816 6.96-0.24-0.479 6.364-12.435 7.859-14.881 2.16-6.689-3.79-9.293-11.666-15.119-16.32-2.059-0.502-3.208-1.912-4.801-2.88-5.372 0.134-10.436 0.287-13.92-1.92-2.16 1.263-3.17 4.747-6 5.521-2.923 0.798-5.911-0.139-8.16 1.92-7.446 1.033-14.465 2.494-19.68 5.76-1.237 0.412-2.52-0.162-3.12 0.479 0.48 2.32 1.668 3.934 1.92 6.48-0.519 0.761-0.962 1.598-1.92 1.92 0.095 1.746 2.833 0.848 3.12 2.4-4.069 1.981-6.507-1.59-7.92-3.841 0.508-4.2-0.333-9.392 2.16-11.52 1.205-1.029 2.837-0.545 4.32-1.68 4.366 0.4 8.705-2.869 12.96-3.84 4.858-1.109 9.547-1.108 11.279-5.28-1.414-1.656-3.291-0.841-5.52-1.44-1.111-0.299-1.463-1.133-2.4-1.68-0.562-0.328-1.474-0.334-2.16-0.72-2.196-1.234-3.287-3.257-6.239-3.841-1.489-0.294-2.832-0.085-4.08-0.479-7.656-2.422-10.618-10.302-13.2-18.24-0.314-3.445-0.995-6.524-1.92-9.359-0.827-8.533-7.048-11.673-13.68-14.4-2.024-0.184-3.309 0.372-5.28 0.24-0.977-0.784-2.486-1.034-2.16-3.12 1.78-0.307 3.603-1.558 5.52-0.96 1.04-0.164 1.452-1.567 2.636-2.16 1.045-0.523 3.934-0.583 5.52-1.92 0.24-0.202 4.291-0.067 4.561 0 2.813 0.7 2.876 4.102 5.04 5.76-1.263 4.763 2.796 8.095 3.6 12.24 0.192 0.99-0.095 1.896 0 2.88 0.472 4.913 2.428 11.467 4.8 14.88 0.998 1.438 2.397 2.623 4.078 3.6z",
                    "fill-rule": "evenodd"
                })
            })
        }

        const oE = [{
            path: "/settings/wallet", element: (0, e.jsx)((() => {
                const t = st();
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("h3", {
                        children: (0, e.jsx)(cl, {
                            id: "cg1VJ2",
                            defaultMessage: "Connect Wallet"
                        })
                    }), (0, e.jsxs)("div", {
                        className: "wallet-grid", children: [(0, e.jsxs)("div", {
                            className: "card", onClick: () => t("/settings/wallet/lnc"), children: [(0, e.jsx)("img", {
                                src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlYAAAHGCAYAAAC2K8XBAAAACXBIWXMAAAsSAAALEgHS3X78AAAVVklEQVR42u3dz2/U95kH8AfHcShxyVA7ZWlXyqQr1SutRF3NwdrDqlNLu1KlRSV/wZrb3gD5DwD/ASPMsSfcveZQurm7jlSRjlajuORkVCXTgqAJpjUQaAw23oOH3TY/gMDY83m+fr2kKEoOycefZ/C855nP9/NEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVNY+W1B9R48erUfEmYg4HhG1gpbWjYiliDh/+fLlZZXqj0arPRMRP42IekRM7vL/fi0ilnu1fTciLnZmp9ZU5ev72aVrMy8N7fvp5qOtQdTx/7wyPBQvD+2LV0eG4uArL1V925c+98/v/tXvqm5EdKcnxrtenQhWQtX7hQWqLzN3+fLlsyr2QoFqMiIuDPJN+CvMR8ScgPVs/vuDjyc/+XTjF5tbW/XS1vbK8FAcfvXleGV4z791LPf++m1ELE9PjC955SJY7Z1gdSEiZpIs963Lly9fVLXnClW1iPio4AC9HBEnOrNTOpNP8LNL12ovv7Tvo4ebW8V+EBraty/ePPRKDHn3+Lyl6HVppyfGvc73sCFbUHnHE631jHI9t1NRdldyMiJ+0QuAfIVXR4bOlRyqIiIebW3FrfsbivVFzd7vsPcXV1Y/WlxZvbC4stq0LYIV1ZPpjWxSuZ7byQRrrEfEOaX6ag82t1J8ELqzvqlYT3+tz0TEr3oh6+ziymrdtghWQAKNVrueKEDP9NbL5yyurE6W3q167NHWVqxvbCnas4esMxGhiyVYAYl+cWfiK98vce3Og1Rfkz7aEqye54NFbHexfiVgCVYAfXtzabTa3lQ+5y8PH9mEvaPZC1gXfEUoWAGF6fzm13H//r1sy9a1gu0O1vuLK6tnbYVgBRTkWvfDdJ/Yda0gIrbPR55ZXFl9f3Fl1QM8ghVQgrt3bsfdO7ezLVvXCv7fZGx3r07ZCsEKKMCNa3/ItmRdK/iic4srq79YXFl155tgBQzS3Tu349bNT7It+4LKwRccj+3D7XVbIVgBA3Q9X9eq3hsaDfytx18NOnclWAGD8mD9s4xdK2et4MvVYrtzJVwJVsCgXP39h7G5mWqWm64VCFeCFVCmzY2N+OTG9WzLPmdAMwhXghVQpI//eD1b16oWER4zh6eHq7qtEKyAXba5sZHxIPtJXSt4arhyFYNgBQzCJzeux4P19WxvGrpW8GST4ZoSwQoYjKRdq7rKwRMdd0O7YAUMwK2bH2cb0FwL1y/AszjjMLtgBQxAwgHNM7pW8EwfQnwlKFgBu82AZqisSV8JClbAACQc0KxrBc/4IcRTgoIVsMsMaIbKqkXEOdsgWAG7LOETgs1Gq91UOXiqGReHClbALjOgGSrNnxXBCthtCQc061rBs9G1EqyA3ZZ1QLPKwTM5aQsEK2CXJRzQPNlotWdUDp5qxhOCghWwy5IOaHZ+BJ6uFhHHbYNgBeyyhAOa67pW8Ez+wxYIVsAAZOxaNVptX3PAkzUdYhesgAFIOKC5HhHGd8DT+TpQsAIGIeGA5pO6VvBUP7UFghUwAAkHNNdC1wqepunpQMEKGJCEA5p1reAZwpUtGIxhWwB72+MBzWOvfzvLkmuxff3CadUrxnJErCVZ62TvNVR1P4qIi16aghUwANev/SFTsIqIONVotc93Zqe6qjfwQPXW9MR4ujosrqxO9kLWD2L7sHe9YrVpenkKVsCAPB7QnCxcnYmIE6o3UKczhqqIiOmJ8eVeMIyION0LWid7IasKHa1JL8/BcMYKiIiUA5pnGq12XeUGYytibXpifKkqP8/0xPjy9MT4iYh4MyLmq/AzLa6sNr1SBStgQAxo5ut4tLW1XMWfa3pifG16Yvx0RPw48pwb+yq6VoIVMEgJBzQfb7TaPpWzEwFrqQLh6g2VFKyAAdrc2Iir3Y+yLduAZnYqXC1HxFuJfwQdK8EKGLRbNz/ONqC5qWvFDoarpYiYE6wQrIDnlnFAs6qxg+Yj51eCLtIVrIAS3Lr5cbZRN81Gq23wLDtiemJ8LSLOZ1z74spqXQUFK6AACUfdeEKQnbSQdN2ClWAFlCDhgOZ6o9WeUTl2Qu8i1GU7gWAFPLdrv/8w25KdtWIn/TLhmpvKJlgBhbh/717cuvlJpiXXG632KZVjhyzZAgQr4IVkfEKw0Wp7Goq+q9IIHwQrYEAerH8Wn/wx1aibWkToWrFT1mwBghXwQq5f+0O2UTcnda3YIQ6wI1gBLybhgGZdK0CwAsqVcEDzmUarXVc5+ixbx+pHSiZYAQUyoBkiIuK2LUCwAvoi4YDmGV0rQLACimVAM4BgBfRJwgHNM41We1LlAMEKKJIBzQCCFdAnCQc0NxutdlPlAMEKKJIBzQCCFdAnCQc061oBghVQroRPCF5QNUCwAoqUcEBzvdFqz6gcIFgBRUo4oNlZK0CwAsqUcECzrhUgWAHlSjig+Vyj1a6pHCBYAcVJOKC5FhGnVA4QrIAiJRzQfFLXChCsgGIlu35B1woQrIByJRzQrGsFCFZAuW7k61oZ0AwIVkCZEg5onmm02nWVAwQroEgGNAOCFUCfJBzQrGsFCFZAuQxoBgQrgD5JOKC52Wi1myoHCFZAkQxoBgQrgD5JOKBZ1woQrIByJRzQrGsFCFZAmRIOaG42Wu0ZlQMEK6BICQc061oBghVQrmTXL9R1rQDBCihWwgHNulaAYAWU60a+rtVZVQMEK6BId+/cjs5vfv3jiDiRZMknG612TeUAwQooVmd2aiEilhMstRYRp1QMEKyA0p1Osk5dK0CwAsrWmZ1aioilBEuthYPsgGAFJDCXZJ2nGq12XbkAwQooVq9rdTHJcnWtAMEKKF6Ws1YzulaAYAUUrTM71Y2IhSTL1bUCBCugeFnOWs00Wu2mcgGCFVCsXtcqS7jStQIEK6B48xGxlmCdTV0rQLACitaZnVqLiPNJlqtrBQhWQPEyda2OKxcgWAHF6nWtsly/cE7FAMEKKD1cLUREN8FS641We0bFAMEKKJ0nBAHBCqAfel2r5QRLrTda7VMqBghWQOmynLU602i1a8oFCFZAsXoDmpcSLLUWEbpWgGAFFC/LWauTulaAYAUUTdcKEKwA+utEknWebLTadeUCwQqgWL0BzQsJlloL1y+AYGULgASynLWa0bUCwQqgaL2u1XyS5epagWAFULy5yDGgeabRak8qFwhWAMXqDWg+n2S5BjSDYAVQvPnI0bVqNlrtpnKBYAVQrF7XyoBmQLAC6FO4mo+IboKl6lqBYAWQQpaulbNWIFgBlK0zO7UQObpWk41We0bFQLACKF2WUTfOWoFgBVC2RAOa67pWIFgBZJDmCcFGq11TLhCsAIqVqWsVEadUDAQrgNJlOWt1UtcKBCuAovUGNC8kWGotdK1AsAJIIMtZK10rEKwAytbrWs0nWGotXBoKghVAAnORY0DzTKPVrisXCFYAxeoNaD6fZLkuDQXBCqB486FrBQhWAC+u17UyoBkQrAD6FK7mI8eA5uONVrupYiBYAZQuzagbpQLBCqBondmphcjRtWrqWoFgBZBBllE3ulYgWAGULdGA5maj1Z5RMRCsAEqX5gnB//qfG+du3FlXMRCsAMqUqGtV+2zj0WTn6l1FA8EKoGinsyz0+p316P7pMxUDwQqgTJ3ZqeWIWMiy3ve6a4oGghVA0bKctYq765tx5eZ9FQPBCqBMndmpbiTqWl3q3o4HG48UDgQrgGKdjhwDmuPBxqP44I/3VAwEK4Ay9QY0n8+y3g9ufKprBYIVQNHmI1HXqnPN9QsgWAEUKmPX6u76psKBYAVQbLg6GzkGNG+v9+odRQPBCqBoaa5fuHLzfhh1A4IVQLE6s1MLkapr5awVCFYAZUs16kbXCgQrgGJ1ZqcuRo4BzRGxfWkoIFgBlCzNWatb9x4adQOCFUC5OrNTS5Goa+UJQRCsAEqX5qzV3fXN+ODGpyoGghVAmTqzU8uRaEBz59pdo25AsAIoWpqzVgY0g2AFULTO7FQ3EnWtjLoBwQqgdKcj04BmB9lBsAIoVbYBzVdu3te1AsEKoGjzkaRrFRHxXndNxUCwAihTtq5V90+fGXUDghVA0eHqbBjQDAhWAH2T5voFA5pBsAIoWmd2aiESda2WfvdnRQPBCqBoabpWd9c3DWgGwQqgXL2u1VKa9V69Y9QNCFYARUvVtTLqBgQrgGJ1ZqeWIlHX6oMbn+pa7bw3kq3XZWeCFUBRDGjmr9WTrfe3SiZYARSj17VaSLPeq3eMugHBCqBoc5kWa0DzjmraAgQrgBcJKrNT3UjUtbpy837cuvdQ4fpscWW1bhcQrAD6Yy5SDWi+rWL9N2kLEKwA+qDXtUozoNmomx3xo4Rr9lSgYAVQrPlMb1QGNPfd8YRrXlY2wQqgzKAyO7UWybpWRt30x+LK6mTku2oBwQqgePORaECzJwT75mTSdetYCVYABQeV7a6VAc17SO9pwJmMa5+eGHfGSrACKD5cLUSirtWl7m2jbl7MhaTr1q0SrADSMOpmD1hcWT0VeS8F1a0SrNjrjh49WrMLZNDrWi1lWa8Bzc8VqmYi4lziH+FdVRSswAV8ZJKqa3XJpaFfJ1Sdi7xfAT7WVUnBCuq2gCx6A5qXsqz3ys37fRvQ/NK+fc2KBqqZxZXVjyLiVAV+HGesBCuIH9gCktmzA5p7X5VVIUzVF1dWT/UC1YWqfMCbnhgXrAZg2BZQitHR0RgbG2u+8cYbtXfeecehS3IEldmppUarvRBJHse/cvN+THz7QBw5+Eo//nPnFldWaxGxkOGx/t5aHx83aEbEG72/1yv40lzyp1OwYg+r1Wrx2muvRe+X3vvHjh2bi4jld955xycuMpiLRPccda7ejX//p74Eq1psH+4+t7iy6lVQFgfXBSv2qrGxsRgdHf3rf1WP3qHRY8eO2aCnuPVgOS6NOPM/0KAyO9XN1LV6PKC5T10ryrRkCwbDGSsG9+IbGvqyUAVZzUWie4OWfvdnFauutemJccFKsGKvharDhw8LVVRGZ3aqG4kGNBt1U2lClWDFXgxVIyMjNoOqmY9EXSsDmivrl7ZAsGKPGBkZie9+97tCFZXUG9CcqmvVuXZX4arnoi0QrNgjoerw4cMxNORlR6XNR6Ibr426qZwUV18IVvCCRkdHhSr2hF7XyoBmBuXntkCwYg+EqrGxMaGKvRSuFiJZ16pfo24YqK6nAQUrKq5Wq8XY2JiNYC9K1bVykL0SztsCwYoKGxsbe3ybOuw5va5VmskB/RzQzECsRcSCbRCsqOKLamgoXn/9dXdUQcTpTIt916WhmZ13aF2woqKh6vDhw3HgwAGbwZ7XmZ1aikSXNT4edUM6a7H9NCqCFVUyPDzs4k/4orlMi+1cda9VxteYbpVgRcWMjIzEkSNHhCr4fFDZ7lqlubDx+p316P7pM4XLozs9Ma5bJVhRtVDljip4olRnrd7ran4kcsIWCFZUyOjoaBw5ckSogifoDWheyLJeA5rTmHdvlWBFxUKVO6rgmaU6a3Wpe9uom7J1s72mBCt4gkOHDglV8DX0ulZG3dAvJxxYF6yoiLGxsTh48KCNgK9vPrYfjU/BgOZinfYVoGBFFV4svTuqXPwJz6c3oDnN2JEHG4+ic831C4VZ8BSgYEWFQtX+/fttBryYdF0ro26KsTw9Me4pQMGK7B5fp+COKnhxva5VqusXDGguI1RFxI9tg2CFUAV8MVwtxPZTXSlcuXk/bt17qHADDlUOqwtWJLd//34Xf8LOSfWo/Hvd2yomVCFY8bxGR0eFKthBva7Vcpb1GtAsVCFY8QKhyh1VsCtSnbW6pGu1mxamJ8Z/KFQJViQ3NjYmVMEu6Q1oXsqy3lv3Hhp1sztOePpPsKIiocodVbDrUp218oTgjupGxA+nJ8YXbIVgReYXgYs/YXBBZbtrdTHLeu+ub8YHNz5VuP6b74WqZVshWFGBUOXiTxioXPdaXbsb65tG3fTJ4wPqp52nEqxIbmRkJI4cOeKOKhh0UNke0LyQZb0PNh651+rFdWP7LNUPzf0TrKhIqDp8+HAMDw/bDHabT+Vfbs7e7JlANRfOUglWVMeBAwfcUVUhB7eSnXd5e9YZki/R61qlGdD8nYOvKNrXsxzbHao3pyfGz/raT7CiIt2B0dHReP3114WqCnl5ayNTuLqoYk8MV2cjwfULhw4Mxzde9jvkGX//LsT2GSodqj3C90DVdzEiZiIiDh48GIcOHbIjFfS9jWux/PI/Zljqz1Xrqd6KiF9FxGSpC/y3739LlZ4cpi5GxC+nJ8Z9kNiD9tmCajt69OhkRLzvjqrquzQyGbeGaiUvcSHennXp4TNqtNrnIuJUaev6h7FvxH/+83cU6G+D1HJEvBsRF12XgGC1B/zkJz/5aHh4uG4nqu3hvuG4MlyPD1/6+xKXNxdvz55Vpa8drpoRcTIijpewnn9587X41+9/ay9/DbjcC1LvxvYh9GVBCsFqDzp27FgtIs70fjkLWBV3f9/+uDVUi7/s2x+rT+lgbcRLa7eHvrkTbwxrEfHb3pvPxXh71kHdFwtYtYhoxvbXg2/s5p/jo0dG4+++ORJHj7wah79Z6atZ3v2S1/DjPxvLDpsDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADshP8FkLPJRKEMg60AAAAASUVORK5CYII=",
                                width: 100
                            }), (0, e.jsx)("h3", {className: "f-end", children: "LND with LNC"})]
                        }), (0, e.jsxs)("div", {
                            className: "card",
                            onClick: () => t("/settings/wallet/lndhub"),
                            children: [(0, e.jsx)(rE, {width: 100, height: 100}), (0, e.jsx)("h3", {
                                className: "f-end",
                                children: "LNDHub"
                            })]
                        }), (0, e.jsxs)("div", {
                            className: "card",
                            onClick: () => t("/settings/wallet/nwc"),
                            children: [(0, e.jsx)(aE, {width: 100, height: 100}), (0, e.jsx)("h3", {
                                className: "f-end",
                                children: "Nostr Wallet Connect"
                            })]
                        })]
                    })]
                })
            }), {})
        }, {
            path: "/settings/wallet/lnc", element: (0, e.jsx)((() => {
                const {formatMessage: n} = al(),
                    r = st(), [i, s] = (0, t.useState)(), [o, l] = (0, t.useState)(), [c, u] = (0, t.useState)(), [d, h] = (0, t.useState)(), [f, p] = (0, t.useState)();
                return (0, e.jsxs)(e.Fragment, {
                    children: [c ? null : (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("h4", {
                            children: (0, e.jsx)(cl, {
                                id: "Z4BMCZ",
                                defaultMessage: "Enter pairing phrase"
                            })
                        }), (0, e.jsxs)("div", {
                            className: "flex",
                            children: [(0, e.jsx)("div", {
                                className: "f-grow mr10",
                                children: (0, e.jsx)("input", {
                                    type: "text",
                                    placeholder: n({id: "8v1NN+", defaultMessage: "Pairing phrase"}),
                                    className: "w-max",
                                    value: i,
                                    onChange: e => s(e.target.value)
                                })
                            }), (0, e.jsx)(Vd, {
                                onClick: () => async function (e) {
                                    try {
                                        const {LNCWallet: t} = await Promise.all([a.e(669), a.e(516)]).then(a.bind(a, 1516)),
                                            n = await t.Initialize(e), r = await n.getInfo();
                                        u(n), h(r)
                                    } catch (e) {
                                        e instanceof Error ? l(e.message) : l(n({
                                            id: "qDwvZ4",
                                            defaultMessage: "Unknown error"
                                        }))
                                    }
                                }((0, Ks.Wg)(i)),
                                disabled: !i,
                                children: (0, e.jsx)(cl, {id: "+vVZ/G", defaultMessage: "Connect"})
                            })]
                        }), o && (0, e.jsx)("b", {className: "error p10", children: o})]
                    }), c ? (0, e.jsxs)("div", {
                        className: "flex f-col",
                        children: [(0, e.jsx)("h3", {
                            children: (0, e.jsx)(cl, {
                                id: "1c4YST",
                                defaultMessage: "Connected to: {node} ",
                                values: {node: null == d ? void 0 : d.alias}
                            })
                        }), (0, e.jsx)("h4", {
                            children: (0, e.jsx)(cl, {
                                id: "2LbrkB",
                                defaultMessage: "Enter password"
                            })
                        }), (0, e.jsxs)("div", {
                            className: "flex w-max",
                            children: [(0, e.jsx)("div", {
                                className: "f-grow mr10",
                                children: (0, e.jsx)("input", {
                                    type: "password",
                                    placeholder: n({id: "lTbT3s", defaultMessage: "Wallet password"}),
                                    className: "w-max",
                                    value: f,
                                    onChange: e => p(e.target.value)
                                })
                            }), (0, e.jsx)(Vd, {
                                onClick: () => {
                                    return e = (0, Ks.Wg)(f), null == c || c.setPassword(e), Wu.uo.add({
                                        id: Ju(),
                                        kind: Wu.XF.LNC,
                                        active: !0,
                                        info: (0, Ks.Wg)(d)
                                    }), void r("/wallet");
                                    var e
                                },
                                disabled: (null !== (m = null == f ? void 0 : f.length) && void 0 !== m ? m : 0) < 8,
                                children: (0, e.jsx)(cl, {id: "jvo0vs", defaultMessage: "Save"})
                            })]
                        })]
                    }) : null]
                });
                var m
            }), {})
        }, {
            path: "/settings/wallet/lndhub", element: (0, e.jsx)((() => {
                const n = st(), {formatMessage: r} = al(), [i, s] = (0, t.useState)(), [a, o] = (0, t.useState)();
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("h4", {
                        children: (0, e.jsx)(cl, {
                            id: "KAhAcM",
                            defaultMessage: "Enter LNDHub config"
                        })
                    }), (0, e.jsxs)("div", {
                        className: "flex",
                        children: [(0, e.jsx)("div", {
                            className: "f-grow mr10",
                            children: (0, e.jsx)("input", {
                                type: "text",
                                placeholder: "lndhub://username:password@lndhub.io",
                                className: "w-max",
                                value: i,
                                onChange: e => s(e.target.value)
                            })
                        }), (0, e.jsx)(Vd, {
                            onClick: () => async function (e) {
                                try {
                                    const t = new iE.Z(e);
                                    await t.login();
                                    const r = await t.getInfo(),
                                        i = {id: Ju(), kind: Wu.XF.LNDHub, active: !0, info: r, data: e};
                                    Wu.uo.add(i), n("/wallet")
                                } catch (e) {
                                    e instanceof Error ? o(e.message) : o(r({
                                        id: "qDwvZ4",
                                        defaultMessage: "Unknown error"
                                    }))
                                }
                            }((0, Ks.Wg)(i)),
                            disabled: !i,
                            children: (0, e.jsx)(cl, {id: "+vVZ/G", defaultMessage: "Connect"})
                        })]
                    }), a && (0, e.jsx)("b", {className: "error p10", children: a})]
                })
            }), {})
        }, {
            path: "/settings/wallet/nwc", element: (0, e.jsx)((() => {
                const n = st(), {formatMessage: r} = al(), [i, s] = (0, t.useState)(), [a, o] = (0, t.useState)();
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("h4", {
                        children: (0, e.jsx)(cl, {
                            id: "1R43+L",
                            defaultMessage: "Enter Nostr Wallet Connect config"
                        })
                    }), (0, e.jsxs)("div", {
                        className: "flex",
                        children: [(0, e.jsx)("div", {
                            className: "f-grow mr10",
                            children: (0, e.jsx)("input", {
                                type: "text",
                                placeholder: "nostr+walletconnect:<pubkey>?relay=<relay>&secret=<secret>",
                                className: "w-max",
                                value: i,
                                onChange: e => s(e.target.value)
                            })
                        }), (0, e.jsx)(Vd, {
                            onClick: () => async function (e) {
                                try {
                                    const t = new sE.R(e);
                                    await t.login();
                                    const r = await t.getInfo(),
                                        i = {id: Ju(), kind: Wu.XF.NWC, active: !0, info: r, data: e};
                                    Wu.uo.add(i), n("/wallet")
                                } catch (e) {
                                    e instanceof Error ? o(e.message) : o(r({
                                        id: "qDwvZ4",
                                        defaultMessage: "Unknown error"
                                    }))
                                }
                            }((0, Ks.Wg)(i)),
                            disabled: !i,
                            children: (0, e.jsx)(cl, {id: "+vVZ/G", defaultMessage: "Connect"})
                        })]
                    }), a && (0, e.jsx)("b", {
                        className: "error p10",
                        children: a
                    }), (0, e.jsx)("p", {
                        children: (0, e.jsx)(cl, {
                            id: "cFbU1B",
                            defaultMessage: "Using Alby? Go to {link} to get your NWC config!",
                            values: {
                                link: (0, e.jsx)(Rt, {
                                    to: "https://nwc.getalby.com/",
                                    target: "_blank",
                                    children: "nwc.getalby.com"
                                })
                            }
                        })
                    })]
                })
            }), {})
        }, {
            path: "/settings/wallet/cashu", element: (0, e.jsx)((() => {
                const n = st(), {formatMessage: r} = al(), [i, s] = (0, t.useState)(), [o, l] = (0, t.useState)();
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("h4", {
                        children: (0, e.jsx)(cl, {
                            id: "KoFlZg",
                            defaultMessage: "Enter mint URL"
                        })
                    }), (0, e.jsxs)("div", {
                        className: "flex",
                        children: [(0, e.jsx)("div", {
                            className: "f-grow mr10",
                            children: (0, e.jsx)("input", {
                                type: "text",
                                placeholder: "Mint URL",
                                className: "w-max",
                                value: i,
                                onChange: e => s(e.target.value)
                            })
                        }), (0, e.jsx)(Vd, {
                            onClick: () => async function (e) {
                                try {
                                    if (!i) throw new Error("Mint URL is required");
                                    const {CashuWallet: t} = await Promise.all([a.e(983), a.e(808)]).then(a.bind(a, 498)),
                                        r = new t(e);
                                    await r.login();
                                    const s = await r.getInfo(),
                                        o = {id: Ju(), kind: Wu.XF.Cashu, active: !0, info: s, data: i};
                                    Wu.uo.add(o), n("/wallet")
                                } catch (e) {
                                    e instanceof Error ? l(e.message) : l(r({
                                        id: "qDwvZ4",
                                        defaultMessage: "Unknown error"
                                    }))
                                }
                            }((0, Ks.Wg)(i)),
                            disabled: !i,
                            children: (0, e.jsx)(cl, {id: "+vVZ/G", defaultMessage: "Connect"})
                        })]
                    }), o && (0, e.jsx)("b", {className: "error p10", children: o})]
                })
            }), {})
        }];

        function lE(n) {
            var r;
            let {handle: i} = n;
            const {formatMessage: s} = al(),
                a = hc(), [o, l] = (0, t.useState)(null !== (r = i.lnAddress) && void 0 !== r ? r : ""), [c, u] = (0, t.useState)("");
            return (0, e.jsxs)("div", {
                className: "card",
                children: [(0, e.jsx)("h4", {
                    children: (0, e.jsx)(cl, {
                        id: "SOqbe9",
                        defaultMessage: "Update Lightning Address"
                    })
                }), (0, e.jsx)("p", {
                    children: (0, e.jsx)(cl, {
                        id: "b5vAk0",
                        defaultMessage: "Your handle will act like a lightning address and will redirect to your chosen LNURL or Lightning address"
                    })
                }), (0, e.jsxs)("div", {
                    className: "flex",
                    children: [(0, e.jsx)("div", {
                        className: "f-grow",
                        children: (0, e.jsx)("input", {
                            type: "text",
                            className: "w-max mr10",
                            placeholder: s({id: "yCLnBC", defaultMessage: "LNURL or Lightning Address"}),
                            value: o,
                            onChange: e => l(e.target.value)
                        })
                    }), (0, e.jsx)(Vd, {
                        onClick: () => async function () {
                            if (!a) return;
                            const e = {lnAddress: o};
                            u("");
                            try {
                                const e = new ai.LNURL(o);
                                await e.load()
                            } catch {
                                return void u(s({id: "0jOEtS", defaultMessage: "Invalid LNURL"}))
                            }
                            const t = new $b(a, `${oi}/api/v1/n5sp`), n = await t.patch(i.id, e);
                            "error" in n && u(n.error)
                        }(), children: (0, e.jsx)(cl, {id: "BWpuKl", defaultMessage: "Update"})
                    })]
                }), c && (0, e.jsx)("b", {className: "error", children: c})]
            })
        }

        function cE(n) {
            let {handle: r} = n;
            const i = hc(),
                s = st(), {formatMessage: a} = al(), [o, l] = (0, t.useState)(""), [c, u] = (0, t.useState)([]);
            return (0, e.jsxs)("div", {
                className: "card",
                children: [(0, e.jsx)("h4", {
                    children: (0, e.jsx)(cl, {
                        id: "5u6iEc",
                        defaultMessage: "Transfer to Pubkey"
                    })
                }), (0, e.jsxs)("div", {
                    className: "flex",
                    children: [(0, e.jsx)("div", {
                        className: "f-grow",
                        children: (0, e.jsx)("input", {
                            type: "text",
                            className: "w-max mr10",
                            placeholder: a({id: "VR5eHw", defaultMessage: "Public key (npub/nprofile)"}),
                            value: o,
                            onChange: e => l(e.target.value)
                        })
                    }), (0, e.jsx)(Vd, {
                        onClick: () => async function () {
                            if (!o || !i) return;
                            const e = new $b(i, `${oi}/api/v1/n5sp`);
                            u([]);
                            const t = await e.transfer(r.id, o);
                            "error" in t ? u(t.errors) : s(-1)
                        }(), children: (0, e.jsx)(cl, {id: "DtYelJ", defaultMessage: "Transfer"})
                    })]
                }), c && (0, e.jsx)("b", {className: "error", children: c})]
            })
        }

        const uE = [{
            path: "/settings/handle", element: (0, e.jsx)((function () {
                const t = st();
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("h3", {
                        onClick: () => t("/settings/handle"),
                        className: "pointer",
                        children: (0, e.jsx)(cl, {id: "9pMqYs", defaultMessage: "Nostr Address"})
                    }), (0, e.jsx)(yt, {})]
                })
            }), {}), children: [{
                path: "", element: (0, e.jsx)((function () {
                    const n = st(), r = hc(), [i, s] = (0, t.useState)([]);
                    return (0, t.useEffect)((() => {
                        (async function () {
                            if (!r) return;
                            const e = new $b(r, `${oi}/api/v1/n5sp`), t = await e.list();
                            s(t)
                        })().catch(console.error)
                    }), [r]), (0, e.jsxs)(e.Fragment, {
                        children: [0 === i.length && (0, e.jsx)(cl, {
                            id: "mErPop",
                            defaultMessage: "It looks like you dont have any, check {link} to buy one!",
                            values: {
                                link: (0, e.jsx)(Rt, {
                                    to: "/verification",
                                    children: (0, e.jsx)(cl, {id: "FpxElY", defaultMessage: "Verification"})
                                })
                            }
                        }), i.map((t => {
                            var r;
                            return (0, e.jsxs)("div", {
                                className: "card flex",
                                children: [(0, e.jsx)("div", {
                                    className: "f-grow",
                                    children: (0, e.jsxs)("h4", {
                                        className: "nip05",
                                        children: [t.handle, "@", (0, e.jsx)("span", {
                                            className: "domain",
                                            "data-domain": null === (r = t.domain) || void 0 === r ? void 0 : r.toLowerCase(),
                                            children: t.domain
                                        })]
                                    })
                                }), (0, e.jsx)("div", {
                                    children: (0, e.jsx)("button", {
                                        onClick: () => n("manage", {state: t}),
                                        children: (0, e.jsx)(cl, {id: "0Azlrb", defaultMessage: "Manage"})
                                    })
                                })]
                            }, t.id)
                        })), i.length > 0 && (0, e.jsx)("button", {
                            onClick: () => n("/verification"),
                            children: (0, e.jsx)(cl, {id: "5oTnfy", defaultMessage: "Buy Handle"})
                        })]
                    })
                }), {})
            }, {
                path: "manage", element: (0, e.jsx)((function () {
                    var t;
                    const n = it().state;
                    return n ? (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsxs)("h3", {
                            className: "nip05",
                            children: [n.handle, "@", (0, e.jsx)("span", {
                                className: "domain",
                                "data-domain": null === (t = n.domain) || void 0 === t ? void 0 : t.toLowerCase(),
                                children: n.domain
                            })]
                        }), (0, e.jsx)(lE, {handle: n}), (0, e.jsx)(cE, {handle: n})]
                    }) : (0, e.jsx)(gt, {to: "/settings/handle"})
                }), {})
            }]
        }], dE = [{
            path: "", element: (0, e.jsx)((() => {
                const t = Qs(), n = st(), r = Db(Xs.allSubscriptions());
                return (0, e.jsx)(e.Fragment, {
                    children: (0, e.jsxs)("div", {
                        className: "settings-nav", children: [(0, e.jsx)(Xw, {
                            title: (0, e.jsxs)("div", {
                                className: "flex",
                                children: [(0, e.jsx)(Gl, {
                                    name: "user",
                                    className: "mr10"
                                }), (0, e.jsx)(cl, {id: "TwyMau", defaultMessage: "Account"})]
                            }), className: "settings-group-header", children: (0, e.jsxs)("div", {
                                className: "card",
                                children: [(0, e.jsxs)("div", {
                                    className: "settings-row inner",
                                    onClick: () => n("profile"),
                                    children: [(0, e.jsx)(Gl, {name: "profile"}), (0, e.jsx)(cl, {...Jw}), (0, e.jsx)(Gl, {name: "arrowFront"})]
                                }), (0, e.jsxs)("div", {
                                    className: "settings-row inner",
                                    onClick: () => n("relays"),
                                    children: [(0, e.jsx)(Gl, {name: "relay"}), (0, e.jsx)(cl, {...ex}), (0, e.jsx)(Gl, {name: "arrowFront"})]
                                }), (0, e.jsxs)("div", {
                                    className: "settings-row inner",
                                    onClick: () => n("keys"),
                                    children: [(0, e.jsx)(Gl, {name: "key"}), (0, e.jsx)(cl, {
                                        id: "08zn6O",
                                        defaultMessage: "Export Keys"
                                    }), (0, e.jsx)(Gl, {name: "arrowFront"})]
                                }), (0, e.jsxs)("div", {
                                    className: "settings-row inner",
                                    onClick: () => n("handle"),
                                    children: [(0, e.jsx)(Gl, {name: "badge"}), (0, e.jsx)(cl, {
                                        id: "wYSD2L",
                                        defaultMessage: "Nostr Adddress"
                                    }), (0, e.jsx)(Gl, {name: "arrowFront"})]
                                }), (0, e.jsxs)("div", {
                                    className: "settings-row inner",
                                    onClick: () => n("/subscribe/manage"),
                                    children: [(0, e.jsx)(Gl, {name: "diamond"}), (0, e.jsx)(cl, {
                                        id: "R/6nsx",
                                        defaultMessage: "Subscription"
                                    }), (0, e.jsx)(Gl, {name: "arrowFront"})]
                                }), r && (0, e.jsxs)("div", {
                                    className: "settings-row inner",
                                    onClick: () => n("accounts"),
                                    children: [(0, e.jsx)(Gl, {name: "code-circle"}), (0, e.jsx)(cl, {
                                        id: "7BX/yC",
                                        defaultMessage: "Account Switcher"
                                    }), (0, e.jsx)(Gl, {name: "arrowFront"})]
                                })]
                            })
                        }), (0, e.jsxs)("div", {
                            className: "settings-row",
                            onClick: () => n("preferences"),
                            children: [(0, e.jsx)(Gl, {name: "gear"}), (0, e.jsx)(cl, {...ax}), (0, e.jsx)(Gl, {name: "arrowFront"})]
                        }), (0, e.jsxs)("div", {
                            className: "settings-row",
                            onClick: () => n("wallet"),
                            children: [(0, e.jsx)(Gl, {name: "wallet"}), (0, e.jsx)(cl, {
                                id: "3yk8fB",
                                defaultMessage: "Wallet"
                            }), (0, e.jsx)(Gl, {name: "arrowFront"})]
                        }), (0, e.jsxs)("div", {
                            className: "settings-row",
                            onClick: () => n("/donate"),
                            children: [(0, e.jsx)(Gl, {name: "heart"}), (0, e.jsx)(cl, {...ox}), (0, e.jsx)(Gl, {name: "arrowFront"})]
                        }), (0, e.jsxs)("div", {
                            className: "settings-row",
                            onClick: () => n("/zap-pool"),
                            children: [(0, e.jsx)(Gl, {name: "piggy-bank"}), (0, e.jsx)(cl, {
                                id: "i/dBAR",
                                defaultMessage: "Zap Pool"
                            }), (0, e.jsx)(Gl, {name: "arrowFront"})]
                        }), (0, e.jsxs)("div", {
                            className: "settings-row",
                            onClick: function () {
                                !function (e) {
                                    Xs.removeSession(e)
                                }((0, Ks.Wg)(t.publicKey)), n("/")
                            },
                            children: [(0, e.jsx)(Gl, {name: "logout"}), (0, e.jsx)(cl, {...lx}), (0, e.jsx)(Gl, {name: "arrowFront"})]
                        })]
                    })
                })
            }), {})
        }, {
            path: "profile", element: (0, e.jsx)((function (n) {
                var r;
                const i = st(), {publicKey: s} = Qs(), a = (0, hl.useUserProfile)(DS, null != s ? s : ""), o = hc(),
                    l = Nu(), [c, u] = (0, t.useState)(), [d, h] = (0, t.useState)(), [f, p] = (0, t.useState)(), [m, g] = (0, t.useState)(), [y, v] = (0, t.useState)(), [b, w] = (0, t.useState)(), [x, E] = (0, t.useState)(), [S, k] = (0, t.useState)(),
                    A = 0 === (null !== (r = null == f ? void 0 : f.length) && void 0 !== r ? r : 0) ? ql : f;
                return (0, t.useEffect)((() => {
                    a && (u(a.name), h(a.display_name), p(a.picture), g(a.banner), v(a.about), w(a.website), E(a.nip05), k(a.lud16))
                }), [a]), (0, e.jsxs)("div", {
                    className: "settings",
                    children: [(0, e.jsx)("h3", {children: (0, e.jsx)(cl, {...Ox})}), s ? (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsxs)("div", {
                            className: "flex f-center image-settings",
                            children: [(null === (T = n.avatar) || void 0 === T || T) && (0, e.jsxs)("div", {
                                className: "image-setting card",
                                children: [(0, e.jsxs)("div", {children: [(0, e.jsx)(cl, {...Ux}), ":"]}), (0, e.jsx)(Jx, {
                                    picture: A,
                                    onPictureChange: e => p(e)
                                })]
                            }), (null === (C = n.banner) || void 0 === C || C) && (0, e.jsxs)("div", {
                                className: "image-setting card",
                                children: [(0, e.jsxs)("div", {children: [(0, e.jsx)(cl, {...Hx}), ":"]}), (0, e.jsx)("div", {
                                    style: {backgroundImage: `url(${0 === (null !== (R = null == m ? void 0 : m.length) && void 0 !== R ? R : 0) ? ql : m})`},
                                    className: "banner",
                                    children: (0, e.jsx)("div", {
                                        className: "edit", onClick: () => async function () {
                                            const e = await async function () {
                                                const e = await (0, Ks.ZB)();
                                                if (e) {
                                                    console.log(e);
                                                    const t = await l.upload(e, e.name);
                                                    if (console.log(t), "string" == typeof (null == t ? void 0 : t.error)) throw new Error(`Upload failed ${t.error}`);
                                                    return t.url
                                                }
                                            }();
                                            e && g(e)
                                        }(), children: (0, e.jsx)(cl, {...$x})
                                    })
                                })]
                            })]
                        }), (0, e.jsxs)("div", {
                            className: "editor form",
                            children: [(0, e.jsxs)("div", {
                                className: "form-group card",
                                children: [(0, e.jsxs)("div", {children: [(0, e.jsx)(cl, {...Gx}), ":"]}), (0, e.jsx)("div", {
                                    children: (0, e.jsx)("input", {
                                        type: "text",
                                        value: c,
                                        onChange: e => u(e.target.value)
                                    })
                                })]
                            }), (0, e.jsxs)("div", {
                                className: "form-group card",
                                children: [(0, e.jsxs)("div", {children: [(0, e.jsx)(cl, {...Vx}), ":"]}), (0, e.jsx)("div", {
                                    children: (0, e.jsx)("input", {
                                        type: "text",
                                        value: d,
                                        onChange: e => h(e.target.value)
                                    })
                                })]
                            }), (0, e.jsxs)("div", {
                                className: "form-group card",
                                children: [(0, e.jsxs)("div", {children: [(0, e.jsx)(cl, {...Bx}), ":"]}), (0, e.jsx)("div", {
                                    className: "w-max",
                                    children: (0, e.jsx)("textarea", {
                                        className: "w-max",
                                        onChange: e => v(e.target.value),
                                        value: y
                                    })
                                })]
                            }), (0, e.jsxs)("div", {
                                className: "form-group card",
                                children: [(0, e.jsxs)("div", {children: [(0, e.jsx)(cl, {...qx}), ":"]}), (0, e.jsx)("div", {
                                    children: (0, e.jsx)("input", {
                                        type: "text",
                                        value: b,
                                        onChange: e => w(e.target.value)
                                    })
                                })]
                            }), (0, e.jsxs)("div", {
                                className: "form-group card",
                                children: [(0, e.jsxs)("div", {children: [(0, e.jsx)(cl, {...Zx}), ":"]}), (0, e.jsxs)("div", {
                                    children: [(0, e.jsx)("input", {
                                        type: "text",
                                        className: "mr10",
                                        value: x,
                                        onChange: e => E(e.target.value)
                                    }), (0, e.jsxs)("button", {
                                        type: "button",
                                        onClick: () => i("/verification"),
                                        children: [(0, e.jsx)(Gl, {name: "shopping-bag"}), " ", (0, e.jsx)(cl, {...Yx})]
                                    })]
                                })]
                            }), (0, e.jsxs)("div", {
                                className: "form-group card",
                                children: [(0, e.jsxs)("div", {children: [(0, e.jsx)(cl, {...Fx}), ":"]}), (0, e.jsx)("div", {
                                    children: (0, e.jsx)("input", {
                                        type: "text",
                                        value: S,
                                        onChange: e => k(e.target.value)
                                    })
                                })]
                            }), (0, e.jsxs)("div", {
                                className: "form-group card",
                                children: [(0, e.jsx)("div", {}), (0, e.jsx)("div", {
                                    children: (0, e.jsx)(Vd, {
                                        onClick: () => async function () {
                                            const e = {
                                                ...a,
                                                name: c,
                                                display_name: d,
                                                about: y,
                                                picture: f,
                                                banner: m,
                                                website: b,
                                                nip05: x,
                                                lud16: S
                                            };
                                            if (delete e.loaded, delete e.created, delete e.pubkey, delete e.npub, delete e.deleted, delete e.zapService, delete e.isNostrAddressValid, console.debug(e), o) {
                                                const t = await o.metadata(e);
                                                DS.BroadcastEvent(t);
                                                const n = (0, Pt.mapEventToProfile)(t);
                                                n && await sc.set(n)
                                            }
                                        }(), children: (0, e.jsx)(cl, {...Wx})
                                    })
                                })]
                            })]
                        })]
                    }) : null]
                });
                var T, C, R
            }), {})
        }, {
            path: "relays", element: (0, e.jsx)((() => {
                const n = hc(), r = Qs(), i = r.relays, [s, a] = (0, t.useState)(),
                    o = (0, t.useMemo)((() => DS.Sockets.filter((e => void 0 === i.item[e.address]))), [i]);
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("h3", {children: (0, e.jsx)(cl, {...ex})}), (0, e.jsx)("div", {
                        className: "flex f-col mb10",
                        children: Object.keys(i.item || {}).map((t => (0, e.jsx)(tE, {addr: t}, t)))
                    }), (0, e.jsxs)("div", {
                        className: "flex mt10",
                        children: [(0, e.jsx)("div", {className: "f-grow"}), (0, e.jsx)("button", {
                            type: "button",
                            onClick: () => async function () {
                                if (n) {
                                    const e = await n.contactList(r.follows.item, r.relays.item);
                                    DS.BroadcastEvent(e);
                                    try {
                                        const e = await fetch("https://api.nostr.watch/v1/online").then((e => e.json())),
                                            t = await n.relayList(r.relays.item);
                                        Object.keys(i.item).concat((0, Ks.mp)(e, 20)).forEach((e => {
                                            DS.WriteOnceToRelay(e, t)
                                        }))
                                    } catch (e) {
                                        console.error(e)
                                    }
                                }
                            }(),
                            children: (0, e.jsx)(cl, {...Wx})
                        })]
                    }), (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("h4", {children: (0, e.jsx)(cl, {...zx})}), (0, e.jsx)("div", {
                            className: "flex mb10",
                            children: (0, e.jsx)("input", {
                                type: "text",
                                className: "f-grow",
                                placeholder: "wss://my-relay.com",
                                value: s,
                                onChange: e => {
                                    const t = e.target.value, n = window.location.protocol;
                                    ("https:" === n && t.startsWith("wss://") || "http:" === n) && a(t)
                                }
                            })
                        }), (0, e.jsx)("button", {
                            className: "secondary mb10", onClick: () => function () {
                                var e;
                                if ((null !== (e = null == s ? void 0 : s.length) && void 0 !== e ? e : 0) > 0) {
                                    const e = new URL(null != s ? s : ""),
                                        t = {...i.item, [e.toString()]: {read: !0, write: !0}};
                                    zs(r, t, (0, Ks.Fd)())
                                }
                            }(), children: (0, e.jsx)(cl, {...Kx})
                        })]
                    }), (0, e.jsx)("h3", {
                        children: (0, e.jsx)(cl, {
                            id: "LF5kYT",
                            defaultMessage: "Other Connections"
                        })
                    }), (0, e.jsx)("div", {
                        className: "flex f-col mb10",
                        children: o.map((t => (0, e.jsx)(tE, {addr: t.address}, t.id)))
                    })]
                })
            }), {})
        }, {
            path: "relays/:id", element: (0, e.jsx)((() => {
                var t, n, r, i, s, a, o, l;
                const c = ot(), u = st(), d = Qs(), h = DS.Sockets.find((e => e.id === c.id)),
                    f = eE(null !== (t = null == h ? void 0 : h.address) && void 0 !== t ? t : "");
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("h3", {
                        className: "pointer",
                        onClick: () => u("/settings/relays"),
                        children: (0, e.jsx)(cl, {...ex})
                    }), (0, e.jsxs)("div", {
                        className: "card",
                        children: [(0, e.jsx)("h3", {children: null == f || null === (n = f.info) || void 0 === n ? void 0 : n.name}), (0, e.jsx)("p", {children: null == f || null === (r = f.info) || void 0 === r ? void 0 : r.description}), (null == f || null === (i = f.info) || void 0 === i ? void 0 : i.pubkey) && (0, e.jsxs)(e.Fragment, {children: [(0, e.jsx)("h4", {children: (0, e.jsx)(cl, {...tx})}), (0, e.jsx)(Tb, {pubkey: (0, Ks.nm)(f.info.pubkey)})]}), (null == f || null === (s = f.info) || void 0 === s ? void 0 : s.software) && (0, e.jsxs)("div", {
                            className: "flex",
                            children: [(0, e.jsx)("h4", {
                                className: "f-grow",
                                children: (0, e.jsx)(cl, {...nx})
                            }), (0, e.jsxs)("div", {
                                className: "flex f-col",
                                children: [f.info.software.startsWith("http") ? (0, e.jsx)("a", {
                                    href: f.info.software,
                                    target: "_blank",
                                    rel: "noreferrer",
                                    children: f.info.software
                                }) : (0, e.jsx)(e.Fragment, {children: f.info.software}), (0, e.jsxs)("small", {children: [!(null !== (a = f.info.version) && void 0 !== a && a.startsWith("v")) && "v", f.info.version]})]
                            })]
                        }), (null == f || null === (o = f.info) || void 0 === o ? void 0 : o.contact) && (0, e.jsxs)("div", {
                            className: "flex",
                            children: [(0, e.jsx)("h4", {
                                className: "f-grow",
                                children: (0, e.jsx)(cl, {...rx})
                            }), (0, e.jsx)("a", {
                                href: `${f.info.contact.startsWith("mailto:") ? "" : "mailto:"}${f.info.contact}`,
                                target: "_blank",
                                rel: "noreferrer",
                                children: f.info.contact
                            })]
                        }), (null == f || null === (l = f.info) || void 0 === l ? void 0 : l.supported_nips) && (0, e.jsxs)(e.Fragment, {
                            children: [(0, e.jsx)("h4", {children: (0, e.jsx)(cl, {...ix})}), (0, e.jsx)("div", {
                                className: "f-grow",
                                children: f.info.supported_nips.map((t => (0, e.jsxs)("a", {
                                    target: "_blank",
                                    rel: "noreferrer",
                                    href: `https://nips.be/${t}`,
                                    className: "pill",
                                    children: ["NIP-", t.toString().padStart(2, "0")]
                                })))
                            })]
                        }), (0, e.jsx)("h4", {
                            children: (0, e.jsx)(cl, {
                                id: "p85Uwy",
                                defaultMessage: "Active Subscriptions"
                            })
                        }), (0, e.jsx)("div", {
                            className: "f-grow",
                            children: null == f ? void 0 : f.activeRequests.map((t => (0, e.jsx)("span", {
                                className: "pill",
                                children: t
                            }, t)))
                        }), (0, e.jsx)("h4", {
                            children: (0, e.jsx)(cl, {
                                id: "UDYlxu",
                                defaultMessage: "Pending Subscriptions"
                            })
                        }), (0, e.jsx)("div", {
                            className: "f-grow",
                            children: null == f ? void 0 : f.pendingRequests.map((t => (0, e.jsx)("span", {
                                className: "pill",
                                children: t
                            }, t)))
                        }), (0, e.jsx)("div", {
                            className: "flex mt10 f-end",
                            children: (0, e.jsx)("div", {
                                className: "btn error", onClick: () => {
                                    var e, t;
                                    e = d, t = (0, Ks.Wg)(h).address, delete e.relays.item[t], Xs.updateSession(e), u("/settings/relays")
                                }, children: (0, e.jsx)(cl, {...sx})
                            })
                        })]
                    })]
                })
            }), {})
        }, {
            path: "preferences", element: (0, e.jsx)((() => {
                var n, r, i;
                const {formatMessage: s} = al(), o = Qs(), l = o.preferences, [c, u] = (0, t.useState)([]);
                return (0, t.useEffect)((() => {
                    (async () => {
                        const e = await a.e(521).then(a.t.bind(a, 4521, 23));
                        u(e.default("").map((e => ({name: e.name, char: e.char}))))
                    })()
                }), []), (0, e.jsxs)("div", {
                    className: "preferences",
                    children: [(0, e.jsx)("h3", {children: (0, e.jsx)(cl, {...ax})}), (0, e.jsxs)("div", {
                        className: "card flex",
                        children: [(0, e.jsx)("div", {
                            className: "flex f-col f-grow",
                            children: (0, e.jsx)("div", {
                                children: (0, e.jsx)(cl, {
                                    id: "y1Z3or",
                                    defaultMessage: "Language"
                                })
                            })
                        }), (0, e.jsx)("div", {
                            children: (0, e.jsx)("select", {
                                value: l.language || Ii.language,
                                onChange: e => Gs(o, {...l, language: e.target.value}),
                                style: {textTransform: "capitalize"},
                                children: nE.sort().map((t => (0, e.jsx)("option", {
                                    value: t,
                                    children: new Intl.DisplayNames([t], {type: "language"}).of(t)
                                })))
                            })
                        })]
                    }), (0, e.jsxs)("div", {
                        className: "card flex",
                        children: [(0, e.jsx)("div", {
                            className: "flex f-col f-grow",
                            children: (0, e.jsx)("div", {children: (0, e.jsx)(cl, {...cx})})
                        }), (0, e.jsx)("div", {
                            children: (0, e.jsxs)("select", {
                                value: l.theme,
                                onChange: e => Gs(o, {...l, theme: e.target.value}),
                                children: [(0, e.jsx)("option", {
                                    value: "system",
                                    children: (0, e.jsx)(cl, {...ux})
                                }), (0, e.jsx)("option", {
                                    value: "light",
                                    children: (0, e.jsx)(cl, {...dx})
                                }), (0, e.jsx)("option", {value: "dark", children: (0, e.jsx)(cl, {...hx})})]
                            })
                        })]
                    }), (0, e.jsxs)("div", {
                        className: "card flex",
                        children: [(0, e.jsx)("div", {
                            className: "flex f-col f-grow",
                            children: (0, e.jsx)("div", {children: (0, e.jsx)(cl, {...fx})})
                        }), (0, e.jsx)("div", {
                            children: (0, e.jsxs)("select", {
                                value: l.defaultRootTab,
                                onChange: e => Gs(o, {...l, defaultRootTab: e.target.value}),
                                children: [(0, e.jsx)("option", {
                                    value: "notes",
                                    children: (0, e.jsx)(cl, {id: "7+Domh", defaultMessage: "Notes"})
                                }), (0, e.jsx)("option", {
                                    value: "conversations",
                                    children: (0, e.jsx)(cl, {...px})
                                }), (0, e.jsx)("option", {value: "global", children: (0, e.jsx)(cl, {...mx})})]
                            })
                        })]
                    }), (0, e.jsx)("div", {
                        className: "card flex",
                        children: (0, e.jsxs)("div", {
                            className: "flex f-col f-grow",
                            children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {...gx})}), (0, e.jsx)("small", {children: (0, e.jsx)(cl, {...yx})}), (0, e.jsx)("div", {
                                className: "mt10",
                                children: (0, e.jsxs)("select", {
                                    value: l.autoLoadMedia,
                                    onChange: e => Gs(o, {...l, autoLoadMedia: e.target.value}),
                                    children: [(0, e.jsx)("option", {
                                        value: "none",
                                        children: (0, e.jsx)(cl, {...vx})
                                    }), (0, e.jsx)("option", {
                                        value: "follows-only",
                                        children: (0, e.jsx)(cl, {...bx})
                                    }), (0, e.jsx)("option", {value: "all", children: (0, e.jsx)(cl, {...wx})})]
                                })
                            })]
                        })
                    }), (0, e.jsxs)("div", {
                        className: "card flex",
                        children: [(0, e.jsx)("div", {
                            className: "flex f-col f-grow",
                            children: (0, e.jsx)("div", {
                                children: (0, e.jsx)(cl, {
                                    id: "qMx1sA",
                                    defaultMessage: "Default Zap amount"
                                })
                            })
                        }), (0, e.jsx)("div", {
                            children: (0, e.jsx)("input", {
                                type: "number",
                                defaultValue: l.defaultZapAmount,
                                min: 1,
                                onChange: e => Gs(o, {...l, defaultZapAmount: parseInt(e.target.value || "0")})
                            })
                        })]
                    }), (0, e.jsxs)("div", {
                        className: "card flex",
                        children: [(0, e.jsxs)("div", {
                            className: "flex f-col f-grow",
                            children: [(0, e.jsx)("div", {
                                children: (0, e.jsx)(cl, {
                                    id: "Dh3hbq",
                                    defaultMessage: "Auto Zap"
                                })
                            }), (0, e.jsx)("small", {
                                children: (0, e.jsx)(cl, {
                                    id: "D+KzKd",
                                    defaultMessage: "Automatically zap every note when loaded"
                                })
                            })]
                        }), (0, e.jsx)("div", {
                            children: (0, e.jsx)("input", {
                                type: "checkbox",
                                checked: l.autoZap,
                                onChange: e => Gs(o, {...l, autoZap: e.target.checked})
                            })
                        })]
                    }), (0, e.jsxs)("div", {
                        className: "card flex f-col",
                        children: [(0, e.jsxs)("div", {
                            className: "flex w-max",
                            children: [(0, e.jsxs)("div", {
                                className: "flex f-col f-grow",
                                children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {...xx})}), (0, e.jsx)("small", {children: (0, e.jsx)(cl, {...Ex})})]
                            }), (0, e.jsx)("div", {
                                children: (0, e.jsx)("input", {
                                    type: "checkbox",
                                    checked: null !== l.imgProxyConfig,
                                    onChange: e => Gs(o, {...l, imgProxyConfig: e.target.checked ? mi : null})
                                })
                            })]
                        }), l.imgProxyConfig && (0, e.jsxs)("div", {
                            className: "w-max mt10 form",
                            children: [(0, e.jsxs)("div", {
                                className: "form-group",
                                children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {...Sx})}), (0, e.jsx)("div", {
                                    className: "w-max",
                                    children: (0, e.jsx)("input", {
                                        type: "text",
                                        value: null === (n = l.imgProxyConfig) || void 0 === n ? void 0 : n.url,
                                        placeholder: s({id: "cQfLWb", defaultMessage: "URL.."}),
                                        onChange: e => Gs(o, {
                                            ...l,
                                            imgProxyConfig: {...(0, Ks.Wg)(l.imgProxyConfig), url: e.target.value}
                                        })
                                    })
                                })]
                            }), (0, e.jsxs)("div", {
                                className: "form-group",
                                children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {...kx})}), (0, e.jsx)("div", {
                                    className: "w-max",
                                    children: (0, e.jsx)("input", {
                                        type: "password",
                                        value: null === (r = l.imgProxyConfig) || void 0 === r ? void 0 : r.key,
                                        placeholder: s({id: "H+vHiz", defaultMessage: "Hex Key.."}),
                                        onChange: e => Gs(o, {
                                            ...l,
                                            imgProxyConfig: {...(0, Ks.Wg)(l.imgProxyConfig), key: e.target.value}
                                        })
                                    })
                                })]
                            }), (0, e.jsxs)("div", {
                                className: "form-group",
                                children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {...Ax})}), (0, e.jsx)("div", {
                                    className: "w-max",
                                    children: (0, e.jsx)("input", {
                                        type: "password",
                                        value: null === (i = l.imgProxyConfig) || void 0 === i ? void 0 : i.salt,
                                        placeholder: s({id: "TpgeGw", defaultMessage: "Hex Salt.."}),
                                        onChange: e => Gs(o, {
                                            ...l,
                                            imgProxyConfig: {...(0, Ks.Wg)(l.imgProxyConfig), salt: e.target.value}
                                        })
                                    })
                                })]
                            })]
                        })]
                    }), (0, e.jsxs)("div", {
                        className: "card flex",
                        children: [(0, e.jsxs)("div", {
                            className: "flex f-col f-grow",
                            children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {...Tx})}), (0, e.jsx)("small", {children: (0, e.jsx)(cl, {...Cx})})]
                        }), (0, e.jsx)("div", {
                            children: (0, e.jsx)("input", {
                                type: "checkbox",
                                checked: l.enableReactions,
                                onChange: e => Gs(o, {...l, enableReactions: e.target.checked})
                            })
                        })]
                    }), (0, e.jsx)("div", {
                        className: "card flex",
                        children: (0, e.jsxs)("div", {
                            className: "flex f-col f-grow",
                            children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {...Xx})}), (0, e.jsx)("small", {children: (0, e.jsx)(cl, {...Qx})}), (0, e.jsx)("div", {
                                className: "mt10",
                                children: (0, e.jsxs)("select", {
                                    className: "emoji-selector",
                                    value: l.reactionEmoji,
                                    onChange: e => Gs(o, {...l, reactionEmoji: e.target.value}),
                                    children: [(0, e.jsxs)("option", {
                                        value: "+",
                                        children: ["+ ", (0, e.jsx)(cl, {...Ix})]
                                    }), c.map((t => {
                                        let {name: n, char: r} = t;
                                        return (0, e.jsxs)("option", {value: r, children: [n, " ", r]})
                                    }))]
                                })
                            })]
                        })
                    }), (0, e.jsxs)("div", {
                        className: "card flex",
                        children: [(0, e.jsxs)("div", {
                            className: "flex f-col f-grow",
                            children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {...Rx})}), (0, e.jsx)("small", {children: (0, e.jsx)(cl, {...Lx})})]
                        }), (0, e.jsx)("div", {
                            children: (0, e.jsx)("input", {
                                type: "checkbox",
                                checked: l.confirmReposts,
                                onChange: e => Gs(o, {...l, confirmReposts: e.target.checked})
                            })
                        })]
                    }), (0, e.jsxs)("div", {
                        className: "card flex",
                        children: [(0, e.jsxs)("div", {
                            className: "flex f-col f-grow",
                            children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {..._x})}), (0, e.jsx)("small", {children: (0, e.jsx)(cl, {...Px})})]
                        }), (0, e.jsx)("div", {
                            children: (0, e.jsx)("input", {
                                type: "checkbox",
                                checked: l.autoShowLatest,
                                onChange: e => Gs(o, {...l, autoShowLatest: e.target.checked})
                            })
                        })]
                    }), (0, e.jsx)("div", {
                        className: "card flex",
                        children: (0, e.jsxs)("div", {
                            className: "flex f-col f-grow",
                            children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {...Nx})}), (0, e.jsx)("small", {children: (0, e.jsx)(cl, {...jx})}), (0, e.jsx)("div", {
                                className: "mt10",
                                children: (0, e.jsxs)("select", {
                                    value: l.fileUploader,
                                    onChange: e => Gs(o, {...l, fileUploader: e.target.value}),
                                    children: [(0, e.jsxs)("option", {
                                        value: "void.cat",
                                        children: ["void.cat ", (0, e.jsx)(cl, {...Ix})]
                                    }), (0, e.jsx)("option", {
                                        value: "nostr.build",
                                        children: "nostr.build"
                                    }), (0, e.jsx)("option", {value: "nostrimg.com", children: "nostrimg.com"})]
                                })
                            })]
                        })
                    }), (0, e.jsxs)("div", {
                        className: "card flex",
                        children: [(0, e.jsxs)("div", {
                            className: "flex f-col f-grow",
                            children: [(0, e.jsx)("div", {children: (0, e.jsx)(cl, {...Mx})}), (0, e.jsx)("small", {children: (0, e.jsx)(cl, {...Dx})})]
                        }), (0, e.jsx)("div", {
                            children: (0, e.jsx)("input", {
                                type: "checkbox",
                                checked: l.showDebugMenus,
                                onChange: e => Gs(o, {...l, showDebugMenus: e.target.checked})
                            })
                        })]
                    })]
                })
            }), {})
        }, {
            path: "accounts", element: (0, e.jsx)((function () {
                const {formatMessage: n} = al(), [r, i] = (0, t.useState)(""), [s, a] = (0, t.useState)(""), o = Jb(),
                    l = Xs.getSessions(), c = Mb(Xs.allSubscriptions());
                return (0, e.jsxs)(e.Fragment, {
                    children: [(0, e.jsx)("h3", {
                        children: (0, e.jsx)(cl, {
                            id: "+vA//S",
                            defaultMessage: "Logins"
                        })
                    }), l.map((t => (0, e.jsx)("div", {
                        className: "card flex",
                        children: (0, e.jsx)(Tb, {
                            pubkey: t,
                            options: {about: !1},
                            actions: (0, e.jsxs)("div", {
                                className: "f-1",
                                children: [(0, e.jsx)("button", {
                                    className: "mb10",
                                    onClick: () => Xs.switchAccount(t),
                                    children: (0, e.jsx)(cl, {id: "n1Whvj", defaultMessage: "Switch"})
                                }), (0, e.jsx)("button", {
                                    onClick: () => Xs.removeSession(t),
                                    children: (0, e.jsx)(cl, {id: "C81/uG", defaultMessage: "Logout"})
                                })]
                            })
                        })
                    }, t))), c && (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("h3", {
                            children: (0, e.jsx)(cl, {
                                id: "F3l7xL",
                                defaultMessage: "Add Account"
                            })
                        }), (0, e.jsxs)("div", {
                            className: "flex",
                            children: [(0, e.jsx)("input", {
                                dir: "auto",
                                type: "text",
                                placeholder: n({id: "X7xU8J", defaultMessage: "nsec, npub, nip-05, hex, mnemonic"}),
                                className: "f-grow mr10",
                                onChange: e => i(e.target.value)
                            }), (0, e.jsx)(Vd, {
                                onClick: () => async function () {
                                    try {
                                        a(""), await o.doLogin(r), i("")
                                    } catch (e) {
                                        e instanceof Error ? a(e.message) : a(n({
                                            id: "OLEm6z",
                                            defaultMessage: "Unknown login error"
                                        })), console.error(e)
                                    }
                                }(), children: (0, e.jsx)(cl, {id: "AyGauy", defaultMessage: "Login"})
                            })]
                        })]
                    }), s && (0, e.jsx)("b", {className: "error", children: s})]
                })
            }), {})
        }, {
            path: "keys", element: (0, e.jsx)((function () {
                const {publicKey: t, privateKey: n, generatedEntropy: r} = Qs();
                return (0, e.jsxs)("div", {
                    className: "export-keys",
                    children: [(0, e.jsx)("h3", {
                        children: (0, e.jsx)(cl, {
                            id: "bep9C3",
                            defaultMessage: "Public Key"
                        })
                    }), (0, e.jsx)(qu, {
                        text: (0, Ks.jm)("npub", null != t ? t : ""),
                        maxSize: 48,
                        className: "mb10"
                    }), (0, e.jsx)(qu, {
                        text: (0, Pt.encodeTLV)(Pt.NostrPrefix.Profile, null != t ? t : ""),
                        maxSize: 48
                    }), n && (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("h3", {
                            children: (0, e.jsx)(cl, {
                                id: "JymXbw",
                                defaultMessage: "Private Key"
                            })
                        }), (0, e.jsx)(qu, {text: (0, Ks.jm)("nsec", n), maxSize: 48})]
                    }), r && (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("h3", {
                            children: (0, e.jsx)(cl, {
                                id: "b12Goz",
                                defaultMessage: "Mnemonic"
                            })
                        }), (0, e.jsx)(qu, {text: Hs(null != r ? r : ""), maxSize: 48})]
                    })]
                })
            }), {})
        }, ...uE, ...oE], hE = t => {
            let {unread: n} = t;
            return (0, e.jsx)("span", {className: "pill " + (n > 0 ? "unread" : ""), children: n})
        };

        function fE() {
            return (0, e.jsxs)("div", {
                children: [(0, e.jsx)(cl, {...Su.NoteToSelf}), " ", (0, e.jsx)(Gl, {
                    name: "badge",
                    size: 15
                })]
            })
        }

        function pE(t) {
            let {pubkey: n, clickable: r, className: i, link: s} = t;
            const a = st();
            return (0, e.jsxs)("div", {
                className: "nts" + (i ? ` ${i}` : ""),
                children: [(0, e.jsx)("div", {
                    className: "avatar-wrapper",
                    children: (0, e.jsx)("div", {
                        className: "avatar" + (r ? " clickable" : ""),
                        children: (0, e.jsx)(Gl, {
                            onClick: () => {
                                r && a(null != s ? s : (0, Ks._v)(n))
                            }, name: "book-closed", size: 20
                        })
                    })
                }), (0, e.jsx)("div", {
                    className: "f-grow",
                    children: (0, e.jsx)("div", {
                        className: "name",
                        children: r && (0, e.jsx)(Rt, {
                            to: null != s ? s : (0, Ks._v)(n),
                            children: (0, e.jsx)(fE, {})
                        }) || (0, e.jsx)(fE, {})
                    })
                })]
            })
        }

        function mE(n) {
            const r = Qs().publicKey, i = hc(), s = n.data,
                a = s.kind === Pt.EventKind.DirectMessage, [o, l] = (0, t.useState)(a ? "Loading..." : s.content), [c, u] = (0, t.useState)(!1), {
                    ref: d,
                    inView: h
                } = Fu(), {formatMessage: f} = al(), p = s.pubkey === r, m = p ? r : Pc(s);
            return (0, t.useEffect)((() => {
                !c && h && a && (u(!0), async function () {
                    if (i) {
                        const e = await i.decryptDm(s);
                        l(e || "<ERROR>"), p || function (e) {
                            const t = (0, Ks.oK)(), n = `dm:seen:${e}`;
                            window.localStorage.setItem(n, t.toString())
                        }(s.pubkey)
                    }
                }().catch(console.error))
            }), [h, s]), (0, e.jsxs)("div", {
                className: p ? "dm me" : "dm other",
                ref: d,
                children: [(0, e.jsxs)("div", {
                    children: [function () {
                        if (n.chat.type !== Tc.DirectMessage && !p) return (0, e.jsx)(Zl, {pubkey: s.pubkey})
                    }(), (0, e.jsx)(uv, {content: o, tags: [], creator: m})]
                }), (0, e.jsx)("div", {children: (0, e.jsx)(xb, {from: 1e3 * s.created_at, fallback: f(Su.JustNow)})})]
            })
        }

        function gE(n) {
            let {chat: r} = n;
            const [i, s] = (0, t.useState)(""), [a, o] = (0, t.useState)(!1), [l, c] = (0, t.useState)(!1), [u, d] = (0, t.useState)([]), [h, f] = (0, t.useState)(""),
                p = hc(), m = Nu();

            async function g() {
                if (i && p && r) {
                    o(!0);
                    const e = await r.createMessage(i, p);
                    await r.sendMessage(e, DS), s(""), o(!1)
                }
            }

            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)("button", {
                    className: "btn-rnd", onClick: () => async function () {
                        try {
                            const e = await (0, Ks.ZB)();
                            e && async function (e) {
                                c(!0);
                                try {
                                    if (e) {
                                        const t = await m.upload(e, e.name);
                                        if (t.header) {
                                            const e = `nostr:${(0, Pt.encodeTLV)(Pt.NostrPrefix.Event, t.header.id, void 0, t.header.kind)}`;
                                            s(`${i ? `${i}\n` : ""}${e}`), d([...u, t.header])
                                        } else t.url ? s(`${i ? `${i}\n` : ""}${t.url}`) : null != t && t.error && f(t.error)
                                    }
                                } catch (e) {
                                    e instanceof Error && f(e.message)
                                } finally {
                                    c(!1)
                                }
                            }(e)
                        } catch (e) {
                            e instanceof Error && f(e.message)
                        }
                    }(), children: l ? (0, e.jsx)(Dd, {width: 20}) : (0, e.jsx)(Gl, {name: "attachment", size: 20})
                }), (0, e.jsxs)("div", {
                    className: "w-max",
                    children: [(0, e.jsx)(Tu, {
                        autoFocus: !0,
                        placeholder: "",
                        className: "",
                        value: i,
                        onChange: e => function (e) {
                            a || s(e.target.value)
                        }(e),
                        onKeyDown: e => async function (e) {
                            "Enter" === e.code && !e.shiftKey && (e.preventDefault(), await g())
                        }(e),
                        onFocus: () => {
                        }
                    }), h && (0, e.jsx)("b", {className: "error", children: h})]
                }), (0, e.jsx)("button", {
                    className: "btn-rnd",
                    onClick: () => g(),
                    children: a ? (0, e.jsx)(Dd, {width: 20}) : (0, e.jsx)(Gl, {name: "arrow-right", size: 20})
                })]
            })
        }

        function yE(t) {
            var n;
            let {id: r} = t;
            const i = Qs().publicKey,
                s = null !== (n = jc().find((e => e.id === r))) && void 0 !== n ? n : Ec.createChatObj(r, []);
            return (0, e.jsxs)("div", {
                className: "dm-window",
                children: [(0, e.jsx)("div", {
                    children: r === i ? (0, e.jsx)(pE, {
                        className: "f-grow mb-10",
                        pubkey: r
                    }) : (null == s ? void 0 : s.type) === Tc.DirectMessage ? (0, e.jsx)(Zl, {
                        pubkey: r,
                        className: "f-grow mb10"
                    }) : null != s && s.profile ? (0, e.jsx)(Zl, {
                        pubkey: r,
                        className: "f-grow mb10",
                        profile: s.profile
                    }) : (0, e.jsx)(Zl, {
                        pubkey: null != r ? r : "",
                        className: "f-grow mb10",
                        overrideUsername: null == s ? void 0 : s.id
                    })
                }), (0, e.jsx)("div", {
                    children: (0, e.jsx)("div", {
                        className: "flex f-col",
                        children: s && (0, e.jsx)(vE, {chat: s})
                    })
                }), (0, e.jsx)("div", {children: (0, e.jsx)(gE, {chat: s})})]
            })
        }

        function vE(n) {
            let {chat: r} = n;
            const {publicKey: i} = Qs(), s = (0, t.useMemo)((() => {
                const e = null == r ? void 0 : r.messages;
                return i && e ? [...e].sort(((e, t) => e.created_at - t.created_at)) : []
            }), [r, i]);
            return (0, e.jsx)(e.Fragment, {children: s.map((t => (0, e.jsx)(mE, {data: t, chat: r}, t.id)))})
        }

        function bE(t) {
            var n;
            let {pubkey: r} = t;
            const i = (0, hl.useUserProfile)(DS, r), {block: s, unblock: a, isBlocked: o} = pc(), l = o(r);
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)(Vl, {
                    user: i,
                    size: 210
                }), (0, e.jsx)("h2", {children: Xl(i, r)}), (0, e.jsx)("p", {
                    children: (0, e.jsx)(uv, {
                        content: null !== (n = function (e) {
                            var t;
                            return (null !== (t = null == e ? void 0 : e.length) && void 0 !== t ? t : 0) > 200 ? `${null == e ? void 0 : e.slice(0, 200)}...` : e
                        }(null == i ? void 0 : i.about)) && void 0 !== n ? n : "",
                        tags: [],
                        creator: r,
                        disableMedia: !0,
                        depth: 0
                    })
                }), (0, e.jsxs)("div", {
                    className: "settings-row",
                    onClick: () => l ? a(r) : s(r),
                    children: [(0, e.jsx)(Gl, {name: "block"}), l ? (0, e.jsx)(cl, {
                        id: "nDejmx",
                        defaultMessage: "Unblock"
                    }) : (0, e.jsx)(cl, {id: "Up5U7K", defaultMessage: "Block"})]
                })]
            })
        }

        const wE = [(0, Ks.FX)(ui), (0, Ks.FX)("npub107jk7htfv243u0x5ynn43scq9wrxtaasmrwwa8lfu2ydwag6cx2quqncxg"), (0, Ks.FX)("npub1r0rs5q2gk0e3dk3nlc7gnu378ec6cnlenqp8a3cjhyzu6f8k5sgs4sq9ac")],
            xE = [(0, Ks.FX)("npub10djxr5pvdu97rjkde7tgcsjxzpdzmdguwacfjwlchvj7t88dl7nsdl54nf"), (0, Ks.FX)("npub148jmlutaa49y5wl5mcll003ftj59v79vf7wuv3apcwpf75hx22vs7kk9ay"), (0, Ks.FX)("npub1xdtducdnjerex88gkg2qk2atsdlqsyxqaag4h05jmcpyspqt30wscmntxy"), (0, Ks.FX)("npub1vp8fdcyejd4pqjyrjk9sgz68vuhq7pyvnzk8j0ehlljvwgp8n6eqsrnpsw"), (0, Ks.FX)("npub179rec9sw2a5ngkr2wsjpjhwp2ksygjxn6uw5py9daj2ezhw3aw5swv3s6q"), (0, Ks.FX)("npub17q5n2z8naw0xl6vu9lvt560lg33pdpe29k0k09umlfxm3vc4tqrq466f2y"), (0, Ks.FX)("npub1ltx67888tz7lqnxlrg06x234vjnq349tcfyp52r0lstclp548mcqnuz40t")],
            EE = [(0, Ks.FX)("npub1s8zws5frm94esxnp9v6zf7vk60m3hum3305n78sr73t78kleus7q8zpwna"), (0, Ks.FX)("npub1z0ykz6lp3y8rjjntenns0ee02062g2f0n55u49w44xdemw35vcpsda5jhh"), (0, Ks.FX)("npub13wa880se2h3l54k7x76edrkrt4p94sh4q090974mt0z6n09qtntqxp47uk"), (0, Ks.FX)("npub147ccm75um0zkn0lr9fg9wrag2g6yxfw234fpmhdwuvaqjyegrhgs46t2td"), (0, Ks.FX)("npub1ppxgsqdv4ygvdnzznudahtwqc3vaqjz3824vawfgwchpegz0lsjqqys35r"), (0, Ks.FX)("npub1ww8kjxz2akn82qptdpl7glywnchhkx3x04hez3d3rye397turrhssenvtp"), (0, Ks.FX)("npub1x8dzy9xegwmdk2vy30l8u08caspcqq2yzncxehdsa6kvnte9pr3qnt8pg4"), (0, Ks.FX)("npub1xwm9svxrlymymph0hka40zw9frg98m6adxmzcq26jhtm5gwlhjrshhgzfd"), (0, Ks.FX)("npub1raspu6ag9kfcw9jz0rz4z693qwmqe5sx6jdhhuvkwz5zy8rygztqnwfhd7"), (0, Ks.FX)("npub13tkge7eqeem5cz8gk7gdju76nytvvf064hm5mzmv3x26k2uvaxfqczet2j"), (0, Ks.FX)("npub10529hxckjm5t5mchss5lnpsqrmavulglxhrmu5quuu4hs6yuyh3qc9gxd5"), (0, Ks.FX)("npub19jk45jz45gczwfm22y9z69xhaex3nwg47dz84zw096xl6z62amkqj99rv7"), (0, Ks.FX)("npub1z9n5ktfjrlpyywds9t7ljekr9cm9jjnzs27h702te5fy8p2c4dgs5zvycf")],
            SE = () => {
                const t = st();
                return (0, e.jsx)("h1", {className: "logo", onClick: () => t("/"), children: "Snort"})
            }, kE = {id: "gBdUXk", defaultMessage: "Save your keys!"}, AE = {
                id: "EPYwm7",
                defaultMessage: "Your private key is your password. If you lose this key, you will lose access to your account! Copy it and keep it in a safe place. There is no way to reset your private key."
            }, TE = {id: "xJ9n2N", defaultMessage: "Your public key"},
            CE = {id: "PLSbmL", defaultMessage: "Your mnemonic phrase"},
            RE = {id: "KWuDfz", defaultMessage: "I have saved my keys, continue"},
            LE = {id: "1A7TZk", defaultMessage: "What is Snort and how does it work?"}, _E = {
                id: "gDZkld",
                defaultMessage: 'Snort is a Nostr UI, nostr is a decentralised protocol for saving and distributing "notes".'
            }, PE = {
                id: "BcGMo+",
                defaultMessage: 'Notes hold text content, the most popular usage of these notes is to store "tweet like" messages.'
            }, NE = {id: "sWnYKw", defaultMessage: "Snort is designed to have a similar experience to Twitter."},
            jE = {id: "Vx7Zm2", defaultMessage: "How do keys work?"}, IE = {
                id: "/RD0e2",
                defaultMessage: "Nostr uses digital signature technology to provide tamper proof notes which can safely be replicated to many relays to provide redundant storage of your content."
            }, ME = {
                id: "IUZC+0",
                defaultMessage: "This means that nobody can modify notes which you have created and everybody can easily verify that the notes they are reading are created by you."
            }, DE = {
                id: "rrfdTe",
                defaultMessage: "This is the same technology which is used by Bitcoin and has been proven to be extremely secure."
            }, OE = {
                id: "reJ6SM",
                defaultMessage: "It is recommended to use one of the following browser extensions if you are on a desktop computer to secure your key:"
            }, BE = {id: "osUr8O", defaultMessage: "You can also use these extensions to login to most Nostr sites."},
            FE = {id: "juhqvW", defaultMessage: "Improve login security with browser extensions"},
            UE = {id: "WxthCV", defaultMessage: "e.g. Jack"},
            HE = {id: "E8a4yq", defaultMessage: "Follow some popular accounts"},
            $E = {id: "/4tOwT", defaultMessage: "Skip"}, KE = {id: "FS3b54", defaultMessage: "Done!"},
            zE = {id: "NNSu3d", defaultMessage: "Import Twitter Follows"},
            GE = {id: "INSqIz", defaultMessage: "Twitter username..."},
            qE = {id: "WONP5O", defaultMessage: "Find your twitter follows on nostr (Data provided by {provider})"},
            WE = {id: "MRp6Ly", defaultMessage: "Twitter username"},
            VE = {id: "xKflGN", defaultMessage: "{username}'s Follows on Nostr"},
            YE = {id: "BOUMjw", defaultMessage: "No nostr users found for {twitterUsername}"},
            ZE = {id: "rudscU", defaultMessage: "Failed to load follows, please try again later"},
            XE = {id: "RDZVQL", defaultMessage: "Check"}, QE = {id: "9+Ddtu", defaultMessage: "Next"},
            JE = {id: "6Yfvvp", defaultMessage: "Get an identifier"}, eS = {
                id: "oxCa4R",
                defaultMessage: "Getting an identifier helps confirm the real you to people who know you. Many people can have a username @jack, but there is only one jack@cash.app."
            }, tS = {id: "iGT1eE", defaultMessage: "Prevent fake accounts from imitating you"},
            nS = {id: "/d6vEc", defaultMessage: "Make your profile easier to find and share"},
            rS = {id: "a5UPxh", defaultMessage: "Fund developers and platforms providing NIP-05 verification services"},
            iS = {
                id: "svOoEH",
                defaultMessage: "Name-squatting and impersonation is not allowed. Snort and our partners reserve the right to terminate your handle (not your account - nobody can take that away) for violating this rule."
            }, sS = {id: "jCA7Cw", defaultMessage: "Preview on snort"},
            aS = {id: "iDGAbc", defaultMessage: "Get a Snort identifier"}, oS = {
                id: "Eqjl5K",
                defaultMessage: "Only Snort and our integration partner identifier gives you a colorful domain name, but you are welcome to use other services too."
            }, lS = {id: "ut+2Cd", defaultMessage: "Get a partner identifier"},
            cS = {id: "F+B3x1", defaultMessage: "We have also partnered with nostrplebs.com to give you more options"},
            uS = {id: "zjJZBd", defaultMessage: "You're ready!"},
            dS = {id: "nN9XTz", defaultMessage: "Share your thoughts with {link}"},
            hS = {id: "hK5ZDk", defaultMessage: "the world"}, fS = () => (0, e.jsxs)(Xw, {
                title: (0, e.jsx)("h3", {children: (0, e.jsx)(cl, {...LE})}),
                children: [(0, e.jsx)("p", {children: (0, e.jsx)(cl, {..._E})}), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...PE})}), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...NE})})]
            }), pS = () => (0, e.jsxs)(Xw, {
                title: (0, e.jsx)("h3", {children: (0, e.jsx)(cl, {...jE})}),
                children: [(0, e.jsx)("p", {children: (0, e.jsx)(cl, {...IE})}), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...ME})}), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...DE})})]
            }), mS = () => (0, e.jsxs)(Xw, {
                title: (0, e.jsx)("h3", {children: (0, e.jsx)(cl, {...FE})}),
                children: [(0, e.jsx)("p", {children: (0, e.jsx)(cl, {...OE})}), (0, e.jsxs)("ul", {
                    children: [(0, e.jsx)("li", {
                        children: (0, e.jsx)("a", {
                            href: "https://getalby.com/",
                            target: "_blank",
                            rel: "noreferrer",
                            children: "Alby"
                        })
                    }), (0, e.jsx)("li", {
                        children: (0, e.jsx)("a", {
                            href: "https://github.com/fiatjaf/nos2x",
                            target: "_blank",
                            rel: "noreferrer",
                            children: "nos2x"
                        })
                    })]
                }), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...BE})})]
            }), gS = "/new/profile", yS = "/new/discover", vS = [{
                path: "/new", element: (0, e.jsx)((function () {
                    var t, n;
                    const r = Qs(), i = st();
                    return (0, e.jsxs)("div", {
                        className: "main-content new-user",
                        dir: "auto",
                        children: [(0, e.jsx)(SE, {}), (0, e.jsx)("div", {
                            className: "progress-bar",
                            children: (0, e.jsx)("div", {className: "progress progress-first"})
                        }), (0, e.jsx)("h1", {children: (0, e.jsx)(cl, {...kE})}), (0, e.jsxs)("div", {
                            className: "card flex",
                            children: [(0, e.jsx)("div", {
                                className: "flex f-col f-grow",
                                children: (0, e.jsx)("div", {
                                    children: (0, e.jsx)(cl, {
                                        id: "y1Z3or",
                                        defaultMessage: "Language"
                                    })
                                })
                            }), (0, e.jsx)("div", {
                                children: (0, e.jsx)("select", {
                                    value: r.preferences.language || Ii.language,
                                    onChange: e => Gs(r, {...r.preferences, language: e.target.value}),
                                    style: {textTransform: "capitalize"},
                                    children: nE.sort().map((t => (0, e.jsx)("option", {
                                        value: t,
                                        children: new Intl.DisplayNames([t], {type: "language"}).of(t)
                                    })))
                                })
                            })]
                        }), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...AE})}), (0, e.jsx)("h2", {children: (0, e.jsx)(cl, {...TE})}), (0, e.jsx)(qu, {text: (0, Ks.jm)("npub", null !== (t = r.publicKey) && void 0 !== t ? t : "")}), (0, e.jsx)("h2", {children: (0, e.jsx)(cl, {...CE})}), (0, e.jsx)(qu, {text: Hs(null !== (n = r.generatedEntropy) && void 0 !== n ? n : "")}), (0, e.jsx)("div", {
                            className: "next-actions",
                            children: (0, e.jsxs)("button", {
                                type: "button",
                                onClick: () => i(gS),
                                children: [(0, e.jsx)(cl, {...RE}), " "]
                            })
                        }), (0, e.jsx)(fS, {}), (0, e.jsx)(pS, {}), (0, e.jsx)(mS, {})]
                    })
                }), {})
            }, {
                path: gS, element: (0, e.jsx)((function () {
                    const n = Qs(),
                        r = (0, hl.useUserProfile)(DS, n.publicKey), [i, s] = (0, t.useState)(""), [a, o] = (0, t.useState)(""), {formatMessage: l} = al(),
                        c = hc(), u = st();
                    return (0, t.useEffect)((() => {
                        var e, t;
                        r && (s(null !== (e = r.name) && void 0 !== e ? e : ""), o(null !== (t = r.picture) && void 0 !== t ? t : ""))
                    }), [r]), (0, e.jsxs)("div", {
                        className: "main-content new-user",
                        dir: "auto",
                        children: [(0, e.jsx)(SE, {}), (0, e.jsx)("div", {
                            className: "progress-bar",
                            children: (0, e.jsx)("div", {className: "progress progress-second"})
                        }), (0, e.jsx)("h1", {
                            children: (0, e.jsx)(cl, {
                                id: "Zr5TMx",
                                defaultMessage: "Setup profile"
                            })
                        }), (0, e.jsx)("h2", {
                            children: (0, e.jsx)(cl, {
                                id: "O9GTIc",
                                defaultMessage: "Profile picture"
                            })
                        }), (0, e.jsx)(Jx, {
                            picture: a,
                            onPictureChange: e => o(e)
                        }), (0, e.jsx)("h2", {
                            children: (0, e.jsx)(cl, {
                                id: "JCIgkj",
                                defaultMessage: "Username"
                            })
                        }), (0, e.jsx)("input", {
                            className: "username",
                            placeholder: l(UE),
                            type: "text",
                            value: i,
                            onChange: e => s(e.target.value)
                        }), (0, e.jsx)("div", {
                            className: "help-text",
                            children: (0, e.jsx)(cl, {
                                id: "QawghE",
                                defaultMessage: "You can change your username at any point."
                            })
                        }), (0, e.jsxs)("div", {
                            className: "next-actions",
                            children: [(0, e.jsx)("button", {
                                type: "button",
                                className: "transparent",
                                onClick: () => u(yS),
                                children: (0, e.jsx)(cl, {...$E})
                            }), (0, e.jsx)("button", {
                                type: "button", onClick: async () => {
                                    if ((i.length > 0 || a.length > 0) && c) {
                                        const e = await c.metadata({...r, name: i, picture: a});
                                        DS.BroadcastEvent(e);
                                        const t = (0, Pt.mapEventToProfile)(e);
                                        t && sc.set(t)
                                    }
                                    u(yS)
                                }, children: (0, e.jsx)(cl, {...QE})
                            })]
                        })]
                    })
                }), {})
            }, {
                path: "/new/import", element: (0, e.jsx)((function () {
                    const n = st(),
                        r = Qs().follows, {formatMessage: i} = al(), [s, a] = (0, t.useState)(""), [o, l] = (0, t.useState)([]), [c, u] = (0, t.useState)(""),
                        d = new qd(oi),
                        h = (0, t.useMemo)((() => o.map((e => (0, Ks.FX)(e))).sort((e => r.item.includes(e) ? 1 : -1))), [o, r]);
                    return (0, e.jsxs)("div", {
                        className: "main-content new-user",
                        dir: "auto",
                        children: [(0, e.jsx)(SE, {}), (0, e.jsx)("div", {
                            className: "progress-bar",
                            children: (0, e.jsx)("div", {className: "progress progress-last"})
                        }), (0, e.jsx)("h1", {children: (0, e.jsx)(cl, {...zE})}), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                ...qE,
                                values: {
                                    provider: (0, e.jsx)("a", {
                                        href: "https://nostr.directory",
                                        target: "_blank",
                                        rel: "noreferrer",
                                        children: "nostr.directory"
                                    })
                                }
                            })
                        }), (0, e.jsx)("div", {
                            className: "next-actions continue-actions",
                            children: (0, e.jsx)("button", {
                                type: "button",
                                onClick: () => n("/new/discover"),
                                children: (0, e.jsx)(cl, {...QE})
                            })
                        }), (0, e.jsx)("h2", {children: (0, e.jsx)(cl, {...WE})}), (0, e.jsxs)("div", {
                            className: "flex",
                            children: [(0, e.jsx)("input", {
                                type: "text",
                                placeholder: i(GE),
                                className: "f-grow mr10",
                                value: s,
                                onChange: e => a(e.target.value)
                            }), (0, e.jsx)(Vd, {
                                type: "button", className: "secondary tall", onClick: async function () {
                                    l([]), u("");
                                    try {
                                        const e = await d.twitterImport(s);
                                        Array.isArray(e) && 0 === e.length ? u(i(YE, {twitterUsername: s})) : l(e)
                                    } catch (e) {
                                        console.warn(e), e instanceof Error ? u(e.message) : u(i(ZE))
                                    }
                                }, children: (0, e.jsx)(cl, {...XE})
                            })]
                        }), c.length > 0 && (0, e.jsx)("b", {
                            className: "error",
                            children: c
                        }), (0, e.jsx)("div", {
                            dir: "ltr",
                            children: h.length > 0 && (0, e.jsx)(Cb, {
                                title: (0, e.jsx)("h2", {
                                    children: (0, e.jsx)(cl, {
                                        ...VE,
                                        values: {username: s}
                                    })
                                }), pubkeys: h
                            })
                        })]
                    })
                }), {})
            }, {
                path: "/new/verify", element: (0, e.jsx)((function () {
                    const n = st(), {publicKey: r} = Qs(), i = (0, hl.useUserProfile)(DS, r), [s, a] = (0, t.useState)(!1),
                        o = (null == i ? void 0 : i.name) || "nostrich", [l, c] = (0, t.useState)(`${o}@snort.social`),
                        u = async () => {
                            n("/new/import")
                        };
                    return (0, e.jsxs)("div", {
                        className: "main-content new-user",
                        dir: "auto",
                        children: [(0, e.jsx)(SE, {}), (0, e.jsx)("div", {
                            className: "progress-bar",
                            children: (0, e.jsx)("div", {className: "progress progress-third"})
                        }), (0, e.jsx)("h1", {children: (0, e.jsx)(cl, {...JE})}), (0, e.jsx)("div", {
                            className: "next-actions continue-actions",
                            children: (0, e.jsx)("button", {
                                className: "secondary",
                                type: "button",
                                onClick: u,
                                children: (0, e.jsx)(cl, {...$E})
                            })
                        }), (0, e.jsx)("h4", {children: (0, e.jsx)(cl, {...sS})}), (0, e.jsx)("div", {
                            className: "profile-preview-nip",
                            children: r && (0, e.jsx)(Zl, {pubkey: r, defaultNip: l, verifyNip: !1})
                        }), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...eS})}), (0, e.jsxs)("ul", {children: [(0, e.jsx)("li", {children: (0, e.jsx)(cl, {...tS})}), (0, e.jsx)("li", {children: (0, e.jsx)(cl, {...nS})}), (0, e.jsx)("li", {children: (0, e.jsx)(cl, {...rS})})]}), (0, e.jsx)("p", {
                            className: "warning",
                            children: (0, e.jsx)(cl, {...iS})
                        }), !s && (0, e.jsxs)(e.Fragment, {
                            children: [(0, e.jsx)("h2", {children: (0, e.jsx)(cl, {...aS})}), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...oS})}), (0, e.jsx)("div", {
                                className: "nip-container",
                                children: (0, e.jsx)(Kb, {
                                    ...Gb[0],
                                    helpText: !1,
                                    onChange: c,
                                    onSuccess: () => a(!0)
                                }, "snort")
                            })]
                        }), !s && (0, e.jsxs)(e.Fragment, {
                            children: [(0, e.jsx)("h2", {children: (0, e.jsx)(cl, {...lS})}), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...cS})}), (0, e.jsx)("div", {
                                className: "nip-container",
                                children: (0, e.jsx)(Kb, {
                                    ...Gb[1],
                                    helpText: !1,
                                    onChange: c,
                                    onSuccess: () => a(!0)
                                }, "nostrplebs")
                            })]
                        }), (0, e.jsxs)("div", {
                            className: "next-actions",
                            children: [!s && (0, e.jsx)("button", {
                                type: "button",
                                className: "transparent",
                                onClick: u,
                                children: (0, e.jsx)(cl, {...$E})
                            }), s && (0, e.jsx)("button", {type: "button", onClick: u, children: (0, e.jsx)(cl, {...QE})})]
                        })]
                    })
                }), {})
            }, {
                path: yS, element: (0, e.jsx)((function () {
                    const {formatMessage: n} = al(), r = Qs(), i = st(),
                        s = (0, t.useMemo)((() => pi.sort((() => Math.random() >= .5 ? -1 : 1)).map((e => e.toLowerCase()))), []);
                    return (0, e.jsxs)("div", {
                        className: "main-content new-user",
                        dir: "auto",
                        children: [(0, e.jsx)(SE, {}), (0, e.jsx)("div", {
                            className: "progress-bar",
                            children: (0, e.jsx)("div", {className: "progress"})
                        }), (0, e.jsx)("h1", {children: (0, e.jsx)(cl, {...uS})}), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                ...dS,
                                values: {link: (0, e.jsx)(Rt, {to: "/", children: n(hS)})}
                            })
                        }), (0, e.jsx)("div", {
                            className: "next-actions continue-actions",
                            children: (0, e.jsxs)("button", {
                                type: "button", onClick: () => async function () {
                                    var e;
                                    (e = r).generatedEntropy = void 0, Xs.updateSession(e), i("/")
                                }(), children: [(0, e.jsx)(cl, {...KE}), " "]
                            })
                        }), (0, e.jsx)("h3", {children: (0, e.jsx)(cl, {...HE})}), s.length > 0 && (0, e.jsx)(Cb, {
                            pubkeys: s,
                            showAbout: !0
                        }), (0, e.jsx)(Hw, {})]
                    })
                }), {})
            }];
        var bS = a(8142);
        const wS = [{
            path: "/wallet", element: (0, e.jsx)((function () {
                const n = st(), {formatMessage: r} = al(), [i, s] = (0, t.useState)(), [a, o] = (0, t.useState)(), [l, c] = (0, t.useState)(), [u, d] = (0, t.useState)(), [h, f] = (0, t.useState)(),
                    p = (0, Wu.Os)(), m = p.wallet;

                async function g(e) {
                    try {
                        const t = await e.getInfo();
                        s(t);
                        const n = await e.getBalance();
                        o(n);
                        const r = await e.getInvoices();
                        c(r.sort(((e, t) => t.timestamp - e.timestamp)))
                    } catch (e) {
                        e instanceof Error ? f(e.message) : f(r({id: "qDwvZ4", defaultMessage: "Unknown error"}))
                    }
                }

                function y(t) {
                    switch (t) {
                        case Wu.kd.Pending:
                            return (0, e.jsx)(Gl, {name: "clock", className: "mr5", size: 15});
                        case Wu.kd.Paid:
                            return (0, e.jsx)(Gl, {name: "check", className: "mr5", size: 15});
                        case Wu.kd.Expired:
                            return (0, e.jsx)(Gl, {name: "close", className: "mr5", size: 15})
                    }
                }

                return (0, t.useEffect)((() => {
                    m && (m.isReady() ? g(m).catch(console.warn) : m.canAutoLogin() && m.login().then((async () => await g(m))).catch(console.warn))
                }), [m]), (0, e.jsxs)("div", {
                    className: "main-content",
                    children: [h && (0, e.jsx)("b", {
                        className: "error",
                        children: h
                    }), 0 === p.configs.length ? (0, e.jsx)("button", {
                        onClick: () => n("/settings/wallet"),
                        children: (0, e.jsx)(cl, {id: "cg1VJ2", defaultMessage: "Connect Wallet"})
                    }) : (0, e.jsxs)("div", {
                        className: "flex w-max",
                        children: [(0, e.jsx)("h4", {
                            className: "f-1",
                            children: (0, e.jsx)(cl, {id: "G1BGCg", defaultMessage: "Select Wallet"})
                        }), (0, e.jsx)("div", {
                            className: "f-1",
                            children: (0, e.jsx)("select", {
                                className: "w-max",
                                onChange: e => Wu.uo.switch(e.target.value),
                                value: null === (b = p.config) || void 0 === b ? void 0 : b.id,
                                children: Wu.uo.list().map((t => (0, e.jsx)("option", {
                                    value: t.id,
                                    children: t.info.alias
                                })))
                            })
                        })]
                    }), !m || m.isReady() ? null : (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("h3", {
                            children: (0, e.jsx)(cl, {
                                id: "r5srDR",
                                defaultMessage: "Enter wallet password"
                            })
                        }), (0, e.jsxs)("div", {
                            className: "flex w-max",
                            children: [(0, e.jsx)("div", {
                                className: "f-grow mr10",
                                children: (0, e.jsx)("input", {
                                    type: "password",
                                    placeholder: r({id: "MP54GY", defaultMessage: "Wallet password"}),
                                    className: "w-max",
                                    value: u,
                                    onChange: e => d(e.target.value)
                                })
                            }), (0, e.jsx)(Vd, {
                                onClick: () => async function (e) {
                                    m && (await m.login(e), await g(m), d(void 0))
                                }((0, Ks.Wg)(u)),
                                disabled: (null !== (v = null == u ? void 0 : u.length) && void 0 !== v ? v : 0) < 8,
                                children: (0, e.jsx)(cl, {id: "xQtL3v", defaultMessage: "Unlock"})
                            })]
                        })]
                    }), null != m && m.isReady() ? (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsxs)("div", {
                            className: "card",
                            children: [(0, e.jsx)("h3", {children: null == i ? void 0 : i.alias}), m instanceof bS.n ? null : (0, e.jsx)("small", {
                                children: (0, e.jsx)(cl, {
                                    id: "VN0+Fz",
                                    defaultMessage: "Balance: {amount} sats",
                                    values: {amount: (0, e.jsx)(yl, {value: null != a ? a : 0})}
                                })
                            })]
                        }), m instanceof bS.n ? null : (0, e.jsxs)(e.Fragment, {
                            children: [(0, e.jsx)("h3", {
                                children: (0, e.jsx)(cl, {
                                    id: "d6CyG5",
                                    defaultMessage: "History"
                                })
                            }), null == l ? void 0 : l.map((t => {
                                var n;
                                return (0, e.jsxs)("div", {
                                    className: "card flex wallet-history-item",
                                    children: [(0, e.jsxs)("div", {
                                        className: "f-grow f-col",
                                        children: [(0, e.jsx)(xb, {
                                            from: 1e3 * t.timestamp,
                                            fallback: r({id: "kaaf1E", defaultMessage: "now"})
                                        }), (0, e.jsx)("div", {children: 0 === (null !== (n = t.memo) && void 0 !== n ? n : "").length ? (0, e.jsx)(e.Fragment, {children: ""}) : t.memo})]
                                    }), (0, e.jsxs)("div", {
                                        className: `nowrap ${(() => {
                                            switch (t.state) {
                                                case Wu.kd.Paid:
                                                    return "success";
                                                case Wu.kd.Expired:
                                                    return "expired";
                                                case Wu.kd.Failed:
                                                    return "failed";
                                                default:
                                                    return "pending"
                                            }
                                        })()}`,
                                        children: [y(t.state), (0, e.jsx)(cl, {
                                            id: "vrTOHJ",
                                            defaultMessage: "{amount} sats",
                                            values: {amount: (0, e.jsx)(yl, {value: t.amount / 1e3})}
                                        })]
                                    })]
                                }, t.timestamp)
                            }))]
                        })]
                    }) : null, (0, e.jsx)("button", {
                        onClick: () => Wu.uo.remove((0, Ks.Wg)(p.config).id),
                        children: (0, e.jsx)(cl, {id: "R2OqnW", defaultMessage: "Delete Account"})
                    })]
                });
                var v, b
            }), {})
        }], xS = t => {
            let {text: n, onClick: r} = t;
            const {formatMessage: i} = al();
            return (0, e.jsxs)("button", {
                className: "back-button", type: "button", onClick: () => {
                    r && r()
                }, children: [(0, e.jsx)(Gl, {name: "arrowBack"}), n || i(Su.Back)]
            })
        };

        function ES(t) {
            var n;
            const r = `note card ${null !== (n = t.className) && void 0 !== n ? n : ""}`;
            return (0, e.jsxs)("div", {
                className: r,
                children: [(0, e.jsx)("div", {
                    className: "header",
                    children: (0, e.jsx)(Zl, {pubkey: ""})
                }), (0, e.jsx)("div", {
                    className: "body",
                    children: t.children
                }), (0, e.jsx)("div", {className: "footer"})]
            })
        }

        const SS = t => {
            let {variant: n = "regular"} = t;
            const r = "small" === n ? "divider divider-small" : "divider";
            return (0, e.jsx)("div", {className: "divider-container", children: (0, e.jsx)("div", {className: r})})
        }, kS = t => {
            let {active: n, notes: r, related: i, chains: s, onNavigate: a} = t;
            return (0, e.jsx)("div", {
                className: "subthread", children: r.map(((t, o) => {
                    const l = o === r.length - 1, c = RS(t.id, s);
                    return (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsxs)("div", {
                            className: "subthread-container " + (c.length > 0 ? "subthread-multi" : ""),
                            children: [(0, e.jsx)(SS, {}), (0, e.jsx)(Pb, {
                                highlight: n === t.id,
                                className: "thread-note " + (l && 0 === c.length ? "is-last-note" : ""),
                                data: t,
                                related: i,
                                onClick: a
                            }, t.id), (0, e.jsx)("div", {className: "line-container"})]
                        }), c.length > 0 && (0, e.jsx)(TS, {
                            active: n,
                            isLastSubthread: l,
                            notes: c,
                            related: i,
                            chains: s,
                            onNavigate: a
                        })]
                    })
                }))
            })
        }, AS = n => {
            let {active: r, note: i, isLast: s, isLastSubthread: a, related: o, chains: l, onNavigate: c} = n;
            const {formatMessage: u} = al(), d = RS(i.id, l),
                h = d.map((e => e.id)).includes(r), [f, p] = (0, t.useState)(!h), m = d.length > 1, g = a && s && !m,
                y = "subthread-container " + (s && f ? "subthread-last" : "subthread-multi subthread-mid");
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsxs)("div", {
                    className: y,
                    children: [(0, e.jsx)(SS, {variant: "small"}), (0, e.jsx)(Pb, {
                        highlight: r === i.id,
                        className: "thread-note " + (g ? "is-last-note" : ""),
                        data: i,
                        related: o,
                        onClick: c
                    }, i.id), (0, e.jsx)("div", {className: "line-container"})]
                }), d.length > 0 && (0, e.jsx)(Qw, {
                    text: u(Su.ShowReplies),
                    collapsed: f,
                    setCollapsed: p,
                    children: (0, e.jsx)(CS, {
                        active: r,
                        isLastSubthread: a,
                        notes: d,
                        related: o,
                        chains: l,
                        onNavigate: c
                    })
                })]
            })
        }, TS = t => {
            let {active: n, isLastSubthread: r, notes: i, related: s, chains: a, onNavigate: o} = t;
            const [l, ...c] = i;
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)(AS, {
                    active: n,
                    onNavigate: o,
                    note: l,
                    chains: a,
                    related: s,
                    isLastSubthread: r,
                    isLast: 0 === c.length
                }), c.map(((t, i) => {
                    const l = i === c.length - 1;
                    return (0, e.jsx)(AS, {
                        active: n,
                        onNavigate: o,
                        note: t,
                        chains: a,
                        related: s,
                        isLastSubthread: r,
                        isLast: l
                    })
                }))]
            })
        }, CS = t => {
            let {active: n, isLastSubthread: r, notes: i, related: s, chains: a, onNavigate: o} = t;
            const [l, ...c] = i, u = RS(l.id, a), d = c.length > 0 || u.length > 0,
                h = 0 === u.length && 0 === c.length;
            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsxs)("div", {
                    className: `subthread-container ${d ? "subthread-multi" : ""} ${h ? "subthread-last" : "subthread-mid"}`,
                    children: [(0, e.jsx)(SS, {variant: "small"}), (0, e.jsx)(Pb, {
                        highlight: n === l.id,
                        className: "thread-note " + (r && h ? "is-last-note" : ""),
                        data: l,
                        related: s
                    }, l.id), (0, e.jsx)("div", {className: "line-container"})]
                }), u.length > 0 && (0, e.jsx)(CS, {
                    active: n,
                    isLastSubthread: r,
                    notes: u,
                    related: s,
                    chains: a,
                    onNavigate: o
                }), c.map(((t, i) => {
                    const a = i === c.length - 1, l = r && a;
                    return (0, e.jsxs)("div", {
                        className: `subthread-container ${a ? "" : "subthread-multi"} ${a ? "subthread-last" : "subthread-mid"}`,
                        children: [(0, e.jsx)(SS, {variant: "small"}), (0, e.jsx)(Pb, {
                            className: "thread-note " + (l ? "is-last-note" : ""),
                            highlight: n === t.id,
                            data: t,
                            related: s,
                            onClick: o
                        }, t.id), (0, e.jsx)("div", {className: "line-container"})]
                    }, t.id)
                }))]
            })
        };

        function RS(e, t) {
            if (!e || !t) return [];
            return t.get(e) || []
        }

        const LS = [{
            name: "nostr.band",
            owner: (0, Ks.FX)("npub1sx9rnd03vs34lp39fvfv5krwlnxpl90f3dzuk8y3cuwutk2gdhdqjz6g8m")
        }, {
            name: "semisol.dev",
            owner: (0, Ks.FX)("npub12262qa4uhw7u8gdwlgmntqtv7aye8vdcmvszkqwgs0zchel6mz7s6cgrkj")
        }, {
            name: "nostr.watch",
            owner: (0, Ks.FX)("npub1uac67zc9er54ln0kl6e4qp2y6ta3enfcg7ywnayshvlw9r5w6ehsqq99rx")
        }, {
            name: "nostr.directory",
            owner: (0, Ks.FX)("npub1teawtzxh6y02cnp9jphxm2q8u6xxfx85nguwg6ftuksgjctvavvqnsgq5u")
        }];

        function _S(t) {
            let {target: n} = t;
            const r = Qs(), i = (0, hl.useUserProfile)(DS, n.pubkey),
                s = (null == i ? void 0 : i.lud16) || (null == i ? void 0 : i.lud06),
                a = Math.ceil(r.preferences.defaultZapAmount * (n.split / 100));
            return (0, e.jsx)(Tb, {
                pubkey: n.pubkey,
                actions: s ? (0, e.jsxs)("div", {
                    children: [(0, e.jsxs)("div", {
                        children: [(0, e.jsx)(yl, {value: n.split}), "% (", (0, e.jsx)(cl, {
                            id: "CsCUYo",
                            defaultMessage: "{n} sats",
                            values: {n: a}
                        }), ")"]
                    }), (0, e.jsx)("input", {
                        type: "range",
                        min: 0,
                        max: 100,
                        value: n.split,
                        onChange: e => wd.set({...n, split: e.target.valueAsNumber})
                    })]
                }) : (0, e.jsx)(cl, {id: "JPFYIM", defaultMessage: "No lightning address"})
            })
        }

        function PS(t) {
            let {id: n} = t;
            const r = eE(n);
            return (0, e.jsx)("div", {children: null != r && r.connected ? (0, e.jsx)(e.Fragment, {children: n}) : (0, e.jsx)("s", {children: n})}, n)
        }

        function NS() {
            const t = (0, hl.useSystemState)(DS), {copy: n} = Gu();

            function r(e) {
                let t = 0;
                for (const n of e) for (const e of Object.values(n)) Array.isArray(e) && (t += e.length);
                return t
            }

            return (0, e.jsxs)(e.Fragment, {
                children: [(0, e.jsx)("b", {children: "Queries"}), null == t ? void 0 : t.queries.map((t => function (t) {
                    return (0, e.jsxs)("div", {
                        children: [t.id, (0, e.jsx)("br", {}), (0, e.jsxs)("span", {
                            onClick: () => n(JSON.stringify(t.filters)),
                            className: "pointer",
                            children: [" Filters: ", t.filters.length, " (", r(t.filters), " elements)"]
                        }), (0, e.jsx)("br", {}), (0, e.jsxs)("span", {
                            onClick: () => n(JSON.stringify(t.subFilters)),
                            className: "pointer",
                            children: [" SubQueries: ", t.subFilters.length, " (", r(t.subFilters), " elements)"]
                        })]
                    }, t.id)
                }(t)))]
            })
        }

        const jS = () => {
            const [n, r] = (0, t.useState)(0), i = [{text: "Connections", value: 0}, {text: "Queries", value: 1}];
            return (0, e.jsxs)("div", {
                className: "sub-debug",
                children: [(0, e.jsx)(db, {
                    tabs: i,
                    setTab: e => r(e.value),
                    tab: (0, Ks.Wg)(i.find((e => e.value === n)))
                }), (() => {
                    switch (n) {
                        case 0:
                            return (0, e.jsxs)(e.Fragment, {children: [(0, e.jsx)("b", {children: "Connections:"}), DS.Sockets.map((t => (0, e.jsx)(PS, {id: t.address})))]});
                        case 1:
                            return (0, e.jsx)(NS, {});
                        default:
                            return null
                    }
                })()]
            })
        };

        function IS(n) {
            var r;
            let {ev: i, link: s} = n;
            const [a, o] = (0, t.useState)(""), l = function (e) {
                const n = (0, t.useMemo)((() => {
                    const t = new Pt.RequestBuilder(`live:${e.id}:${e.author}`);
                    return t.withOptions({leaveOpen: !0}), t.withFilter().kinds([Pt.EventKind.ZapReceipt, 1311]).tag("a", [`${e.kind}:${e.author}:${e.id}`]).limit(100), t
                }), [e]);
                return (0, hl.useRequestBuilder)(DS, Pt.FlatNoteStore, n)
            }(s), c = hc(), {formatMessage: u} = al();

            async function d() {
                if (a.length > 1) {
                    const e = await (null == c ? void 0 : c.generic((e => e.kind(1311).content(a).tag(["a", `${s.kind}:${s.author}:${s.id}`]).processContent())));
                    e && (console.debug(e), DS.BroadcastEvent(e)), o("")
                }
            }

            return (0, e.jsxs)("div", {
                className: "live-chat",
                children: [(0, e.jsx)("div", {
                    children: (0, e.jsx)(cl, {
                        id: "BGxpTN",
                        defaultMessage: "Stream Chat"
                    })
                }), (0, e.jsx)("div", {children: [...null !== (r = l.data) && void 0 !== r ? r : []].sort(((e, t) => t.created_at - e.created_at)).map((t => (0, e.jsx)(MS, {ev: t}, t.id)))}), (0, e.jsxs)("div", {
                    children: [(0, e.jsx)(Tu, {
                        autoFocus: !1,
                        className: "",
                        onChange: e => o(e.target.value),
                        value: a,
                        onFocus: () => {
                        },
                        placeholder: u({id: "qInqHy", defaultMessage: "Message..."}),
                        onKeyDown: async e => {
                            "Enter" === e.code && (e.preventDefault(), await d())
                        }
                    }), (0, e.jsx)(Vd, {onClick: d, children: (0, e.jsx)(cl, {id: "9WRlF4", defaultMessage: "Send"})})]
                })]
            })
        }

        function MS(t) {
            let {ev: n} = t;
            const r = (0, hl.useUserProfile)(DS, n.pubkey), i = st();
            return (0, e.jsxs)("div", {
                className: "message",
                children: [(0, e.jsxs)("div", {
                    className: "name",
                    onClick: () => i((0, Ks._v)(n.pubkey, n.relays)),
                    children: [(0, e.jsx)(Vl, {user: r}), Xl(r, n.pubkey), ":"]
                }), (0, e.jsx)("span", {
                    children: (0, e.jsx)(uv, {
                        disableMedia: !0,
                        content: n.content,
                        creator: n.pubkey,
                        tags: n.tags
                    })
                })]
            })
        }

        const DS = new Pt.NostrSystem({
            relayCache: ac,
            profileCache: sc,
            relayMetrics: oc,
            authHandler: async (e, t) => {
                const {publicKey: n, privateKey: r} = Xs.snapshot();
                if (n) {
                    const i = new Pt.EventPublisher(n, r);
                    return await i.nip42Auth(e, t)
                }
            }
        });
        new Pt.ProfileLoaderService(DS, sc), window.__webpack_nonce__ = "ZmlhdGphZiBzYWlkIHNub3J0LnNvY2lhbCBpcyBwcmV0dHkgZ29vZCwgd2UgbWFkZSBpdCE=", "serviceWorker" in navigator && window.addEventListener("load", (() => {
            !async function (e) {
                try {
                    const e = await navigator.serviceWorker.register("service-worker.js");
                    e.onupdatefound = () => {
                        const t = e.installing;
                        null != t && (t.onstatechange = () => {
                            "installed" === t.state && (navigator.serviceWorker.controller ? console.log("Service worker updated, pending reload") : console.log("Content is cached for offline use."))
                        })
                    }
                } catch (e) {
                    console.error("Error during service worker registration:", e)
                }
            }()
        }));
        const OS = (BS = [{
            element: (0, e.jsx)((function () {
                const n = it(), r = g((e => e.noteCreator.replyTo)), i = g((e => e.noteCreator.show)), s = r && i,
                    a = S(), o = st(), {publicKey: l, relays: c, preferences: u, subscriptions: d} = Qs(),
                    h = Db(d), [f, p] = (0, t.useState)("page");
                !function () {
                    const e = Qs(), {publicKey: n, readNotifications: r, follows: i} = e, {isMuted: s} = pc(), a = hc(),
                        o = (0, t.useMemo)((() => {
                            if (!n) return null;
                            const e = new Pt.RequestBuilder(`login:${n.slice(0, 12)}`);
                            return e.withOptions({leaveOpen: !0}), e.withFilter().authors([n]).kinds([Pt.EventKind.ContactList]), e.withFilter().kinds([Pt.EventKind.TextNote]).tag("p", [n]).limit(1), e.withFilter().kinds([Pt.EventKind.SnortSubscriptions]).authors([(0, Ks.FX)(di)]).tag("p", [n]).limit(1), e.add(Lc.subscription(n)), e.add(_c.subscription("n29.nostr.com/")), e
                        }), [n]), l = (0, t.useMemo)((() => {
                            if (!n) return null;
                            const e = new Pt.RequestBuilder(`login:${n.slice(0, 12)}:lists`);
                            return e.withOptions({leaveOpen: !0}), e.withFilter().authors([n]).kinds([Pt.EventKind.PubkeyLists]).tag("d", [Pt.Lists.Muted, Pt.Lists.Followed, Pt.Lists.Pinned, Pt.Lists.Bookmarked]), e
                        }), [n]), c = (0, hl.useRequestBuilder)(DS, Pt.FlatNoteStore, o);
                    (0, t.useEffect)((() => {
                        if (c.data && a) {
                            const t = (0, Ks.zb)(c.data.filter((e => e.kind === Pt.EventKind.ContactList)));
                            if (t) {
                                if ("" !== t.content && "{}" !== t.content) {
                                    const n = JSON.parse(t.content);
                                    zs(e, n, 1e3 * t.created_at)
                                }
                                const n = t.tags.filter((e => "p" === e[0])).map((e => e[1]));
                                !function (e, t, n) {
                                    e.follows.timestamp >= n || (e.follows.item = t, e.follows.timestamp = n, Xs.updateSession(e))
                                }(e, n, 1e3 * t.created_at)
                            }
                            const n = c.data.filter((e => e.kind === Pt.EventKind.DirectMessage && e.tags.some((e => "p" === e[0]))));
                            Lc.onEvent(n);
                            const r = c.data.filter((e => e.kind === Pt.EventKind.SimpleChatMessage && e.tags.some((e => "g" === e[0]))));
                            _c.onEvent(r);
                            const i = c.data.filter((e => e.kind === Pt.EventKind.SnortSubscriptions && e.pubkey === (0, Ks.FX)(di)));
                            Promise.all(i.map((async e => {
                                const t = await a.decryptDm(e);
                                if (t) {
                                    const n = JSON.parse(t);
                                    return {id: e.id, ...n}
                                }
                            }))).then((t => function (e) {
                                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                                const i = (0, Ks.TR)([...e.subscriptions || [], ...n]);
                                i.length !== e.subscriptions.length && (e.subscriptions = i, Xs.updateSession(e))
                            }(e, ...t.filter((e => void 0 !== e)).map(Ks.Wg))))
                        }
                    }), [c, a]), (0, t.useEffect)((() => {
                        if (c.data) {
                            const t = c.data.filter((e => e.kind === Pt.EventKind.TextNote && !s(e.pubkey) && e.created_at > r));
                            t.forEach((async t => {
                                const n = await async function (e) {
                                    if (e.kind === Pt.EventKind.TextNote) {
                                        if (e.tags.some((0, Ks.JS)(e))) return null;
                                        const t = new Set([e.pubkey, ...e.tags.filter((e => "p" === e[0])).map((e => e[1]))]);
                                        await sc.buffer([...t]);
                                        const n = [...t].map((e => sc.getFromCache(e))).filter((e => e)).map((e => (0, Ks.Wg)(e))),
                                            r = sc.getFromCache(e.pubkey), i = Xl(r, e.pubkey),
                                            s = (null == r ? void 0 : r.picture) || ql;
                                        return {
                                            title: `Reply from ${i}`,
                                            body: dc(e, n).substring(0, 50),
                                            icon: s,
                                            timestamp: 1e3 * e.created_at
                                        }
                                    }
                                    return null
                                }(t);
                                n && async function (e, t) {
                                    if ("Notification" in window && "granted" === Notification.permission && t.timestamp > e.readNotifications) try {
                                        (await navigator.serviceWorker.ready).showNotification(t.title, {
                                            tag: "notification",
                                            vibrate: [500], ...t
                                        })
                                    } catch (e) {
                                        console.warn(e)
                                    }
                                }(e, n)
                            }))
                        }
                    }), [c, r]);
                    const u = (0, hl.useRequestBuilder)(DS, Pt.FlatNoteStore, l);
                    (0, t.useEffect)((() => {
                        if (u.data) {
                            const t = (e, t) => e.filter((e => (0, Ks.Wg)(e.tags.find((e => "d" === e[0])))[1] === t));
                            !function (t) {
                                var r, i, s;
                                const o = fc(t);
                                Ws(e, o.keys, 1e3 * o.createdAt), o.raw && (null !== (r = null === (i = o.raw) || void 0 === i || null === (s = i.content) || void 0 === s ? void 0 : s.length) && void 0 !== r ? r : 0) > 0 && n && (null == a || a.nip4Decrypt(o.raw.content, n).then((t => {
                                    try {
                                        const n = JSON.parse(t).filter((e => e && 2 === e.length && "p" === e[0])).map((e => e[1]));
                                        Vs(e, n, 1e3 * (0, Ks.Wg)(o.raw).created_at)
                                    } catch (e) {
                                        console.debug("Couldn't parse JSON")
                                    }
                                })).catch((e => console.warn(e))))
                            }(t(u.data, Pt.Lists.Muted)), function (t) {
                                const n = (0, Ks.uB)(t, "e");
                                n && Ys(e, n.keys, 1e3 * n.createdAt)
                            }(t(u.data, Pt.Lists.Pinned)), function (t) {
                                const n = (0, Ks.uB)(t, "t");
                                n && qs(e, n.keys, 1e3 * n.createdAt)
                            }(t(u.data, Pt.Lists.Followed)), function (t) {
                                const n = (0, Ks.uB)(t, "e");
                                n && Zs(e, n.keys, 1e3 * n.createdAt)
                            }(t(u.data, Pt.Lists.Bookmarked))
                        }
                    }), [u]), (0, t.useEffect)((() => {
                        ac.buffer(i.item).catch(console.error), DS.ProfileLoader.TrackMetadata(i.item)
                    }), [i.item]);
                    const d = function (e) {
                        var n, r, i, s;
                        const a = (0, t.useMemo)((() => {
                            const t = new Pt.RequestBuilder("relays:follows"), n = ac.newest();
                            return wc()("LoginFeed")("Loading relay lists since %s", new Date(1e3 * n).toISOString()), t.withFilter().authors(e).kinds([Pt.EventKind.Relays, Pt.EventKind.ContactList]).since(n), t
                        }), [e]);

                        function o(e) {
                            return e.map((e => ({
                                pubkey: e.pubkey,
                                created_at: e.created_at,
                                relays: e.tags.map((e => ({
                                    url: (0, Ks.mY)(e[1]),
                                    settings: {
                                        read: "read" === e[2] || void 0 === e[2],
                                        write: "write" === e[2] || void 0 === e[2]
                                    }
                                }))).filter((e => void 0 !== e.url))
                            })))
                        }

                        const l = (0, hl.useRequestBuilder)(DS, Pt.PubkeyReplaceableNoteStore, a),
                            c = null !== (n = null === (r = l.data) || void 0 === r ? void 0 : r.filter((e => e.kind === Pt.EventKind.Relays))) && void 0 !== n ? n : [],
                            u = null !== (i = null === (s = l.data) || void 0 === s ? void 0 : s.filter((e => e.kind === Pt.EventKind.ContactList))) && void 0 !== i ? i : [];
                        return (0, t.useMemo)((() => {
                            return [...(e = u, e.map((e => {
                                if ("" !== e.content && "{}" !== e.content && e.content.startsWith("{") && e.content.endsWith("}")) try {
                                    const t = JSON.parse(e.content);
                                    return {
                                        pubkey: e.pubkey,
                                        created_at: e.created_at,
                                        relays: Object.entries(t).map((e => {
                                            let [t, n] = e;
                                            return {url: (0, Ks.mY)(t), settings: n}
                                        })).filter((e => void 0 !== e.url))
                                    }
                                } catch {
                                }
                                return {pubkey: e.pubkey, created_at: 0, relays: []}
                            }))), ...o(c)];
                            var e
                        }), [l])
                    }(i.item);
                    (0, t.useEffect)((() => {
                        ac.bulkSet(d).catch(console.error)
                    }), [d])
                }();
                const m = (0, t.useMemo)((() => s || ["/settings", "/messages", "/new", "/login", "/donate", "/p/", "/e", "/subscribe", "/live"].some((e => n.pathname.startsWith(e)))), [n, s]),
                    y = (0, t.useMemo)((() => ["/login", "/new"].some((e => n.pathname.startsWith(e)))), [n]);

                function v(e) {
                    const t = document.documentElement;
                    "light" !== e || t.classList.contains("light") ? "dark" === e && t.classList.contains("light") && t.classList.remove("light") : t.classList.add("light")
                }

                return (0, t.useEffect)((() => {
                    ["/login", "/messages", "/live"].some((e => n.pathname.startsWith(e))) ? p(["/messages", "/live"].some((e => n.pathname.startsWith(e))) ? "scroll-lock" : "") : p("page")
                }), [n]), (0, t.useEffect)((() => {
                    c && (async () => {
                        for (const [e, t] of Object.entries(c.item)) await DS.ConnectToRelay(e, t);
                        for (const e of DS.Sockets) c.item[e.address] || e.ephemeral || DS.DisconnectRelay(e.address)
                    })()
                }), [c]), (0, t.useEffect)((() => {
                    const e = window.matchMedia("(prefers-color-scheme: light)");
                    return v("system" === u.theme && e.matches || "light" === u.theme ? "light" : "dark"), e.onchange = e => {
                        "system" === u.theme && v(e.matches ? "light" : "dark")
                    }, () => {
                        e.onchange = null
                    }
                }), [u.theme]), (0, e.jsxs)("div", {
                    className: f,
                    children: [!y && (0, e.jsxs)("header", {
                        className: "main-content mt5",
                        children: [(0, e.jsxs)("div", {
                            className: "logo",
                            onClick: () => o("/"),
                            children: [(0, e.jsx)("h1", {children: "Snort"}), h && (0, e.jsxs)("small", {
                                className: "flex",
                                children: [(0, e.jsx)(Gl, {name: "diamond", size: 10, className: "mr5"}), Wb(h.type)]
                            })]
                        }), (0, e.jsx)("div", {
                            children: l ? (0, e.jsx)(Xb, {}) : (0, e.jsx)("button", {
                                type: "button",
                                onClick: () => o("/login"),
                                children: (0, e.jsx)(cl, {...vl})
                            })
                        })]
                    }), (0, e.jsx)(yt, {}), !m && (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("button", {
                            className: "note-create-button",
                            onClick: () => {
                                r && a(Zo()), a(Bo(!0))
                            },
                            children: (0, e.jsx)(Gl, {name: "plus", size: 16})
                        }), (0, e.jsx)(Bb, {})]
                    }), (0, e.jsx)(od, {})]
                })
            }), {}), errorElement: (0, e.jsx)((() => {
                const t = mt();
                return console.error(t), (0, e.jsxs)("div", {
                    className: "main-content page",
                    children: [(0, e.jsx)("h4", {
                        children: (0, e.jsx)(cl, {
                            id: "FfYsOb",
                            defaultMessage: "An error has occured!"
                        })
                    }), (0, e.jsx)(Vd, {
                        onClick: async () => {
                            await tc.delete(), globalThis.localStorage.clear(), globalThis.location.href = "/"
                        }, children: (0, e.jsx)(cl, {id: "HWbkEK", defaultMessage: "Clear cache and reload"})
                    }), (0, e.jsx)("pre", {
                        children: JSON.stringify(t instanceof Error ? {
                            name: t.name,
                            message: t.message,
                            stack: t.stack
                        } : t, void 0, "  ")
                    })]
                })
            }), {}), loader: async () => {
                const e = Xs.takeSnapshot();
                tc.ready = await tc.isAvailable(), tc.ready && await async function (e) {
                    const t = [sc.preload(e), lc.preload(), uc.preload(), ac.preload(e), oc.preload()];
                    await Promise.all(t)
                }(e.follows.item);
                for (const [t, n] of Object.entries(e.relays.item)) DS.ConnectToRelay(t, n);
                try {
                    "registerProtocolHandler" in window.navigator && (window.navigator.registerProtocolHandler("web+nostr", `${window.location.protocol}//${window.location.host}/%s`), console.info("Registered protocol handler for 'web+nostr'"))
                } catch (e) {
                    console.error("Failed to register protocol handler", e)
                }
                return null
            }, children: [...Kw, {
                path: "/login", element: (0, e.jsx)((function () {
                    var n;
                    const r = st(),
                        i = Qs(), [s, a] = (0, t.useState)(""), [o, l] = (0, t.useState)(""), [c, u] = (0, t.useState)(), [d, h] = (0, t.useState)(!0), {formatMessage: f} = al(), {proxy: p} = Wl(),
                        m = Jb(), g = "nostr" in window, y = void 0 !== window.crypto.subtle;

                    async function v() {
                        var e;
                        const t = "getRelays" in (0, Ks.Wg)(window.nostr) ? await (0, Ks.Wg)(null === (e = window.nostr) || void 0 === e ? void 0 : e.getRelays).call(window.nostr) : void 0,
                            n = await (0, Ks.Wg)(window.nostr).getPublicKey();
                        Xs.loginWithPubkey(n, t)
                    }

                    return (0, t.useEffect)((() => {
                        i.publicKey && r("/")
                    }), [i, r]), (0, t.useEffect)((() => {
                        const e = (0, Ks.Wg)(tw.at(tw.length * Math.random())), t = p(e.link);
                        u({...e, link: t})
                    }), []), (0, e.jsxs)("div", {
                        className: "login", children: [(0, e.jsx)("div", {
                            children: (0, e.jsxs)("div", {
                                className: "login-container",
                                children: [(0, e.jsx)("h1", {
                                    className: "logo",
                                    onClick: () => r("/"),
                                    children: "Snort"
                                }), (0, e.jsx)("h1", {
                                    dir: "auto",
                                    children: (0, e.jsx)(cl, {id: "odhABf", defaultMessage: "Login"})
                                }), (0, e.jsx)("p", {
                                    dir: "auto",
                                    children: (0, e.jsx)(cl, {id: "wLtRCF", defaultMessage: "Your key"})
                                }), (0, e.jsxs)("div", {
                                    className: "flex",
                                    children: [(0, e.jsx)("input", {
                                        dir: "auto",
                                        type: d ? "password" : "text",
                                        placeholder: f({
                                            id: "X7xU8J",
                                            defaultMessage: "nsec, npub, nip-05, hex, mnemonic"
                                        }),
                                        className: "f-grow",
                                        onChange: e => a(e.target.value)
                                    }), (0, e.jsx)(Gl, {
                                        name: d ? "openeye" : "closedeye",
                                        size: 30,
                                        className: "highlight btn-sm pointer",
                                        onClick: () => h(!d)
                                    })]
                                }), o.length > 0 ? (0, e.jsx)("b", {
                                    className: "error",
                                    children: o
                                }) : null, (0, e.jsx)("p", {
                                    children: (0, e.jsx)(cl, {
                                        id: "o6Uy3d",
                                        defaultMessage: "Only the secret key can be used to publish (sign events), everything else logs you in read-only mode."
                                    })
                                }), (0, e.jsxs)("div", {
                                    dir: "auto",
                                    className: "login-actions",
                                    children: [(0, e.jsx)("button", {
                                        type: "button", onClick: async function () {
                                            try {
                                                await m.doLogin(s)
                                            } catch (e) {
                                                e instanceof Error ? l(e.message) : l(f({
                                                    id: "OLEm6z",
                                                    defaultMessage: "Unknown login error"
                                                })), console.error(e)
                                            }
                                        }, children: (0, e.jsx)(cl, {id: "9gqH2W", defaultMessage: "Login"})
                                    }), (0, e.jsx)(Vd, {
                                        onClick: () => async function () {
                                            await async function () {
                                                const e = Us(), t = si.ci(e), n = $s(e);
                                                let r = {};
                                                try {
                                                    const e = await fetch("https://api.nostr.watch/v1/online");
                                                    if (e.ok) {
                                                        const t = await e.json(),
                                                            n = (0, Ks.mp)(t, 4).map((e => [(0, Ks.Wg)((0, Ks.mY)(e)), {
                                                                read: !0,
                                                                write: !0
                                                            }]));
                                                        r = {...Object.fromEntries(n), ...Object.fromEntries(hi.entries())}
                                                    }
                                                } catch (e) {
                                                    console.warn(e)
                                                }
                                                const i = si.ci(ii.xW.getPublicKey(n)), s = new Pt.EventPublisher(i, n),
                                                    a = await s.contactList([(0, Ks.FX)(di), i], r);
                                                DS.BroadcastEvent(a), Xs.loginWithPrivateKey(n, t, r)
                                            }(), r("/new")
                                        }(), children: (0, e.jsx)(cl, {id: "5JcXdV", defaultMessage: "Create Account"})
                                    }), function () {
                                        if (g) return (0, e.jsx)("button", {
                                            type: "button",
                                            onClick: v,
                                            children: (0, e.jsx)(cl, {
                                                id: "VtPV/B",
                                                defaultMessage: "Login with Extension (NIP-07)"
                                            })
                                        })
                                    }()]
                                }), function () {
                                    if (!y) return (0, e.jsxs)(e.Fragment, {
                                        children: [(0, e.jsxs)("div", {
                                            className: "flex login-or",
                                            children: [(0, e.jsx)(cl, {
                                                id: "3xCwbZ",
                                                defaultMessage: "OR"
                                            }), (0, e.jsx)("div", {className: "divider w-max"})]
                                        }), (0, e.jsx)("h1", {
                                            dir: "auto",
                                            children: (0, e.jsx)(cl, {
                                                id: "c+oiJe",
                                                defaultMessage: "Install Extension"
                                            })
                                        }), (0, e.jsx)("p", {
                                            children: (0, e.jsx)(cl, {
                                                id: "XzF0aC",
                                                defaultMessage: "Key manager extensions are more secure and allow you to easily login to any Nostr client, here are some well known extensions:"
                                            })
                                        }), (0, e.jsxs)("ul", {
                                            children: [(0, e.jsx)("li", {
                                                children: (0, e.jsx)("a", {
                                                    href: "https://getalby.com/",
                                                    target: "_blank",
                                                    rel: "noreferrer",
                                                    children: "Alby"
                                                })
                                            }), (0, e.jsx)("li", {
                                                children: (0, e.jsx)("a", {
                                                    href: "https://chrome.google.com/webstore/detail/nos2x/kpgefcfmnafjgpblomihpgmejjdanjjp",
                                                    target: "_blank",
                                                    rel: "noreferrer",
                                                    children: "nos2x"
                                                })
                                            })]
                                        }), (0, e.jsx)("p", {
                                            children: (0, e.jsx)(cl, {
                                                id: "lBboHo",
                                                defaultMessage: "If you want to try out some others, check out {link} for more!",
                                                values: {
                                                    link: (0, e.jsx)("a", {
                                                        href: "https://github.com/aljazceru/awesome-nostr#browser-extensions",
                                                        children: "awesome-nostr"
                                                    })
                                                }
                                            })
                                        }), (0, e.jsx)("p", {
                                            children: (0, e.jsx)(cl, {
                                                id: "5rOdPG",
                                                defaultMessage: "Once you setup your key manager extension and generated a key, you can follow our new users flow to setup your profile and help you find some interesting people on Nostr to follow."
                                            })
                                        }), g ? (0, e.jsx)("div", {
                                            className: "login-actions",
                                            children: (0, e.jsx)("button", {
                                                type: "button",
                                                onClick: () => v().then((() => r("/new/username"))),
                                                children: (0, e.jsx)(cl, {
                                                    id: "nOaArs",
                                                    defaultMessage: "Setup Profile"
                                                })
                                            })
                                        }) : (0, e.jsx)("b", {
                                            className: "error",
                                            children: (0, e.jsx)(cl, {
                                                id: "VBadwB",
                                                defaultMessage: "Hmm, can't find a key manager extension.. try reloading the page."
                                            })
                                        })]
                                    })
                                }()]
                            })
                        }), (0, e.jsx)("div", {
                            children: (0, e.jsx)("div", {
                                className: "artwork",
                                style: {"--img-src": `url('${null == c ? void 0 : c.link}')`},
                                children: (0, e.jsxs)("div", {
                                    className: "attribution",
                                    children: [(0, e.jsx)(cl, {
                                        id: "QxCuTo",
                                        defaultMessage: "Art by {name}",
                                        values: {name: (0, e.jsx)("span", {className: "artist", children: "Karnage"})}
                                    }), (0, e.jsx)(Qb, {pubkey: null !== (n = null == c ? void 0 : c.pubkey) && void 0 !== n ? n : ""})]
                                })
                            })
                        })]
                    })
                }), {})
            }, {
                path: "/help", element: (0, e.jsx)((function () {
                    return (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("h2", {
                            children: (0, e.jsx)(cl, {
                                id: "7hp70g",
                                defaultMessage: "NIP-05"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "c35bj2",
                                defaultMessage: "If you have an enquiry about your NIP-05 order please DM {link}",
                                values: {link: (0, e.jsx)(Rt, {to: `/messages/${ui}`, children: "Kieran"})}
                            })
                        })]
                    })
                }), {})
            }, {
                path: "/e/:id", element: (0, e.jsx)((function () {
                    var n, r;
                    const i = ot(), s = it(),
                        a = (0, Pt.parseNostrLink)(null !== (n = i.id) && void 0 !== n ? n : "", Pt.NostrPrefix.Note),
                        o = function (e) {
                            const [n, r] = (0, t.useState)([]), [i, s] = (0, t.useState)([]), [a, o] = (0, t.useState)([]),
                                l = Qs().preferences, c = (0, t.useMemo)((() => {
                                    const t = new Pt.RequestBuilder(`thread:${e.id.substring(0, 8)}`);
                                    if (t.withOptions({leaveOpen: !0}), n.length > 0) for (const e of n) {
                                        const n = t.withFilter();
                                        n.ids([e.id]), e.relay && n.relay(e.relay)
                                    }
                                    if (a.length > 0 && t.withFilter().kinds(l.enableReactions ? [Pt.EventKind.Reaction, Pt.EventKind.TextNote, Pt.EventKind.Repost, Pt.EventKind.ZapReceipt] : [Pt.EventKind.TextNote, Pt.EventKind.ZapReceipt, Pt.EventKind.Repost]).tag("e", a.map((e => e.id))), i.length > 0) {
                                        const e = i.map((e => e.split(":")));
                                        t.withFilter().kinds(e.map((e => Number(e[0])))).authors(e.map((e => e[1]))).tag("d", e.map((e => e[2]))), t.withFilter().tag("a", i)
                                    }
                                    return t
                                }), [n, i, a, l]), u = (0, hl.useRequestBuilder)(DS, Pt.FlatNoteStore, c);
                            return (0, t.useEffect)((() => {
                                if (e.type === Pt.NostrPrefix.Address) s([`${e.kind}:${e.author}:${e.id}`]); else {
                                    var t;
                                    const n = {
                                        id: e.id,
                                        relay: null === (t = e.relays) || void 0 === t ? void 0 : t[0]
                                    };
                                    r([n]), o([n])
                                }
                            }), [e.id]), (0, t.useEffect)((() => {
                                if (u.data) {
                                    var e, t;
                                    const n = null !== (e = null === (t = u.data) || void 0 === t ? void 0 : t.filter((e => e.kind === Pt.EventKind.TextNote || e.kind === Pt.EventKind.Polls))) && void 0 !== e ? e : [],
                                        i = n.map((e => e.tags.filter((e => "e" === e[0])).map((e => ({
                                            id: e[1],
                                            relay: e[2]
                                        }))))).flat(), a = i.filter((e => !n.some((t => t.id === e.id))));
                                    r((e => (0, Ks.NP)(e, a))), o((e => (0, Ks.NP)(e, i)));
                                    const l = n.map((e => e.tags.filter((e => "a" === e[0])).map((e => e[1])))).flat();
                                    s((e => (0, Ks.NP)(e, l)))
                                }
                            }), [u]), u
                        }(a), [l, c] = (0, t.useState)(a.id), u = st(),
                        d = 1 === (null === (r = o.data) || void 0 === r ? void 0 : r.filter((e => e.kind === Pt.EventKind.TextNote)).length), {formatMessage: h} = al();

                    function f(e) {
                        c(e.id)
                    }

                    const p = (0, t.useMemo)((() => {
                        const e = new Map;
                        var t;
                        return o.data && (null === (t = o.data) || void 0 === t || t.filter((e => e.kind === Pt.EventKind.TextNote)).sort(((e, t) => t.created_at - e.created_at)).forEach((t => {
                            var n, r, i, s, a;
                            const l = Pt.EventExt.extractThread(t);
                            let c = null !== (n = null == l || null === (r = l.replyTo) || void 0 === r ? void 0 : r.value) && void 0 !== n ? n : null == l || null === (i = l.root) || void 0 === i ? void 0 : i.value;
                            if ("a" === (null == l || null === (s = l.root) || void 0 === s ? void 0 : s.key) && null != l && null !== (a = l.root) && void 0 !== a && a.value) {
                                var u, d;
                                const e = l.root.value.split(":");
                                c = null === (u = o.data) || void 0 === u || null === (d = u.find((t => t.kind === Number(e[0]) && t.pubkey === e[1] && (0, Ks.MV)(t, "d") === e[2]))) || void 0 === d ? void 0 : d.id
                            }
                            c && (e.has(c) ? (0, Ks.Wg)(e.get(c)).push(t) : e.set(c, [t]))
                        }))), e
                    }), [o.data]), m = (0, t.useMemo)((() => {
                        var e, t;
                        const n = null !== (e = null === (t = o.data) || void 0 === t ? void 0 : t.find((e => e.id === l || a.type === Pt.NostrPrefix.Address && (0, Ks.MV)(e, "d") === l && e.pubkey === a.author))) && void 0 !== e ? e : s.state && "sig" in s.state ? s.state : void 0;
                        if (n) {
                            var r, i;
                            const e = Pt.EventExt.extractThread(n), t = e => void 0 === e;
                            if (t(e)) return n;
                            const s = null !== (r = null == e ? void 0 : e.replyTo) && void 0 !== r ? r : null == e ? void 0 : e.root;
                            if (s) {
                                if ("a" === s.key && s.value) {
                                    var c;
                                    const e = s.value.split(":");
                                    return null === (c = o.data) || void 0 === c ? void 0 : c.find((t => t.kind === Number(e[0]) && t.pubkey === e[1] && (0, Ks.MV)(t, "d") === e[2]))
                                }
                                var u;
                                if (s.value) return null === (u = o.data) || void 0 === u ? void 0 : u.find((e => e.id === s.value))
                            }
                            const a = null === (i = o.data) || void 0 === i ? void 0 : i.filter((e => {
                                const n = Pt.EventExt.extractThread(e);
                                return t(n)
                            }));
                            if (a) for (const e of a) {
                                var d;
                                if ((null !== (d = p.get(e.id)) && void 0 !== d ? d : []).find((e => e.id === l))) return e
                            }
                        }
                    }), [o.data, l, s]), g = (0, t.useMemo)((() => {
                        if (m) {
                            var e, t, n, r, i, s;
                            const a = Pt.EventExt.extractThread(m);
                            return null !== (e = null !== (t = null == a || null === (n = a.replyTo) || void 0 === n ? void 0 : n.value) && void 0 !== t ? t : null == a || null === (r = a.root) || void 0 === r ? void 0 : r.value) && void 0 !== e ? e : "a" === (null == a || null === (i = a.root) || void 0 === i ? void 0 : i.key) && (null === (s = a.root) || void 0 === s ? void 0 : s.value)
                        }
                    }), [m]), y = Array.from(null == p ? void 0 : p.keys()).filter((e => {
                        var t;
                        return !(null !== (t = o.data) && void 0 !== t && t.some((t => t.id === e)))
                    }));

                    function v(t) {
                        if (!t || !p) return;
                        const n = p.get(t);
                        return n && l ? (0, e.jsx)(kS, {
                            active: l,
                            notes: n,
                            related: (0, Ks.wo)(o.data, n.map((e => e.id))),
                            chains: p,
                            onNavigate: f
                        }) : void 0
                    }

                    const b = h({id: "ADmfQT", defaultMessage: "Parent"}),
                        w = h({id: "jfV8Wr", defaultMessage: "Back"});
                    return (0, e.jsxs)("div", {
                        className: "main-content mt10",
                        children: [(0, e.jsx)(xS, {
                            onClick: function () {
                                g ? c(g) : u(-1)
                            }, text: g ? b : w
                        }), (0, e.jsxs)("div", {
                            className: "thread-container", children: [m && function (t) {
                                const n = "thread-root" + (d ? " thread-root-single" : "");
                                return t ? (0, e.jsx)(Pb, {
                                    className: n,
                                    data: t,
                                    related: (0, Ks.Ym)(o.data, t.id),
                                    options: {showReactionsLink: !0},
                                    onClick: f
                                }, t.id) : (0, e.jsxs)(ES, {
                                    className: n,
                                    children: ["Loading thread root.. (", null === (r = o.data) || void 0 === r ? void 0 : r.length, " notes loaded)"]
                                });
                                var r
                            }(m), m && v(m.id), y.length > 0 && (0, e.jsx)("h3", {children: "Other replies"}), y.map((t => (0, e.jsxs)("div", {
                                className: "mb10",
                                children: [(0, e.jsxs)(ES, {
                                    className: "thread-note thread-root ghost-root",
                                    children: ["Missing event ", (0, e.jsx)(Rt, {
                                        to: (0, Ks.sC)(t),
                                        children: t.substring(0, 8)
                                    })]
                                }, t), v(t)]
                            })))]
                        })]
                    })
                }), {})
            }, {
                path: "/p/:id", element: (0, e.jsx)((function () {
                    var n;
                    const {formatMessage: r} = al(), i = ot(), s = st(), [a, o] = (0, t.useState)(),
                        l = (0, hl.useUserProfile)(DS, a), c = Qs().publicKey,
                        u = c === a, [d, h] = (0, t.useState)(!1), [f, p] = (0, t.useState)(!1),
                        m = (null == l ? void 0 : l.about) || "",
                        g = uv({content: m, tags: [], creator: "", disableMedia: !0}),
                        y = null != a && a.startsWith(Pt.NostrPrefix.PublicKey) ? a : (0, Ks.jm)(Pt.NostrPrefix.PublicKey, a || void 0),
                        v = (() => {
                            try {
                                return new ai.LNURL((null == l ? void 0 : l.lud16) || (null == l ? void 0 : l.lud06) || "")
                            } catch {
                            }
                        })(),
                        b = null != l && l.website && !l.website.startsWith("http") ? "https://" + l.website : (null == l ? void 0 : l.website) || "", {blocked: w} = pc(),
                        x = function (e) {
                            const t = Qs().pinned.item;
                            return aw(e, Pt.Lists.Pinned, t)
                        }(a), E = function (e) {
                            const {publicKey: n, muted: r} = Qs(), i = n === e, s = (0, t.useMemo)((() => {
                                    if (i || !e) return null;
                                    const t = new Pt.RequestBuilder(`muted:${e.slice(0, 12)}`);
                                    return t.withFilter().authors([e]).kinds([Pt.EventKind.PubkeyLists]).tag("d", [Pt.Lists.Muted]), t
                                }), [e]), a = (0, hl.useRequestBuilder)(DS, Pt.ParameterizedReplaceableNoteStore, s),
                                o = (0, t.useMemo)((() => e && a.data ? function (e, t) {
                                    const n = e.filter((e => e.kind === Pt.EventKind.PubkeyLists && e.pubkey === t));
                                    return fc(n).keys
                                }(a.data, e) : []), [a, e]);
                            return i ? r.item : o
                        }(a), S = function (e) {
                            const n = (0, t.useMemo)((() => {
                                    if (!e) return null;
                                    const t = new Pt.RequestBuilder(`badges:${e.slice(0, 12)}`);
                                    return t.withFilter().kinds([Pt.EventKind.ProfileBadges]).tag("d", [Pt.Lists.Badges]).authors([e]), t
                                }), [e]), r = (0, hl.useRequestBuilder)(DS, Pt.ReplaceableNoteStore, n),
                                i = (0, t.useMemo)((() => r.data ? (0, Ks.OZ)(r.data.tags.filter((e => "a" === e[0] || "e" === e[0])), 2).reduce(((e, t) => {
                                    let [n, r] = t;
                                    return {...e, [r[1]]: n[1]}
                                }), {}) : {}), [r]), {
                                    ds: s,
                                    pubkeys: a
                                } = (0, t.useMemo)((() => Object.values(i).reduce(((e, t) => {
                                    const [, n, r] = t.split(":");
                                    return e.pubkeys.push(n), (null == r ? void 0 : r.length) > 0 && e.ds.push(r), e
                                }), {pubkeys: [], ds: []})), [i]), o = (0, t.useMemo)((() => {
                                    const t = Object.keys(i);
                                    if (!e || 0 === t.length) return null;
                                    const n = new Pt.RequestBuilder(`profile_awards:${e.slice(0, 12)}`);
                                    return n.withFilter().kinds([Pt.EventKind.BadgeAward]).ids(t), n.withFilter().kinds([Pt.EventKind.Badge]).tag("d", s).authors(a), n
                                }), [i, s]), l = (0, hl.useRequestBuilder)(DS, Pt.FlatNoteStore, o), c = (0, t.useMemo)((() => {
                                    if (l.data) return l.data.map(((e, t, n) => {
                                        var r, i, s;
                                        const [, a, o] = null !== (r = null === (i = e.tags.find((e => "a" === e[0]))) || void 0 === i || null === (s = i.at(1)) || void 0 === s ? void 0 : s.split(":")) && void 0 !== r ? r : [],
                                            l = n.find((e => e.pubkey === a && (0, Ks.MV)(e, "d") === o));
                                        return {award: e, badge: l}
                                    })).filter((t => {
                                        let {award: n, badge: r} = t;
                                        return r && n.pubkey === r.pubkey && n.tags.find((t => "p" === t[0] && t[1] === e))
                                    })).map((e => {
                                        let {badge: t} = e;
                                        return (0, Ks.Wg)(t)
                                    }))
                                }), [e, l]);
                            return null != c ? c : []
                        }(a), k = ow(a), A = {
                            Notes: {text: r(Sl), value: 0},
                            Reactions: {text: r(kl), value: 1},
                            Followers: {text: r(Al), value: 2},
                            Follows: {text: r(Tl), value: 3},
                            Zaps: {text: r(Cl), value: 4},
                            Muted: {text: r(Rl), value: 5},
                            Blocked: {text: r(Ll, {n: w.length}), value: 6},
                            Relays: {text: r($l), value: 7},
                            Bookmarks: {text: r(Kl), value: 8}
                        }, [T, C] = (0, t.useState)(A.Notes),
                        R = [A.Zaps, A.Relays, A.Bookmarks, A.Muted].filter((e => (0, Ks.Wg)(e))), L = cb();

                    function _() {
                        if (!a) return;
                        const t = (0, Pt.encodeTLV)(Pt.NostrPrefix.Profile, a);
                        return (0, e.jsxs)("div", {
                            className: "icon-actions",
                            children: [(0, e.jsx)(gw, {
                                onClick: () => p(!0),
                                children: (0, e.jsx)(Gl, {name: "qr", size: 16})
                            }), f && (0, e.jsxs)(Cu, {
                                className: "qr-modal",
                                onClose: () => p(!1),
                                children: [(0, e.jsx)(Zl, {pubkey: a}), (0, e.jsx)(zu, {
                                    data: t,
                                    className: "m10 align-center"
                                }), (0, e.jsx)(qu, {text: t, className: "align-center"})]
                            }), u ? (0, e.jsx)(e.Fragment, {
                                children: (0, e.jsx)("button", {
                                    type: "button",
                                    onClick: () => s("/settings"),
                                    children: (0, e.jsx)(cl, {...Pl})
                                })
                            }) : (0, e.jsxs)(e.Fragment, {
                                children: [v && (0, e.jsx)(gw, {
                                    onClick: () => h(!0),
                                    children: (0, e.jsx)(Gl, {name: "zap", size: 16})
                                }), c && (0, e.jsx)(e.Fragment, {
                                    children: (0, e.jsx)(gw, {
                                        onClick: () => s(`/messages/${(0, Ks.jm)(Pt.NostrPrefix.PublicKey, a)}`),
                                        children: (0, e.jsx)(Gl, {name: "envelope", size: 16})
                                    })
                                })]
                            })]
                        })
                    }

                    function P(t) {
                        return (0, e.jsx)(ub, {t, tab: T, setTab: C}, t.value)
                    }

                    (0, t.useEffect)((() => {
                        var e;
                        if (null !== (e = i.id) && void 0 !== e && e.match(yi)) nw(i.id).then((e => {
                            o(e)
                        })); else {
                            var t;
                            const e = (0, Pt.tryParseNostrLink)(null !== (t = i.id) && void 0 !== t ? t : "");
                            var n;
                            (null == e ? void 0 : e.type) === Pt.NostrPrefix.PublicKey || (null == e ? void 0 : e.type) === Pt.NostrPrefix.Profile ? o(e.id) : o((0, Ks.nm)(null !== (n = i.id) && void 0 !== n ? n : ""))
                        }
                        C(A.Notes)
                    }), [i]);
                    const N = null === (n = window.document.querySelector(".page")) || void 0 === n ? void 0 : n.clientWidth;
                    return (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsxs)("div", {
                            className: "profile flex",
                            children: [(null == l ? void 0 : l.banner) && (0, e.jsx)(Wd, {
                                alt: "banner",
                                className: "banner",
                                src: l.banner,
                                size: N
                            }), (0, e.jsxs)("div", {
                                className: "profile-wrapper flex",
                                children: [(0, e.jsx)("div", {
                                    className: "avatar-wrapper",
                                    children: (0, e.jsx)(Vl, {user: l})
                                }), function () {
                                    if (a) return (0, e.jsxs)("div", {
                                        className: "details-wrapper",
                                        children: [(0, e.jsxs)("div", {
                                            className: "name",
                                            children: [(0, e.jsxs)("h2", {children: [(null == l ? void 0 : l.display_name) || (null == l ? void 0 : l.name) || "Nostrich", (0, e.jsx)(yw, {followsMe: k.includes(null != c ? c : "")})]}), (null == l ? void 0 : l.nip05) && (0, e.jsx)(Yl, {
                                                nip05: l.nip05,
                                                pubkey: l.pubkey
                                            }), (0, e.jsx)(bw, {badges: S}), (0, e.jsx)(qu, {text: y}), (0, e.jsxs)("div", {
                                                className: "links",
                                                children: [(null == l ? void 0 : l.website) && (0, e.jsxs)("div", {
                                                    className: "website f-ellipsis",
                                                    children: [(0, e.jsx)(Gl, {name: "link"}), (0, e.jsx)("a", {
                                                        href: b,
                                                        target: "_blank",
                                                        rel: "noreferrer",
                                                        children: l.website
                                                    })]
                                                }), v && (0, e.jsxs)("div", {
                                                    className: "lnurl f-ellipsis",
                                                    onClick: () => h(!0),
                                                    children: [(0, e.jsx)(Gl, {name: "zap"}), v.name]
                                                }), (0, e.jsx)(Ed, {
                                                    lnurl: null == v ? void 0 : v.lnurl,
                                                    show: d,
                                                    onClose: () => h(!1),
                                                    author: a,
                                                    target: (null == l ? void 0 : l.display_name) || (null == l ? void 0 : l.name)
                                                })]
                                            })]
                                        }), (0, e.jsxs)("div", {
                                            className: "profile-actions",
                                            children: [_(), !u && (0, e.jsx)(Ab, {pubkey: a})]
                                        }), m.length > 0 && (0, e.jsx)("div", {
                                            dir: "auto",
                                            className: "details",
                                            children: g
                                        })]
                                    })
                                }()]
                            })]
                        }), (0, e.jsx)("div", {
                            className: "main-content",
                            children: (0, e.jsxs)("div", {
                                className: "tabs",
                                ref: L,
                                children: [[A.Notes, A.Followers, A.Follows].map(P), R.map(P), u && w.length > 0 && P(A.Blocked)]
                            })
                        }), (0, e.jsx)("div", {
                            className: "main-content", children: function () {
                                if (!a) return null;
                                switch (T.value) {
                                    case 0:
                                        return (0, e.jsxs)(e.Fragment, {
                                            children: [x.filter((e => e.kind === Pt.EventKind.TextNote)).map((t => (0, e.jsx)(Pb, {
                                                data: t,
                                                related: (0, Ks.Ym)(x, t.id),
                                                options: {showTime: !1, showPinned: !0, canUnpin: a === c}
                                            }, `pinned-${t.id}`))), (0, e.jsx)(dw, {
                                                subject: {
                                                    type: "pubkey",
                                                    items: [a],
                                                    discriminator: a.slice(0, 12)
                                                },
                                                postsOnly: !1,
                                                method: "LIMIT_UNTIL",
                                                loadMore: !1,
                                                ignoreModeration: !0,
                                                window: 21600
                                            }, a)]
                                        });
                                    case 4:
                                        return (0, e.jsx)(ww, {id: a});
                                    case 3:
                                        return u ? (0, e.jsx)(Cb, {
                                            pubkeys: k,
                                            showFollowAll: !u,
                                            showAbout: !1
                                        }) : (0, e.jsx)(Ew, {id: a});
                                    case 2:
                                        return (0, e.jsx)(xw, {id: a});
                                    case 5:
                                        return (0, e.jsx)(mw, {pubkeys: E});
                                    case 6:
                                        return (0, e.jsx)(fw, {});
                                    case 7:
                                        return (0, e.jsx)(Sw, {id: a});
                                    case 8:
                                        return (0, e.jsx)(kw, {id: a})
                                }
                            }()
                        })]
                    })
                }), {})
            }, {
                path: "/notifications", element: (0, e.jsx)((function () {
                    const n = Qs(), [r] = (0, t.useState)((0, Ks.oK)());
                    return (0, t.useEffect)((() => {
                        var e;
                        (e = n).readNotifications = (0, Ks.Fd)(), Xs.updateSession(e)
                    }), []), (0, e.jsxs)("div", {
                        className: "main-content",
                        children: [(0, e.jsx)(Vw, {}), n.publicKey && (0, e.jsx)(dw, {
                            subject: {
                                type: "ptag",
                                items: [n.publicKey],
                                discriminator: n.publicKey.slice(0, 12)
                            }, now: r, window: 43200, postsOnly: !1, method: "TIME_RANGE"
                        })]
                    })
                }), {})
            }, {
                path: "/settings", element: (0, e.jsx)((function () {
                    const t = st();
                    return (0, e.jsxs)("div", {
                        className: "main-content",
                        children: [(0, e.jsx)("h2", {
                            onClick: () => t("/settings"),
                            className: "pointer",
                            children: (0, e.jsx)(cl, {...Pl})
                        }), (0, e.jsx)(yt, {})]
                    })
                }), {}), children: dE
            }, {
                path: "/verification", element: (0, e.jsx)((function () {
                    return (0, e.jsxs)("div", {
                        className: "main-content verification",
                        children: [(0, e.jsx)("h2", {children: (0, e.jsx)(cl, {...Il})}), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...Ml})}), (0, e.jsx)("p", {children: (0, e.jsx)(cl, {...Dl})}), (0, e.jsxs)("ul", {children: [(0, e.jsx)("li", {children: (0, e.jsx)(cl, {...Ol})}), (0, e.jsx)("li", {children: (0, e.jsx)(cl, {...Bl})}), (0, e.jsx)("li", {children: (0, e.jsx)(cl, {...Fl})})]}), Gb.map((t => (0, e.jsx)(Kb, {...t}, t.name)))]
                    })
                }), {})
            }, {
                path: "/messages/:id?", element: (0, e.jsx)((function () {
                    const n = Qs(), {formatMessage: r} = al(), i = st(), {id: s} = ot(), [a, o] = (0, t.useState)(),
                        l = function () {
                            const e = (0, t.useRef)(document.querySelector("#root")), [n, r] = (0, t.useState)(0);
                            return (0, t.useEffect)((() => {
                                const t = () => {
                                    e.current && r(e.current.offsetWidth)
                                };
                                return window.addEventListener("resize", t), t(), () => window.removeEventListener("resize", t)
                            }), [e]), n
                        }();
                    (0, t.useEffect)((() => {
                        const e = (0, Ks.nm)(null != s ? s : "");
                        o(s ? e : void 0)
                    }), [s]);
                    const c = jc(), u = (0, t.useMemo)((() => c.reduce(((e, t) => e + t.unread), 0)), [c]);

                    function d(e, t, n) {
                        e.stopPropagation(), e.preventDefault(), t === Tc.DirectMessage ? i(`/messages/${(0, Ks.jm)(Pt.NostrPrefix.PublicKey, n)}`, {replace: !0}) : i(`/messages/${encodeURIComponent(n)}`, {replace: !0})
                    }

                    return (0, e.jsxs)("div", {
                        className: "dm-page",
                        children: [(l >= 768 || !a) && (0, e.jsxs)("div", {
                            children: [(0, e.jsxs)("div", {
                                className: "flex",
                                children: [(0, e.jsx)("h3", {
                                    className: "f-grow",
                                    children: (0, e.jsx)(cl, {...Nl})
                                }), (0, e.jsx)("button", {
                                    disabled: u <= 0,
                                    type: "button",
                                    children: (0, e.jsx)(cl, {...jl})
                                })]
                            }), c.sort(((e, t) => e.id === n.publicKey ? -1 : t.id === n.publicKey ? 1 : t.lastMessage - e.lastMessage)).map((function (t) {
                                return n.publicKey ? t.id === n.publicKey ? function (t) {
                                    return (0, e.jsx)("div", {
                                        className: "flex mb10",
                                        onClick: e => d(e, t.type, t.id),
                                        children: (0, e.jsx)(pE, {
                                            clickable: !0,
                                            className: "f-grow",
                                            link: "",
                                            pubkey: t.id
                                        })
                                    }, t.id)
                                }(t) : (0, e.jsxs)("div", {
                                    className: "flex mb10",
                                    onClick: e => d(e, t.type, t.id),
                                    children: [t.type === Tc.DirectMessage ? (0, e.jsx)(Zl, {
                                        pubkey: t.id,
                                        className: "f-grow",
                                        link: ""
                                    }) : (0, e.jsx)(Zl, {
                                        pubkey: t.id,
                                        overrideUsername: t.id,
                                        className: "f-grow",
                                        link: ""
                                    }), (0, e.jsxs)("div", {
                                        className: "nowrap",
                                        children: [(0, e.jsx)("small", {
                                            children: (0, e.jsx)(xb, {
                                                from: 1e3 * t.lastMessage,
                                                fallback: r({id: "bxv59V", defaultMessage: "Just now"})
                                            })
                                        }), t.unread > 0 && (0, e.jsx)(hE, {unread: t.unread})]
                                    })]
                                }, t.id) : null
                            }))]
                        }), a && (0, e.jsx)(yE, {id: a}), l >= 1500 && a && (0, e.jsx)("div", {children: (0, e.jsx)(bE, {pubkey: a})})]
                    })
                }), {})
            }, {
                path: "/donate", element: (0, e.jsx)((() => {
                    const [n, r] = (0, t.useState)([]), [i, s] = (0, t.useState)(), a = new qd(oi);

                    function o(t) {
                        const r = n.find((e => (0, Ks.FX)(e.pubKey) === t));
                        return r ? (0, e.jsxs)(e.Fragment, {children: [(100 * r.split).toLocaleString(), "%"]}) : (0, e.jsx)(e.Fragment, {})
                    }

                    return (0, t.useEffect)((() => {
                        (async function () {
                            const e = await a.revenueSplits();
                            r(e);
                            const t = await a.revenueToday();
                            s(t)
                        })().catch(console.warn)
                    }), []), (0, e.jsxs)("div", {
                        className: "main-content m5",
                        children: [(0, e.jsx)("h2", {
                            children: (0, e.jsx)(cl, {
                                id: "Y31HTH",
                                defaultMessage: "Help fund the development of Snort"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "BOr9z/",
                                defaultMessage: "Snort is an open source project built by passionate people in their free time"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "nn1qb3",
                                defaultMessage: "Your donations are greatly appreciated"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "u4bHcR",
                                defaultMessage: "Check out the code here: {link}",
                                values: {
                                    link: (0, e.jsx)("a", {
                                        className: "highlight",
                                        href: "https://git.v0l.io/Kieran/snort",
                                        rel: "noreferrer",
                                        target: "_blank",
                                        children: "https://git.v0l.io/Kieran/snort"
                                    })
                                }
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "mH91FY",
                                defaultMessage: "Each contributor will get paid a percentage of all donations and NIP-05 orders, you can see the split amounts below"
                            })
                        }), (0, e.jsxs)("div", {
                            className: "card",
                            children: [(0, e.jsxs)("div", {
                                className: "flex",
                                children: [(0, e.jsx)("div", {
                                    className: "mr10",
                                    children: (0, e.jsx)(cl, {id: "ZUZedV", defaultMessage: "Lightning Donation:"})
                                }), (0, e.jsx)(Qb, {
                                    pubkey: (0, Ks.FX)(di),
                                    lnurl: "donate@snort.social",
                                    children: (0, e.jsx)(cl, {id: "2IFGap", defaultMessage: "Donate"})
                                })]
                            }), i && (0, e.jsx)("small", {
                                children: (0, e.jsx)(cl, {
                                    id: "P7nJT9",
                                    defaultMessage: "Total today (UTC): {amount} sats",
                                    values: {amount: i.donations.toLocaleString()}
                                })
                            })]
                        }), (0, e.jsx)("h3", {
                            children: (0, e.jsx)(cl, {
                                id: "4IPzdn",
                                defaultMessage: "Primary Developers"
                            })
                        }), wE.map((t => (0, e.jsx)(Tb, {
                            pubkey: t,
                            actions: o(t)
                        }, t))), (0, e.jsx)("h4", {
                            children: (0, e.jsx)(cl, {
                                id: "ZLmyG9",
                                defaultMessage: "Contributors"
                            })
                        }), xE.map((t => (0, e.jsx)(Tb, {
                            pubkey: t,
                            actions: o(t)
                        }, t))), (0, e.jsx)("h4", {
                            children: (0, e.jsx)(cl, {
                                id: "3gOsZq",
                                defaultMessage: "Translators"
                            })
                        }), EE.map((t => (0, e.jsx)(Tb, {pubkey: t, actions: o(t)}, t)))]
                    })
                }), {})
            }, {
                path: "/t/:tag", element: (0, e.jsx)((() => {
                    var n;
                    const r = (null !== (n = ot().tag) && void 0 !== n ? n : "").toLowerCase(), i = Qs(),
                        s = (0, t.useMemo)((() => i.tags.item.includes(r)), [i, r]), a = hc();

                    async function o(e) {
                        if (a) {
                            const t = await a.tags(e);
                            DS.BroadcastEvent(t), qs(i, e, 1e3 * t.created_at)
                        }
                    }

                    return (0, e.jsxs)(e.Fragment, {
                        children: [(0, e.jsx)("div", {
                            className: "main-content",
                            children: (0, e.jsxs)("div", {
                                className: "action-heading",
                                children: [(0, e.jsxs)("h2", {children: ["#", r]}), s ? (0, e.jsx)("button", {
                                    type: "button",
                                    className: "secondary",
                                    onClick: () => o(i.tags.item.filter((e => e !== r))),
                                    children: (0, e.jsx)(cl, {id: "izWS4J", defaultMessage: "Unfollow"})
                                }) : (0, e.jsx)("button", {
                                    type: "button",
                                    onClick: () => o(i.tags.item.concat([r])),
                                    children: (0, e.jsx)(cl, {id: "ieGrWo", defaultMessage: "Follow"})
                                })]
                            })
                        }), (0, e.jsx)(dw, {
                            subject: {type: "hashtag", items: [r], discriminator: r},
                            postsOnly: !1,
                            method: "TIME_RANGE"
                        }, r)]
                    })
                }), {})
            }, {
                path: "/search/:keyword?", element: (0, e.jsx)((() => {
                    const n = ot(), {formatMessage: r} = al(), [i, s] = (0, t.useState)(n.keyword), [a, o] = (0, t.useState)(n.keyword), [l, c] = (0, t.useState)(!0),
                        u = {
                            Posts: {text: r({id: "7+Domh", defaultMessage: "Notes"}), value: 0},
                            Profiles: {text: r({id: "Tpy00S", defaultMessage: "People"}), value: 1}
                        }, [d, h] = (0, t.useState)(u.Posts);
                    return (0, t.useEffect)((() => {
                        a ? OS.navigate(`/search/${encodeURIComponent(a)}`) : OS.navigate("/search")
                    }), [a]), (0, t.useEffect)((() => (0, Ks.Ds)(500, (() => o(i)))), [i]), (0, e.jsxs)("div", {
                        className: "main-content",
                        children: [(0, e.jsx)("h2", {
                            children: (0, e.jsx)(cl, {
                                id: "xmcVZ0",
                                defaultMessage: "Search"
                            })
                        }), (0, e.jsx)("div", {
                            className: "flex mb10",
                            children: (0, e.jsx)("input", {
                                type: "text",
                                className: "f-grow mr10",
                                placeholder: r({id: "0BUTMv", defaultMessage: "Search..."}),
                                value: i,
                                onChange: e => s(e.target.value),
                                autoFocus: !0
                            })
                        }), (0, e.jsx)("div", {
                            className: "tabs", children: [u.Posts, u.Profiles].map((function (t) {
                                return (0, e.jsx)(ub, {t, tab: d, setTab: h}, t.value)
                            }))
                        }), function () {
                            if (!a) {
                                switch (d.value) {
                                    case 1:
                                        return (0, e.jsx)(Hw, {});
                                    case 0:
                                        return (0, e.jsx)(Uw, {})
                                }
                                return null
                            }
                            const t = 1 == d.value;
                            return (0, e.jsxs)(e.Fragment, {
                                children: [1 != d.value ? null : (0, e.jsxs)("div", {
                                    className: "flex mb10 f-end",
                                    children: [(0, e.jsx)(cl, {
                                        id: "RwFaYs",
                                        defaultMessage: "Sort"
                                    }), "", (0, e.jsxs)("select", {
                                        onChange: e => c("true" == e.target.value),
                                        value: l ? "true" : "false",
                                        children: [(0, e.jsx)("option", {
                                            value: "true",
                                            children: (0, e.jsx)(cl, {id: "mTJFgF", defaultMessage: "Popular"})
                                        }), (0, e.jsx)("option", {
                                            value: "false",
                                            children: (0, e.jsx)(cl, {id: "RjpoYG", defaultMessage: "Recent"})
                                        })]
                                    })]
                                }), (0, e.jsx)(dw, {
                                    subject: {
                                        type: t ? "profile_keyword" : "post_keyword",
                                        items: [a + (l ? " sort:popular" : "")],
                                        discriminator: a
                                    }, postsOnly: !1, noSort: t && l, method: "LIMIT_UNTIL", loadMore: !1
                                }, a + (t ? "_p" : ""))]
                            })
                        }()]
                    })
                }), {})
            }, {
                path: "/zap-pool", element: (0, e.jsx)((function () {
                    var n;
                    const r = Qs(),
                        i = (0, t.useSyncExternalStore)((e => wd.hook(e)), (() => wd.snapshot())), {wallet: s} = (0, Wu.Os)(),
                        a = (0, t.useMemo)((() => DS.Sockets.map((e => {
                            var t;
                            if (null !== (t = e.info) && void 0 !== t && t.pubkey && !e.ephemeral) return {
                                address: e.address,
                                pubkey: e.info.pubkey
                            }
                        })).filter((e => void 0 !== e)).map(Ks.Wg)), [r.relays]),
                        o = i.reduce(((e, t) => e + t.sum), 0);
                    return (0, e.jsxs)("div", {
                        className: "zap-pool main-content",
                        children: [(0, e.jsx)("h1", {
                            children: (0, e.jsx)(cl, {
                                id: "i/dBAR",
                                defaultMessage: "Zap Pool"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "x/Fx2P",
                                defaultMessage: "Fund the services that you use by splitting a portion of all your zaps into a pool of funds!"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "QWhotP",
                                defaultMessage: "Zap Pool only works if you use one of the supported wallet connections (WebLN, LNC, LNDHub or Nostr Wallet Connect)"
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "Xopqkl",
                                defaultMessage: "Your default zap amount is {number} sats, example values are calculated from this.",
                                values: {number: (0, e.jsx)("b", {children: (0, e.jsx)(yl, {value: r.preferences.defaultZapAmount})})}
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "eSzf2G",
                                defaultMessage: "A single zap of {nIn} sats will allocate {nOut} sats to the zap pool.",
                                values: {
                                    nIn: (0, e.jsx)("b", {children: (0, e.jsx)(yl, {value: r.preferences.defaultZapAmount})}),
                                    nOut: (0, e.jsx)("b", {children: (0, e.jsx)(yl, {value: wd.calcAllocation(r.preferences.defaultZapAmount)})})
                                }
                            })
                        }), (0, e.jsx)("p", {
                            children: (0, e.jsx)(cl, {
                                id: "Qxv0B2",
                                defaultMessage: "You currently have {number} sats in your zap pool.",
                                values: {number: (0, e.jsx)("b", {children: (0, e.jsx)(yl, {value: o})})}
                            })
                        }), (0, e.jsx)("p", {
                            children: s && (0, e.jsx)(Vd, {
                                onClick: () => wd.payout(s),
                                children: (0, e.jsx)(cl, {id: "+PzQ9Y", defaultMessage: "Payout Now"})
                            })
                        }), (0, e.jsx)("div", {
                            className: "card",
                            children: (0, e.jsx)(_S, {
                                target: null !== (n = i.find((e => e.pubkey === (0, Ks.FX)(di) && e.type === gd.Generic))) && void 0 !== n ? n : {
                                    type: gd.Generic,
                                    pubkey: (0, Ks.FX)(di),
                                    split: 0,
                                    sum: 0
                                }
                            })
                        }), (0, e.jsx)("h3", {
                            children: (0, e.jsx)(cl, {
                                id: "RoOyAh",
                                defaultMessage: "Relays"
                            })
                        }), a.map((t => {
                            var n;
                            return (0, e.jsxs)("div", {
                                className: "card",
                                children: [(0, e.jsx)("h4", {children: (0, Ks.Os)(t.address)}), (0, e.jsx)(_S, {
                                    target: null !== (n = i.find((e => e.pubkey === t.pubkey && e.type === gd.Relay))) && void 0 !== n ? n : {
                                        type: gd.Relay,
                                        pubkey: t.pubkey,
                                        split: 0,
                                        sum: 0
                                    }
                                })]
                            })
                        })), (0, e.jsx)("h3", {
                            children: (0, e.jsx)(cl, {
                                id: "XICsE8",
                                defaultMessage: "File hosts"
                            })
                        }), Pu.map((t => {
                            var n;
                            return (0, e.jsxs)("div", {
                                className: "card",
                                children: [(0, e.jsx)("h4", {children: t.name}), (0, e.jsx)(_S, {
                                    target: null !== (n = i.find((e => e.pubkey === t.owner && e.type === gd.FileHost))) && void 0 !== n ? n : {
                                        type: gd.FileHost,
                                        pubkey: t.owner,
                                        split: 0,
                                        sum: 0
                                    }
                                })]
                            })
                        })), (0, e.jsx)("h3", {
                            children: (0, e.jsx)(cl, {
                                id: "ELbg9p",
                                defaultMessage: "Data Providers"
                            })
                        }), LS.map((t => {
                            var n;
                            return (0, e.jsxs)("div", {
                                className: "card",
                                children: [(0, e.jsx)("h4", {children: t.name}), (0, e.jsx)(_S, {
                                    target: null !== (n = i.find((e => e.pubkey === t.owner && e.type === gd.DataProvider))) && void 0 !== n ? n : {
                                        type: gd.DataProvider,
                                        pubkey: t.owner,
                                        split: 0,
                                        sum: 0
                                    }
                                })]
                            })
                        }))]
                    })
                }), {})
            }, {
                path: "/live/:id", element: (0, e.jsx)((function () {
                    var t;
                    const n = ot(), r = (0, Pt.parseNostrLink)((0, Ks.Wg)(n.id)), i = nv(r);
                    return i.data ? (0, e.jsxs)("div", {
                        className: "live-page main-content",
                        children: [(0, e.jsxs)("div", {
                            children: [(0, e.jsx)(Qy, {
                                stream: (0, Ks.Wg)((0, Ks.MV)(i.data, "streaming")),
                                autoPlay: !0
                            }), (0, e.jsxs)("div", {
                                className: "flex",
                                children: [(0, e.jsxs)("div", {
                                    className: "f-grow",
                                    children: [(0, e.jsx)("h1", {children: (0, Ks.MV)(i.data, "title")}), (0, e.jsx)("p", {children: (0, Ks.MV)(i.data, "summary")}), (0, e.jsx)("div", {
                                        children: null === (t = i.data) || void 0 === t ? void 0 : t.tags.filter((e => "t" === e[0])).map((e => e[1])).map((t => (0, e.jsx)("div", {
                                            className: "pill",
                                            children: t
                                        }, t)))
                                    })]
                                }), (0, e.jsx)("div", {
                                    children: (0, e.jsx)(Tb, {
                                        pubkey: i.data.pubkey,
                                        className: "g10",
                                        options: {about: !1},
                                        actions: (0, e.jsx)("div", {
                                            className: "flex",
                                            children: (0, e.jsxs)(Vd, {
                                                onClick: () => {
                                                },
                                                children: [(0, e.jsx)(Gl, {
                                                    name: "zap",
                                                    size: 16,
                                                    className: "mr5"
                                                }), (0, e.jsx)(cl, {id: "fBI91o", defaultMessage: "Zap"})]
                                            })
                                        })
                                    })
                                })]
                            })]
                        }), (0, e.jsx)(IS, {ev: i.data, link: r})]
                    }) : (0, e.jsx)(Yd, {})
                }), {})
            }, ...vS, ...wS, ...Zb, {
                path: "/debug", element: (0, e.jsx)((function () {
                    return (0, e.jsx)(e.Fragment, {children: (0, e.jsx)(jS, {})})
                }), {})
            }, {
                path: "/*", element: (0, e.jsx)((function () {
                    var n;
                    const r = ot(), i = st(), [s, a] = (0, t.useState)(!0),
                        o = decodeURIComponent(null !== (n = r["*"]) && void 0 !== n ? n : "").toLowerCase();
                    return (0, t.useEffect)((() => {
                        o.length > 0 && async function (e) {
                            const t = (0, Pt.tryParseNostrLink)(e);
                            if (t) t.type === Pt.NostrPrefix.Event || t.type === Pt.NostrPrefix.Note || t.type === Pt.NostrPrefix.Address ? i(`/e/${t.encode()}`) : t.type !== Pt.NostrPrefix.PublicKey && t.type !== Pt.NostrPrefix.Profile || i(`/p/${t.encode()}`); else try {
                                const t = await nw(`${e}@snort.social`);
                                t && i((0, Ks._v)(t))
                            } catch {
                            }
                            a(!1)
                        }(o).catch(console.error)
                    }), [o]), (0, e.jsx)("div", {
                        className: "flex f-center",
                        children: s ? (0, e.jsx)(Dd, {width: 50, height: 50}) : (0, e.jsx)("b", {
                            className: "error",
                            children: (0, e.jsx)(cl, {id: "oJ+JJN", defaultMessage: "Nothing found :/"})
                        })
                    })
                }), {})
            }]
        }], function (e) {
            R(e.routes.length > 0, "You must provide a non-empty routes array to createRouter");
            let t, n = e.detectErrorBoundary || we, r = {}, i = D(e.routes, n, void 0, r),
                s = T({v7_normalizeFormMethod: !1}, e.future), a = null, o = new Set, l = null, c = null, u = null,
                d = null != e.hydrationData, h = O(i, e.history.location, e.basename), f = null;
            if (null == h) {
                let t = je(404, {pathname: e.history.location.pathname}), {matches: n, route: r} = Ne(i);
                h = n, f = {[r.id]: t}
            }
            let p, m, g = !(h.some((e => e.route.lazy)) || h.some((e => e.route.loader)) && null == e.hydrationData),
                y = {
                    historyAction: e.history.action,
                    location: e.history.location,
                    matches: h,
                    initialized: g,
                    navigation: pe,
                    restoreScrollPosition: null == e.hydrationData && null,
                    preventScrollReset: !1,
                    revalidation: "idle",
                    loaderData: e.hydrationData && e.hydrationData.loaderData || {},
                    actionData: e.hydrationData && e.hydrationData.actionData || null,
                    errors: e.hydrationData && e.hydrationData.errors || f,
                    fetchers: new Map,
                    blockers: new Map
                }, v = A.Pop, b = !1, w = !1, x = !1, E = [], S = [], k = new Map, C = 0, _ = -1, N = new Map,
                j = new Set, M = new Map, B = new Map, F = new Map, U = !1;

            function H(e) {
                y = T({}, y, e), o.forEach((e => e(y)))
            }

            function $(n, r) {
                var s, a;
                let o,
                    l = null != y.actionData && null != y.navigation.formMethod && Fe(y.navigation.formMethod) && "loading" === y.navigation.state && !0 !== (null == (s = n.state) ? void 0 : s._isRedirect);
                o = r.actionData ? Object.keys(r.actionData).length > 0 ? r.actionData : null : l ? y.actionData : null;
                let c = r.loaderData ? _e(y.loaderData, r.loaderData, r.matches || [], r.errors) : y.loaderData;
                for (let [e] of F) ee(e);
                let u = !0 === b || null != y.navigation.formMethod && Fe(y.navigation.formMethod) && !0 !== (null == (a = n.state) ? void 0 : a._isRedirect);
                t && (i = t, t = void 0), H(T({}, r, {
                    actionData: o,
                    loaderData: c,
                    historyAction: v,
                    location: n,
                    initialized: !0,
                    navigation: pe,
                    revalidation: "idle",
                    restoreScrollPosition: ie(n, r.matches || y.matches),
                    preventScrollReset: u,
                    blockers: new Map(y.blockers)
                })), w || v === A.Pop || (v === A.Push ? e.history.push(n, n.state) : v === A.Replace && e.history.replace(n, n.state)), v = A.Pop, b = !1, w = !1, x = !1, E = [], S = []
            }

            async function K(s, a, o) {
                m && m.abort(), m = null, v = s, w = !0 === (o && o.startUninterruptedRevalidation), function (e, t) {
                    if (l && c && u) {
                        let n = t.map((e => Ke(e, y.loaderData))), r = c(e, n) || e.key;
                        l[r] = u()
                    }
                }(y.location, y.matches), b = !0 === (o && o.preventScrollReset);
                let d = t || i, h = o && o.overrideNavigation, f = O(d, a, e.basename);
                if (!f) {
                    let e = je(404, {pathname: a.pathname}), {matches: t, route: n} = Ne(d);
                    return re(), void $(a, {matches: t, loaderData: {}, errors: {[n.id]: e}})
                }
                if (function (e, t) {
                    return e.pathname === t.pathname && e.search === t.search && e.hash !== t.hash
                }(y.location, a) && !(o && o.submission && Fe(o.submission.formMethod))) return void $(a, {matches: f});
                m = new AbortController;
                let g, L, P = Ce(e.history, a, m.signal, o && o.submission);
                if (o && o.pendingError) L = {[Pe(f).route.id]: o.pendingError}; else if (o && o.submission && Fe(o.submission.formMethod)) {
                    let e = await async function (e, t, i, s, a) {
                        let o;
                        W(), H({navigation: T({state: "submitting", location: t}, i)});
                        let l = ze(s, t);
                        if (l.route.action || l.route.lazy) {
                            if (o = await Te("action", e, l, s, r, n, p.basename), e.signal.aborted) return {shortCircuited: !0}
                        } else o = {
                            type: I.error,
                            error: je(405, {method: e.method, pathname: t.pathname, routeId: l.route.id})
                        };
                        if (Be(o)) {
                            let e;
                            return e = a && null != a.replace ? a.replace : o.location === y.location.pathname + y.location.search, await G(y, o, {
                                submission: i,
                                replace: e
                            }), {shortCircuited: !0}
                        }
                        if (Oe(o)) {
                            let e = Pe(s, l.route.id);
                            return !0 !== (a && a.replace) && (v = A.Push), {
                                pendingActionData: {},
                                pendingActionError: {[e.route.id]: o.error}
                            }
                        }
                        if (De(o)) throw je(400, {type: "defer-action"});
                        return {pendingActionData: {[l.route.id]: o.data}}
                    }(P, a, o.submission, f, {replace: o.replace});
                    if (e.shortCircuited) return;
                    g = e.pendingActionData, L = e.pendingActionError, h = T({
                        state: "loading",
                        location: a
                    }, o.submission), P = new Request(P.url, {signal: P.signal})
                }
                let {shortCircuited: N, loaderData: D, errors: F} = await async function (n, r, s, a, o, l, c, u, d) {
                    let h = a;
                    h || (h = T({
                        state: "loading",
                        location: r,
                        formMethod: void 0,
                        formAction: void 0,
                        formEncType: void 0,
                        formData: void 0
                    }, o));
                    let f = o || l ? o || l : h.formMethod && h.formAction && h.formData && h.formEncType ? {
                        formMethod: h.formMethod,
                        formAction: h.formAction,
                        formData: h.formData,
                        formEncType: h.formEncType
                    } : void 0, p = t || i, [g, v] = Ee(e.history, y, s, f, r, x, E, S, M, p, e.basename, u, d);
                    if (re((e => !(s && s.some((t => t.route.id === e))) || g && g.some((t => t.route.id === e)))), 0 === g.length && 0 === v.length) return $(r, T({
                        matches: s,
                        loaderData: {},
                        errors: d || null
                    }, u ? {actionData: u} : {})), {shortCircuited: !0};
                    if (!w) {
                        v.forEach((e => {
                            let t = y.fetchers.get(e.key), n = {
                                state: "loading",
                                data: t && t.data,
                                formMethod: void 0,
                                formAction: void 0,
                                formEncType: void 0,
                                formData: void 0,
                                " _hasFetcherDoneAnything ": !0
                            };
                            y.fetchers.set(e.key, n)
                        }));
                        let e = u || y.actionData;
                        H(T({navigation: h}, e ? 0 === Object.keys(e).length ? {actionData: null} : {actionData: e} : {}, v.length > 0 ? {fetchers: new Map(y.fetchers)} : {}))
                    }
                    _ = ++C, v.forEach((e => k.set(e.key, m)));
                    let {results: b, loaderResults: A, fetcherResults: L} = await q(y.matches, s, g, v, n);
                    if (n.signal.aborted) return {shortCircuited: !0};
                    v.forEach((e => k.delete(e.key)));
                    let P = Ie(b);
                    if (P) return await G(y, P, {replace: c}), {shortCircuited: !0};
                    let {loaderData: N, errors: I} = Le(y, s, g, A, d, v, L, B);
                    return B.forEach(((e, t) => {
                        e.subscribe((n => {
                            (n || e.done) && B.delete(t)
                        }))
                    })), function () {
                        let e = [];
                        for (let t of j) {
                            let n = y.fetchers.get(t);
                            R(n, "Expected fetcher: " + t), "loading" === n.state && (j.delete(t), e.push(t))
                        }
                        Q(e)
                    }(), T({loaderData: N, errors: I}, J(_) || v.length > 0 ? {fetchers: new Map(y.fetchers)} : {})
                }(P, a, f, h, o && o.submission, o && o.fetcherSubmission, o && o.replace, g, L);
                N || (m = null, $(a, T({matches: f}, g ? {actionData: g} : {}, {loaderData: D, errors: F})))
            }

            function z(e) {
                return y.fetchers.get(e) || me
            }

            async function G(t, n, r) {
                var i;
                let {submission: s, replace: a, isFetchActionRedirect: o} = void 0 === r ? {} : r;
                n.revalidate && (x = !0);
                let l = P(t.location, n.location, T({_isRedirect: !0}, o ? {_isFetchActionRedirect: !0} : {}));
                if (R(l, "Expected a location on the redirect navigation"), ye.test(n.location) && ve && void 0 !== (null == (i = window) ? void 0 : i.location)) {
                    let t = e.history.createURL(n.location), r = null == X(t.pathname, e.basename || "/");
                    if (window.location.origin !== t.origin || r) return void (a ? window.location.replace(n.location) : window.location.assign(n.location))
                }
                m = null;
                let c = !0 === a ? A.Replace : A.Push, {
                    formMethod: u,
                    formAction: d,
                    formEncType: h,
                    formData: f
                } = t.navigation;
                !s && u && d && f && h && (s = {
                    formMethod: u,
                    formAction: d,
                    formEncType: h,
                    formData: f
                }), fe.has(n.status) && s && Fe(s.formMethod) ? await K(c, l, {
                    submission: T({}, s, {formAction: n.location}),
                    preventScrollReset: b
                }) : o ? await K(c, l, {
                    overrideNavigation: {
                        state: "loading",
                        location: l,
                        formMethod: void 0,
                        formAction: void 0,
                        formEncType: void 0,
                        formData: void 0
                    }, fetcherSubmission: s, preventScrollReset: b
                }) : await K(c, l, {
                    overrideNavigation: {
                        state: "loading",
                        location: l,
                        formMethod: s ? s.formMethod : void 0,
                        formAction: s ? s.formAction : void 0,
                        formEncType: s ? s.formEncType : void 0,
                        formData: s ? s.formData : void 0
                    }, preventScrollReset: b
                })
            }

            async function q(t, i, s, a, o) {
                let l = await Promise.all([...s.map((e => Te("loader", o, e, i, r, n, p.basename))), ...a.map((t => t.matches && t.match ? Te("loader", Ce(e.history, t.path, o.signal), t.match, t.matches, r, n, p.basename) : {
                    type: I.error,
                    error: je(404, {pathname: t.path})
                }))]), c = l.slice(0, s.length), u = l.slice(s.length);
                return await Promise.all([Ue(t, s, c, o.signal, !1, y.loaderData), Ue(t, a.map((e => e.match)), u, o.signal, !0)]), {
                    results: l,
                    loaderResults: c,
                    fetcherResults: u
                }
            }

            function W() {
                x = !0, E.push(...re()), M.forEach(((e, t) => {
                    k.has(t) && (S.push(t), Z(t))
                }))
            }

            function V(e, t, n) {
                let r = Pe(y.matches, t);
                Y(e), H({errors: {[r.route.id]: n}, fetchers: new Map(y.fetchers)})
            }

            function Y(e) {
                k.has(e) && Z(e), M.delete(e), N.delete(e), j.delete(e), y.fetchers.delete(e)
            }

            function Z(e) {
                let t = k.get(e);
                R(t, "Expected fetch controller: " + e), t.abort(), k.delete(e)
            }

            function Q(e) {
                for (let t of e) {
                    let e = {
                        state: "idle",
                        data: z(t).data,
                        formMethod: void 0,
                        formAction: void 0,
                        formEncType: void 0,
                        formData: void 0,
                        " _hasFetcherDoneAnything ": !0
                    };
                    y.fetchers.set(t, e)
                }
            }

            function J(e) {
                let t = [];
                for (let [n, r] of N) if (r < e) {
                    let e = y.fetchers.get(n);
                    R(e, "Expected fetcher: " + n), "loading" === e.state && (Z(n), N.delete(n), t.push(n))
                }
                return Q(t), t.length > 0
            }

            function ee(e) {
                y.blockers.delete(e), F.delete(e)
            }

            function te(e, t) {
                let n = y.blockers.get(e) || ge;
                R("unblocked" === n.state && "blocked" === t.state || "blocked" === n.state && "blocked" === t.state || "blocked" === n.state && "proceeding" === t.state || "blocked" === n.state && "unblocked" === t.state || "proceeding" === n.state && "unblocked" === t.state, "Invalid blocker state transition: " + n.state + " -> " + t.state), y.blockers.set(e, t), H({blockers: new Map(y.blockers)})
            }

            function ne(e) {
                let {currentLocation: t, nextLocation: n, historyAction: r} = e;
                if (0 === F.size) return;
                F.size > 1 && L(!1, "A router only supports one blocker at a time");
                let i = Array.from(F.entries()), [s, a] = i[i.length - 1], o = y.blockers.get(s);
                return o && "proceeding" === o.state ? void 0 : a({
                    currentLocation: t,
                    nextLocation: n,
                    historyAction: r
                }) ? s : void 0
            }

            function re(e) {
                let t = [];
                return B.forEach(((n, r) => {
                    e && !e(r) || (n.cancel(), t.push(r), B.delete(r))
                })), t
            }

            function ie(e, t) {
                if (l && c && u) {
                    let n = t.map((e => Ke(e, y.loaderData))), r = c(e, n) || e.key, i = l[r];
                    if ("number" == typeof i) return i
                }
                return null
            }

            return p = {
                get basename() {
                    return e.basename
                },
                get state() {
                    return y
                },
                get routes() {
                    return i
                },
                initialize: function () {
                    return a = e.history.listen((t => {
                        let {action: n, location: r, delta: i} = t;
                        if (U) return void (U = !1);
                        L(0 === F.size || null != i, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
                        let s = ne({currentLocation: y.location, nextLocation: r, historyAction: n});
                        return s && null != i ? (U = !0, e.history.go(-1 * i), void te(s, {
                            state: "blocked",
                            location: r,
                            proceed() {
                                te(s, {
                                    state: "proceeding",
                                    proceed: void 0,
                                    reset: void 0,
                                    location: r
                                }), e.history.go(i)
                            },
                            reset() {
                                ee(s), H({blockers: new Map(p.state.blockers)})
                            }
                        })) : K(n, r)
                    })), y.initialized || K(A.Pop, y.location), p
                },
                subscribe: function (e) {
                    return o.add(e), () => o.delete(e)
                },
                enableScrollRestoration: function (e, t, n) {
                    if (l = e, u = t, c = n || (e => e.key), !d && y.navigation === pe) {
                        d = !0;
                        let e = ie(y.location, y.matches);
                        null != e && H({restoreScrollPosition: e})
                    }
                    return () => {
                        l = null, u = null, c = null
                    }
                },
                navigate: async function t(n, r) {
                    if ("number" == typeof n) return void e.history.go(n);
                    let {path: i, submission: a, error: o} = xe(n, s, r), l = y.location,
                        c = P(y.location, i, r && r.state);
                    c = T({}, c, e.history.encodeLocation(c));
                    let u = r && null != r.replace ? r.replace : void 0, d = A.Push;
                    !0 === u ? d = A.Replace : !1 === u || null != a && Fe(a.formMethod) && a.formAction === y.location.pathname + y.location.search && (d = A.Replace);
                    let h = r && "preventScrollReset" in r ? !0 === r.preventScrollReset : void 0,
                        f = ne({currentLocation: l, nextLocation: c, historyAction: d});
                    if (!f) return await K(d, c, {
                        submission: a,
                        pendingError: o,
                        preventScrollReset: h,
                        replace: r && r.replace
                    });
                    te(f, {
                        state: "blocked", location: c, proceed() {
                            te(f, {state: "proceeding", proceed: void 0, reset: void 0, location: c}), t(n, r)
                        }, reset() {
                            ee(f), H({blockers: new Map(y.blockers)})
                        }
                    })
                },
                fetch: function (a, o, l, c) {
                    if (be) throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
                    k.has(a) && Z(a);
                    let u = O(t || i, l, e.basename);
                    if (!u) return void V(a, o, je(404, {pathname: l}));
                    let {path: d, submission: h} = xe(l, s, c, !0), f = ze(u, d);
                    b = !0 === (c && c.preventScrollReset), h && Fe(h.formMethod) ? async function (s, a, o, l, c, u) {
                        if (W(), M.delete(s), !l.route.action && !l.route.lazy) {
                            let e = je(405, {method: u.formMethod, pathname: o, routeId: a});
                            return void V(s, a, e)
                        }
                        let d = y.fetchers.get(s),
                            h = T({state: "submitting"}, u, {data: d && d.data, " _hasFetcherDoneAnything ": !0});
                        y.fetchers.set(s, h), H({fetchers: new Map(y.fetchers)});
                        let f = new AbortController, g = Ce(e.history, o, f.signal, u);
                        k.set(s, f);
                        let b = await Te("action", g, l, c, r, n, p.basename);
                        if (g.signal.aborted) return void (k.get(s) === f && k.delete(s));
                        if (Be(b)) {
                            k.delete(s), j.add(s);
                            let e = T({state: "loading"}, u, {data: void 0, " _hasFetcherDoneAnything ": !0});
                            return y.fetchers.set(s, e), H({fetchers: new Map(y.fetchers)}), G(y, b, {
                                submission: u,
                                isFetchActionRedirect: !0
                            })
                        }
                        if (Oe(b)) return void V(s, a, b.error);
                        if (De(b)) throw je(400, {type: "defer-action"});
                        let w = y.navigation.location || y.location, A = Ce(e.history, w, f.signal), L = t || i,
                            P = "idle" !== y.navigation.state ? O(L, y.navigation.location, e.basename) : y.matches;
                        R(P, "Didn't find any matches after fetcher action");
                        let I = ++C;
                        N.set(s, I);
                        let D = T({state: "loading", data: b.data}, u, {" _hasFetcherDoneAnything ": !0});
                        y.fetchers.set(s, D);
                        let [F, U] = Ee(e.history, y, P, u, w, x, E, S, M, L, e.basename, {[l.route.id]: b.data}, void 0);
                        U.filter((e => e.key !== s)).forEach((e => {
                            let t = e.key, n = y.fetchers.get(t), r = {
                                state: "loading",
                                data: n && n.data,
                                formMethod: void 0,
                                formAction: void 0,
                                formEncType: void 0,
                                formData: void 0,
                                " _hasFetcherDoneAnything ": !0
                            };
                            y.fetchers.set(t, r), k.set(t, f)
                        })), H({fetchers: new Map(y.fetchers)});
                        let {results: K, loaderResults: z, fetcherResults: Y} = await q(y.matches, P, F, U, A);
                        if (f.signal.aborted) return;
                        N.delete(s), k.delete(s), U.forEach((e => k.delete(e.key)));
                        let Z = Ie(K);
                        if (Z) return G(y, Z);
                        let {loaderData: X, errors: Q} = Le(y, y.matches, F, z, void 0, U, Y, B), ee = {
                            state: "idle",
                            data: b.data,
                            formMethod: void 0,
                            formAction: void 0,
                            formEncType: void 0,
                            formData: void 0,
                            " _hasFetcherDoneAnything ": !0
                        };
                        y.fetchers.set(s, ee);
                        let te = J(I);
                        "loading" === y.navigation.state && I > _ ? (R(v, "Expected pending action"), m && m.abort(), $(y.navigation.location, {
                            matches: P,
                            loaderData: X,
                            errors: Q,
                            fetchers: new Map(y.fetchers)
                        })) : (H(T({
                            errors: Q,
                            loaderData: _e(y.loaderData, X, P, Q)
                        }, te ? {fetchers: new Map(y.fetchers)} : {})), x = !1)
                    }(a, o, d, f, u, h) : (M.set(a, {routeId: o, path: d}), async function (t, i, s, a, o, l) {
                        let c = y.fetchers.get(t), u = T({
                            state: "loading",
                            formMethod: void 0,
                            formAction: void 0,
                            formEncType: void 0,
                            formData: void 0
                        }, l, {data: c && c.data, " _hasFetcherDoneAnything ": !0});
                        y.fetchers.set(t, u), H({fetchers: new Map(y.fetchers)});
                        let d = new AbortController, h = Ce(e.history, s, d.signal);
                        k.set(t, d);
                        let f = await Te("loader", h, a, o, r, n, p.basename);
                        if (De(f) && (f = await He(f, h.signal, !0) || f), k.get(t) === d && k.delete(t), h.signal.aborted) return;
                        if (Be(f)) return void await G(y, f);
                        if (Oe(f)) {
                            let e = Pe(y.matches, i);
                            return y.fetchers.delete(t), void H({
                                fetchers: new Map(y.fetchers),
                                errors: {[e.route.id]: f.error}
                            })
                        }
                        R(!De(f), "Unhandled fetcher deferred data");
                        let m = {
                            state: "idle",
                            data: f.data,
                            formMethod: void 0,
                            formAction: void 0,
                            formEncType: void 0,
                            formData: void 0,
                            " _hasFetcherDoneAnything ": !0
                        };
                        y.fetchers.set(t, m), H({fetchers: new Map(y.fetchers)})
                    }(a, o, d, f, u, h))
                },
                revalidate: function () {
                    W(), H({revalidation: "loading"}), "submitting" !== y.navigation.state && ("idle" !== y.navigation.state ? K(v || y.historyAction, y.navigation.location, {overrideNavigation: y.navigation}) : K(y.historyAction, y.location, {startUninterruptedRevalidation: !0}))
                },
                createHref: t => e.history.createHref(t),
                encodeLocation: t => e.history.encodeLocation(t),
                getFetcher: z,
                deleteFetcher: Y,
                dispose: function () {
                    a && a(), o.clear(), m && m.abort(), y.fetchers.forEach(((e, t) => Y(t))), y.blockers.forEach(((e, t) => ee(t)))
                },
                getBlocker: function (e, t) {
                    let n = y.blockers.get(e) || ge;
                    return F.get(e) !== t && F.set(e, t), n
                },
                deleteBlocker: ee,
                _internalFetchControllers: k,
                _internalActiveDeferreds: B,
                _internalSetRoutes: function (e) {
                    t = e
                }
            }, p
        }({
            basename: void 0,
            future: void 0,
            history: (FS = {window: void 0}, void 0 === FS && (FS = {}), function (e, t, n, r) {
                void 0 === r && (r = {});
                let {window: i = document.defaultView, v5Compat: s = !1} = r, a = i.history, o = A.Pop, l = null,
                    c = u();

                function u() {
                    return (a.state || {idx: null}).idx
                }

                function d() {
                    o = A.Pop;
                    let e = u(), t = null == e ? null : e - c;
                    c = e, l && l({action: o, location: f.location, delta: t})
                }

                function h(e) {
                    let t = "null" !== i.location.origin ? i.location.origin : i.location.href,
                        n = "string" == typeof e ? e : N(e);
                    return R(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t)
                }

                null == c && (c = 0, a.replaceState(T({}, a.state, {idx: c}), ""));
                let f = {
                    get action() {
                        return o
                    }, get location() {
                        return e(i, a)
                    }, listen(e) {
                        if (l) throw new Error("A history only accepts one active listener");
                        return i.addEventListener(C, d), l = e, () => {
                            i.removeEventListener(C, d), l = null
                        }
                    }, createHref: e => t(i, e), createURL: h, encodeLocation(e) {
                        let t = h(e);
                        return {pathname: t.pathname, search: t.search, hash: t.hash}
                    }, push: function (e, t) {
                        o = A.Push;
                        let r = P(f.location, e, t);
                        n && n(r, e), c = u() + 1;
                        let d = _(r, c), h = f.createHref(r);
                        try {
                            a.pushState(d, "", h)
                        } catch (e) {
                            i.location.assign(h)
                        }
                        s && l && l({action: o, location: f.location, delta: 1})
                    }, replace: function (e, t) {
                        o = A.Replace;
                        let r = P(f.location, e, t);
                        n && n(r, e), c = u();
                        let i = _(r, c), d = f.createHref(r);
                        a.replaceState(i, "", d), s && l && l({action: o, location: f.location, delta: 0})
                    }, go: e => a.go(e)
                };
                return f
            }((function (e, t) {
                let {pathname: n, search: r, hash: i} = e.location;
                return P("", {
                    pathname: n,
                    search: r,
                    hash: i
                }, t.state && t.state.usr || null, t.state && t.state.key || "default")
            }), (function (e, t) {
                return "string" == typeof t ? t : N(t)
            }), null, FS)),
            hydrationData: function () {
                var e;
                let t = null == (e = window) ? void 0 : e.__staticRouterHydrationData;
                return t && t.errors && (t = St({}, t, {errors: At(t.errors)})), t
            }(),
            routes: BS,
            detectErrorBoundary: function (e) {
                return Boolean(e.ErrorBoundary) || Boolean(e.errorElement)
            }
        }).initialize());
        var BS, FS;
        r.s((0, Ks.Wg)(document.getElementById("root"))).render((0, e.jsx)(t.StrictMode, {
            children: (0, e.jsx)((function ({store: e, context: n, children: r, serverState: i}) {
                const s = (0, t.useMemo)((() => {
                    const t = function (e, t) {
                        let n, r = y;

                        function i() {
                            a.onStateChange && a.onStateChange()
                        }

                        function s() {
                            n || (n = t ? t.addNestedSub(i) : e.subscribe(i), r = function () {
                                const e = u();
                                let t = null, n = null;
                                return {
                                    clear() {
                                        t = null, n = null
                                    }, notify() {
                                        e((() => {
                                            let e = t;
                                            for (; e;) e.callback(), e = e.next
                                        }))
                                    }, get() {
                                        let e = [], n = t;
                                        for (; n;) e.push(n), n = n.next;
                                        return e
                                    }, subscribe(e) {
                                        let r = !0, i = n = {callback: e, next: null, prev: n};
                                        return i.prev ? i.prev.next = i : t = i, function () {
                                            r && null !== t && (r = !1, i.next ? i.next.prev = i.prev : n = i.prev, i.prev ? i.prev.next = i.next : t = i.next)
                                        }
                                    }
                                }
                            }())
                        }

                        const a = {
                            addNestedSub: function (e) {
                                return s(), r.subscribe(e)
                            }, notifyNestedSubs: function () {
                                r.notify()
                            }, handleChangeWrapper: i, isSubscribed: function () {
                                return Boolean(n)
                            }, trySubscribe: s, tryUnsubscribe: function () {
                                n && (n(), n = void 0, r.clear(), r = y)
                            }, getListeners: () => r
                        };
                        return a
                    }(e);
                    return {store: e, subscription: t, getServerState: i ? () => i : void 0}
                }), [e, i]), a = (0, t.useMemo)((() => e.getState()), [e]);
                v((() => {
                    const {subscription: t} = s;
                    return t.onStateChange = t.notifyNestedSubs, t.trySubscribe(), a !== e.getState() && t.notifyNestedSubs(), () => {
                        t.tryUnsubscribe(), t.onStateChange = void 0
                    }
                }), [s, a]);
                const o = n || d;
                return t.createElement(o.Provider, {value: s}, r)
            }), {
                store: sl, children: (0, e.jsx)((n => {
                    let {children: r} = n;
                    const {language: i} = Qs().preferences,
                        s = null != i ? i : null !== (c = null !== (u = navigator.languages && navigator.languages[0]) && void 0 !== u ? u : navigator.language) && void 0 !== c ? c : Js, [o, l] = (0, t.useState)(ri);
                    var c, u;
                    return (0, t.useEffect)((() => {
                        (e => {
                            var t, n;
                            const r = e.toLowerCase().split(/[_-]+/)[0], i = async e => {
                                switch (e) {
                                    case"es-ES":
                                    case"es":
                                        return (await a.e(976).then(a.t.bind(a, 4976, 19))).default;
                                    case"zh-CN":
                                    case"zh-Hans-CN":
                                    case"zh":
                                        return (await a.e(211).then(a.t.bind(a, 7211, 19))).default;
                                    case"zh-TW":
                                        return (await a.e(26).then(a.t.bind(a, 1026, 19))).default;
                                    case"ja-JP":
                                    case"ja":
                                        return (await a.e(409).then(a.t.bind(a, 1409, 19))).default;
                                    case"fr-FR":
                                    case"fr":
                                        return (await a.e(462).then(a.t.bind(a, 4462, 19))).default;
                                    case"hu-HU":
                                    case"hu":
                                        return (await a.e(45).then(a.t.bind(a, 6045, 19))).default;
                                    case"id-ID":
                                    case"id":
                                        return (await a.e(790).then(a.t.bind(a, 5790, 19))).default;
                                    case"ar-SA":
                                    case"ar":
                                        return (await a.e(245).then(a.t.bind(a, 2245, 19))).default;
                                    case"it-IT":
                                    case"it":
                                        return (await a.e(109).then(a.t.bind(a, 109, 19))).default;
                                    case"de-DE":
                                    case"de":
                                        return (await a.e(769).then(a.t.bind(a, 9769, 19))).default;
                                    case"ru-RU":
                                    case"ru":
                                        return (await a.e(215).then(a.t.bind(a, 9215, 19))).default;
                                    case"sv-SE":
                                    case"sv":
                                        return (await a.e(310).then(a.t.bind(a, 4310, 19))).default;
                                    case"hr-HR":
                                    case"hr":
                                        return (await a.e(279).then(a.t.bind(a, 3279, 19))).default;
                                    case"ta-IN":
                                    case"ta":
                                        return (await a.e(579).then(a.t.bind(a, 6579, 19))).default;
                                    case"fa-IR":
                                    case"fa":
                                        return (await a.e(365).then(a.t.bind(a, 3365, 19))).default;
                                    case Js:
                                    case"en":
                                        return ri
                                }
                            };
                            return null !== (t = null !== (n = i(e)) && void 0 !== n ? n : i(r)) && void 0 !== t ? t : Promise.resolve(ri)
                        })(s).then((e => {
                            e && l(e)
                        })).catch(console.error)
                    }), [i]), (0, e.jsx)(ni, {locale: s, messages: o, children: r})
                }), {
                    children: (0, e.jsx)((function (e) {
                        let {fallbackElement: n, router: r} = e, i = t.useCallback((() => r.state), [r]),
                            s = Ye(r.subscribe, i, i), a = t.useMemo((() => ({
                                createHref: r.createHref,
                                encodeLocation: r.encodeLocation,
                                go: e => r.navigate(e),
                                push: (e, t, n) => r.navigate(e, {
                                    state: t,
                                    preventScrollReset: null == n ? void 0 : n.preventScrollReset
                                }),
                                replace: (e, t, n) => r.navigate(e, {
                                    replace: !0,
                                    state: t,
                                    preventScrollReset: null == n ? void 0 : n.preventScrollReset
                                })
                            })), [r]), o = r.basename || "/",
                            l = t.useMemo((() => ({router: r, navigator: a, static: !1, basename: o})), [r, a, o]);
                        return t.createElement(t.Fragment, null, t.createElement(Ze.Provider, {value: l}, t.createElement(Xe.Provider, {value: s}, t.createElement(bt, {
                            basename: r.basename,
                            location: r.state.location,
                            navigationType: r.state.historyAction,
                            navigator: a
                        }, r.state.initialized ? t.createElement(wt, null) : n))), null)
                    }), {router: OS})
                })
            })
        }))
    })()
})();
//# sourceMappingURL=main.2e1da670c4b2575129a8.js.map